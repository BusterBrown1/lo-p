{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Preface \u00b6 Star Basic is the native language of Star Office which has been incorporated by Open Office and Libre Office. This means that all other supported languages must negotiate a basic bridge. This comment from Dan Dascalescu offers a challenge to the community: after 20 years of software development, the LibreOffice API is the crappiest one I've had the \"pleasure\" of working with. The documentation is horrible , spread all over the place, littered with Uyghur , or completely missing . The LibreOffice macro IDE is also extremely unhelpful. LibreOffice Programming offers a framework for the community to take another step to change this. The starting point is Java LibreOffice Programming which we thank Andrew Davison for kindly making available provided his work is acknowledged. Since Java is not Basic it provides good insight into using non-Basic languages even if the language is different. Changes required are reformatting for this media since the scripts have missed a lot of detail including code, generalising the content so it is more widely applicable to supported languages and complementing Java examples with examples of other language. Please contribute where you can. \u00a9 Contributors: Andrew Davison, flywire https://creativecommons.org/licenses/by-sa/4.0/ Overview \u00b6 Java LibreOffice Programming (JLOP) is intended for programmers who want to learn how to use the Java version of the LibreOffice API. This allows Java to control and manipulate LibreOffice's text, drawing, presentation, spreadsheet, and database applications, and a lot more (e.g. its spell checker, forms designer, and charting tools). This book is not about how to use LibreOffice's GUI. I won't explain where to find a particular menu item to change text colour or run the spell checker. But I will explain how to do these kinds of things via API calls from Java programs. For instance, I describe a program that constructs a Word file full of randomly generated algebra questions, and show how a ASCII text file can be transformed into a slide presentation. Although most of the examples are Java programs that call the LibreOffice API, I briefly look at other kinds of programming, such as Java macros and new LibreOffice functionality, accessible via menu items or as spreadsheet functions, and the dispatching of commands to the GUI. One of my aims was to develop utility code to help flatten the steep learning curve for the API. For example, my Lo class simplifies the steps needed to initialize the API (by creating a connection to a LibreOffice process), to open/create a document, save it, and close down LibreOffice. Another aim was to have my code work on LibreOffice and OpenOffice , which isn't difficult since their APIs are nearly identical. However, I must admit that at this stage I've restricted myself to testing the programs only on LibreOffice, and only on MS Windows. Part 1: Basics \u00b6 Chapter 1. LibreOffice API Concepts \u00b6 Topics: Some History; Help and Examples for the LibreOffice SDK (loDoc, loGuide); Office as a Process; Common Structures (Interface, Property, Service, and Component); Service and Interface Inheritance Hierarchies; the Frame-Controller-Model (FCM) Relationship; Extensions; Comparison with Basic. Chapter (400 KB; pdf). Updated: 20 th March 2017. Utilities (Utils/) (184 KB; zip). Updated: 13 th Jan. 2017. How to install, compile, and run my code. Chapter 2. Starting and Stopping \u00b6 Topics: Starting Office; Closing Down/Killing Office; Opening a Document; Creating a Document; Saving; Closing; Document Conversion; Bug Detection and Reporting. Chapter (472 KB; pdf). Updated: 20 th March 2017. Examples (Office Tests/) (920 KB; zip). Updated: 15 th August 2015. Place Office Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 3. Examining \u00b6 Topics: Examining Office; Getting and Setting Document Properties; Examining a Document for API Details; Examining a Document Using MRI. Chapter (312 KB; pdf). Updated: 20 th March 2017. For the examples (Office Tests/), see chapter 2 . Chapter 4. Listening, and Other Techniques \u00b6 Topics: Window Listeners; Office Manipulation with JNA; Dispatching; Robot Keys. Chapter (208 KB; pdf). Updated: 20 th March 2017. For the examples (Office Tests/), see chapter 2 . Part 2: Writer Modules \u00b6 Chapter 5. Text API Overview \u00b6 Topics: API Overview; Text Cursors; Extracting Text; Cursor Iteration; Creating Cursors; Creating a Document; Using and Comparing Text Cursors; Inserting/Changing Text in a Document; Text Enumeration; Appending Documents. Chapter (344 KB; pdf). Updated: 20 th March 2017. Examples (Text Tests/) (304 KB; zip). Updated: 15 th August 2015. Place Text Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 6. Text Styles \u00b6 Topics: Five Style Families; Properties; Listing Styles; Creating a Style; Applying Styles; Paragraph/Word Styles; Hyperlink Styling; Text Numbering; Headers and Footers. Chapter (396 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 . Chapter 7. Text Content Other than Strings \u00b6 Topics: Accessing Text Content; Text Frames; Embedded Objects (Math Formulae); Text Fields; Text Tables; Bookmarks. Chapter (528 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 . Chapter 8. Graphic Content \u00b6 Topics: Graphics; Linked Images/Shapes. Chapter (252 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 . Chapter 9. Text Search and Replace \u00b6 Topics: Finding the First Matching Phrase; Replacing all the Matching Words; Finding all Matching Phrases. Chapter (144 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 . Chapter 10. The Linguistics API \u00b6 Topics: Linguistic Tools; Using the Spell Checker; Using the Thesaurus; Grammar Checking; Guessing the Language used in a String; Spell Checking and Grammar Checking a Document. Chapter (628 KB; pdf). Updated: 20 th March 2017. Examples (Lingu Tests/) (40 KB; zip). Updated: 2 nd August 2016. Place Lingu Tests/ and Utils/ (see chapter 1 ) in the same directory. Part 3: Draw & Impress Modules \u00b6 Chapter 11. Draw/Impress APIs Overview \u00b6 Topics: Draw Pages and Master Pages; Draw Page Details; API Hierarchy Code Examples; Shapes in a Drawing; Shapes in a Presentation ; The Slide Show APIs. Chapter (360 KB; pdf). Updated: 20 th March 2017. Examples (Draw Tests/) (1.77 MB; zip). Updated: 15 th August 2015. Place Draw Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 12. Examining a Draw/Impress Document \u00b6 Topics: Examining Slides/Pages; Page Layers; Styles. Chapter (228 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . Chapter 13. Drawing Basic Shapes \u00b6 Topics: A Black Dashed Line; A Red Ellipse; Filled Rectangles; Text; Shape Names; A Transparent Circle and a Polar Line; A Math Formula as an OLE Shape; Polygons; Multiple Lines, Partial Elipses. Chapter (488 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . Chapter 14. Animation \u00b6 Topics: Circle Movement; Line Rotation; Animating an Image; The Gallery Module. Chapter (292 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . Chapter 15. Complex Shapes \u00b6 Topics: Connecting Two Rectangles; Shape Composition (grouping, binding, and combining); Combining with Dispatches; Undoing Composition; Bezier Curves (simple and complex). Chapter (404 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . Chapter 16. Making Slides \u00b6 Topics: Creating Slides: title, subtitle, bullets, images, video, buttons; Shape Animations; Dispatch Shapes (special symbols, block arrows, 3D shapes, flowchart elements, callouts, and stars); Slide Viewing. Chapter (572 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . wildlife.wmv video (38.5 MB) Chapter 17. Slide Deck Manipulation \u00b6 Topics: Deck Building; Master Pages; Adding a Slide to a Deck; Rearranging a Deck; Appending Two Decks; Exporting a Slide as an Image; Extracting the Text from a Deck. Chapter (368 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . Chapter 18. Slide Shows \u00b6 Topics: Starting a Slide Show; Play and End a Slide Show Automatically; Play a Slide Show Repeatedly; Play a Custom Slide Show. Chapter (236 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . Part 4: Calc Modules \u00b6 Chapter 19. Calc API Overview \u00b6 Topics: The Spreadsheet Document; Document Spreadsheets; Spreadsheet Data; The Spreadsheet Service; Cell Range Services; Cell Services; Sheet Cell Ranges. Chapter (380 KB; pdf). Updated: 20 th March 2017. Examples (Calc Tests/) (372 KB; zip). Updated: 2 nd October 2015. Place Calc Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 20. Spreadsheet Displaying and Creation \u00b6 Topics: Displaying a Document; Read-only and Protected Viewing; Active Sheets; Sheet Names; Zooming; Creating a Document; Cell Names and Ranges; Cell Values; Data Arrays; Rows and Columns of Data; Adding a Picture and a Chart. Chapter (200 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 21. Extracting Data \u00b6 Topics: Getting a Cell Value; Getting the Data from a Cell Range; Getting Rows and Columns of Data; Obtaining Cell Ranges by Using Queries; Finding the Used Area with Sheet Cursors. Chapter (204 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 22. Styles \u00b6 Topics: Obtaining Style Information: the TableCellStyle and TablePageStyle Services; Creating and Using a New Style; Adding Borders. Chapter (164 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 23. Garlic Secrets \u00b6 Topics: Freezing Rows; GeneralFunctions; Sheet Searching; Sheet Range Queries; Hidden Cells; Cell Merging; Splitting Windows; View Panes; View State Data; Active Panes; Inserting Rows and Columns; Shifting Cells. Chapter (392 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 24. Complex Data Manipulation \u00b6 Topics: Sorting Data; Generating Data: Automatic, LINEAR Mode, DATE Mode, GROWTH Mode; Fancy Text: borders, headlines, hyperlinks, annotations. Chapter (228 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 25. Monitoring Sheets \u00b6 Topics: Listening for Document Modifications (XModifyListener); Listening for Application Closing (XTopWindowListener); Listening for Cell Selection (XSelectionChangeListener). Chapter (156 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 26. Search and Replace \u00b6 Topics: XSearchable; XReplaceable; SearchDescriptor; ReplaceDescriptor; Searching Iteratively; Searching For All Matches; Replacing All Matches. Chapter (228 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Chapter 27. Functions and Data Analysis \u00b6 Topics: Calling Calc Functions from Code; Pivot Tables; Goal Seek; Linear and Nonlinear Solving (using SCO, DEPS). Chapter (560 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 . Part 5: Chart Modules \u00b6 Chapter 28. Chart2 API Overview \u00b6 Topics: Charting Elements; Chart Creation: TableChart, ChartDocument, linking template, diagram, and data source; Modifying Chart Elements: diagram, coordinate system, chart type, data series. Chapter (596 KB; pdf). Updated: 20 th March 2017. Examples (Chart2 Tests/) (36 KB; zip). Updated: 7 th Nov. 2015. Place Chart2 Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 29. Column Charts \u00b6 Topics: Creating a Chart Title; Creating Axis Titles; Rotating Axis Titles; What Chart Templates are Available?; Multiple Columns; 3D Pizazz; The Column and Line Chart. Chapter (284 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 . Chapter 30. Bar, Pie, Area, Line Charts \u00b6 Topics: The Bar Chart; The Pie Chart; 3D Pie; Donuts; The Area Chart; The Line Chart: multiple lines. Chapter (412 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 . Chapter 31. XY (Scatter) Charts \u00b6 Topics: A Scatter Chart (with Regressions); Calculating Regressions; Drawing a Regression Curve; Changing Axis Scales; Adding Error Bars. Chapter (476 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 . Chapter 32. Bubble, Net, Stock Charts \u00b6 Topics: The Bubble Chart; The Net Chart; The Stock Chart: basic and modified candle sticks; Stock Chart and Line Graph. Chapter (436 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 . Chapter 33. Using Charts in Other Documents \u00b6 Topics: Copy-and-Paste Dispatches; Adding a Chart to a Text Document; Adding a Chart to a Slide Document; Saving the Chart as an Image. Chapter (216 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 . Part 6: Base Modules \u00b6 Chapter 34. From JDBC to the Base API \u00b6 Topics: Three Database Modules: sdbc, sdbcx, sdb; A Little JDBC; From JDBC to sdbc. Chapter (336 KB; pdf). Updated: 20 th March 2017. Examples (Base Tests/) (276 KB; zip). Updated: 13 th April 2016. Place Base Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 35. Examining Base Documents \u00b6 Topics: Querying an Embedded HSQLDB Database; Using Metadata when Querying; Debugging Database Code; Creating a Base Document; Processing Multiple SQL Commands; Displaying Table Relationships; Prepared Statements; Scrollable and Updatable Result Sets; Converting a Database to Text. Chapter (576 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 . Chapter 36. Using RowSets and Database Context \u00b6 Topics: Using RowSets; Using the Database Context; Copying Data From Base To Calc. Chapter (260 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 . Chapter 37. Using the Driver Manager \u00b6 Topics: Querying a CSV File; Querying an Access File; Querying a Calc Spreadsheet; Querying a Thunderbird Address Book. Chapter (232 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 . Chapter 38. Treating an ODB File as a Zipped Folder \u00b6 Topics: Extracting a Database from an ODB File; Querying an Extracted HSQLDB Database; Querying an Extracted Firebird Database. Chapter (380 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 . Part 7: Cross-application Modules \u00b6 Chapter 39. Forms API Overview \u00b6 Topics: An Overview of the Forms API; Examining a Text-based Form; Attaching Listeners to a View. Chapter (388 KB; pdf). Updated: 20 th March 2017. Examples (Forms Tests/) (52 KB; zip). Updated: 14 th June 2016. Place Forms Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 40. Building a Form Programmatically \u00b6 Topics: Creating Controls; Assigning a Data Source to a Form; Creating Data-aware Controls; Attaching Listeners. Chapter (376 KB; pdf). Updated: 20 th March 2017. For the examples (Forms Tests/), see chapter 39 . Chapter 41. Printing \u00b6 Topics: The Java Print Service (JPS); Printing in Office Writer, Impress, Calc; Viewing a Document's Print Properties; Specialized Printing: Writer, Impress, Calc; Hacking the GUI; Command Prompt Printing. Chapter (600 KB; pdf). Updated: 20 th March 2017. Examples (Printing Tests/) (744 KB; zip). Updated: 26 th June 2016. Place Printing Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 42. Sending E-mail \u00b6 Topics: SimpleSystemMail / SimpleCommandMail; Using the MailServiceProvider Service; Using JavaMail; The Desktop API; Thunderbird Scripting; Office Mail Merge. Chapter (468 KB; pdf). Updated: 20 th March 2017. Examples (Mail Tests/) (132 KB; zip). Updated: 8 th July 2016. Place Mail Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 43. Using the Clipboard \u00b6 Topics: The Office Clipboard API: adding, retrieving, text, images; Java's Clipboard API adding, retrieving, text, images, 2D arrays; Copy and Pasting in an Office Document: Writer, Calc, Impress, Base. Chapter (512 KB; pdf). Updated: 20 th March 2017. Examples (Clipboard Tests/) (416 KB; zip). Updated: 21 st July 2016. Place Clipboard Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 44. Office as a GUI Component \u00b6 Topics: OOoBean; Wrapping OOoBean in a JPanel; Using the OBeanPanel; Using an Undecorated Office Window; Augmenting the User Interface: a New Toolbar Item; Augmenting the User Interface: a New Menu Item. Chapter (500 KB; pdf). Updated: 20 th March 2017. Examples (GUI Tests/) (400 KB; zip). Updated: 29 th August 2016. Place GUI Tests/ and Utils/ (see chapter 1 ) in the same directory. Part 8: Extending LibreOffice \u00b6 Chapter 45. Coding UNO Components \u00b6 Topics: Using the RandomSents Component; Writing IDL Definitions; Using idlc.bat; Merging Type Data into a Registry Database; Generating the Java Package and Interface; Creating a Skeleton Component; Compiling the Completed Implementation; Packaging the Component; Installing the Extension; Using a New Component in a Program. Chapter (480 KB; pdf). Updated: 20 th March 2017. Examples (UNO Comps Tests/) (1.51 MB; zip). Updated: 26 th Sept. 2016. Place UNO Comps Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 46. Add-ons \u00b6 Topics: What is an Add-on?; Creating the EzHighlight Add-on; Creating a Partial Add-on Implementation; The FreeMarker-generated EzHighlightAddonImpl; Creating the Dialog; Configuring the Add-on; Building and Installing the OXT File. Chapter (616 KB; pdf). Updated: 20 th March 2017. Examples (AddOn Tests/) (428 KB; zip). Updated: 14 th Oct. 2016. Place AddOn Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 47. Calc Add-ins \u00b6 Topics: Implementing a Calc Add-in; The IDL definitions of the Functions; XCU creation. Chapter (480 KB; pdf). Updated: 20 th March 2017. Examples (Addin Tests/) (1.74 MB; zip). Updated: 4 th Nov. 2016. Place Addin Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 48. Event Macros \u00b6 Topics: Macro Locations; Naming Macro Functions; Calling Existing Macros; The LibreLogo Macro; Writing a Simple Event Macro; Automating the Assigning of Event Macros. Chapter (652 KB; pdf). Updated: 20 th March 2017. Examples (EvMacro Tests/) (636 KB; zip). Updated: 16 th Dec. 2016. Place EvMacro Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 49. Extension and Document Event Macros \u00b6 Topics: Form Macros as an Extension; Loading an XML Dialog; Building a Dialog at Runtime; Storing Macros inside the (Form) Document; Attaching Macros to Other Events; Executing Macros from the Command Line. Chapter (528 KB; pdf). Updated: 20 th March 2017. For the examples (EvMacro Tests/), see chapter 48 . Part 9: The ODF Format \u00b6 Chapter 50. Importing XML \u00b6 Topics: XSLT Filters; Using Filters with Java; Alternatives to XSLT Filters: DOM Parsing, Node and Attribute Data Extraction, JAXB Conversion. Chapter (582 KB; pdf). Updated: 20 th March 2017. Examples (Filter Tests/) (56 KB; zip). Updated: 6 th Jan. 2017. Place Filter Tests/ and Utils/ (see chapter 1 ) in the same directory. Chapter 51. Simple ODF \u00b6 Topics: The OpenDocument Format; Doc Information; Unzipping an ODF Doc; the Simple Java API for ODF (Apache ODF Toolkit): making docs (text, sheet, and slides), slide movement, doc concatenation (text, sheet, and slides). Chapter (304 KB; pdf). Updated: 20 th March 2017. Examples (ODFToolkit Tests/) (544 KB; zip). Updated: 13 th Jan. 2017. Place ODFToolkit Tests/ and Utils/ (see chapter 1 ) in the same directory. A collection of all the libraries needed to get ODF Toolkit to work (\"ODFToolkit Libs\") (78.7 MB ). Updated: 13 th Jan. 2017.","title":"Preface"},{"location":"index.html#preface","text":"Star Basic is the native language of Star Office which has been incorporated by Open Office and Libre Office. This means that all other supported languages must negotiate a basic bridge. This comment from Dan Dascalescu offers a challenge to the community: after 20 years of software development, the LibreOffice API is the crappiest one I've had the \"pleasure\" of working with. The documentation is horrible , spread all over the place, littered with Uyghur , or completely missing . The LibreOffice macro IDE is also extremely unhelpful. LibreOffice Programming offers a framework for the community to take another step to change this. The starting point is Java LibreOffice Programming which we thank Andrew Davison for kindly making available provided his work is acknowledged. Since Java is not Basic it provides good insight into using non-Basic languages even if the language is different. Changes required are reformatting for this media since the scripts have missed a lot of detail including code, generalising the content so it is more widely applicable to supported languages and complementing Java examples with examples of other language. Please contribute where you can. \u00a9 Contributors: Andrew Davison, flywire https://creativecommons.org/licenses/by-sa/4.0/","title":"Preface"},{"location":"index.html#overview","text":"Java LibreOffice Programming (JLOP) is intended for programmers who want to learn how to use the Java version of the LibreOffice API. This allows Java to control and manipulate LibreOffice's text, drawing, presentation, spreadsheet, and database applications, and a lot more (e.g. its spell checker, forms designer, and charting tools). This book is not about how to use LibreOffice's GUI. I won't explain where to find a particular menu item to change text colour or run the spell checker. But I will explain how to do these kinds of things via API calls from Java programs. For instance, I describe a program that constructs a Word file full of randomly generated algebra questions, and show how a ASCII text file can be transformed into a slide presentation. Although most of the examples are Java programs that call the LibreOffice API, I briefly look at other kinds of programming, such as Java macros and new LibreOffice functionality, accessible via menu items or as spreadsheet functions, and the dispatching of commands to the GUI. One of my aims was to develop utility code to help flatten the steep learning curve for the API. For example, my Lo class simplifies the steps needed to initialize the API (by creating a connection to a LibreOffice process), to open/create a document, save it, and close down LibreOffice. Another aim was to have my code work on LibreOffice and OpenOffice , which isn't difficult since their APIs are nearly identical. However, I must admit that at this stage I've restricted myself to testing the programs only on LibreOffice, and only on MS Windows.","title":"Overview"},{"location":"index.html#part-1-basics","text":"","title":"Part 1: Basics"},{"location":"index.html#chapter-1-libreoffice-api-concepts","text":"Topics: Some History; Help and Examples for the LibreOffice SDK (loDoc, loGuide); Office as a Process; Common Structures (Interface, Property, Service, and Component); Service and Interface Inheritance Hierarchies; the Frame-Controller-Model (FCM) Relationship; Extensions; Comparison with Basic. Chapter (400 KB; pdf). Updated: 20 th March 2017. Utilities (Utils/) (184 KB; zip). Updated: 13 th Jan. 2017. How to install, compile, and run my code.","title":"Chapter 1. LibreOffice API Concepts"},{"location":"index.html#chapter-2-starting-and-stopping","text":"Topics: Starting Office; Closing Down/Killing Office; Opening a Document; Creating a Document; Saving; Closing; Document Conversion; Bug Detection and Reporting. Chapter (472 KB; pdf). Updated: 20 th March 2017. Examples (Office Tests/) (920 KB; zip). Updated: 15 th August 2015. Place Office Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 2. Starting and Stopping"},{"location":"index.html#chapter-3-examining","text":"Topics: Examining Office; Getting and Setting Document Properties; Examining a Document for API Details; Examining a Document Using MRI. Chapter (312 KB; pdf). Updated: 20 th March 2017. For the examples (Office Tests/), see chapter 2 .","title":"Chapter 3. Examining"},{"location":"index.html#chapter-4-listening-and-other-techniques","text":"Topics: Window Listeners; Office Manipulation with JNA; Dispatching; Robot Keys. Chapter (208 KB; pdf). Updated: 20 th March 2017. For the examples (Office Tests/), see chapter 2 .","title":"Chapter 4. Listening, and Other Techniques"},{"location":"index.html#part-2-writer-modules","text":"","title":"Part 2: Writer Modules"},{"location":"index.html#chapter-5-text-api-overview","text":"Topics: API Overview; Text Cursors; Extracting Text; Cursor Iteration; Creating Cursors; Creating a Document; Using and Comparing Text Cursors; Inserting/Changing Text in a Document; Text Enumeration; Appending Documents. Chapter (344 KB; pdf). Updated: 20 th March 2017. Examples (Text Tests/) (304 KB; zip). Updated: 15 th August 2015. Place Text Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 5. Text API Overview"},{"location":"index.html#chapter-6-text-styles","text":"Topics: Five Style Families; Properties; Listing Styles; Creating a Style; Applying Styles; Paragraph/Word Styles; Hyperlink Styling; Text Numbering; Headers and Footers. Chapter (396 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 .","title":"Chapter 6. Text Styles"},{"location":"index.html#chapter-7-text-content-other-than-strings","text":"Topics: Accessing Text Content; Text Frames; Embedded Objects (Math Formulae); Text Fields; Text Tables; Bookmarks. Chapter (528 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 .","title":"Chapter 7. Text Content Other than Strings"},{"location":"index.html#chapter-8-graphic-content","text":"Topics: Graphics; Linked Images/Shapes. Chapter (252 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 .","title":"Chapter 8. Graphic Content"},{"location":"index.html#chapter-9-text-search-and-replace","text":"Topics: Finding the First Matching Phrase; Replacing all the Matching Words; Finding all Matching Phrases. Chapter (144 KB; pdf). Updated: 20 th March 2017. For the examples (Text Tests/), see chapter 5 .","title":"Chapter 9. Text Search and Replace"},{"location":"index.html#chapter-10-the-linguistics-api","text":"Topics: Linguistic Tools; Using the Spell Checker; Using the Thesaurus; Grammar Checking; Guessing the Language used in a String; Spell Checking and Grammar Checking a Document. Chapter (628 KB; pdf). Updated: 20 th March 2017. Examples (Lingu Tests/) (40 KB; zip). Updated: 2 nd August 2016. Place Lingu Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 10. The Linguistics API"},{"location":"index.html#part-3-draw-impress-modules","text":"","title":"Part 3: Draw &amp; Impress Modules"},{"location":"index.html#chapter-11-drawimpress-apis-overview","text":"Topics: Draw Pages and Master Pages; Draw Page Details; API Hierarchy Code Examples; Shapes in a Drawing; Shapes in a Presentation ; The Slide Show APIs. Chapter (360 KB; pdf). Updated: 20 th March 2017. Examples (Draw Tests/) (1.77 MB; zip). Updated: 15 th August 2015. Place Draw Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 11. Draw/Impress APIs Overview"},{"location":"index.html#chapter-12-examining-a-drawimpress-document","text":"Topics: Examining Slides/Pages; Page Layers; Styles. Chapter (228 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 .","title":"Chapter 12. Examining a Draw/Impress Document"},{"location":"index.html#chapter-13-drawing-basic-shapes","text":"Topics: A Black Dashed Line; A Red Ellipse; Filled Rectangles; Text; Shape Names; A Transparent Circle and a Polar Line; A Math Formula as an OLE Shape; Polygons; Multiple Lines, Partial Elipses. Chapter (488 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 .","title":"Chapter 13. Drawing Basic Shapes"},{"location":"index.html#chapter-14-animation","text":"Topics: Circle Movement; Line Rotation; Animating an Image; The Gallery Module. Chapter (292 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 .","title":"Chapter 14. Animation"},{"location":"index.html#chapter-15-complex-shapes","text":"Topics: Connecting Two Rectangles; Shape Composition (grouping, binding, and combining); Combining with Dispatches; Undoing Composition; Bezier Curves (simple and complex). Chapter (404 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 .","title":"Chapter 15. Complex Shapes"},{"location":"index.html#chapter-16-making-slides","text":"Topics: Creating Slides: title, subtitle, bullets, images, video, buttons; Shape Animations; Dispatch Shapes (special symbols, block arrows, 3D shapes, flowchart elements, callouts, and stars); Slide Viewing. Chapter (572 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 . wildlife.wmv video (38.5 MB)","title":"Chapter 16. Making Slides"},{"location":"index.html#chapter-17-slide-deck-manipulation","text":"Topics: Deck Building; Master Pages; Adding a Slide to a Deck; Rearranging a Deck; Appending Two Decks; Exporting a Slide as an Image; Extracting the Text from a Deck. Chapter (368 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 .","title":"Chapter 17. Slide Deck Manipulation"},{"location":"index.html#chapter-18-slide-shows","text":"Topics: Starting a Slide Show; Play and End a Slide Show Automatically; Play a Slide Show Repeatedly; Play a Custom Slide Show. Chapter (236 KB; pdf). Updated: 20 th March 2017. For the examples (Draw Tests/), see chapter 11 .","title":"Chapter 18. Slide Shows"},{"location":"index.html#part-4-calc-modules","text":"","title":"Part 4: Calc Modules"},{"location":"index.html#chapter-19-calc-api-overview","text":"Topics: The Spreadsheet Document; Document Spreadsheets; Spreadsheet Data; The Spreadsheet Service; Cell Range Services; Cell Services; Sheet Cell Ranges. Chapter (380 KB; pdf). Updated: 20 th March 2017. Examples (Calc Tests/) (372 KB; zip). Updated: 2 nd October 2015. Place Calc Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 19. Calc API Overview"},{"location":"index.html#chapter-20-spreadsheet-displaying-and-creation","text":"Topics: Displaying a Document; Read-only and Protected Viewing; Active Sheets; Sheet Names; Zooming; Creating a Document; Cell Names and Ranges; Cell Values; Data Arrays; Rows and Columns of Data; Adding a Picture and a Chart. Chapter (200 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 20. Spreadsheet Displaying and Creation"},{"location":"index.html#chapter-21-extracting-data","text":"Topics: Getting a Cell Value; Getting the Data from a Cell Range; Getting Rows and Columns of Data; Obtaining Cell Ranges by Using Queries; Finding the Used Area with Sheet Cursors. Chapter (204 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 21. Extracting Data"},{"location":"index.html#chapter-22-styles","text":"Topics: Obtaining Style Information: the TableCellStyle and TablePageStyle Services; Creating and Using a New Style; Adding Borders. Chapter (164 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 22. Styles"},{"location":"index.html#chapter-23-garlic-secrets","text":"Topics: Freezing Rows; GeneralFunctions; Sheet Searching; Sheet Range Queries; Hidden Cells; Cell Merging; Splitting Windows; View Panes; View State Data; Active Panes; Inserting Rows and Columns; Shifting Cells. Chapter (392 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 23. Garlic Secrets"},{"location":"index.html#chapter-24-complex-data-manipulation","text":"Topics: Sorting Data; Generating Data: Automatic, LINEAR Mode, DATE Mode, GROWTH Mode; Fancy Text: borders, headlines, hyperlinks, annotations. Chapter (228 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 24. Complex Data Manipulation"},{"location":"index.html#chapter-25-monitoring-sheets","text":"Topics: Listening for Document Modifications (XModifyListener); Listening for Application Closing (XTopWindowListener); Listening for Cell Selection (XSelectionChangeListener). Chapter (156 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 25. Monitoring Sheets"},{"location":"index.html#chapter-26-search-and-replace","text":"Topics: XSearchable; XReplaceable; SearchDescriptor; ReplaceDescriptor; Searching Iteratively; Searching For All Matches; Replacing All Matches. Chapter (228 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 26. Search and Replace"},{"location":"index.html#chapter-27-functions-and-data-analysis","text":"Topics: Calling Calc Functions from Code; Pivot Tables; Goal Seek; Linear and Nonlinear Solving (using SCO, DEPS). Chapter (560 KB; pdf). Updated: 20 th March 2017. For the examples (Calc Tests/), see chapter 19 .","title":"Chapter 27. Functions and Data Analysis"},{"location":"index.html#part-5-chart-modules","text":"","title":"Part 5: Chart Modules"},{"location":"index.html#chapter-28-chart2-api-overview","text":"Topics: Charting Elements; Chart Creation: TableChart, ChartDocument, linking template, diagram, and data source; Modifying Chart Elements: diagram, coordinate system, chart type, data series. Chapter (596 KB; pdf). Updated: 20 th March 2017. Examples (Chart2 Tests/) (36 KB; zip). Updated: 7 th Nov. 2015. Place Chart2 Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 28. Chart2 API Overview"},{"location":"index.html#chapter-29-column-charts","text":"Topics: Creating a Chart Title; Creating Axis Titles; Rotating Axis Titles; What Chart Templates are Available?; Multiple Columns; 3D Pizazz; The Column and Line Chart. Chapter (284 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 .","title":"Chapter 29. Column Charts"},{"location":"index.html#chapter-30-bar-pie-area-line-charts","text":"Topics: The Bar Chart; The Pie Chart; 3D Pie; Donuts; The Area Chart; The Line Chart: multiple lines. Chapter (412 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 .","title":"Chapter 30. Bar, Pie, Area, Line Charts"},{"location":"index.html#chapter-31-xy-scatter-charts","text":"Topics: A Scatter Chart (with Regressions); Calculating Regressions; Drawing a Regression Curve; Changing Axis Scales; Adding Error Bars. Chapter (476 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 .","title":"Chapter 31. XY (Scatter) Charts"},{"location":"index.html#chapter-32-bubble-net-stock-charts","text":"Topics: The Bubble Chart; The Net Chart; The Stock Chart: basic and modified candle sticks; Stock Chart and Line Graph. Chapter (436 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 .","title":"Chapter 32. Bubble, Net, Stock Charts"},{"location":"index.html#chapter-33-using-charts-in-other-documents","text":"Topics: Copy-and-Paste Dispatches; Adding a Chart to a Text Document; Adding a Chart to a Slide Document; Saving the Chart as an Image. Chapter (216 KB; pdf). Updated: 20 th March 2017. For the examples (Chart2 Tests/), see chapter 28 .","title":"Chapter 33. Using Charts in Other Documents"},{"location":"index.html#part-6-base-modules","text":"","title":"Part 6: Base Modules"},{"location":"index.html#chapter-34-from-jdbc-to-the-base-api","text":"Topics: Three Database Modules: sdbc, sdbcx, sdb; A Little JDBC; From JDBC to sdbc. Chapter (336 KB; pdf). Updated: 20 th March 2017. Examples (Base Tests/) (276 KB; zip). Updated: 13 th April 2016. Place Base Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 34. From JDBC to the Base API"},{"location":"index.html#chapter-35-examining-base-documents","text":"Topics: Querying an Embedded HSQLDB Database; Using Metadata when Querying; Debugging Database Code; Creating a Base Document; Processing Multiple SQL Commands; Displaying Table Relationships; Prepared Statements; Scrollable and Updatable Result Sets; Converting a Database to Text. Chapter (576 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 .","title":"Chapter 35. Examining Base Documents"},{"location":"index.html#chapter-36-using-rowsets-and-database-context","text":"Topics: Using RowSets; Using the Database Context; Copying Data From Base To Calc. Chapter (260 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 .","title":"Chapter 36. Using RowSets and Database Context"},{"location":"index.html#chapter-37-using-the-driver-manager","text":"Topics: Querying a CSV File; Querying an Access File; Querying a Calc Spreadsheet; Querying a Thunderbird Address Book. Chapter (232 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 .","title":"Chapter 37. Using the Driver Manager"},{"location":"index.html#chapter-38-treating-an-odb-file-as-a-zipped-folder","text":"Topics: Extracting a Database from an ODB File; Querying an Extracted HSQLDB Database; Querying an Extracted Firebird Database. Chapter (380 KB; pdf). Updated: 20 th March 2017. For the examples (Base Tests/), see chapter 34 .","title":"Chapter 38. Treating an ODB File as a Zipped Folder"},{"location":"index.html#part-7-cross-application-modules","text":"","title":"Part 7: Cross-application Modules"},{"location":"index.html#chapter-39-forms-api-overview","text":"Topics: An Overview of the Forms API; Examining a Text-based Form; Attaching Listeners to a View. Chapter (388 KB; pdf). Updated: 20 th March 2017. Examples (Forms Tests/) (52 KB; zip). Updated: 14 th June 2016. Place Forms Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 39. Forms API Overview"},{"location":"index.html#chapter-40-building-a-form-programmatically","text":"Topics: Creating Controls; Assigning a Data Source to a Form; Creating Data-aware Controls; Attaching Listeners. Chapter (376 KB; pdf). Updated: 20 th March 2017. For the examples (Forms Tests/), see chapter 39 .","title":"Chapter 40. Building a Form Programmatically"},{"location":"index.html#chapter-41-printing","text":"Topics: The Java Print Service (JPS); Printing in Office Writer, Impress, Calc; Viewing a Document's Print Properties; Specialized Printing: Writer, Impress, Calc; Hacking the GUI; Command Prompt Printing. Chapter (600 KB; pdf). Updated: 20 th March 2017. Examples (Printing Tests/) (744 KB; zip). Updated: 26 th June 2016. Place Printing Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 41. Printing"},{"location":"index.html#chapter-42-sending-e-mail","text":"Topics: SimpleSystemMail / SimpleCommandMail; Using the MailServiceProvider Service; Using JavaMail; The Desktop API; Thunderbird Scripting; Office Mail Merge. Chapter (468 KB; pdf). Updated: 20 th March 2017. Examples (Mail Tests/) (132 KB; zip). Updated: 8 th July 2016. Place Mail Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 42. Sending E-mail"},{"location":"index.html#chapter-43-using-the-clipboard","text":"Topics: The Office Clipboard API: adding, retrieving, text, images; Java's Clipboard API adding, retrieving, text, images, 2D arrays; Copy and Pasting in an Office Document: Writer, Calc, Impress, Base. Chapter (512 KB; pdf). Updated: 20 th March 2017. Examples (Clipboard Tests/) (416 KB; zip). Updated: 21 st July 2016. Place Clipboard Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 43. Using the Clipboard"},{"location":"index.html#chapter-44-office-as-a-gui-component","text":"Topics: OOoBean; Wrapping OOoBean in a JPanel; Using the OBeanPanel; Using an Undecorated Office Window; Augmenting the User Interface: a New Toolbar Item; Augmenting the User Interface: a New Menu Item. Chapter (500 KB; pdf). Updated: 20 th March 2017. Examples (GUI Tests/) (400 KB; zip). Updated: 29 th August 2016. Place GUI Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 44. Office as a GUI Component"},{"location":"index.html#part-8-extending-libreoffice","text":"","title":"Part 8: Extending LibreOffice"},{"location":"index.html#chapter-45-coding-uno-components","text":"Topics: Using the RandomSents Component; Writing IDL Definitions; Using idlc.bat; Merging Type Data into a Registry Database; Generating the Java Package and Interface; Creating a Skeleton Component; Compiling the Completed Implementation; Packaging the Component; Installing the Extension; Using a New Component in a Program. Chapter (480 KB; pdf). Updated: 20 th March 2017. Examples (UNO Comps Tests/) (1.51 MB; zip). Updated: 26 th Sept. 2016. Place UNO Comps Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 45. Coding UNO Components"},{"location":"index.html#chapter-46-add-ons","text":"Topics: What is an Add-on?; Creating the EzHighlight Add-on; Creating a Partial Add-on Implementation; The FreeMarker-generated EzHighlightAddonImpl; Creating the Dialog; Configuring the Add-on; Building and Installing the OXT File. Chapter (616 KB; pdf). Updated: 20 th March 2017. Examples (AddOn Tests/) (428 KB; zip). Updated: 14 th Oct. 2016. Place AddOn Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 46. Add-ons"},{"location":"index.html#chapter-47-calc-add-ins","text":"Topics: Implementing a Calc Add-in; The IDL definitions of the Functions; XCU creation. Chapter (480 KB; pdf). Updated: 20 th March 2017. Examples (Addin Tests/) (1.74 MB; zip). Updated: 4 th Nov. 2016. Place Addin Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 47. Calc Add-ins"},{"location":"index.html#chapter-48-event-macros","text":"Topics: Macro Locations; Naming Macro Functions; Calling Existing Macros; The LibreLogo Macro; Writing a Simple Event Macro; Automating the Assigning of Event Macros. Chapter (652 KB; pdf). Updated: 20 th March 2017. Examples (EvMacro Tests/) (636 KB; zip). Updated: 16 th Dec. 2016. Place EvMacro Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 48. Event Macros"},{"location":"index.html#chapter-49-extension-and-document-event-macros","text":"Topics: Form Macros as an Extension; Loading an XML Dialog; Building a Dialog at Runtime; Storing Macros inside the (Form) Document; Attaching Macros to Other Events; Executing Macros from the Command Line. Chapter (528 KB; pdf). Updated: 20 th March 2017. For the examples (EvMacro Tests/), see chapter 48 .","title":"Chapter 49. Extension and Document Event Macros"},{"location":"index.html#part-9-the-odf-format","text":"","title":"Part 9: The ODF Format"},{"location":"index.html#chapter-50-importing-xml","text":"Topics: XSLT Filters; Using Filters with Java; Alternatives to XSLT Filters: DOM Parsing, Node and Attribute Data Extraction, JAXB Conversion. Chapter (582 KB; pdf). Updated: 20 th March 2017. Examples (Filter Tests/) (56 KB; zip). Updated: 6 th Jan. 2017. Place Filter Tests/ and Utils/ (see chapter 1 ) in the same directory.","title":"Chapter 50. Importing XML"},{"location":"index.html#chapter-51-simple-odf","text":"Topics: The OpenDocument Format; Doc Information; Unzipping an ODF Doc; the Simple Java API for ODF (Apache ODF Toolkit): making docs (text, sheet, and slides), slide movement, doc concatenation (text, sheet, and slides). Chapter (304 KB; pdf). Updated: 20 th March 2017. Examples (ODFToolkit Tests/) (544 KB; zip). Updated: 13 th Jan. 2017. Place ODFToolkit Tests/ and Utils/ (see chapter 1 ) in the same directory. A collection of all the libraries needed to get ODF Toolkit to work (\"ODFToolkit Libs\") (78.7 MB ). Updated: 13 th Jan. 2017.","title":"Chapter 51. Simple ODF"},{"location":"01%20Part%201%20Basics.html","text":"Part 1 Basics \u00b6","title":"Part 1 Basics"},{"location":"01%20Part%201%20Basics.html#part-1-basics","text":"","title":"Part 1 Basics"},{"location":"01-Concepts.html","text":"Chapter 1. LibreOffice API Concepts \u00b6 Topics Some History; Help and Examples for the LibreOffice SDK (lodoc, loguide); Office as a Process; Common Structures (Interface, Property, Service, and Component); Service and Interface Inheritance Hierarchies; the Frame- Controller-Model (FCM) Relationship; Extensions; Comparison with Basic Example folder: \"Utils\" This chapter describes LibreOffice API concepts without resorting to code (that comes along in the next chapter). These concepts include Office as a (possibly networked) process, the interface, property, service, and component structures, the two API inheritance hierarchies, and the Frame-Controller-Model (FCM) relationship. LibreOffice is an open source, cross-platform, office suite, made up of six main applications, and lots of other useful stuff. The applications are: Writer (a word processor), Draw (vector graphics drawing), Impress (for slide presentations), Calc (spreadsheets), Base (a database front- end), and Math (for writing formulae). Some of the lesser- known features include a charting library, spell checker, forms designer, thesaurus, e- mail package, and support for extensions (e.g. new menu items and libraries). Aside from Open Document Format (ODF) files, LibreOffice can import, convert, and export a vast number of text, graphic, and other formats, including Microsoft Office documents, PDF, HTML, SWF (Flash), and SQL databases. LibreOffice is managed and developed by The Document Foundation ( https://libreoffice.org/ ), and was first released in 2010. However, earlier Office versions date back to the 1980's, and traces of this heritage are visible in many parts of its API. Figure 1 shows a simplified timeline of how StarOffice begat OpenOffice, and so on to LibreOffice. Figure 1. Office's Timeline. This book is not about how to use LibreOffice's GUI (e.g. where to find the menu item for italicizing text). I'm also not going to discuss how to compile the LibreOffice source, which is a focus of LibreOffice's development webpage ( https://wiki.documentfoundation.org/Development/ ). My intention is to explain the Java API that comes as part of the LibreOffice SDK, which you can obtain from https://libreoffice.org/download/libreoffice-still/ . If you're unsure how to install the SDK then please refer to the website accompanying this book ( https://fivedots.coe.psu.ac.th/~ad/jlop/ ). The \"Installing the code for Java LibreOffice Programming\" page at https://fivedots.coe.psu.ac.th/~ad/jlop/install.html gives step-by-step instructions, and also explains how to download the book's utility classes and examples. 1. Sources for API Information \u00b6 Rather amazingly, today's API in LibreOffice is almost 100% compatible with OpenOffice, which means that code developed 10-15 years ago (i.e. during the Sun and Oracle stewardships of Office) still works with no (or very minor) changes. It also means that a programmer can choose to read the LibreOffice Java API documentation or the older OpenOffice material since, apart from formatting differences, they're virtually the same. However, my preference is for the LibreOffice pages because of the clickable inheritance diagrams, as I'll explain later. Indeed, the examples at the LibreOffice API website ( https://api.libreoffice.org/ ) link to the OpenOffice Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OpenOffice.org_Developers_Guide/ . Sadly, that rather old manual (for OpenOffice v3.1 released in 2009) is the only long description of the Java Office API, and is overly technical in places. It can be downloaded as a single PDF file from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . The PDF version has two drawbacks \u2013 its sections and sub-sections are unnumbered, making the overall structure of each chapter somewhat confusing. Another problem is that many of the code examples are missing newline characters, so are hard to read. This book is my attempt to write a more gradual, modern introduction to the API. I'm going to refer to the LibreOffice and OpenOffice APIs collectively as the Office API due to their similarities. I believe that everything I say about LibreOffice Java programming applies to OpenOffice. But, to be honest, I've only tested my examples in LibreOffice on Windows 7. If you do find any inconsistencies, then please contact me at ad@fivedots.coe.psu.ac.th with details. I hope this book will make the more esoteric materials in the developer's guide easier to understand. One of the ways I'll be flattening the learning curve is by hiding parts of the API behind my own collection of utility classes. This is far from being a novel idea, as it seems that every programmer who has ever written more than a few pages of Office code ends up developing support functions. I've gratefully borrowed very liberally from those intrepid programmers, but I take full responsibility for my coding choices. There's a lot of Java Office API examples and code snippets online (as you might expect after 15+ years of existence). Your first stop should be the two groups of examples at https://api.libreoffice.org/examples/examples.html (in the Java and Developer's Guide subdirectories). They can also be found in the Office download in /sdk/examples; Basic, C++ and Python code is there as well. By the way, is my way of writing the path to the LibreOffice directory, which for example is \"C:\\Program Files\\LibreOffice 5\" on my 32-bit test machine. You should also browse the LibreOffice development forums ( https://imaccanici.org/en.libreofficeforum.org/ ) and the corresponding ones for OpenOffice ( https://forum.openoffice.org/en/forum/ ). Look for the sub-forums that talk about the UNO API and/or macros. Sadly, imaccanici.org is an archive of the defunct https://en.libreofficeforum.org/ site, but the OpenOffice forum is still going strong, and very relevant. LibreOffice has a question-posing page, at https://ask.libreoffice.org/en/questions/ , which is a good source of information. https://oooforum.org/ is an older forum site, which has the unfortunate habit of periodically disappearing from the Web. Often the only way to access one of its posts or threads is via cached pages maintained by Google. The Office API has been ported to many programming languages. The API was first coded in C++, and later converted to Java, Basic, Python, C#, Perl, JavaScript, OORexx, and many more. The most popular language is probably Basic, which is principally used for writing macros (also called scripts) embedded in Office documents, or in the Office application. A big advantage of Basic is its lack of typing, which simplifies its version of the API. Basic macros utilize a similar set of Office API functions as Java, so can be a useful source of ideas. Perhaps the best place for learning about Office macro programming is Andrew Pitonyak's website ( https://pitonyak.org/ ), which includes an excellent free-to- download book: \"OpenOffice.org Macros Explained\", a macros cookbook, and a document focusing on database macros. Another great site is https://openoffice3.web.fc2.com/ , which is mostly written in Japanese. This shouldn't put off non-Japanese readers since Google is quite happy to translate the pages for you, and the code examples are mostly ASCII. Finding API Documentation Online \u00b6 The online API documentation can be time-consuming to search due to its great size. If you want to have a browse, start at https://api.libreoffice.org/docs/idl/ref/namespaces.html , which takes a while to load. Each Office application (e.g. Writer, Draw, Impress, Calc, Base, Math) is supported by multiple modules (similar to Java packages). For example, most of Writer's API is in Office's \"text\" module, while Impress' functionality comes from the \"presentation\" and \"drawing\" modules. These modules are located in com.sun.star package, which is documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star.html . Rather than searching manually through a module for a given class, it's a lot quicker to get a search engine to do it for you. This is the purpose of my lodoc.bat batch file, which utilizes DuckDuckGo ( https://duckduckgo.com/ ). For instance, at the command line, you can type: lodoc xtext and the Office API documentation on the XText interface will open in your browser. lodoc.bat is 'almost' always returns the right page, mainly because Office interfaces, and many of its services, have long unique names. (I'll explain what a service is shortly.) loDoc.bat can be found in the Utils/ folder listed at the start of this chapter, and its also included in every example folder used in later chapters. Service names are less unusual, and so you should probably add the word \"service\" to your search. For instance, if you're looking for the Text service, type: lodoc text service Module names are also quite common words, so add \"module\" to the search. If you want to reach the \"text\" module (which implements most of Writer), search for: lodoc text module You can call lodoc with Office application names, which are mapped to API module names. For instance: lodoc Impress brings up the \"presentation\" module page. You may be wondering why I chose to implement this script using DuckDuckGo rather than Google? Google doesn't seem to like me querying it from the command line. It periodically keeps asking me to type in a captcha string when I call it from lodoc.bat. Another problem is that Google likes to replace my search strings with 'more likely' strings. Searching the Online Developer's Guide \u00b6 The online Developer's Guide can also be time-consuming to search because it's both long (around 1650 pages), and poorly organized. To help, I've written a small batch file called loGuide.bat which is quite similar to loDoc.bat. It calls DuckDuckGo, limiting the search to the Developer's Guide web pages, and loads the first matching page into your web browser. For example: loguide \"Lifetime of UNO Objects\" loads the guide page with that heading into the browser. A less precise query will probably produce the same page, but even when the result is 'wrong' it'll still be somewhere in the guide. loGuide.bat can be found in the Utils/ folder mentioned at the start of this chapter, and is also included in every example folder used in later chapters. The first argument of loGuide.bat can be an Office application name, which restricts the search to the part of the guide focusing on that application's API. For instance: loguide Calc \"Data Validation\" and loguide impress \"Page Formatting\" search the Calc and Impress parts of the guide. Calling loGuide.bat with just an application name, opens the guide at the start of the chapter on that topic. For example: loguide writer opens the guide at the start of the \"Text Documents\" chapter. Calling loGuide.bat with no arguments, makes the browser load the first page of the guide. 2. Office as a Process \u00b6 Office is started as an OS process, and a Java program communicates with it via a socket or named pipe. This necessarily complicates the Java/Office link, which is illustrated in Figure 2. Figure 2. A Java Program Using Office. The invocation of Office and the setup of a named pipe link can be achieved with a single call to the SDK's Bootstrap.bootstrap() method. Its source code is available online, and makes for interesting reading. (Probably the most reliable way of finding it is to google using the terms `Bootstrap libreoffice filetype:java.) bootstrap() starts the Office executable (called soffice.exe) with several command line arguments, the most important being \"-accept\" which specifies the use of pipes or sockets for the interprocess link. A call to XUnoUrlResolver.resolve() inside bootstrap() creates a remote component context, which acts as proxy for the 'real' component context over in the Office process (see Figure 2). The context is a container/environment for components and UNO objects which I'll explain below. When a Java program refers to components and UNO objects in the remote component context, the interprocess bridge maps those references across the process boundaries to the corresponding components and objects on the Office side. Underpinning this mapping is the Universal Network Object (UNO) model which links objects in different environments using the UNO remote protocol (URP). For example, a method call is converted into a byte stream, sent across the bridge and reconstructed. Method results are returned in the same way. Thankfully, this network communication is hidden by the Office API. The only place a beginner might encounter UNO mechanisms is when loading or saving documents. Every document (more generally called a resource) is referred to using a Uniform Resource Identifier (URI); URIs are employed by Office\u2019s Universal Content Broker (UCB) and Universal Content Providers (UCPs) to load and save a wide range of data formats. Bootstrap.bootstrap() sets up a remote component context based on named pipes, but if you want to utilize sockets, then the coding is left to you. My Lo utility class contains a socketContext() method that does the necessary work, and I'll show some examples of its use in the next chapter. Obtaining a remote component context is not the end of Office\u2019s initialization. Typically, at least three UNO objects are needed over on the Java side for most programming tasks: a service manager, a Desktop object, and a component loader. The service manager is used to load additional services into Office at runtime. The Desktop object has nothing to do with the OS'es desktop \u2013 it refers to the top-level of the Office application, particularly to its GUI. The component loader is used to load or create Office documents. Other UNO objects might be more useful depending on your programming task. For example, for historical reasons, Office supports two slightly different service managers (one that requires an explicit component context argument, and an older one that doesn't). I've chosen to add both of them to the component context, as a convenience to the programmer; this detail is hidden by my Lo util class. 3. API Data Structures: interface, property, service, and component \u00b6 There are four main data structures used by the API: interface, property, service, and component. The use of the word 'interface' is obviously influenced by its meaning in Java, but it's probably best to keep it separate in your mind. An Office interface is a collection of method prototypes (i.e. method names, input arguments, and return types) without any implementation or associated data. A property is a name-value pair, used to store data. A service comprises a set of interfaces and properties needed to support an Office feature. Figure 3 illustrates how interface, property, and service are related. Figure 3. Services, Interfaces, Properties. The Office documentation often talks about property structs (e.g. the Point and KeyEvent structs). These are coded in Java as classes, and their names often clash with classes in the standard JDK which can complicate their usage. Since interfaces contain no code, a service is a specification for an Office feature. When a service is implemented (i.e. its interfaces are implemented), it becomes a component. This distinction means that the Office API can be implemented in different languages (as components) but always employs the same specifications (services), as represented in Figure 4. Figure 4. Components and Services. The developer's guide uses a notation like that shown in Figure 5 to draw a service and its interfaces. Figure 5. The OfficeDocument service. I haven't drawn all the interfaces for OfficeDocument, since they're quite numerous, and I haven\u2019t listed the methods defined by each interface. The developer's guide drawing for the SpellChecker service is shown in Figure 6. Figure 6. The SpellChecker service. The two figures illustrate a useful naming convention: all interface names start with the letter \"X\". The developer's guide notation leaves out information about the properties managed by the services. Also, the services webpages at the LibreOffice site don't use the guide\u2019s notation. The URLs for these pages are somewhat difficult to remember. The best thing is to use my loDoc.bat tool to find them. For instance, you can access the office document and spell checker services with: lodoc officedocument service and lodoc spellchecker service Note that the \"officedocument\" search result isn't ideal \u2013 it takes you to the IDL page for the service. You need to click on the \"OfficeDocument\" link under the \"Classes\" heading to get to the actual service details. The LibreOffice service webpages usually list properties, but sometimes refer to them as 'attributes'. If the service documentation doesn't describe the properties, then they're probably being managed by a separate \u201cSupplier\u201d interface (e.g. XDocumentPropertiesSupplier for OfficeDocument in Figure 5). The supplier will include methods for accessing the properties as an XPropertySet object. One great feature of the LibreOffice webpages is the inheritance diagrams on each service and interface page. Part of the diagram for the OfficeDocument service is shown in Figure 7. Figure 7. Part of the Inheritance Diagram for the OfficeDocument Service. Each box in the diagram can be clicked upon to jump to the documentation for that subclass or superclass. 4. Two Inheritance Hierarchies for Services and interfaces \u00b6 Services and interfaces both use inheritance, as shown by the UML diagram in Figure 8. Figure 8. Service and Interface Relationships and Hierarchies. For example, OfficeDocument is the superclass service of all other document formats, as illustrated in Figure 9. Figure 9. OfficeDocument as a Superclass Service. Part of this hierarchy can also be seen in Figure 7. An interface can also be part of an inheritance hierarchy. For instance, the XModel interface inherits XComponent and XInterface, as in Figure 10. Figure 10. The Superclasses of XModel. The LibreOffice documentation graphically displays these hierarchies (e.g. see Figure 7), but makes no visual distinction between the service and interface hierarchies. It also represents the \"contains\" relationship between services and interfaces as inheritance, rather than as lines with circles as in the developer's guide (e.g. see Figures 5 and 6). 5. The FCM Relationship \u00b6 The Frame-Controller-Model (FCM) relationship (or design pattern) is a part of Office which programmers will encounter frequently. It appears in the API as connections between the XFrame, XController, and XModel interfaces, as shown in Figure 11. Figure 11. The FCM Relationship. Every Office document inherits the OfficeDocument service (see Figure 9), and Figure 5 shows that OfficeDocument supports the XModel interface. This means that every document will include XModel methods for accessing the document's resources, such as its URL, file name, type, and meta information. Via XModel.getCurrentController(), a document's controller can be accessed. A controller manages the visual presentation of a document. For instance, the Office GUI interacts with the controller to position the cursor in a document, to control which page is displayed, and to highlight selections. The XController interface belongs to the Controller service, which is a superclass for viewing documents; subclasses include TextDocumentView, DrawingDocumentDrawView, and PresentationView. From XController, it's possible to reach XFrame, which contains information about the document's display window. A document utilizes two XWindow objects, called the component and container windows. The component window represents the rectangular area on screen that displays the document. It also handles GUI events, such as window activation or minimization. The container window is the component's parent. For example, a component window displaying a chart might be contained within a spreadsheet window A frame can contain child frames, allowing the Office GUI to be thought of as a tree of frames. The root frame of this tree is the Desktop object, which you may recall is one of the first three objects stored in the remote component context when we start Office. This means that we can move around the frames in the Office GUI starting from the loaded document, or from the root frame referred to from XDesktop. For example, XDesktop provides getCurrentFrame() to access the currently active frame. 6. Components Again \u00b6 A knowledge of the FCM relationship, and its XFrame, XController, and XModel interfaces, lets me give a more detailed definition of a component. Back in section 3 (and in Figure 4), I said a component was an implemented service. Another way of understanding a component is in terms of how much of the FCM relationship it supports, which allows the 'component' idea to be divided into three: A component that supports both the XModel and XController interfaces is usually an Office document. A component with a controller but no model is typically used to implement library functionality that doesn't need to load data. Examples include the spell checker, and Office tools for creating database forms. A component with no model or controller (i.e. just an XWindow object) is used for simple GUI elements, such as Office's help windows. Of these three types, the component-as-document (number 1) is the most important for our needs. In particular, I'll be using the component loader in the remote component context to load Office documents. 7. What's an Extension? \u00b6 The Office developer's guide often uses the words 'extension', 'add-on', and 'add-in'. I'll be spending four chapters on these features in Part 8 (along with macro programming in Java), but it's worth briefly explaining them now. An extension is a code library that extends Office's functionality. For Java programmers, an extension usually takes the form of a JAR file containing a service, its interfaces, properties, and their implementations. Since an extension implements the service, it may also be referred to as a component. An add-on is an extension with additional XML files defining a GUI for the extension (e.g. a menu bar, menu item, or toolbar icon). An add-on is rendered in Office's GUI in the same way as standard Office elements. An add-in or, to use its full name, a Calc Add-in, is an extension that adds a new function to Calc. 8. A Comparison with the Basic API \u00b6 If you start searching the forums, newsgroups, blogs, and web sites for Office examples, it soon becomes clear that Java is not the language of choice for most Office programmers. Basic (sometimes called StarBasic, OpenOffice.org Basic, LibreOffice Basic, or even Visual Basic or VB by mistake) is the darling of the coding crowd. This is understandable since Office (both LibreOffice and OpenOffice) includes an IDE for editing and debugging Basic macros. Also, there's a lot of good resources on how to utilize these tools (e.g. start browsing the LibreOffice wiki page \"LibreOffice Basic Help\", https://help.libreoffice.org/Basic/Basic_Help/ ). The few books that have been written about programming the Office API have all used Basic (e.g. Pitonyak's \"OpenOffice.org Macros Explained\" at https://pitonyak.org/book/ ). There are two styles of Basic macro programming \u2013 scripts can be attached to specific documents, or to the Office application. In a document, a macro can respond to Office events, such as the loading of the document, or its modification. The macro can monitor the user's key presses or menu button presses, and can utilize Office dialogs. This isn't the place for a language war between Java and Basic, but it's fair to say that the Basic Office API is simpler than the Java version! This is partly due to the fact that Basic has a weaker typing system than Java, but also that the Office abstractions used by Basic are simpler than those in Java. The main difference is that the Basic API doesn't use interfaces. Instead of a service containing a collection of interfaces, each of which has methods, a Basic service directly contains all the methods. This means that an Office service can be understood as a plain-old object containing methods and data (in the form of properties). I'm at a loss why this abstraction wasn't used in Java. One use of interfaces is to employ interface typing, but most of the typing protection is applied at runtime when one interface is cast to another. This means that one of the big benefits of typing (compile-time error detection) is lost. Another advantage of Basic is its hiding of the complexities of accessing Office at start-up, and for requesting services. In comparison, for many years, there was no Bootstrap class in the Java Office API. This meant that every Java programmer had to grapple with difficult code for linking to Office and obtaining a remote component context. In the Basic API, there's no remote component context since the macros run inside Office or inside a document that is loaded into Office. Incidentally, this means that Basic code doesn't need those few extra microseconds for every operation to communicate across process boundaries. The Basic programmer still utilizes a service manager, Desktop object, and perhaps a loader. This means that the first few lines of a macro might be: Dim oSM , oDesk , oDoc As Object Set oSM = CreateObject ( \"com.sun.star.ServiceManager\" ) Set oDesk = oSM . createInstance ( \"com.sun.star.frame.Desktop\" ) Set oDoc = oDesk . loadComponentFromURL ( \"file:///C:/tmp/testdoc.odt\" , \"_blank\" , 0 , noArgs ()) However, if the script is part of a loaded document, then the call to loadComponentFromURL() isn't needed, reducing the code to: Set oSM = CreateObject ( \"com.sun.star.ServiceManager\" ) Set oDesk = oSM . createInstance ( \"com.sun.star.frame.Desktop\" ) Set oDoc = oDesk . CurrentComponent Also, Office's Basic runtime environment automatically creates a service manager and Desktop object, so it's unnecessary to create them explicitly. This reduces the code to a one-liner: Set oDoc = StarDesktop . CurrentComponent or even: Set oDoc = ThisComponent If other services are needed, Basic programmers call the createUnoService() function which transparently requests the named service from the service manager. For instance: set sfAcc = CreateUnoService ( \"com.sun.star.ucb.SimpleFileAccess\" ) sfAcc . CreateFolder ( dirName ) Recall that a Basic service contains all the methods from its interfaces, so once the service reference has been obtained, methods can be called directly. One of the aims of my utilities is to hide as much of the complexity of Office as the Basic version of the API. Having just reread this section, I may have just convinced myself to become a Basic programmer \uf04a. The reason I'm going to stick with Java is that it's a full-featured language, with massive numbers of standard and third-part APIs which can augment the Office API.","title":"Chapter 1. LibreOffice API Concepts"},{"location":"01-Concepts.html#chapter-1-libreoffice-api-concepts","text":"Topics Some History; Help and Examples for the LibreOffice SDK (lodoc, loguide); Office as a Process; Common Structures (Interface, Property, Service, and Component); Service and Interface Inheritance Hierarchies; the Frame- Controller-Model (FCM) Relationship; Extensions; Comparison with Basic Example folder: \"Utils\" This chapter describes LibreOffice API concepts without resorting to code (that comes along in the next chapter). These concepts include Office as a (possibly networked) process, the interface, property, service, and component structures, the two API inheritance hierarchies, and the Frame-Controller-Model (FCM) relationship. LibreOffice is an open source, cross-platform, office suite, made up of six main applications, and lots of other useful stuff. The applications are: Writer (a word processor), Draw (vector graphics drawing), Impress (for slide presentations), Calc (spreadsheets), Base (a database front- end), and Math (for writing formulae). Some of the lesser- known features include a charting library, spell checker, forms designer, thesaurus, e- mail package, and support for extensions (e.g. new menu items and libraries). Aside from Open Document Format (ODF) files, LibreOffice can import, convert, and export a vast number of text, graphic, and other formats, including Microsoft Office documents, PDF, HTML, SWF (Flash), and SQL databases. LibreOffice is managed and developed by The Document Foundation ( https://libreoffice.org/ ), and was first released in 2010. However, earlier Office versions date back to the 1980's, and traces of this heritage are visible in many parts of its API. Figure 1 shows a simplified timeline of how StarOffice begat OpenOffice, and so on to LibreOffice. Figure 1. Office's Timeline. This book is not about how to use LibreOffice's GUI (e.g. where to find the menu item for italicizing text). I'm also not going to discuss how to compile the LibreOffice source, which is a focus of LibreOffice's development webpage ( https://wiki.documentfoundation.org/Development/ ). My intention is to explain the Java API that comes as part of the LibreOffice SDK, which you can obtain from https://libreoffice.org/download/libreoffice-still/ . If you're unsure how to install the SDK then please refer to the website accompanying this book ( https://fivedots.coe.psu.ac.th/~ad/jlop/ ). The \"Installing the code for Java LibreOffice Programming\" page at https://fivedots.coe.psu.ac.th/~ad/jlop/install.html gives step-by-step instructions, and also explains how to download the book's utility classes and examples.","title":"Chapter 1. LibreOffice API Concepts"},{"location":"01-Concepts.html#1-sources-for-api-information","text":"Rather amazingly, today's API in LibreOffice is almost 100% compatible with OpenOffice, which means that code developed 10-15 years ago (i.e. during the Sun and Oracle stewardships of Office) still works with no (or very minor) changes. It also means that a programmer can choose to read the LibreOffice Java API documentation or the older OpenOffice material since, apart from formatting differences, they're virtually the same. However, my preference is for the LibreOffice pages because of the clickable inheritance diagrams, as I'll explain later. Indeed, the examples at the LibreOffice API website ( https://api.libreoffice.org/ ) link to the OpenOffice Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OpenOffice.org_Developers_Guide/ . Sadly, that rather old manual (for OpenOffice v3.1 released in 2009) is the only long description of the Java Office API, and is overly technical in places. It can be downloaded as a single PDF file from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . The PDF version has two drawbacks \u2013 its sections and sub-sections are unnumbered, making the overall structure of each chapter somewhat confusing. Another problem is that many of the code examples are missing newline characters, so are hard to read. This book is my attempt to write a more gradual, modern introduction to the API. I'm going to refer to the LibreOffice and OpenOffice APIs collectively as the Office API due to their similarities. I believe that everything I say about LibreOffice Java programming applies to OpenOffice. But, to be honest, I've only tested my examples in LibreOffice on Windows 7. If you do find any inconsistencies, then please contact me at ad@fivedots.coe.psu.ac.th with details. I hope this book will make the more esoteric materials in the developer's guide easier to understand. One of the ways I'll be flattening the learning curve is by hiding parts of the API behind my own collection of utility classes. This is far from being a novel idea, as it seems that every programmer who has ever written more than a few pages of Office code ends up developing support functions. I've gratefully borrowed very liberally from those intrepid programmers, but I take full responsibility for my coding choices. There's a lot of Java Office API examples and code snippets online (as you might expect after 15+ years of existence). Your first stop should be the two groups of examples at https://api.libreoffice.org/examples/examples.html (in the Java and Developer's Guide subdirectories). They can also be found in the Office download in /sdk/examples; Basic, C++ and Python code is there as well. By the way, is my way of writing the path to the LibreOffice directory, which for example is \"C:\\Program Files\\LibreOffice 5\" on my 32-bit test machine. You should also browse the LibreOffice development forums ( https://imaccanici.org/en.libreofficeforum.org/ ) and the corresponding ones for OpenOffice ( https://forum.openoffice.org/en/forum/ ). Look for the sub-forums that talk about the UNO API and/or macros. Sadly, imaccanici.org is an archive of the defunct https://en.libreofficeforum.org/ site, but the OpenOffice forum is still going strong, and very relevant. LibreOffice has a question-posing page, at https://ask.libreoffice.org/en/questions/ , which is a good source of information. https://oooforum.org/ is an older forum site, which has the unfortunate habit of periodically disappearing from the Web. Often the only way to access one of its posts or threads is via cached pages maintained by Google. The Office API has been ported to many programming languages. The API was first coded in C++, and later converted to Java, Basic, Python, C#, Perl, JavaScript, OORexx, and many more. The most popular language is probably Basic, which is principally used for writing macros (also called scripts) embedded in Office documents, or in the Office application. A big advantage of Basic is its lack of typing, which simplifies its version of the API. Basic macros utilize a similar set of Office API functions as Java, so can be a useful source of ideas. Perhaps the best place for learning about Office macro programming is Andrew Pitonyak's website ( https://pitonyak.org/ ), which includes an excellent free-to- download book: \"OpenOffice.org Macros Explained\", a macros cookbook, and a document focusing on database macros. Another great site is https://openoffice3.web.fc2.com/ , which is mostly written in Japanese. This shouldn't put off non-Japanese readers since Google is quite happy to translate the pages for you, and the code examples are mostly ASCII.","title":"1.  Sources for API Information"},{"location":"01-Concepts.html#finding-api-documentation-online","text":"The online API documentation can be time-consuming to search due to its great size. If you want to have a browse, start at https://api.libreoffice.org/docs/idl/ref/namespaces.html , which takes a while to load. Each Office application (e.g. Writer, Draw, Impress, Calc, Base, Math) is supported by multiple modules (similar to Java packages). For example, most of Writer's API is in Office's \"text\" module, while Impress' functionality comes from the \"presentation\" and \"drawing\" modules. These modules are located in com.sun.star package, which is documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star.html . Rather than searching manually through a module for a given class, it's a lot quicker to get a search engine to do it for you. This is the purpose of my lodoc.bat batch file, which utilizes DuckDuckGo ( https://duckduckgo.com/ ). For instance, at the command line, you can type: lodoc xtext and the Office API documentation on the XText interface will open in your browser. lodoc.bat is 'almost' always returns the right page, mainly because Office interfaces, and many of its services, have long unique names. (I'll explain what a service is shortly.) loDoc.bat can be found in the Utils/ folder listed at the start of this chapter, and its also included in every example folder used in later chapters. Service names are less unusual, and so you should probably add the word \"service\" to your search. For instance, if you're looking for the Text service, type: lodoc text service Module names are also quite common words, so add \"module\" to the search. If you want to reach the \"text\" module (which implements most of Writer), search for: lodoc text module You can call lodoc with Office application names, which are mapped to API module names. For instance: lodoc Impress brings up the \"presentation\" module page. You may be wondering why I chose to implement this script using DuckDuckGo rather than Google? Google doesn't seem to like me querying it from the command line. It periodically keeps asking me to type in a captcha string when I call it from lodoc.bat. Another problem is that Google likes to replace my search strings with 'more likely' strings.","title":"Finding API Documentation Online"},{"location":"01-Concepts.html#searching-the-online-developers-guide","text":"The online Developer's Guide can also be time-consuming to search because it's both long (around 1650 pages), and poorly organized. To help, I've written a small batch file called loGuide.bat which is quite similar to loDoc.bat. It calls DuckDuckGo, limiting the search to the Developer's Guide web pages, and loads the first matching page into your web browser. For example: loguide \"Lifetime of UNO Objects\" loads the guide page with that heading into the browser. A less precise query will probably produce the same page, but even when the result is 'wrong' it'll still be somewhere in the guide. loGuide.bat can be found in the Utils/ folder mentioned at the start of this chapter, and is also included in every example folder used in later chapters. The first argument of loGuide.bat can be an Office application name, which restricts the search to the part of the guide focusing on that application's API. For instance: loguide Calc \"Data Validation\" and loguide impress \"Page Formatting\" search the Calc and Impress parts of the guide. Calling loGuide.bat with just an application name, opens the guide at the start of the chapter on that topic. For example: loguide writer opens the guide at the start of the \"Text Documents\" chapter. Calling loGuide.bat with no arguments, makes the browser load the first page of the guide.","title":"Searching the Online Developer's Guide"},{"location":"01-Concepts.html#2-office-as-a-process","text":"Office is started as an OS process, and a Java program communicates with it via a socket or named pipe. This necessarily complicates the Java/Office link, which is illustrated in Figure 2. Figure 2. A Java Program Using Office. The invocation of Office and the setup of a named pipe link can be achieved with a single call to the SDK's Bootstrap.bootstrap() method. Its source code is available online, and makes for interesting reading. (Probably the most reliable way of finding it is to google using the terms `Bootstrap libreoffice filetype:java.) bootstrap() starts the Office executable (called soffice.exe) with several command line arguments, the most important being \"-accept\" which specifies the use of pipes or sockets for the interprocess link. A call to XUnoUrlResolver.resolve() inside bootstrap() creates a remote component context, which acts as proxy for the 'real' component context over in the Office process (see Figure 2). The context is a container/environment for components and UNO objects which I'll explain below. When a Java program refers to components and UNO objects in the remote component context, the interprocess bridge maps those references across the process boundaries to the corresponding components and objects on the Office side. Underpinning this mapping is the Universal Network Object (UNO) model which links objects in different environments using the UNO remote protocol (URP). For example, a method call is converted into a byte stream, sent across the bridge and reconstructed. Method results are returned in the same way. Thankfully, this network communication is hidden by the Office API. The only place a beginner might encounter UNO mechanisms is when loading or saving documents. Every document (more generally called a resource) is referred to using a Uniform Resource Identifier (URI); URIs are employed by Office\u2019s Universal Content Broker (UCB) and Universal Content Providers (UCPs) to load and save a wide range of data formats. Bootstrap.bootstrap() sets up a remote component context based on named pipes, but if you want to utilize sockets, then the coding is left to you. My Lo utility class contains a socketContext() method that does the necessary work, and I'll show some examples of its use in the next chapter. Obtaining a remote component context is not the end of Office\u2019s initialization. Typically, at least three UNO objects are needed over on the Java side for most programming tasks: a service manager, a Desktop object, and a component loader. The service manager is used to load additional services into Office at runtime. The Desktop object has nothing to do with the OS'es desktop \u2013 it refers to the top-level of the Office application, particularly to its GUI. The component loader is used to load or create Office documents. Other UNO objects might be more useful depending on your programming task. For example, for historical reasons, Office supports two slightly different service managers (one that requires an explicit component context argument, and an older one that doesn't). I've chosen to add both of them to the component context, as a convenience to the programmer; this detail is hidden by my Lo util class.","title":"2.  Office as a Process"},{"location":"01-Concepts.html#3-api-data-structures-interface-property-service-and-component","text":"There are four main data structures used by the API: interface, property, service, and component. The use of the word 'interface' is obviously influenced by its meaning in Java, but it's probably best to keep it separate in your mind. An Office interface is a collection of method prototypes (i.e. method names, input arguments, and return types) without any implementation or associated data. A property is a name-value pair, used to store data. A service comprises a set of interfaces and properties needed to support an Office feature. Figure 3 illustrates how interface, property, and service are related. Figure 3. Services, Interfaces, Properties. The Office documentation often talks about property structs (e.g. the Point and KeyEvent structs). These are coded in Java as classes, and their names often clash with classes in the standard JDK which can complicate their usage. Since interfaces contain no code, a service is a specification for an Office feature. When a service is implemented (i.e. its interfaces are implemented), it becomes a component. This distinction means that the Office API can be implemented in different languages (as components) but always employs the same specifications (services), as represented in Figure 4. Figure 4. Components and Services. The developer's guide uses a notation like that shown in Figure 5 to draw a service and its interfaces. Figure 5. The OfficeDocument service. I haven't drawn all the interfaces for OfficeDocument, since they're quite numerous, and I haven\u2019t listed the methods defined by each interface. The developer's guide drawing for the SpellChecker service is shown in Figure 6. Figure 6. The SpellChecker service. The two figures illustrate a useful naming convention: all interface names start with the letter \"X\". The developer's guide notation leaves out information about the properties managed by the services. Also, the services webpages at the LibreOffice site don't use the guide\u2019s notation. The URLs for these pages are somewhat difficult to remember. The best thing is to use my loDoc.bat tool to find them. For instance, you can access the office document and spell checker services with: lodoc officedocument service and lodoc spellchecker service Note that the \"officedocument\" search result isn't ideal \u2013 it takes you to the IDL page for the service. You need to click on the \"OfficeDocument\" link under the \"Classes\" heading to get to the actual service details. The LibreOffice service webpages usually list properties, but sometimes refer to them as 'attributes'. If the service documentation doesn't describe the properties, then they're probably being managed by a separate \u201cSupplier\u201d interface (e.g. XDocumentPropertiesSupplier for OfficeDocument in Figure 5). The supplier will include methods for accessing the properties as an XPropertySet object. One great feature of the LibreOffice webpages is the inheritance diagrams on each service and interface page. Part of the diagram for the OfficeDocument service is shown in Figure 7. Figure 7. Part of the Inheritance Diagram for the OfficeDocument Service. Each box in the diagram can be clicked upon to jump to the documentation for that subclass or superclass.","title":"3.  API Data Structures: interface, property, service, and component"},{"location":"01-Concepts.html#4-two-inheritance-hierarchies-for-services-and-interfaces","text":"Services and interfaces both use inheritance, as shown by the UML diagram in Figure 8. Figure 8. Service and Interface Relationships and Hierarchies. For example, OfficeDocument is the superclass service of all other document formats, as illustrated in Figure 9. Figure 9. OfficeDocument as a Superclass Service. Part of this hierarchy can also be seen in Figure 7. An interface can also be part of an inheritance hierarchy. For instance, the XModel interface inherits XComponent and XInterface, as in Figure 10. Figure 10. The Superclasses of XModel. The LibreOffice documentation graphically displays these hierarchies (e.g. see Figure 7), but makes no visual distinction between the service and interface hierarchies. It also represents the \"contains\" relationship between services and interfaces as inheritance, rather than as lines with circles as in the developer's guide (e.g. see Figures 5 and 6).","title":"4.  Two Inheritance Hierarchies for Services and interfaces"},{"location":"01-Concepts.html#5-the-fcm-relationship","text":"The Frame-Controller-Model (FCM) relationship (or design pattern) is a part of Office which programmers will encounter frequently. It appears in the API as connections between the XFrame, XController, and XModel interfaces, as shown in Figure 11. Figure 11. The FCM Relationship. Every Office document inherits the OfficeDocument service (see Figure 9), and Figure 5 shows that OfficeDocument supports the XModel interface. This means that every document will include XModel methods for accessing the document's resources, such as its URL, file name, type, and meta information. Via XModel.getCurrentController(), a document's controller can be accessed. A controller manages the visual presentation of a document. For instance, the Office GUI interacts with the controller to position the cursor in a document, to control which page is displayed, and to highlight selections. The XController interface belongs to the Controller service, which is a superclass for viewing documents; subclasses include TextDocumentView, DrawingDocumentDrawView, and PresentationView. From XController, it's possible to reach XFrame, which contains information about the document's display window. A document utilizes two XWindow objects, called the component and container windows. The component window represents the rectangular area on screen that displays the document. It also handles GUI events, such as window activation or minimization. The container window is the component's parent. For example, a component window displaying a chart might be contained within a spreadsheet window A frame can contain child frames, allowing the Office GUI to be thought of as a tree of frames. The root frame of this tree is the Desktop object, which you may recall is one of the first three objects stored in the remote component context when we start Office. This means that we can move around the frames in the Office GUI starting from the loaded document, or from the root frame referred to from XDesktop. For example, XDesktop provides getCurrentFrame() to access the currently active frame.","title":"5.  The FCM Relationship"},{"location":"01-Concepts.html#6-components-again","text":"A knowledge of the FCM relationship, and its XFrame, XController, and XModel interfaces, lets me give a more detailed definition of a component. Back in section 3 (and in Figure 4), I said a component was an implemented service. Another way of understanding a component is in terms of how much of the FCM relationship it supports, which allows the 'component' idea to be divided into three: A component that supports both the XModel and XController interfaces is usually an Office document. A component with a controller but no model is typically used to implement library functionality that doesn't need to load data. Examples include the spell checker, and Office tools for creating database forms. A component with no model or controller (i.e. just an XWindow object) is used for simple GUI elements, such as Office's help windows. Of these three types, the component-as-document (number 1) is the most important for our needs. In particular, I'll be using the component loader in the remote component context to load Office documents.","title":"6.  Components Again"},{"location":"01-Concepts.html#7-whats-an-extension","text":"The Office developer's guide often uses the words 'extension', 'add-on', and 'add-in'. I'll be spending four chapters on these features in Part 8 (along with macro programming in Java), but it's worth briefly explaining them now. An extension is a code library that extends Office's functionality. For Java programmers, an extension usually takes the form of a JAR file containing a service, its interfaces, properties, and their implementations. Since an extension implements the service, it may also be referred to as a component. An add-on is an extension with additional XML files defining a GUI for the extension (e.g. a menu bar, menu item, or toolbar icon). An add-on is rendered in Office's GUI in the same way as standard Office elements. An add-in or, to use its full name, a Calc Add-in, is an extension that adds a new function to Calc.","title":"7.  What's an Extension?"},{"location":"01-Concepts.html#8-a-comparison-with-the-basic-api","text":"If you start searching the forums, newsgroups, blogs, and web sites for Office examples, it soon becomes clear that Java is not the language of choice for most Office programmers. Basic (sometimes called StarBasic, OpenOffice.org Basic, LibreOffice Basic, or even Visual Basic or VB by mistake) is the darling of the coding crowd. This is understandable since Office (both LibreOffice and OpenOffice) includes an IDE for editing and debugging Basic macros. Also, there's a lot of good resources on how to utilize these tools (e.g. start browsing the LibreOffice wiki page \"LibreOffice Basic Help\", https://help.libreoffice.org/Basic/Basic_Help/ ). The few books that have been written about programming the Office API have all used Basic (e.g. Pitonyak's \"OpenOffice.org Macros Explained\" at https://pitonyak.org/book/ ). There are two styles of Basic macro programming \u2013 scripts can be attached to specific documents, or to the Office application. In a document, a macro can respond to Office events, such as the loading of the document, or its modification. The macro can monitor the user's key presses or menu button presses, and can utilize Office dialogs. This isn't the place for a language war between Java and Basic, but it's fair to say that the Basic Office API is simpler than the Java version! This is partly due to the fact that Basic has a weaker typing system than Java, but also that the Office abstractions used by Basic are simpler than those in Java. The main difference is that the Basic API doesn't use interfaces. Instead of a service containing a collection of interfaces, each of which has methods, a Basic service directly contains all the methods. This means that an Office service can be understood as a plain-old object containing methods and data (in the form of properties). I'm at a loss why this abstraction wasn't used in Java. One use of interfaces is to employ interface typing, but most of the typing protection is applied at runtime when one interface is cast to another. This means that one of the big benefits of typing (compile-time error detection) is lost. Another advantage of Basic is its hiding of the complexities of accessing Office at start-up, and for requesting services. In comparison, for many years, there was no Bootstrap class in the Java Office API. This meant that every Java programmer had to grapple with difficult code for linking to Office and obtaining a remote component context. In the Basic API, there's no remote component context since the macros run inside Office or inside a document that is loaded into Office. Incidentally, this means that Basic code doesn't need those few extra microseconds for every operation to communicate across process boundaries. The Basic programmer still utilizes a service manager, Desktop object, and perhaps a loader. This means that the first few lines of a macro might be: Dim oSM , oDesk , oDoc As Object Set oSM = CreateObject ( \"com.sun.star.ServiceManager\" ) Set oDesk = oSM . createInstance ( \"com.sun.star.frame.Desktop\" ) Set oDoc = oDesk . loadComponentFromURL ( \"file:///C:/tmp/testdoc.odt\" , \"_blank\" , 0 , noArgs ()) However, if the script is part of a loaded document, then the call to loadComponentFromURL() isn't needed, reducing the code to: Set oSM = CreateObject ( \"com.sun.star.ServiceManager\" ) Set oDesk = oSM . createInstance ( \"com.sun.star.frame.Desktop\" ) Set oDoc = oDesk . CurrentComponent Also, Office's Basic runtime environment automatically creates a service manager and Desktop object, so it's unnecessary to create them explicitly. This reduces the code to a one-liner: Set oDoc = StarDesktop . CurrentComponent or even: Set oDoc = ThisComponent If other services are needed, Basic programmers call the createUnoService() function which transparently requests the named service from the service manager. For instance: set sfAcc = CreateUnoService ( \"com.sun.star.ucb.SimpleFileAccess\" ) sfAcc . CreateFolder ( dirName ) Recall that a Basic service contains all the methods from its interfaces, so once the service reference has been obtained, methods can be called directly. One of the aims of my utilities is to hide as much of the complexity of Office as the Basic version of the API. Having just reread this section, I may have just convinced myself to become a Basic programmer \uf04a. The reason I'm going to stick with Java is that it's a full-featured language, with massive numbers of standard and third-part APIs which can augment the Office API.","title":"8.  A Comparison with the Basic API"},{"location":"02-Starting_and_Stopping.html","text":"Chapter 2. Starting and Stopping \u00b6 Topics Starting Office; Closing Down/Killing Office; Opening a Document; Creating a Document; Saving; Closing; Document Conversion; Bug Detection and Reporting Example folders: \"Office Tests\" and \"Utils\" Chapter 1 introduced some of the core ideas of Office. Now it's time to show how these data structures and relationships (e.g. service, interfaces, FCM, inheritance) are programmed in Office's Java API. This chapter will focus on the most fundamental tasks: starting Office, loading (or creating) a document, saving and closing the document, and shutting down Office. The DocConverter.java example at the end pulls these together to show how to convert a document into another format. All the examples come from the \"Office Tests\" directory in the code download associated with this book, and make liberal use of the classes in the \"Utils\" directory. For details please visit https://fivedots.coe.psu.ac.th/~ad/jlop/ . My aim with these utilities is to hide some of the verbiage of Office. When (if?) a programmer feels ready for more detail, then my code is documented. I'll only explain functions here that illustrate Office ideas, such as service managers and components. This is the first chapter with code, and so the first where programs could crash! Section 8 gives a few tips on bug detection and reporting. 1. Starting Office \u00b6 Every program must load Office before working with a document, and shut it down before exiting. These tasks are handled by loadOffice() and closeOffice() from the Lo utility class. A typical program will look like the following: import com.sun.star.uno.* ; import com.sun.star.lang.* ; import com.sun.star.frame.* ; public class OfficeInfo { public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); // load, manipulate and close a document Lo . closeOffice (); } // end of main() } // end of OfficeInfo class Lo.loadOffice() invokes Office and sets up a UNO bridge using named pipes. There's also a Lo.loadSocketOffice() which uses sockets instead of pipes. Both functions return a reference to a component loader which can be used to load a document. loadOffice() and loadSocketOffice() call a one-argument version of loadOffice() which uses a boolean to decide whether to use pipes or sockets to link to Office. In both cases, a remote component context is created on the Java side (see Chapter 1, Figure 2) and then a service manager, Desktop object, and component loader are initialized. The code below shows some details: // in the Lo class // globals private static XComponentContext xcc = null ; private static XDesktop xDesktop = null ; private static XMultiComponentFactory mcFactory = null ; public static XComponentLoader loadOffice ( boolean usingPipes ) { System . out . println ( \"Loading Office...\" ); if ( usingPipes ) xcc = bootstrapContext (); // connects to office via pipes else xcc = socketContext (); // connects to office via a socket if ( xcc == null ) { System . out . println ( \"Office context could not be created\" ); System . exit ( 1 ); } // get the remote office service manager mcFactory = xcc . getServiceManager (); if ( mcFactory == null ) { System . out . println ( \"Office Service Manager is unavailable\" ); System . exit ( 1 ); } // desktop service handles application windows and documents xDesktop = createInstanceMCF ( XDesktop . class , \"com.sun.star.frame.Desktop\" ); if ( xDesktop == null ) { System . out . println ( \"Could not create a desktop service\" ); System . exit ( 1 ); } // XComponentLoader provides ability to load components return Lo . qi ( XComponentLoader . class , xDesktop ); } // end of loadOffice() loadOffice() probably illustrates my most significant coding decisions \u2013 the use of global static variables inside the Lo class. In particular, the XComponentContext, XDesktop, and XMultiComponentFactory objects created by loadOffice() are stored globally for later use. I chose this approach since it allows other support functions to be called with simpler arguments because the objects can be accessed without the user having to explicitly pass around references to them. The main drawback is that loadOffice() cannot be safely called more than once (i.e. it is non-reentrant) since a second call will overwrite the globals set during the first call. The creation of the XDesktop interface object uses createInstanceMCF(): // in the Lo class public static < T > T createInstanceMCF ( Class < T > aType , String serviceName ) { if (( xcc == null ) || ( mcFactory == null )) { System . out . println ( \"No office connection found\" ); return null ; } T interfaceObj = null ; try { // get service, then interface Object o = mcFactory . createInstanceWithContext ( serviceName , xcc ); interfaceObj = Lo . qi ( aType , o ); } catch ( Exception e ) { System . out . println ( \"Couldn't create interface for \\\"\" + serviceName + \"\\\": \" + e ); } return interfaceObj ; } // end of createInstanceMCF() public static < T > T qi ( Class < T > aType , Object o ) // the \"Loki\" function -- reduces typing { return UnoRuntime . queryInterface ( aType , o ); } If you ignore the error-checking, createInstanceMCF() does two things. The call to XMultiComponentFactory.createInstanceWithContext() asks the service manager (mcFactory) to create a service object inside the remote component context (xcc). Then the call to UnoRuntime.queryInterface() looks inside the service instance for the specified interface (aType), returning an instance of the interface as its result. My Lo.qi() function's only purpose is to reduce programmer typing, since calls to UnoRuntime.queryInterface() are very common. The use of generics makes createInstanceMCF() useful for creating any type of interface object. Unfortunately, generics aren't utilized in the Office API, which relies instead on Object, Office's Any class, or the XInterface class which is inherited by all interfaces. A Quick Look at Sockets \u00b6 Note: you can skip this section if socket communication with Office isn't of interest. loadOffice() starts by calling bootstrapContext() or socketContext() to create a remote component context. bootstrapContext() is very short since it build a UNO bridge based on named pipes using Office's Bootstrap class. However, I also implemented a socket-based bridge, in Lo.socketContext(). The steps it performs are: * invoke Office as a process using sockets; * create a local component context and service manager (local in the sense of being in the Java process); * connect to Office via its socket. I use the Connector service, but another approach is to employ the UnoUrlResolver service; * layer a UNO bridge on top of the socket link; * retrieve a reference to the remote component context via the UNO bridge (remote in the sense that it refers across process boundaries to Office). Office's own Bootstrap class implements a similar sequence of steps for linking to Office via pipes. It starts Office by calling Java's Runtime.exec(), and I've used the same approach, but assumed that soffice.exe is part of Window's PATH environment variable. The relevant code fragment is: String [] cmdArray = new String [ 3 ] ; cmdArray [ 0 ] = \"soffice\" ; cmdArray [ 1 ] = \"-headless\" ; cmdArray [ 2 ] = \"-accept=socket,host=localhost,port=\" + SOCKET_PORT + \";urp;\" ; Process p = Runtime . getRuntime (). exec ( cmdArray ); SOCKET_PORT has the value 8100. Since this port number is fixed, it\u2019s possible to check the socket\u2019s status outside Office. For example, on Windows, I type: netstat | grep 8100 If you wondering where grep comes from, I got it from gow ( https://github.com/bmatzelle/gow/ ), a light-weight installer of UNIX command line utilities for Windows. 2. Closing Down/Killing Office \u00b6 Lo.closeOffice() shuts down Office by calling terminate() on the XDesktop instance created inside loadOffice(): boolean isDead = xDesktop.terminate() This is usually sufficient but occasionally I've found it necessary to delay the terminate() call for a few milliseconds in order to give Office components time to finish. I noticed this especially when using an OfficeBean panel for displaying documents (which I'll describe much later in Chapter 44). As a consequence, Lo.closeDown() may actually call terminate() a few times, until it returns true. While developing/debugging code, it's quite easy to inadvertently trigger a runtime exception in the Office API. In the worst case, this can cause your program to exit without calling Lo.closeDown(). This will leave an extraneous Office process running in the OS, which should be killed. The easiest way is with a Windows batch file containing: taskkill /f /t /im soffice.exe This uses the fact that the office process is called soffice.exe. Another useful batch script is one that checks only if the process is running: tasklist /FI \"IMAGENAME eq soffice.exe\" These are packaged up as lokill.bat and lolist.bat in my code. So if you're unsure if Office is really dead, type: lokill at a command prompt. The Unix shell script versions of these files could use killall, pkill, ps, or kill. Lo.killOffice() inelegantly terminates Office by calling the lokill.bat script from inside Java: // part of the Lo class public static void killOffice () { try { Runtime . getRuntime (). exec ( \"cmd /c lokill.bat\" ); System . out . println ( \"Killed Office\" ); } catch ( java . lang . Exception e ) { System . out . println ( \"Unable to kill Office: \" + e ); } } // end of killOffice() The code is nasty since it relies on there being a cmd.exe OS tool and a lokill.bat batch file in the current directory. 3. Opening a Document \u00b6 The general format of a program that opens a document, manipulates it in some way, and then saves it, is: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // use the Office API to manipulate doc... Lo . saveDoc ( doc , \"foo.docx\" ); // save as a Word file Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The new methods are Lo.openDoc(), Lo.saveDoc(), and Lo.closeDoc(). openDoc() calls XComponentLoader.loadComponentFromURL(), which requires a document URL, the type of Office frame used to display the document, optional search flags, and an array of document properties. For example: String fileURL = FileIO . fnmToURL ( fnm ); PropertyValue [] props = Props . makeProps ( \"Hidden\" , true ); XComponent doc = loader . loadComponentFromURL ( fileURL , \"_blank\" , 0 , props ); The frame type is almost always \"_blank\" which indicates that a new window will be created for the newly loaded document. (Other possibilities are listed in the XComponentLoader documentation which you can access with lodoc XComponentLoader .) The search flags are usually set to 0, and document properties are stored in the PropertyValue array, props. loadComponentFromURL()'s return type is XComponent, which refers to the document. FileIO.fnmToURL() converts an ordinary filename (e.g. \u201cfoo.doc\u201d) into a URL (a full path prefixed with file:///). Props.makeProps() takes a property name and value and returns a PropertyValue array; there are several variants which accept different numbers of property name- value pairs. A complete list of document properties can be found in the MediaDescriptor documentation (accessed with lodoc MediaDescriptor service ), but some of the important ones are listed in Table 1. Property Name Use AsTemplate Creates a new document using a specified template Hidden Determines if the document is invisible after being loaded ReadOnly Opens the document read-only StartPresentation Starts showing a slide presentation immediately after loading the document Table 1. Some Document Properties. 4. Creating a Document \u00b6 A new document is created by calling XComponentLoader.loadComponentFromURL() with a special URL string for the document type. The possible strings are listed in Table 2. URL String Document Type \"private:factory/swriter\" Writer \"private:factory/sdraw\" Draw \"private:factory/simpress\" Impress \"private:factory/scalc\" Calc \"private:factory/sdatabase\" Base \"private:factory/swriter/web\" HTML document in Writer \"private:factory/swriter/GlobalDocument\" A Master document in Writer \"private:factory/schart\" Chart \"private:factory/smath\" Math Formulae \".component:Bibliography/View1\" Bibliography Entries \".component:DB/QueryDesign\" Database User Interfaces \".component:DB/TableDesign\" \".component:DB/RelationDesign\" \".component:DB/DataSourceBrowser\" \".component:DB/FormGridView\" Table 2. URLs for Creating New Documents. For instance, a Writer document is created by: XComponent doc = loader . loadComponentFromURL ( \"private:factory/swriter\" , \"_blank\" , 0 , props ); The utility classes include code for simplifying the creation of Writer, Draw, Impress, Calc, and Base documents, which I'll be looking at in later chapters. A Second Service Manager \u00b6 Lo.loadDoc() and Lo.createDoc() do a bit of additional work after document loading/creation \u2013 they instantiate a XMultiServiceFactory service manager which is stored in the Lo class. This is done by applying Lo.qi() to the document: // global in Lo.java private static XMultiServiceFactory msFactory = null ; // in loadDoc() XComponent doc = loader . loadComponentFromURL ( fileURL , \"_blank\" , 0 , props ); msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); I first employed Lo.qi() in createInstanceMCF() to access an interface inside a service. This time qi() is casting one interface (XComponent) to another (XMultiServiceFactory). The XMultiServiceFactory object is the second service manager we've encountered; the first was an XMultiComponentFactory instance, created during Office's loading. The reasons for Office having two service managers are historical: the XMultiServiceFactory manager is older, and creates a service object without the need for an explicit reference to the remote component context. As Office developed, it was decided that service object creation should always be relative to an explicit component context, and so the newer XMultiComponentFactory service manager came into being. A lot of older code still uses the XMultiServiceFactory service manager, so both are supported in the Lo class. Another difference between the managers is that the XMultiComponentFactory manager is available as soon as Office is loaded, while the XMultiServiceFactory manager is initialized only when a document is loaded or created. 5. Saving a Document \u00b6 One of the great strengths of Office is that it can export a document in a vast number of formats, but the programmer must specify the output format (which is called a filter in the Office documentation). XStorable.storeToURL() takes the name of the output file (in URL format), and an array of properties, one of which should be \"FilterName\". Two other useful output properties are \"Overwrite\" and \"Password\". Input and output document properties are listed in the MediaDescriptor service documentation ( lodoc MediaDescriptor service ). If \"Overwrite\" is set to true then the file will be saved without prompting the user if the file already exists. The \"Password\" property contains a string which must be entered into an Office dialog by the user before the file can be opened again. The steps in saving a file are: String saveFileURL = FileIO . fnmToURL ( fnm ); String [] nms = new String [] { \"Overwrite\" , \"FilterName\" , \"Password\" }; Object [] vals = new Object [] { true , format , password }; PropertyValue [] storeProps = Props . makeProps ( nms , vals ); XStorable store = Lo . qi ( XStorable . class , doc ); store . storeToURL ( saveFileURL , storeProps ); I've used a variant of the Props.makeProps() method to create an array of three properties. If you don't want a password, then the third property should be left out. Lo.qi() is used again to cast an interface, this time from XComponent to XStoreable. Figure 5 in Chapter 1 shows that XStoreable is part of the OfficeDocument service, which means that it's inherited by all Office document types. What's a Filter Name? \u00b6 XStorable.storeToURL() needs a \"FilterName\" property value, but what should the string be to export the document in Word format for example? Info.getFilterNames() returns an array of all the filter names supported by Office. There's an example call in OfficeInfo.java, but is commented out because it returns a 250+ element list! Rather than force a programmer to search through this list for the correct name, Lo.saveDoc() allows him to supply just the name and extension of the output file. For example, in section 3, Lo.saveDoc() was called like so: Lo . saveDoc ( doc , \"foo.docx\" ); saveDoc() extracts the file extension (i.e. \"docx\") and maps it to a corresponding filter name in Office (in this case, \"Office Open XML Text\"). One concern is that it's not always clear which extension-to-filter mapping should be utilized. For instance, another suitable filter name for \"docx\" is \"MS Word 2007 XML\". I've essentially ignored this problem, by hardwiring a fixed selection into saveDoc(). Another issue is that the choice of filter sometimes depends on the extension and the document type. For example, a Writer document saved as a PDF file should use the filter \"writer_pdf_Export\", but if the document is a spreadsheet then \"calc_pdf_Export\" is the correct choice. Consequently, saveDoc() examines both the extension and the document's service name, which is accessed via the XServiceInfo interface: XServiceInfo xInfo = Lo . qi ( XServiceInfo . class , doc ); boolean isWriter = // is it a Writer doc? xInfo . supportsService ( \"com.sun.star.text.TextDocument\" ); The main document service names are listed in Table 3. Document Type Service Name Writer com.sun.star.text.TextDocument Draw com.sun.star.drawing.DrawingDocument Impress com.sun.star.presentation.PresentationDocument Calc com.sun.star.sheet.SpreadsheetDocument Base com.sun.star.sdb.OfficeDatabaseDocument Table 3. Document Service Names. We encountered these service names back in Chapter 1, Figure 8 \u2013 they're subclasses of the OfficeDocument service. A third problem is incompletness; I've only implemented saveDoc() mappings for a small subset of Office's 250+ filter names, so if you try to save a file with an exotic extension then my code will most likely break. If you want to study the details, start with Lo.saveDoc(), and burrow down; the trickiest part is Lo.ext2Format(). 6. Closing a Document \u00b6 Closing a document is a pain if you want to check with the user beforehand: should a modified file be saved, thereby overwriting the old version? My solution is not to bother the user, so the file is closed without saving, irrespective of any modifications. In other words, it's essential to explicitly save a changed document with Lo.saveDoc() before calling Lo.closeDoc(). The code for closing employs Lo.qi() to cast the document's XComponent interface to XCloseable: XCloseable closeable = Lo . qi ( XCloseable . class , doc ); closeable . close ( false ); // doc. closed without saving 7. A General Purpose Converter \u00b6 The DocConverter.java example in \"Office Tests/\" takes two command line arguments: the name of an input file and the extension that should be used when saving the loaded document. For instance: run DocConverter points . ppt odp will save slides in MS PowerPoint format as an Impress presentation. The following converts a JPEG image into PNG: run DocConverter skinner . jpg png The code for DocConverter is short: import com.sun.star.uno.* ; import com.sun.star.lang.* ; import com.sun.star.frame.* ; public class DocConverter { public static void main ( String args [] ) { if ( args . length != 2 ) { System . out . println ( \"Usage: DocConverter fnm extension\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } String name = Info . getName ( args [ 0 ] ); Lo . saveDoc ( doc , name + \".\" + args [ 1 ] ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of DocConverter class 8. Bug Detection and Reporting \u00b6 This chapter began our coding with the Office API, and so the possibility of bugs also becomes an issue. If you find a problem with one of my support classes (e.g. in Lo.java) or one of my examples (e.g. in DocConverter.java), then please contact me at ad@fivedots.coe.psu.ac.th , supplying as much detail as possible. Another source of bugs is the LibreOffice API itself, which is hardly a surprise considering its complexity and age. If you find a problem, then you should first search LibreOffice's Bugzilla site at https://bugs.documentfoundation.org/ to see if the problem has been reported previously (it probably has). Various types of search are explained in the Bugzilla documentation at https://bugs.documentfoundation.org/docs/en/html/using/ If you want to report a new bug, then you'll need to set up an account, which is quite simple, and also explained by the documentation. Often when people report bugs they don't include enough information, perhaps because the error window displayed by Windows is somewhat lacking. For example, a typical crash report window is shown in Figure 1. Figure 1. The LibreOffice Crash Reported by Windows 7. If you're going to make an official report, you should first read the article \"How to Report Bugs in LibreOffice\" ( https://wiki.documentfoundation.org/QA/BugReport/ ). Expert forum members and Bugzilla maintainers sometimes point people towards WinDbg for Windows as a tool for producing good debugging details. The wiki has a detailed explanation of how to install and use it ( https://wiki.documentfoundation.org/How_to_get_a_backtrace_with_WinDbg/ ), which is a bit scary in its complexity. A much easier alternative is the WinCrashReport application from NirSoft ( https://nirsoft.net/utils/application_crash_report.html ). It presents the Windows Error Reporting (WER) data generated by a crash in a readable form. When a crash window appears (like the one in Figure 1), start WinCrashReport to examine the automatically-generated error report, as in Figure 2. Figure 2. WinCrashReport GUI Figure 2 indicates that the problem lies inside mergedlo.dll, an access violation (the exception code 0xC0000005) to a memory address. mergedlo.dll is part of LibreOffice which probably means that you can find the DLL in /program. Most Office DLLs are located in that directory, but it's useful to have a fast file search utility on your machine to find files that might be in third- party libraries or in Windows. I use SwiftSearch ( https://sourceforge.net/projects/swiftsearch/ ). WinCrashReport generates two alternative call stacks, with slightly more information in the second in this case. mergedlo.dll is called by the uno_getCurrentEnvironment() function in cppu3.dll, as indicated in Figure 3. Figure 3. The Second Call Stack in WinCrashReport. This narrows the problem to a specific function and two DLLs, which is very helpful. If you want to better understand the DLLs, they can be examined using DLL Export Viewer , another NirSoft tool ( https://nirsoft.net/utils/dll_export_viewer.html ), which lists a DLL's exported functions. Running it on mergedlo.dll turns up nothing, but the details for cppu3.dll are shown in Figure 4. Figure 4. DLL Export Viewer's view of cppu3.dll mergedlo.dll appears to be empty inside DLL Export Viewer because it exports no functions. That probably means it's being used as a store for resources, such as icons, cursors, and images. There's another NirSoft tool for looking at DLL resources, called ResourcesExtract ( https://nirsoft.net/utils/resources_extract.html ). The offending function must be uno_getCurrentEnvironment() which Figure 4 confirms to be in cppu3.dll. Looking at the Source Code You might want to narrow the problem down further by looking at uno_getCurrentEnvironment()'s source. This is easy with the \"OpenGrok for LibreOffice\" website ( https://opengrok.libreoffice.org/ ) for searching the gigantic code base. Figure 5 shows the results for an \"uno_getCurrentEnvironment\" search. Figure 5. OpenGrok Results for \"uno_getCurrentEnvironment\" The function's code is in EnvStack.cxx, which can be examined by clicking on the linked function name shown at the bottom of Figure 5. If you're interested in exploring the code base more widely, there are some very good blog posts about it by Eilidh McAdam: \"Exploring the LibreOffice code base\" ( https://lanedo.com/exploring-the-libreoffice-code-base/ ) and \"LibreOffice Development Howto\" ( https://lanedo.com/libreoffice-development-howto/ ).","title":"Chapter 2. Starting and Stopping"},{"location":"02-Starting_and_Stopping.html#chapter-2-starting-and-stopping","text":"Topics Starting Office; Closing Down/Killing Office; Opening a Document; Creating a Document; Saving; Closing; Document Conversion; Bug Detection and Reporting Example folders: \"Office Tests\" and \"Utils\" Chapter 1 introduced some of the core ideas of Office. Now it's time to show how these data structures and relationships (e.g. service, interfaces, FCM, inheritance) are programmed in Office's Java API. This chapter will focus on the most fundamental tasks: starting Office, loading (or creating) a document, saving and closing the document, and shutting down Office. The DocConverter.java example at the end pulls these together to show how to convert a document into another format. All the examples come from the \"Office Tests\" directory in the code download associated with this book, and make liberal use of the classes in the \"Utils\" directory. For details please visit https://fivedots.coe.psu.ac.th/~ad/jlop/ . My aim with these utilities is to hide some of the verbiage of Office. When (if?) a programmer feels ready for more detail, then my code is documented. I'll only explain functions here that illustrate Office ideas, such as service managers and components. This is the first chapter with code, and so the first where programs could crash! Section 8 gives a few tips on bug detection and reporting.","title":"Chapter 2. Starting and Stopping"},{"location":"02-Starting_and_Stopping.html#1-starting-office","text":"Every program must load Office before working with a document, and shut it down before exiting. These tasks are handled by loadOffice() and closeOffice() from the Lo utility class. A typical program will look like the following: import com.sun.star.uno.* ; import com.sun.star.lang.* ; import com.sun.star.frame.* ; public class OfficeInfo { public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); // load, manipulate and close a document Lo . closeOffice (); } // end of main() } // end of OfficeInfo class Lo.loadOffice() invokes Office and sets up a UNO bridge using named pipes. There's also a Lo.loadSocketOffice() which uses sockets instead of pipes. Both functions return a reference to a component loader which can be used to load a document. loadOffice() and loadSocketOffice() call a one-argument version of loadOffice() which uses a boolean to decide whether to use pipes or sockets to link to Office. In both cases, a remote component context is created on the Java side (see Chapter 1, Figure 2) and then a service manager, Desktop object, and component loader are initialized. The code below shows some details: // in the Lo class // globals private static XComponentContext xcc = null ; private static XDesktop xDesktop = null ; private static XMultiComponentFactory mcFactory = null ; public static XComponentLoader loadOffice ( boolean usingPipes ) { System . out . println ( \"Loading Office...\" ); if ( usingPipes ) xcc = bootstrapContext (); // connects to office via pipes else xcc = socketContext (); // connects to office via a socket if ( xcc == null ) { System . out . println ( \"Office context could not be created\" ); System . exit ( 1 ); } // get the remote office service manager mcFactory = xcc . getServiceManager (); if ( mcFactory == null ) { System . out . println ( \"Office Service Manager is unavailable\" ); System . exit ( 1 ); } // desktop service handles application windows and documents xDesktop = createInstanceMCF ( XDesktop . class , \"com.sun.star.frame.Desktop\" ); if ( xDesktop == null ) { System . out . println ( \"Could not create a desktop service\" ); System . exit ( 1 ); } // XComponentLoader provides ability to load components return Lo . qi ( XComponentLoader . class , xDesktop ); } // end of loadOffice() loadOffice() probably illustrates my most significant coding decisions \u2013 the use of global static variables inside the Lo class. In particular, the XComponentContext, XDesktop, and XMultiComponentFactory objects created by loadOffice() are stored globally for later use. I chose this approach since it allows other support functions to be called with simpler arguments because the objects can be accessed without the user having to explicitly pass around references to them. The main drawback is that loadOffice() cannot be safely called more than once (i.e. it is non-reentrant) since a second call will overwrite the globals set during the first call. The creation of the XDesktop interface object uses createInstanceMCF(): // in the Lo class public static < T > T createInstanceMCF ( Class < T > aType , String serviceName ) { if (( xcc == null ) || ( mcFactory == null )) { System . out . println ( \"No office connection found\" ); return null ; } T interfaceObj = null ; try { // get service, then interface Object o = mcFactory . createInstanceWithContext ( serviceName , xcc ); interfaceObj = Lo . qi ( aType , o ); } catch ( Exception e ) { System . out . println ( \"Couldn't create interface for \\\"\" + serviceName + \"\\\": \" + e ); } return interfaceObj ; } // end of createInstanceMCF() public static < T > T qi ( Class < T > aType , Object o ) // the \"Loki\" function -- reduces typing { return UnoRuntime . queryInterface ( aType , o ); } If you ignore the error-checking, createInstanceMCF() does two things. The call to XMultiComponentFactory.createInstanceWithContext() asks the service manager (mcFactory) to create a service object inside the remote component context (xcc). Then the call to UnoRuntime.queryInterface() looks inside the service instance for the specified interface (aType), returning an instance of the interface as its result. My Lo.qi() function's only purpose is to reduce programmer typing, since calls to UnoRuntime.queryInterface() are very common. The use of generics makes createInstanceMCF() useful for creating any type of interface object. Unfortunately, generics aren't utilized in the Office API, which relies instead on Object, Office's Any class, or the XInterface class which is inherited by all interfaces.","title":"1.  Starting Office"},{"location":"02-Starting_and_Stopping.html#a-quick-look-at-sockets","text":"Note: you can skip this section if socket communication with Office isn't of interest. loadOffice() starts by calling bootstrapContext() or socketContext() to create a remote component context. bootstrapContext() is very short since it build a UNO bridge based on named pipes using Office's Bootstrap class. However, I also implemented a socket-based bridge, in Lo.socketContext(). The steps it performs are: * invoke Office as a process using sockets; * create a local component context and service manager (local in the sense of being in the Java process); * connect to Office via its socket. I use the Connector service, but another approach is to employ the UnoUrlResolver service; * layer a UNO bridge on top of the socket link; * retrieve a reference to the remote component context via the UNO bridge (remote in the sense that it refers across process boundaries to Office). Office's own Bootstrap class implements a similar sequence of steps for linking to Office via pipes. It starts Office by calling Java's Runtime.exec(), and I've used the same approach, but assumed that soffice.exe is part of Window's PATH environment variable. The relevant code fragment is: String [] cmdArray = new String [ 3 ] ; cmdArray [ 0 ] = \"soffice\" ; cmdArray [ 1 ] = \"-headless\" ; cmdArray [ 2 ] = \"-accept=socket,host=localhost,port=\" + SOCKET_PORT + \";urp;\" ; Process p = Runtime . getRuntime (). exec ( cmdArray ); SOCKET_PORT has the value 8100. Since this port number is fixed, it\u2019s possible to check the socket\u2019s status outside Office. For example, on Windows, I type: netstat | grep 8100 If you wondering where grep comes from, I got it from gow ( https://github.com/bmatzelle/gow/ ), a light-weight installer of UNIX command line utilities for Windows.","title":"A Quick Look at Sockets"},{"location":"02-Starting_and_Stopping.html#2-closing-downkilling-office","text":"Lo.closeOffice() shuts down Office by calling terminate() on the XDesktop instance created inside loadOffice(): boolean isDead = xDesktop.terminate() This is usually sufficient but occasionally I've found it necessary to delay the terminate() call for a few milliseconds in order to give Office components time to finish. I noticed this especially when using an OfficeBean panel for displaying documents (which I'll describe much later in Chapter 44). As a consequence, Lo.closeDown() may actually call terminate() a few times, until it returns true. While developing/debugging code, it's quite easy to inadvertently trigger a runtime exception in the Office API. In the worst case, this can cause your program to exit without calling Lo.closeDown(). This will leave an extraneous Office process running in the OS, which should be killed. The easiest way is with a Windows batch file containing: taskkill /f /t /im soffice.exe This uses the fact that the office process is called soffice.exe. Another useful batch script is one that checks only if the process is running: tasklist /FI \"IMAGENAME eq soffice.exe\" These are packaged up as lokill.bat and lolist.bat in my code. So if you're unsure if Office is really dead, type: lokill at a command prompt. The Unix shell script versions of these files could use killall, pkill, ps, or kill. Lo.killOffice() inelegantly terminates Office by calling the lokill.bat script from inside Java: // part of the Lo class public static void killOffice () { try { Runtime . getRuntime (). exec ( \"cmd /c lokill.bat\" ); System . out . println ( \"Killed Office\" ); } catch ( java . lang . Exception e ) { System . out . println ( \"Unable to kill Office: \" + e ); } } // end of killOffice() The code is nasty since it relies on there being a cmd.exe OS tool and a lokill.bat batch file in the current directory.","title":"2.  Closing Down/Killing Office"},{"location":"02-Starting_and_Stopping.html#3-opening-a-document","text":"The general format of a program that opens a document, manipulates it in some way, and then saves it, is: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // use the Office API to manipulate doc... Lo . saveDoc ( doc , \"foo.docx\" ); // save as a Word file Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The new methods are Lo.openDoc(), Lo.saveDoc(), and Lo.closeDoc(). openDoc() calls XComponentLoader.loadComponentFromURL(), which requires a document URL, the type of Office frame used to display the document, optional search flags, and an array of document properties. For example: String fileURL = FileIO . fnmToURL ( fnm ); PropertyValue [] props = Props . makeProps ( \"Hidden\" , true ); XComponent doc = loader . loadComponentFromURL ( fileURL , \"_blank\" , 0 , props ); The frame type is almost always \"_blank\" which indicates that a new window will be created for the newly loaded document. (Other possibilities are listed in the XComponentLoader documentation which you can access with lodoc XComponentLoader .) The search flags are usually set to 0, and document properties are stored in the PropertyValue array, props. loadComponentFromURL()'s return type is XComponent, which refers to the document. FileIO.fnmToURL() converts an ordinary filename (e.g. \u201cfoo.doc\u201d) into a URL (a full path prefixed with file:///). Props.makeProps() takes a property name and value and returns a PropertyValue array; there are several variants which accept different numbers of property name- value pairs. A complete list of document properties can be found in the MediaDescriptor documentation (accessed with lodoc MediaDescriptor service ), but some of the important ones are listed in Table 1. Property Name Use AsTemplate Creates a new document using a specified template Hidden Determines if the document is invisible after being loaded ReadOnly Opens the document read-only StartPresentation Starts showing a slide presentation immediately after loading the document Table 1. Some Document Properties.","title":"3.  Opening a Document"},{"location":"02-Starting_and_Stopping.html#4-creating-a-document","text":"A new document is created by calling XComponentLoader.loadComponentFromURL() with a special URL string for the document type. The possible strings are listed in Table 2. URL String Document Type \"private:factory/swriter\" Writer \"private:factory/sdraw\" Draw \"private:factory/simpress\" Impress \"private:factory/scalc\" Calc \"private:factory/sdatabase\" Base \"private:factory/swriter/web\" HTML document in Writer \"private:factory/swriter/GlobalDocument\" A Master document in Writer \"private:factory/schart\" Chart \"private:factory/smath\" Math Formulae \".component:Bibliography/View1\" Bibliography Entries \".component:DB/QueryDesign\" Database User Interfaces \".component:DB/TableDesign\" \".component:DB/RelationDesign\" \".component:DB/DataSourceBrowser\" \".component:DB/FormGridView\" Table 2. URLs for Creating New Documents. For instance, a Writer document is created by: XComponent doc = loader . loadComponentFromURL ( \"private:factory/swriter\" , \"_blank\" , 0 , props ); The utility classes include code for simplifying the creation of Writer, Draw, Impress, Calc, and Base documents, which I'll be looking at in later chapters.","title":"4.  Creating a Document"},{"location":"02-Starting_and_Stopping.html#a-second-service-manager","text":"Lo.loadDoc() and Lo.createDoc() do a bit of additional work after document loading/creation \u2013 they instantiate a XMultiServiceFactory service manager which is stored in the Lo class. This is done by applying Lo.qi() to the document: // global in Lo.java private static XMultiServiceFactory msFactory = null ; // in loadDoc() XComponent doc = loader . loadComponentFromURL ( fileURL , \"_blank\" , 0 , props ); msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); I first employed Lo.qi() in createInstanceMCF() to access an interface inside a service. This time qi() is casting one interface (XComponent) to another (XMultiServiceFactory). The XMultiServiceFactory object is the second service manager we've encountered; the first was an XMultiComponentFactory instance, created during Office's loading. The reasons for Office having two service managers are historical: the XMultiServiceFactory manager is older, and creates a service object without the need for an explicit reference to the remote component context. As Office developed, it was decided that service object creation should always be relative to an explicit component context, and so the newer XMultiComponentFactory service manager came into being. A lot of older code still uses the XMultiServiceFactory service manager, so both are supported in the Lo class. Another difference between the managers is that the XMultiComponentFactory manager is available as soon as Office is loaded, while the XMultiServiceFactory manager is initialized only when a document is loaded or created.","title":"A Second Service Manager"},{"location":"02-Starting_and_Stopping.html#5-saving-a-document","text":"One of the great strengths of Office is that it can export a document in a vast number of formats, but the programmer must specify the output format (which is called a filter in the Office documentation). XStorable.storeToURL() takes the name of the output file (in URL format), and an array of properties, one of which should be \"FilterName\". Two other useful output properties are \"Overwrite\" and \"Password\". Input and output document properties are listed in the MediaDescriptor service documentation ( lodoc MediaDescriptor service ). If \"Overwrite\" is set to true then the file will be saved without prompting the user if the file already exists. The \"Password\" property contains a string which must be entered into an Office dialog by the user before the file can be opened again. The steps in saving a file are: String saveFileURL = FileIO . fnmToURL ( fnm ); String [] nms = new String [] { \"Overwrite\" , \"FilterName\" , \"Password\" }; Object [] vals = new Object [] { true , format , password }; PropertyValue [] storeProps = Props . makeProps ( nms , vals ); XStorable store = Lo . qi ( XStorable . class , doc ); store . storeToURL ( saveFileURL , storeProps ); I've used a variant of the Props.makeProps() method to create an array of three properties. If you don't want a password, then the third property should be left out. Lo.qi() is used again to cast an interface, this time from XComponent to XStoreable. Figure 5 in Chapter 1 shows that XStoreable is part of the OfficeDocument service, which means that it's inherited by all Office document types.","title":"5.  Saving a Document"},{"location":"02-Starting_and_Stopping.html#whats-a-filter-name","text":"XStorable.storeToURL() needs a \"FilterName\" property value, but what should the string be to export the document in Word format for example? Info.getFilterNames() returns an array of all the filter names supported by Office. There's an example call in OfficeInfo.java, but is commented out because it returns a 250+ element list! Rather than force a programmer to search through this list for the correct name, Lo.saveDoc() allows him to supply just the name and extension of the output file. For example, in section 3, Lo.saveDoc() was called like so: Lo . saveDoc ( doc , \"foo.docx\" ); saveDoc() extracts the file extension (i.e. \"docx\") and maps it to a corresponding filter name in Office (in this case, \"Office Open XML Text\"). One concern is that it's not always clear which extension-to-filter mapping should be utilized. For instance, another suitable filter name for \"docx\" is \"MS Word 2007 XML\". I've essentially ignored this problem, by hardwiring a fixed selection into saveDoc(). Another issue is that the choice of filter sometimes depends on the extension and the document type. For example, a Writer document saved as a PDF file should use the filter \"writer_pdf_Export\", but if the document is a spreadsheet then \"calc_pdf_Export\" is the correct choice. Consequently, saveDoc() examines both the extension and the document's service name, which is accessed via the XServiceInfo interface: XServiceInfo xInfo = Lo . qi ( XServiceInfo . class , doc ); boolean isWriter = // is it a Writer doc? xInfo . supportsService ( \"com.sun.star.text.TextDocument\" ); The main document service names are listed in Table 3. Document Type Service Name Writer com.sun.star.text.TextDocument Draw com.sun.star.drawing.DrawingDocument Impress com.sun.star.presentation.PresentationDocument Calc com.sun.star.sheet.SpreadsheetDocument Base com.sun.star.sdb.OfficeDatabaseDocument Table 3. Document Service Names. We encountered these service names back in Chapter 1, Figure 8 \u2013 they're subclasses of the OfficeDocument service. A third problem is incompletness; I've only implemented saveDoc() mappings for a small subset of Office's 250+ filter names, so if you try to save a file with an exotic extension then my code will most likely break. If you want to study the details, start with Lo.saveDoc(), and burrow down; the trickiest part is Lo.ext2Format().","title":"What's a Filter Name?"},{"location":"02-Starting_and_Stopping.html#6-closing-a-document","text":"Closing a document is a pain if you want to check with the user beforehand: should a modified file be saved, thereby overwriting the old version? My solution is not to bother the user, so the file is closed without saving, irrespective of any modifications. In other words, it's essential to explicitly save a changed document with Lo.saveDoc() before calling Lo.closeDoc(). The code for closing employs Lo.qi() to cast the document's XComponent interface to XCloseable: XCloseable closeable = Lo . qi ( XCloseable . class , doc ); closeable . close ( false ); // doc. closed without saving","title":"6.  Closing a Document"},{"location":"02-Starting_and_Stopping.html#7-a-general-purpose-converter","text":"The DocConverter.java example in \"Office Tests/\" takes two command line arguments: the name of an input file and the extension that should be used when saving the loaded document. For instance: run DocConverter points . ppt odp will save slides in MS PowerPoint format as an Impress presentation. The following converts a JPEG image into PNG: run DocConverter skinner . jpg png The code for DocConverter is short: import com.sun.star.uno.* ; import com.sun.star.lang.* ; import com.sun.star.frame.* ; public class DocConverter { public static void main ( String args [] ) { if ( args . length != 2 ) { System . out . println ( \"Usage: DocConverter fnm extension\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } String name = Info . getName ( args [ 0 ] ); Lo . saveDoc ( doc , name + \".\" + args [ 1 ] ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of DocConverter class","title":"7.  A General Purpose Converter"},{"location":"02-Starting_and_Stopping.html#8-bug-detection-and-reporting","text":"This chapter began our coding with the Office API, and so the possibility of bugs also becomes an issue. If you find a problem with one of my support classes (e.g. in Lo.java) or one of my examples (e.g. in DocConverter.java), then please contact me at ad@fivedots.coe.psu.ac.th , supplying as much detail as possible. Another source of bugs is the LibreOffice API itself, which is hardly a surprise considering its complexity and age. If you find a problem, then you should first search LibreOffice's Bugzilla site at https://bugs.documentfoundation.org/ to see if the problem has been reported previously (it probably has). Various types of search are explained in the Bugzilla documentation at https://bugs.documentfoundation.org/docs/en/html/using/ If you want to report a new bug, then you'll need to set up an account, which is quite simple, and also explained by the documentation. Often when people report bugs they don't include enough information, perhaps because the error window displayed by Windows is somewhat lacking. For example, a typical crash report window is shown in Figure 1. Figure 1. The LibreOffice Crash Reported by Windows 7. If you're going to make an official report, you should first read the article \"How to Report Bugs in LibreOffice\" ( https://wiki.documentfoundation.org/QA/BugReport/ ). Expert forum members and Bugzilla maintainers sometimes point people towards WinDbg for Windows as a tool for producing good debugging details. The wiki has a detailed explanation of how to install and use it ( https://wiki.documentfoundation.org/How_to_get_a_backtrace_with_WinDbg/ ), which is a bit scary in its complexity. A much easier alternative is the WinCrashReport application from NirSoft ( https://nirsoft.net/utils/application_crash_report.html ). It presents the Windows Error Reporting (WER) data generated by a crash in a readable form. When a crash window appears (like the one in Figure 1), start WinCrashReport to examine the automatically-generated error report, as in Figure 2. Figure 2. WinCrashReport GUI Figure 2 indicates that the problem lies inside mergedlo.dll, an access violation (the exception code 0xC0000005) to a memory address. mergedlo.dll is part of LibreOffice which probably means that you can find the DLL in /program. Most Office DLLs are located in that directory, but it's useful to have a fast file search utility on your machine to find files that might be in third- party libraries or in Windows. I use SwiftSearch ( https://sourceforge.net/projects/swiftsearch/ ). WinCrashReport generates two alternative call stacks, with slightly more information in the second in this case. mergedlo.dll is called by the uno_getCurrentEnvironment() function in cppu3.dll, as indicated in Figure 3. Figure 3. The Second Call Stack in WinCrashReport. This narrows the problem to a specific function and two DLLs, which is very helpful. If you want to better understand the DLLs, they can be examined using DLL Export Viewer , another NirSoft tool ( https://nirsoft.net/utils/dll_export_viewer.html ), which lists a DLL's exported functions. Running it on mergedlo.dll turns up nothing, but the details for cppu3.dll are shown in Figure 4. Figure 4. DLL Export Viewer's view of cppu3.dll mergedlo.dll appears to be empty inside DLL Export Viewer because it exports no functions. That probably means it's being used as a store for resources, such as icons, cursors, and images. There's another NirSoft tool for looking at DLL resources, called ResourcesExtract ( https://nirsoft.net/utils/resources_extract.html ). The offending function must be uno_getCurrentEnvironment() which Figure 4 confirms to be in cppu3.dll. Looking at the Source Code You might want to narrow the problem down further by looking at uno_getCurrentEnvironment()'s source. This is easy with the \"OpenGrok for LibreOffice\" website ( https://opengrok.libreoffice.org/ ) for searching the gigantic code base. Figure 5 shows the results for an \"uno_getCurrentEnvironment\" search. Figure 5. OpenGrok Results for \"uno_getCurrentEnvironment\" The function's code is in EnvStack.cxx, which can be examined by clicking on the linked function name shown at the bottom of Figure 5. If you're interested in exploring the code base more widely, there are some very good blog posts about it by Eilidh McAdam: \"Exploring the LibreOffice code base\" ( https://lanedo.com/exploring-the-libreoffice-code-base/ ) and \"LibreOffice Development Howto\" ( https://lanedo.com/libreoffice-development-howto/ ).","title":"8.  Bug Detection and Reporting"},{"location":"03-Examining.html","text":"Chapter 3. Examining \u00b6 Topics Examining Office; Getting and Setting Document Properties; Examining a Document for API Details; Examining a Document Using MRI Example folders: \"Office Tests\" and \"Utils\" This chapter looks at ways to examine the state of the Office application and a document. A document will be examined in three different ways: the first retrieves properties about the file, such as its author, keywords, and when it was last modified. The second and third approaches extract API details, such as what services and interfaces it uses. This can be done by calling functions in my Utils class or by utilizing the MRI extension added to Office. Once again all the examples come from the \"Office Tests\" directory in the code download associated with this book, and make liberal use of the classes in the \"Utils\" directory. For details please visit https://fivedots.coe.psu.ac.th/~ad/jlop/ . 1. Examining Office \u00b6 It's sometimes necessary to examine the state of the Office application, for example to determine its version number or installation directory. There are two main ways of finding this information, using configuration properties and path settings. 1.1 Examining Configuration Properties \u00b6 Configuration management is a complex area, which is explained reasonably well in chapter 15 of the developer's guide and online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Config/Configuration_Management/ ; I'll only explain the basics here. The easiest way of accessing the relevant online section is by typing: loguide \"Configuration Management\" Office stores a large assortment of XML configuration data as \".xcd\" files in the \\share\\registry directory. They can be programatically accessed in three steps: first a ConfigurationProvider service is created, which represents the configuration database tree. The tree is examined with a ConfigurationAccess service which is supplied with the path to the node of interest. Configuration properties can be accessed by name with the XNameAccess interface. These steps are hidden inside Info.getConfig() which requires at most two arguments \u2013 the path to the required node, and the name of the property inside that node. The two most useful paths seem to be \"/org.openoffice.Setup/Product\" and \"/org.openoffice.Setup/L10N\", which are hardwired as constants in the Info class. The simplest version of getConfig() looks along both paths by default so the programmer only has to supply a property name when calling the method. This is illustrated in the OfficeInfo.java example in the \"Office Tests/\" folder: // in OfficeInfo.java XComponentLoader loader = Lo . loadOffice (); // look up 5 Office properties System . out . println ( \"Office name: \" + Info . getConfig ( \"ooName\" )); System . out . println ( \"Office version (long): \" + Info . getConfig ( \"ooSetupVersionAboutBox\" )); System . out . println ( \"Office version (short): \" + Info . getConfig ( \"ooSetupVersion\" )); System . out . println ( \"Office language location: \" + Info . getConfig ( \"ooLocale\" )); System . out . println ( \"System language location: \\\"\" + Info . getConfig ( \"ooSetupSystemLocale\" ) + \"\\\"\" ); On one of my test machines, the following is printed: Office name: LibreOffice Office version (long): 5.1.0.3 Office version (short): 5.1 Office language location: en-US System language location: \"\" Many other property names, which don't seem that useful, are documented in my Info class. One way of finding the most current list is to browse main.xcd in \\share\\registry. 1.2. Examining Path Settings \u00b6 Path settings store directory locations for parts of the Office installation, such as the whereabouts of the gallery and spellchecker files. A partial list of predefined paths is accessible from within LibreOffice, via the Tools menu: Tools, Options, LibreOffice, Paths. But the best source of information is the developer's guide, in the \"Path Organization\" section of chapter 6, or at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Path_Organization/ , which can be accessed using: loguide \"Path Organization\" One issue is that path settings comes in two forms: a string holding a single directory path, or a string made up of a \";'-separated paths. Additionally, the directories are returned in URI format (i.e. they start with \"file:///\"). Info.getPaths() hides the creation of a PathSettings service, and the accessing of its properties. Probably the most common Office forum question about paths is how to determine Office's installation directory. Unfortunately, that isn't one of the paths stored in the PathSettings service, but the information is accessible via one of the other paths. It's possible to retrieve the path for AddIns (which is /program/addin), and move up the directory hierarchy two levels. This trick is implemented by Info.getOfficeDir(). Examples of using Info.getOfficeDir() and Info.getPaths() appear in OfficeInfo.java: // in OfficeInfo.java System . out . println ( \"Office Dir: \" + Info . getOfficeDir ()); System . out . println ( \"Working Dir: \" + Info . getPaths ( \"Work\" )); System . out . println ( \"Addin Dir: \" + Info . getPaths ( \"Addin\" )); System . out . println ( \"Filters Dir: \" + Info . getPaths ( \"Filter\" )); System . out . println ( \"Templates Dirs: \" + Info . getPaths ( \"Template\" )); System . out . println ( \"Gallery Dir: \" + Info . getPaths ( \"Gallery\" )); 2. Getting and Setting Document Properties \u00b6 Document properties is the information that's displayed when you right-click on a file icon, and select \"Properties\" from the menu, as in Figure 1. Figure 1. A Properties Dialog in Windows 7 for \"algs.odp\". If you select the \"Details\" tab, a list of properties appears like those in Figure 2. Figure 2. Details Properties List for \"algs.odp\". An issue with document properties is that the Office API for manipulating them has changed. The old interfaces were XDocumentInfoSupplier and XDocumentInfo, but these have been deprecated, and replaced by XDocumentPropertiesSupplier and XDocumentProperties. This wouldn't really matter except that while OpenOffice retains those deprecated interfaces, LibreOffice has removed them. 2.1. Reporting OS File Properties \u00b6 My DocProps.java example prints the document properties by calling: Info.printDocProperties(doc); printDocProperties() converts the document to an XDocumentPropertiesSupplier interface, and extracts the XDocumentProperties object: public static void printDocProperties ( XComponent doc ) { XDocumentPropertiesSupplier docPropsSupp = UnoRuntime . queryInterface ( XDocumentPropertiesSupplier . class , doc ); XDocumentProperties dps = docPropsSupp . getDocumentProperties (); printDocProps ( dps ); XPropertyContainer udProps = dps . getUserDefinedProperties (); Props . showObjProps ( \"UserDefined Info\" , udProps ); } // end of printDocProperties() Although the XDocumentProperties interface belongs to a DocumentProperties service, that service does not contain any properties/attributes. Instead its data is stored inside XDocumentProperties and accessed and changed with get/set methods based on the attribute names. For example, the Author attribute is obtained by calling XDocumentProperties.getAuthor(). As a consequence, my printDocProps() consists of a long list of get method calls inside print statements: public static void printDocProps ( XDocumentProperties dps ) { System . out . println ( \"Document Properties Info\" ); System . out . println ( \"Author: \" + dps . getAuthor ()); System . out . println ( \"Title: \" + dps . getTitle ()); System . out . println ( \"Subject: \" + dps . getSubject ()); System . out . println ( \"Description: \" + dps . getDescription ()); System . out . println ( \"Generator: \" + dps . getGenerator ()); : // more of the same } However, user-defined file properties are accessed with an XPropertyContainer, as can be seen back in printDocProperties(). 2.2. Setting Document Properties \u00b6 The setting of document properties is done with set methods, as in Info.setDocProps() which sets the file's subject, title, and author properties: // in the Info class public static void setDocProps ( XComponent doc , String subject , String title , String author ) { XDocumentPropertiesSupplier dpSupplier = UnoRuntime . queryInterface ( XDocumentPropertiesSupplier . class , doc ); XDocumentProperties docProps = dpSupplier . getDocumentProperties (); docProps . setSubject ( subject ); docProps . setTitle ( title ); docProps . setAuthor ( author ); } // end setDocProps() This method is called at the end of DocProps.java: // code fragment from DocProps.java Info . setDocProps ( doc , \"Example\" , \"Examples\" , \"Andrew Davison\" ); Lo . save ( doc ); // must save or the props are lost After the properties are changed, the document must be saved otherwise the changes will be lost when the document is closed. The changed properties appear in the \"Document Statistics\" list shown in Figure 3. Figure 3. \"Document Statistics\" Properties List for \"algs.odp\". 3. Examining a Document for API Information \u00b6 After programming with the Office API for a while, you may start to notice that two coding questions keep coming up. They are: 1. For the service I'm using at the moment, what are its properties? 2. When I need to do something to a document (e.g. close an XComponent instance), which interface should I cast XComponent to by calling Lo.qi? The first question arose in Chapter 2 when I needed to set properties in loadComponentFromURL() and storeToURL(). Unfortunately the LibreOffice documentation for OfficeDocument doesn't list all the properties associated with the service. Have a look for yourself by typing lodoc OfficeDocument service , which takes you to its IDL Page unfortunately. You'll then need to click on the \"OfficeDocument\" link in the \"Classes\" section to reach the documentation. OfficeDocument's \"Public Attributes\" section only lists four properties. The second problem is also only partly addressed by the LibreOffice documentation. The pages helpfully includes inheritance tree diagrams that can be clicked on to jump to the documentation about other services and interfaces. But the diagrams don't make a distinction between \u201ccontains\u201d relationships (for interfaces in a service) and the two kinds of inheritance (for services and for interfaces). I'm not the first person to notice these problems; in fact, similar complaints have appeared frequently in the Office forums. Two approaches for easing matters are often suggested. One is to write code to print out details about a loaded document, which is my approach in the next subsection. A second technique is to install an Office extension for browsing a document's structure. I'll look at one such extension, MRI, in section 2.2. 3.1. Printing Programming Details about a Document \u00b6 I've hidden the messy job of collecting service, interface, property, and method information about a document inside the Info and Props utility classes. The five main methods for retrieving details can be understood by considering their position in Figure 4's Service and Interface Relationship diagram. Figure 4. Methods to Investigate the Service and Interface Relationships and Hierarchies. The methods are shown in action in the DocProps.java example, which loads a document and prints information about its services, interfaces, methods, and properties. The relevant code fragment: // part of DocProps.java XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); System . out . println ( \"\\n------ Services for this document: -------\" ); for ( String service : Info . getServices ( doc )) System . out . println ( \" \" + service ); System . out . println ( \"\\n--- Available Services for this doc: ---\" ); int count = 0 ; for ( String service : Info . getAvailableServices ( doc )) { System . out . println ( \" \" + service ); count ++ ; } System . out . println ( \"No. available services: \" + count ); System . out . println ( \"\\n------ Interfaces for this document: -------\" ); count = 0 ; for ( String intfs : Info . getInterfaces ( doc )) { System . out . println ( \" \" + intfs ); count ++ ; } System . out . println ( \"No. interfaces: \" + count ); String interfaceName = \"com.sun.star.text.XTextDocument\" ; System . out . println ( \"\\n------ Methods for interface \" + interfaceName + \": ------\" ); String [] methods = Info . getMethods ( interfaceName ); for ( String methodName : methods ) System . out . println ( \" \" + methodName + \"();\" ); System . out . println ( \"No. methods: \" + methods . length ); System . out . println ( \"\\n---- Properties for this document: ----\" ); count = 0 ; for ( Property p : Props . getProperties ( doc )) { System . out . println ( \" \" + Props . showProperty ( p )); count ++ ; } System . out . println ( \"No. properties: \" + count ); When I examined a Word file with this program, only three services were found: OfficeDocument, GenericTextDocument, and TextDocument, which correspond to the text document part of the hierarchy in Chapter 1, Figure 9. That doesn't seem so bad until you look at the output from the other Info.getXXX() methods: the document can call 206 other available services, 69 interfaces, and manipulate 40 properties. In the code above only the methods available to XTextDocument are printed: String interfaceName = \"com.sun.star.text.XTextDocument\" ; String [] methods = Info . getMethods ( interfaceName ); Sixteen methods are listed, collectively inherited from the interfaces in XTextDocument 's inheritance hierarchy shown in Figure 5. Figure 5. Inheritance Hierarchy for XTextDocument. A similar diagram appears on the XTextDocument documentation webpage ( lodoc XTextDocument ), but is complicated by also including the inheritance hierarchy for the TextDocument service. Note, the interface hierarchy is also textually represented in the \"Public Member Functions\" section of the documentation. The last part of the code fragment prints all the document's property names and types by calling Props.showProperty(). If you only want to know about one specific property then use Props.getProperty(), which requires a reference to the document and the property name: String propName = \"CharacterCount\" ; System . out . println ( \"Value of \" + propName + \": \" + Props . getProperty ( doc , propName ) ); File Types Another group of utility methods let a programmer investigate a file's document type. The DocProps.java example also shows these methods in action: // part of DocProps.java XComponentLoader loader = Lo . loadOffice (); String ext = Info . getExt ( args [ 0 ] ); if ( ext != null ) { System . out . println ( \"\\nFile Extension: \" + ext ); System . out . println ( \"Extension format: \" + Lo . ext2Format ( ext )); } // get document type String docType = Info . getDocType ( args [ 0 ] ); if ( docType != null ) { System . out . println ( \"Doc type: \" + docType + \"\\n\" ); Props . showDocTypeProps ( docType ); } One advantage of these functions is that they can be called before the file's document is loaded with Lo.openDoc(). The data printed for the Word file, \"story.doc\", is: File Extension: doc Extension format: MS Word 97 Doc type: writer_MS_Word_97 Properties for \"writer_MS_Word_97\": Mandatory: false Finalized: false MediaType: application/msword Preferred: true UIName: Microsoft Word 97/2000/XP/2003 Extensions: [doc] DetectService: com.sun.star.text.FormatDetector UINames: [ = Microsoft Word 97/2000/XP/2003 ] PreferredFilter: MS Word 97 ClipboardFormat: MSWordDoc URLPattern: [] Name: writer_MS_Word_97 Lo.ext2Format() print's the Office filter name (\"MS Word 97\") associated with the file's extension (\".doc\"). Info.getDocType() returns the type of the document once the file has been loaded (e.g. \"writer_MS_Word_97\"). Props.showDocTypeProps() prints the properties associated with that type. Probably the most useful is the \"PreferredFilter\" which is the best filter name to use when saving the document. 3.2. Examining a Document Using Extensions \u00b6 It's hardly surprising that Office developers have wanted to make the investigation of services, interfaces, and properties associated with documents and other objects easier. There are several extension which do this, and I tried three of them: MRI, XRayTool ( https://bernard.marcelly.perso.sfr.fr/Files_en/XrayTool60_en.odt ), and Object Inspector ( https://wiki.openoffice.org/wiki/Object_Inspector/ ). Probably the best in terms of functionality and documentation is MRI, which I'll describe here. MRI can be downloaded from https://extensions.services.openoffice.org/en/project/mri-uno-object-inspection-tool/ , depositing an OXT file (probably called \"MRI-1.3.3.oxt\") on your machine. Installing an extension is done through the Tools, Extension Manager menu item. Click on the \"Add\" button and select the OXT file. Or you may be able to simply double click on the file to start the installation. One (perhaps temporary) problem is that I was unable to install the versions of MRI available at the LibreOffice extensions site (v.1.1.2 or the pre-release v.1.1.4 at https://extensions.libreoffice.org/extension-center/ ). However, the newer edition, v.1.2.4, at OpenOffice's extension's website ( https://extensions.services.openoffice.org/en/project/mri-uno-object-inspection-tool/ ) did install successfully. Once installed, MRI can be accessed through Office's GUI via the Tools, Add-ons menu item, or programmatically as in my ExamineDoc.java example: // part of ExamineDoc.java XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); Lo . mriInspect ( doc ); A window appears, like the one in Figure 6. Figure 6. MRI Examination of a Document. The tabs along the top of the large window allow you to switch between information about the document's properties, methods, interfaces, and services. Unlike my earlier print methods, it's possible to move around the window's data, looking inside property objects. One enormously useful feature is automatic code generation, which is possible in a variety of different languages, including Java. The code type is set through the Tools, Code menu item, and the code appears in a window which is initially of size 0. It's hidden below the large window and above the status bar; drag the large window's lower border upwards to make the code window visible. A click on a method or property will cause code to be generated which utilizes the method or property. For example, when I clicked on the CharacterCount property (shown at the bottom of Figure 6), the following code fragment was produced: public static void snippet ( XComponentContext xComponentContext , Object oInitialTarget ) { try { XPropertySet xPropSet = UnoRuntime . queryInterface ( XPropertySet . class , oInitialTarget ); int nCharacterCount = AnyConverter . toInt ( xPropSet . getPropertyValue ( \"CharacterCount\" )); } catch ( UnknownPropertyException e1 ) { e1 . printStackTrace (); } catch ( IllegalArgumentException e2 ) { e2 . printStackTrace (); } catch ( WrappedTargetException e3 ) { e3 . printStackTrace (); } } The snippet() function is passed the component context and initial target object (the text document). UnoRuntime.queryInterface() casts the document to the XPropertySet interface, and getPropertyValue() looks up the CharacterCount value. (Recall that Office's UnoRuntime.queryInterface() is my Lo.qi().) The Office AnyConverter class converts Office types to Java types, but could actually be left out in this case. The exception handling could also be shortened. One benefit of using MRI is the large amount of excellent documentation. The extension includes a \"Help\" menu item, and a configurable link to online Office documentation. MRI has its own wiki, at https://github.com/hanya/MRI/wiki/ , and there are several forum posts about using it for code generation (e.g. https://forum.openoffice.org/en/forum/viewtopic.php?f=74&t=49294 ) and for navigating MRI's object hierarchy ( https://forum.openoffice.org/en/forum/download/file.php?id=17368&sid=373c5d78240f4093fb3721fe4264dd20 ). Some Quirks of Using MRI \u00b6 Lo.mriInspect() executes the following code, which I lifted from the \"Run MRI\" section of the MRI wiki: // in Lo.java public static void mriInspect ( Object obj ) { XIntrospection xi = createInstanceMCF ( XIntrospection . class , \"mytools.Mri\" ); if ( xi == null ) { System . out . println ( \"MRI Inspector Service could not be instantiated\" ); return ; } System . out . println ( \"MRI Inspector Service instantiated\" ); xi . inspect ( obj ); } // end of mriInspect() \"mytools.Mri\" is the name of the service added to Office when MRI is installed. createInstanceMCF() creates an instance of the service, and accesses its XIntrospection interface, so that the XIntrospection.inspect() method can be called. One drawback is that inspect() returns immediately after spawning the MRI GUI (i.e. the window in Figure 3), allowing ExamineDoc.java to continue. It would be better if the program paused, which can be achieved by calling Lo.waitEnter(): // part of ExamineDoc.java XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); Lo . mriInspect ( doc ); Lo . waitEnter (); Another issue is that when the MRI window is closed by the user, the link to Office is broken (the UNO bridge is deleted). But this doesn't happen if the document is visible on-screen when the MRI window is closed. In general, it turns out to be quite useful to display the document, especially during program debugging and development. A visible document allows the coder to see incremental changes as they occur. The simplest way of making a document visible is by employing the FCM relationship mentioned in Chapter 1. Starting from the document, it's easy to switch to the XModel interface, and from there go to the container window. Its XWindow interface has a setVisible() method that can make the document visible (or hide it). The corresponding code fragment is: XModel model = Lo . qi ( XModel . class , doc ); XFrame frame = model . getCurrentController (). getFrame (); XWindow xWindow = frame . getContainerWindow (); xWindow . setVisible ( true ); // or false to hide xWindow . setFocus (); This code is packaged up in the GUI utility class, and called with GUI.setVisible(). The code in ExpandDoc becomes: // part of ExamineDoc.java XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); GUI . setVisible ( doc , true ); // needed so that close of MRI doesn't // cause the UNO bridge to be disposed Lo . mriInspect ( doc ); Lo . waitEnter ();","title":"Chapter 3. Examining"},{"location":"03-Examining.html#chapter-3-examining","text":"Topics Examining Office; Getting and Setting Document Properties; Examining a Document for API Details; Examining a Document Using MRI Example folders: \"Office Tests\" and \"Utils\" This chapter looks at ways to examine the state of the Office application and a document. A document will be examined in three different ways: the first retrieves properties about the file, such as its author, keywords, and when it was last modified. The second and third approaches extract API details, such as what services and interfaces it uses. This can be done by calling functions in my Utils class or by utilizing the MRI extension added to Office. Once again all the examples come from the \"Office Tests\" directory in the code download associated with this book, and make liberal use of the classes in the \"Utils\" directory. For details please visit https://fivedots.coe.psu.ac.th/~ad/jlop/ .","title":"Chapter 3. Examining"},{"location":"03-Examining.html#1-examining-office","text":"It's sometimes necessary to examine the state of the Office application, for example to determine its version number or installation directory. There are two main ways of finding this information, using configuration properties and path settings.","title":"1.  Examining Office"},{"location":"03-Examining.html#11-examining-configuration-properties","text":"Configuration management is a complex area, which is explained reasonably well in chapter 15 of the developer's guide and online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Config/Configuration_Management/ ; I'll only explain the basics here. The easiest way of accessing the relevant online section is by typing: loguide \"Configuration Management\" Office stores a large assortment of XML configuration data as \".xcd\" files in the \\share\\registry directory. They can be programatically accessed in three steps: first a ConfigurationProvider service is created, which represents the configuration database tree. The tree is examined with a ConfigurationAccess service which is supplied with the path to the node of interest. Configuration properties can be accessed by name with the XNameAccess interface. These steps are hidden inside Info.getConfig() which requires at most two arguments \u2013 the path to the required node, and the name of the property inside that node. The two most useful paths seem to be \"/org.openoffice.Setup/Product\" and \"/org.openoffice.Setup/L10N\", which are hardwired as constants in the Info class. The simplest version of getConfig() looks along both paths by default so the programmer only has to supply a property name when calling the method. This is illustrated in the OfficeInfo.java example in the \"Office Tests/\" folder: // in OfficeInfo.java XComponentLoader loader = Lo . loadOffice (); // look up 5 Office properties System . out . println ( \"Office name: \" + Info . getConfig ( \"ooName\" )); System . out . println ( \"Office version (long): \" + Info . getConfig ( \"ooSetupVersionAboutBox\" )); System . out . println ( \"Office version (short): \" + Info . getConfig ( \"ooSetupVersion\" )); System . out . println ( \"Office language location: \" + Info . getConfig ( \"ooLocale\" )); System . out . println ( \"System language location: \\\"\" + Info . getConfig ( \"ooSetupSystemLocale\" ) + \"\\\"\" ); On one of my test machines, the following is printed: Office name: LibreOffice Office version (long): 5.1.0.3 Office version (short): 5.1 Office language location: en-US System language location: \"\" Many other property names, which don't seem that useful, are documented in my Info class. One way of finding the most current list is to browse main.xcd in \\share\\registry.","title":"1.1 Examining Configuration Properties"},{"location":"03-Examining.html#12-examining-path-settings","text":"Path settings store directory locations for parts of the Office installation, such as the whereabouts of the gallery and spellchecker files. A partial list of predefined paths is accessible from within LibreOffice, via the Tools menu: Tools, Options, LibreOffice, Paths. But the best source of information is the developer's guide, in the \"Path Organization\" section of chapter 6, or at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Path_Organization/ , which can be accessed using: loguide \"Path Organization\" One issue is that path settings comes in two forms: a string holding a single directory path, or a string made up of a \";'-separated paths. Additionally, the directories are returned in URI format (i.e. they start with \"file:///\"). Info.getPaths() hides the creation of a PathSettings service, and the accessing of its properties. Probably the most common Office forum question about paths is how to determine Office's installation directory. Unfortunately, that isn't one of the paths stored in the PathSettings service, but the information is accessible via one of the other paths. It's possible to retrieve the path for AddIns (which is /program/addin), and move up the directory hierarchy two levels. This trick is implemented by Info.getOfficeDir(). Examples of using Info.getOfficeDir() and Info.getPaths() appear in OfficeInfo.java: // in OfficeInfo.java System . out . println ( \"Office Dir: \" + Info . getOfficeDir ()); System . out . println ( \"Working Dir: \" + Info . getPaths ( \"Work\" )); System . out . println ( \"Addin Dir: \" + Info . getPaths ( \"Addin\" )); System . out . println ( \"Filters Dir: \" + Info . getPaths ( \"Filter\" )); System . out . println ( \"Templates Dirs: \" + Info . getPaths ( \"Template\" )); System . out . println ( \"Gallery Dir: \" + Info . getPaths ( \"Gallery\" ));","title":"1.2.  Examining Path Settings"},{"location":"03-Examining.html#2-getting-and-setting-document-properties","text":"Document properties is the information that's displayed when you right-click on a file icon, and select \"Properties\" from the menu, as in Figure 1. Figure 1. A Properties Dialog in Windows 7 for \"algs.odp\". If you select the \"Details\" tab, a list of properties appears like those in Figure 2. Figure 2. Details Properties List for \"algs.odp\". An issue with document properties is that the Office API for manipulating them has changed. The old interfaces were XDocumentInfoSupplier and XDocumentInfo, but these have been deprecated, and replaced by XDocumentPropertiesSupplier and XDocumentProperties. This wouldn't really matter except that while OpenOffice retains those deprecated interfaces, LibreOffice has removed them.","title":"2.  Getting and Setting Document Properties"},{"location":"03-Examining.html#21-reporting-os-file-properties","text":"My DocProps.java example prints the document properties by calling: Info.printDocProperties(doc); printDocProperties() converts the document to an XDocumentPropertiesSupplier interface, and extracts the XDocumentProperties object: public static void printDocProperties ( XComponent doc ) { XDocumentPropertiesSupplier docPropsSupp = UnoRuntime . queryInterface ( XDocumentPropertiesSupplier . class , doc ); XDocumentProperties dps = docPropsSupp . getDocumentProperties (); printDocProps ( dps ); XPropertyContainer udProps = dps . getUserDefinedProperties (); Props . showObjProps ( \"UserDefined Info\" , udProps ); } // end of printDocProperties() Although the XDocumentProperties interface belongs to a DocumentProperties service, that service does not contain any properties/attributes. Instead its data is stored inside XDocumentProperties and accessed and changed with get/set methods based on the attribute names. For example, the Author attribute is obtained by calling XDocumentProperties.getAuthor(). As a consequence, my printDocProps() consists of a long list of get method calls inside print statements: public static void printDocProps ( XDocumentProperties dps ) { System . out . println ( \"Document Properties Info\" ); System . out . println ( \"Author: \" + dps . getAuthor ()); System . out . println ( \"Title: \" + dps . getTitle ()); System . out . println ( \"Subject: \" + dps . getSubject ()); System . out . println ( \"Description: \" + dps . getDescription ()); System . out . println ( \"Generator: \" + dps . getGenerator ()); : // more of the same } However, user-defined file properties are accessed with an XPropertyContainer, as can be seen back in printDocProperties().","title":"2.1.  Reporting OS File Properties"},{"location":"03-Examining.html#22-setting-document-properties","text":"The setting of document properties is done with set methods, as in Info.setDocProps() which sets the file's subject, title, and author properties: // in the Info class public static void setDocProps ( XComponent doc , String subject , String title , String author ) { XDocumentPropertiesSupplier dpSupplier = UnoRuntime . queryInterface ( XDocumentPropertiesSupplier . class , doc ); XDocumentProperties docProps = dpSupplier . getDocumentProperties (); docProps . setSubject ( subject ); docProps . setTitle ( title ); docProps . setAuthor ( author ); } // end setDocProps() This method is called at the end of DocProps.java: // code fragment from DocProps.java Info . setDocProps ( doc , \"Example\" , \"Examples\" , \"Andrew Davison\" ); Lo . save ( doc ); // must save or the props are lost After the properties are changed, the document must be saved otherwise the changes will be lost when the document is closed. The changed properties appear in the \"Document Statistics\" list shown in Figure 3. Figure 3. \"Document Statistics\" Properties List for \"algs.odp\".","title":"2.2.  Setting Document Properties"},{"location":"03-Examining.html#3-examining-a-document-for-api-information","text":"After programming with the Office API for a while, you may start to notice that two coding questions keep coming up. They are: 1. For the service I'm using at the moment, what are its properties? 2. When I need to do something to a document (e.g. close an XComponent instance), which interface should I cast XComponent to by calling Lo.qi? The first question arose in Chapter 2 when I needed to set properties in loadComponentFromURL() and storeToURL(). Unfortunately the LibreOffice documentation for OfficeDocument doesn't list all the properties associated with the service. Have a look for yourself by typing lodoc OfficeDocument service , which takes you to its IDL Page unfortunately. You'll then need to click on the \"OfficeDocument\" link in the \"Classes\" section to reach the documentation. OfficeDocument's \"Public Attributes\" section only lists four properties. The second problem is also only partly addressed by the LibreOffice documentation. The pages helpfully includes inheritance tree diagrams that can be clicked on to jump to the documentation about other services and interfaces. But the diagrams don't make a distinction between \u201ccontains\u201d relationships (for interfaces in a service) and the two kinds of inheritance (for services and for interfaces). I'm not the first person to notice these problems; in fact, similar complaints have appeared frequently in the Office forums. Two approaches for easing matters are often suggested. One is to write code to print out details about a loaded document, which is my approach in the next subsection. A second technique is to install an Office extension for browsing a document's structure. I'll look at one such extension, MRI, in section 2.2.","title":"3.  Examining a Document for API Information"},{"location":"03-Examining.html#31-printing-programming-details-about-a-document","text":"I've hidden the messy job of collecting service, interface, property, and method information about a document inside the Info and Props utility classes. The five main methods for retrieving details can be understood by considering their position in Figure 4's Service and Interface Relationship diagram. Figure 4. Methods to Investigate the Service and Interface Relationships and Hierarchies. The methods are shown in action in the DocProps.java example, which loads a document and prints information about its services, interfaces, methods, and properties. The relevant code fragment: // part of DocProps.java XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); System . out . println ( \"\\n------ Services for this document: -------\" ); for ( String service : Info . getServices ( doc )) System . out . println ( \" \" + service ); System . out . println ( \"\\n--- Available Services for this doc: ---\" ); int count = 0 ; for ( String service : Info . getAvailableServices ( doc )) { System . out . println ( \" \" + service ); count ++ ; } System . out . println ( \"No. available services: \" + count ); System . out . println ( \"\\n------ Interfaces for this document: -------\" ); count = 0 ; for ( String intfs : Info . getInterfaces ( doc )) { System . out . println ( \" \" + intfs ); count ++ ; } System . out . println ( \"No. interfaces: \" + count ); String interfaceName = \"com.sun.star.text.XTextDocument\" ; System . out . println ( \"\\n------ Methods for interface \" + interfaceName + \": ------\" ); String [] methods = Info . getMethods ( interfaceName ); for ( String methodName : methods ) System . out . println ( \" \" + methodName + \"();\" ); System . out . println ( \"No. methods: \" + methods . length ); System . out . println ( \"\\n---- Properties for this document: ----\" ); count = 0 ; for ( Property p : Props . getProperties ( doc )) { System . out . println ( \" \" + Props . showProperty ( p )); count ++ ; } System . out . println ( \"No. properties: \" + count ); When I examined a Word file with this program, only three services were found: OfficeDocument, GenericTextDocument, and TextDocument, which correspond to the text document part of the hierarchy in Chapter 1, Figure 9. That doesn't seem so bad until you look at the output from the other Info.getXXX() methods: the document can call 206 other available services, 69 interfaces, and manipulate 40 properties. In the code above only the methods available to XTextDocument are printed: String interfaceName = \"com.sun.star.text.XTextDocument\" ; String [] methods = Info . getMethods ( interfaceName ); Sixteen methods are listed, collectively inherited from the interfaces in XTextDocument 's inheritance hierarchy shown in Figure 5. Figure 5. Inheritance Hierarchy for XTextDocument. A similar diagram appears on the XTextDocument documentation webpage ( lodoc XTextDocument ), but is complicated by also including the inheritance hierarchy for the TextDocument service. Note, the interface hierarchy is also textually represented in the \"Public Member Functions\" section of the documentation. The last part of the code fragment prints all the document's property names and types by calling Props.showProperty(). If you only want to know about one specific property then use Props.getProperty(), which requires a reference to the document and the property name: String propName = \"CharacterCount\" ; System . out . println ( \"Value of \" + propName + \": \" + Props . getProperty ( doc , propName ) ); File Types Another group of utility methods let a programmer investigate a file's document type. The DocProps.java example also shows these methods in action: // part of DocProps.java XComponentLoader loader = Lo . loadOffice (); String ext = Info . getExt ( args [ 0 ] ); if ( ext != null ) { System . out . println ( \"\\nFile Extension: \" + ext ); System . out . println ( \"Extension format: \" + Lo . ext2Format ( ext )); } // get document type String docType = Info . getDocType ( args [ 0 ] ); if ( docType != null ) { System . out . println ( \"Doc type: \" + docType + \"\\n\" ); Props . showDocTypeProps ( docType ); } One advantage of these functions is that they can be called before the file's document is loaded with Lo.openDoc(). The data printed for the Word file, \"story.doc\", is: File Extension: doc Extension format: MS Word 97 Doc type: writer_MS_Word_97 Properties for \"writer_MS_Word_97\": Mandatory: false Finalized: false MediaType: application/msword Preferred: true UIName: Microsoft Word 97/2000/XP/2003 Extensions: [doc] DetectService: com.sun.star.text.FormatDetector UINames: [ = Microsoft Word 97/2000/XP/2003 ] PreferredFilter: MS Word 97 ClipboardFormat: MSWordDoc URLPattern: [] Name: writer_MS_Word_97 Lo.ext2Format() print's the Office filter name (\"MS Word 97\") associated with the file's extension (\".doc\"). Info.getDocType() returns the type of the document once the file has been loaded (e.g. \"writer_MS_Word_97\"). Props.showDocTypeProps() prints the properties associated with that type. Probably the most useful is the \"PreferredFilter\" which is the best filter name to use when saving the document.","title":"3.1.  Printing Programming Details about a Document"},{"location":"03-Examining.html#32-examining-a-document-using-extensions","text":"It's hardly surprising that Office developers have wanted to make the investigation of services, interfaces, and properties associated with documents and other objects easier. There are several extension which do this, and I tried three of them: MRI, XRayTool ( https://bernard.marcelly.perso.sfr.fr/Files_en/XrayTool60_en.odt ), and Object Inspector ( https://wiki.openoffice.org/wiki/Object_Inspector/ ). Probably the best in terms of functionality and documentation is MRI, which I'll describe here. MRI can be downloaded from https://extensions.services.openoffice.org/en/project/mri-uno-object-inspection-tool/ , depositing an OXT file (probably called \"MRI-1.3.3.oxt\") on your machine. Installing an extension is done through the Tools, Extension Manager menu item. Click on the \"Add\" button and select the OXT file. Or you may be able to simply double click on the file to start the installation. One (perhaps temporary) problem is that I was unable to install the versions of MRI available at the LibreOffice extensions site (v.1.1.2 or the pre-release v.1.1.4 at https://extensions.libreoffice.org/extension-center/ ). However, the newer edition, v.1.2.4, at OpenOffice's extension's website ( https://extensions.services.openoffice.org/en/project/mri-uno-object-inspection-tool/ ) did install successfully. Once installed, MRI can be accessed through Office's GUI via the Tools, Add-ons menu item, or programmatically as in my ExamineDoc.java example: // part of ExamineDoc.java XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); Lo . mriInspect ( doc ); A window appears, like the one in Figure 6. Figure 6. MRI Examination of a Document. The tabs along the top of the large window allow you to switch between information about the document's properties, methods, interfaces, and services. Unlike my earlier print methods, it's possible to move around the window's data, looking inside property objects. One enormously useful feature is automatic code generation, which is possible in a variety of different languages, including Java. The code type is set through the Tools, Code menu item, and the code appears in a window which is initially of size 0. It's hidden below the large window and above the status bar; drag the large window's lower border upwards to make the code window visible. A click on a method or property will cause code to be generated which utilizes the method or property. For example, when I clicked on the CharacterCount property (shown at the bottom of Figure 6), the following code fragment was produced: public static void snippet ( XComponentContext xComponentContext , Object oInitialTarget ) { try { XPropertySet xPropSet = UnoRuntime . queryInterface ( XPropertySet . class , oInitialTarget ); int nCharacterCount = AnyConverter . toInt ( xPropSet . getPropertyValue ( \"CharacterCount\" )); } catch ( UnknownPropertyException e1 ) { e1 . printStackTrace (); } catch ( IllegalArgumentException e2 ) { e2 . printStackTrace (); } catch ( WrappedTargetException e3 ) { e3 . printStackTrace (); } } The snippet() function is passed the component context and initial target object (the text document). UnoRuntime.queryInterface() casts the document to the XPropertySet interface, and getPropertyValue() looks up the CharacterCount value. (Recall that Office's UnoRuntime.queryInterface() is my Lo.qi().) The Office AnyConverter class converts Office types to Java types, but could actually be left out in this case. The exception handling could also be shortened. One benefit of using MRI is the large amount of excellent documentation. The extension includes a \"Help\" menu item, and a configurable link to online Office documentation. MRI has its own wiki, at https://github.com/hanya/MRI/wiki/ , and there are several forum posts about using it for code generation (e.g. https://forum.openoffice.org/en/forum/viewtopic.php?f=74&t=49294 ) and for navigating MRI's object hierarchy ( https://forum.openoffice.org/en/forum/download/file.php?id=17368&sid=373c5d78240f4093fb3721fe4264dd20 ).","title":"3.2.  Examining a Document Using Extensions"},{"location":"03-Examining.html#some-quirks-of-using-mri","text":"Lo.mriInspect() executes the following code, which I lifted from the \"Run MRI\" section of the MRI wiki: // in Lo.java public static void mriInspect ( Object obj ) { XIntrospection xi = createInstanceMCF ( XIntrospection . class , \"mytools.Mri\" ); if ( xi == null ) { System . out . println ( \"MRI Inspector Service could not be instantiated\" ); return ; } System . out . println ( \"MRI Inspector Service instantiated\" ); xi . inspect ( obj ); } // end of mriInspect() \"mytools.Mri\" is the name of the service added to Office when MRI is installed. createInstanceMCF() creates an instance of the service, and accesses its XIntrospection interface, so that the XIntrospection.inspect() method can be called. One drawback is that inspect() returns immediately after spawning the MRI GUI (i.e. the window in Figure 3), allowing ExamineDoc.java to continue. It would be better if the program paused, which can be achieved by calling Lo.waitEnter(): // part of ExamineDoc.java XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); Lo . mriInspect ( doc ); Lo . waitEnter (); Another issue is that when the MRI window is closed by the user, the link to Office is broken (the UNO bridge is deleted). But this doesn't happen if the document is visible on-screen when the MRI window is closed. In general, it turns out to be quite useful to display the document, especially during program debugging and development. A visible document allows the coder to see incremental changes as they occur. The simplest way of making a document visible is by employing the FCM relationship mentioned in Chapter 1. Starting from the document, it's easy to switch to the XModel interface, and from there go to the container window. Its XWindow interface has a setVisible() method that can make the document visible (or hide it). The corresponding code fragment is: XModel model = Lo . qi ( XModel . class , doc ); XFrame frame = model . getCurrentController (). getFrame (); XWindow xWindow = frame . getContainerWindow (); xWindow . setVisible ( true ); // or false to hide xWindow . setFocus (); This code is packaged up in the GUI utility class, and called with GUI.setVisible(). The code in ExpandDoc becomes: // part of ExamineDoc.java XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); GUI . setVisible ( doc , true ); // needed so that close of MRI doesn't // cause the UNO bridge to be disposed Lo . mriInspect ( doc ); Lo . waitEnter ();","title":"Some Quirks of Using MRI"},{"location":"04-Listening.html","text":"Chapter 4. Listening, and Other Techniques \u00b6 Topics Window Listeners; Office Manipulation with JNA; Dispatching; Robot Keys Example folders: \"Office Tests\" and \"Utils\" This chapter concludes the general introduction to Office programming by looking at several techniques that will reappear periodically in later chapters: the use of window listeners, the manipulation of Office using the JNA library, dispatching messages to the Office GUI, and the Java Robot package. Once again the examples come from the \"Office Tests\" directory in the code download associated with this book, and make liberal use of the classes in the \"Utils\" directory. For details please visit https://fivedots.coe.psu.ac.th/~ad/jlop/ . 1. Listening to a Window \u00b6 I haven't previously mentioned Office's listener interfaces (there are about 140 of them), because they work in the same way as listeners in Java. Probably the easiest way of obtaining a list of them all is to visit the LibreOffice documentation for XEventListener (use lodoc XEventListener ). The tree diagram at the top of the page shows that every listener interface is a subclass of XEventListener, and you can click on a subclass box to jump to its documentation. One nice syntactic feature of listeners is that almost all their names end with \u201cListener\u201d. This makes them easy to find when searching through indices of class names, such as the \u201cClass Index\u201d page at https://api.libreoffice.org/docs/idl/ref/classes.html . The top-level document window can be monitored for changes using XTopWindowListener, which responds to modifications of the window\u2019s state, such as when it is opened, closed, minimized, and made active. The DocWindow.java example illustrates how to use the listener: public class DocWindow implements XTopWindowListener { public DocWindow ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( this ); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // various window manipulation code; see below // : Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of DocWindow() // --------- 7 XTopWindowListener methods ----------- public void windowOpened ( EventObject event ) { System . out . println ( \"WL: Opened\" ); XWindow xWin = Lo . qi ( XWindow . class , event . Source ); GUI . printRect ( xWin . getPosSize ()); } // end of windowOpened() public void windowActivated ( EventObject event ) { System . out . println ( \"WL: Activated\" ); System . out . println ( \" Title bar: \\\"\" + GUI . getTitleBar () + \"\\\"\" ); } // end of windowActivated() public void windowMinimized ( EventObject event ) { System . out . println ( \"WL: Minimized\" ); } public void windowNormalized ( EventObject event ) { System . out . println ( \"WL: Normalized\" ); } public void windowDeactivated ( EventObject event ) { System . out . println ( \"WL: De-activated\" ); } public void windowClosing ( EventObject event ) // never called (?) { System . out . println ( \"WL: Closing\" ); } public void windowClosed ( EventObject event ) { System . out . println ( \"WL: Closed\" ); } // --------- XEventListener method ------------ public void disposing ( EventObject event ) // never called (?) { System . out . println ( \"WL: Disposing\" ); } } // end of DocWindow class The class implements seven methods for XTopWindowListener, and disposing() inherited from XEventListener. The DocWindow object is made the listener for the window by accessing the XExtendedToolkit interface, which is part of the Toolkit service. Toolkit is utilized by Office to create windows, and XExtendedToolkit adds three kinds of listeners: XTopWindowListener, XFocusListener, and the XKeyHandler listener. When an event arrives at a listener method, one of the more useful things to do is to transform it into an XWindow instance: XWindow xWin = Lo . qi ( XWindow . class , event . Source ); It's then possible to access details about the frame, such as its size. Events are fired when GUI.setVisible() is called in the DocWindow() constructor. An opened event is issued, followed by an activated event, triggering calls to windowOpened() and windowActivated(). Rather confusingly, both these methods are called twice. When Lo.closeDoc() is called at the end of the constructor, a single de-activated event is fired, but two closed events are issued. Consequently, there's a single call to windowDeactivated() and two to windowClosed(). Strangely, there's no window closing event trigger of windowClosing(), and Lo.closeOffice() doesn't cause disposing() to fire. 2. Office Manipulation with JNA \u00b6 Although XTopWindowListener can detect the minimization and re-activation of the document window, there's no way to trigger these changes from the Office API. Fixing this requires a trip outside Office because I need a library that can manipulate a window controlled by the OS. One very nice API that fits my needs is Java Native Access (JNA, https://github.com/twall/jna/ ), which supports OS programming without writing anything but Java. JNA comes with numerous classes, representing OS data structures, such as window handles and process IDs. The JNA-powered methods in my JNAUtils.java utilities class fall roughly into three groups: functions for accessing windows via their handles, methods for accessing buttons inside windows via their handles, and functions that map between handles and process IDs. In the DocWindow.java example, the document window\u2019s handle is retrieved first, then minimization and re-activation methods change the window: // part of DocWindow.java HWND handle = JNAUtils . getHandle (); System . out . println ( \"Handle: \\\"\" + JNAUtils . handleString ( handle ) + \"\\\"\" ); JNAUtils . winMinimize ( handle ); // triggers minimized and de-activated events Lo . delay ( 3000 ); JNAUtils . winRestore ( handle ); // triggers normalized and activated events Lo . delay ( 3000 ); The calls to Lo.delay() slow down the window changes at run time so the user can see what's happening. JNAUtils.getHandle() employs JNA's User32 library function FindWindow(). It finds the handle associated with a specific application window's class name, which is \"SALFRAME\" for both LibreOffice and OpenOffice. JNAUtils.handleString() converts the HWND handle into a hexadecimal string, which prints nicely. JNAUtils.winMinimize() and JNAUtils.winRestore() call User32.ShowWindow() with different state parameters. The JNA User32 class contains many functions related to window manipulation. For example, it's easy to implement window movement and resizing using SetWindowPos(). However, that functionality is already available in Office's XWindow.setPosSize(). Incidentally, it's possible for Office to access a window\u2019s handle as an integer by means of XSystemDependentWindowPeer (e.g. see the code in GUI.getWindowHandle()), but there are no Office methods which utilize this integer. JNA methods require a HWND instance, so the handle needs to be obtained using JNA. 3. Detecting Office Termination \u00b6 Office termination is most easily observed by attaching a listener to the Desktop object, as in DocMonitor.java: public class DocMonitor { public DocMonitor ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); XDesktop xDesktop = Lo . getDesktop (); xDesktop . addTerminateListener ( new XTerminateListener () { public void queryTermination ( EventObject e ) throws TerminationVetoException { System . out . println ( \"TL: Starting Closing\" ); } public void notifyTermination ( EventObject e ) { System . out . println ( \"TL: Finished Closing\" ); } public void disposing ( EventObject e ) { System . out . println ( \"TL: Disposing\" ); } }); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); System . out . println ( \"Waiting for 5 secs before closing doc\u2026\" ); Lo . delay ( 5000 ); Lo . closeDoc ( doc ); System . out . println ( \"Waiting for 5 secs before closing Office\u2026\" ); Lo . delay ( 5000 ); Lo . closeOffice (); } // end of DocMonitor() } An XTerminateListener is attached to the XDesktop instance. The program's output is: > run DocMonitor algs.odp Loading Office... Opening algs.odp Waiting for 5 secs before closing doc... Closing the document Waiting for 5 secs before closing Office... Closing Office TL: Starting Closing TL: Finished Closing Office terminated XTerminateListener\u2019s queryTermination() and notifyTermination() are called at the start and end of the Office closing sequence. As in the DocWindow.java example, disposing() is never triggered. 4. Bridge Shutdown Detection \u00b6 There's another way to detect Office closure: by listening for the shutdown of the UNO bridge between the Java and Office processes. This can be useful if Office crashes independently of your Java code. However, I was only able to get this approach to work when using a socket-based link to Office. The modified parts of DocMonitor.java are: // in DocMonitor() XComponentLoader loader = // Lo.loadOffice(); Lo . loadSocketOffice (); : // more code XComponent bridgeComp = Lo . getBridge (); if ( bridgeComp != null ) { System . out . println ( \"Found bridge\" ); bridgeComp . addEventListener ( new XEventListener () { public void disposing ( EventObject e ) { /* remote bridge has gone down, because office crashed or was terminated. */ System . out . println ( \"Office bridge has gone!!\" ); System . exit ( 1 ); } }); } XComponent doc = Lo . openDoc ( fnm , loader ); : // more code Since the disappearance of the Office bridge is a fatal event, disposing() finishes by calling System.exit() to kill Java. The output of the revised DocMonitor.java is: > run DocMonitor algs.odp Loading Office... Office process created Found bridge Opening algs.odp Waiting for 5 secs before closing doc... Closing the document Waiting for 5 secs before closing Office... Closing Office TL: Starting Closing TL: Finished Closing Office terminated Office bridge has gone!! This output shows that bridge closure follows the call to Lo.closeOffice(), as you'd expect. However, if I make Office crash while DocMonitor is running, then the output becomes: > run DocMonitor algs.odp Loading Office... Office process created Found bridge Opening algs.odp Waiting for 5 secs before closing doc... Office bridge has gone!! I killed Office while the Java program was still running, so it never reached its Lo.closeOffice() call which triggers the XTerminateListener methods. However, the XEventListener attached to the bridge did fire. (If you're wondering, I killed Office by opening the Task manager on my test machine, and stopped the soffice process.) 5. Dispatching \u00b6 This book is about the Java Office API, which manipulates UNO data structures such as services, interfaces, and components. There's an alternative programming style, based on the dispatching of messages to Office. These messages are mostly related to menu items, so, for example, the messages \".uno:Copy\", \".uno:Cut\", \".uno:Paste\", and \".uno:Undo\" duplicate commands in the \"Edit\" menu. The use of messages tends to be most common when writing macros (scripts) in Basic, because Office's built-in Macro recorder automatically converts a user's interaction with menus into dispatches. One drawback of dispatching is that it isn't a complete programming solution. For instance, copying requires the selection of text, which has to be implemented with the Office API. LibreOffice has a comprehensive webpage listing all the dispatch commands ( https://wiki.documentfoundation.org/Development/DispatchCommands ). An older source is the UICommands.ods spreadsheet, put together by Ariel Constenla-Haile in 2010, at https://arielch.fedorapeople.org/devel/ooo/UICommands.ods . Another resource is chapter 10 of \"OpenOffice.org Macros Explained\" by Andrew Pitonyak (free online at https://pitonyak.org/book/ ) Creating a dispatcher in Java is a little complicated since XDispatchProvider and XDispatchHelper instances are needed. XDispatchProvider is obtained from the frame (i.e. window) where the message will be delivered, which is almost always the Desktop's frame (i.e. Office application's window). XDispatchHelper sends the message via its executeDispatch() method. It's also possible to examine the result status in an DispatchResultEvent object, but that seems a bit flakey \u2013 it reports failure when the dispatch works, and raises an exception when the dispatch really fails. The code is wrapped up in Lo.dispatchCmd() , which is called twice in the DispatchTest.java example: public DispatchTest ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 100 ); toggleSlidePane (); Lo . dispatchCmd ( \"HelpIndex\" ); // show online Help Lo . dispatchCmd ( \"Presentation\" ); // start slideshow //Lo.closeDoc(doc); //Lo.closeOffice(); } // end of DispatchTest() The Lo.dispatchCmd() string doesn't require an \".uno\"\" prefix. The first call sends \".uno:HelpIndex\" to open Office's help window, and the second (\".uno:Presentation\") starts an Impress slideshow. This latter message only works if the loaded file is an Impress document. DispatchTest() doesn't close the document or Office at the end, so the user must explicitly exit the slideshow and close the Office application himself by clicking on its close box. 6. Robot Keys \u00b6 Another menu-related approach to controlling Office is to programmatically send menu shortcut key strokes to the currently active window. For example, a loaded Impress document is often displayed with a slide selection pane. This can be closed using the menu item View, Slide Pane, which is assigned the shortcut keys ALT-v ALT-l. toggleSlidePane() 'types' these key strokes with the help of Java's Robot class: // in DispatchTest.java private void toggleSlidePane () // send ALT-v and then ALT-l to foreground window; // makes slide pane appear/disappear in Impress { try { Robot robot = new Robot (); robot . setAutoDelay ( 250 ); robot . keyPress ( KeyEvent . VK_ALT ); robot . keyPress ( KeyEvent . VK_V ); robot . keyRelease ( KeyEvent . VK_V ); robot . keyPress ( KeyEvent . VK_L ); robot . keyRelease ( KeyEvent . VK_L ); robot . keyRelease ( KeyEvent . VK_ALT ); } catch ( AWTException e ) { System . out . println ( \"sendkeys slidePane exception: \" + e ); } } // end of toggleSlidePane() This technique has a few drawbacks \u2013 one is that Robot can only send key strokes to the currently active window on the OS' desktop. I've assumed this is Office, because I just made Office visible with a call to GUI.setVisible() back in the DispatchTest() constructor. Of course, the OS can do whatever it likes, such as suddenly pop up an instant messaging window or a software update alert, which would cause the characters to head to the wrong place. Another problem is that toggleSlidePane() is in the dark about the current state of the GUI. If the slide pane is visible then the keys will make it disappear, but if the pane is not currently on-screen then these keys will bring it up. Also, what if the current GUI isn't the one for Impress? Do these combination of keys do something deadly in one of Office's other applications? One nice feature is that there's lots of documentation on keyboard shortcuts for Office in its User guides (downloadable from https://th.libreoffice.org/get-help/documentation/ ), and these can be easily translated into key presses and releases in Robot.","title":"Chapter 4. Listening, and Other Techniques"},{"location":"04-Listening.html#chapter-4-listening-and-other-techniques","text":"Topics Window Listeners; Office Manipulation with JNA; Dispatching; Robot Keys Example folders: \"Office Tests\" and \"Utils\" This chapter concludes the general introduction to Office programming by looking at several techniques that will reappear periodically in later chapters: the use of window listeners, the manipulation of Office using the JNA library, dispatching messages to the Office GUI, and the Java Robot package. Once again the examples come from the \"Office Tests\" directory in the code download associated with this book, and make liberal use of the classes in the \"Utils\" directory. For details please visit https://fivedots.coe.psu.ac.th/~ad/jlop/ .","title":"Chapter 4. Listening, and Other Techniques"},{"location":"04-Listening.html#1-listening-to-a-window","text":"I haven't previously mentioned Office's listener interfaces (there are about 140 of them), because they work in the same way as listeners in Java. Probably the easiest way of obtaining a list of them all is to visit the LibreOffice documentation for XEventListener (use lodoc XEventListener ). The tree diagram at the top of the page shows that every listener interface is a subclass of XEventListener, and you can click on a subclass box to jump to its documentation. One nice syntactic feature of listeners is that almost all their names end with \u201cListener\u201d. This makes them easy to find when searching through indices of class names, such as the \u201cClass Index\u201d page at https://api.libreoffice.org/docs/idl/ref/classes.html . The top-level document window can be monitored for changes using XTopWindowListener, which responds to modifications of the window\u2019s state, such as when it is opened, closed, minimized, and made active. The DocWindow.java example illustrates how to use the listener: public class DocWindow implements XTopWindowListener { public DocWindow ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( this ); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // various window manipulation code; see below // : Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of DocWindow() // --------- 7 XTopWindowListener methods ----------- public void windowOpened ( EventObject event ) { System . out . println ( \"WL: Opened\" ); XWindow xWin = Lo . qi ( XWindow . class , event . Source ); GUI . printRect ( xWin . getPosSize ()); } // end of windowOpened() public void windowActivated ( EventObject event ) { System . out . println ( \"WL: Activated\" ); System . out . println ( \" Title bar: \\\"\" + GUI . getTitleBar () + \"\\\"\" ); } // end of windowActivated() public void windowMinimized ( EventObject event ) { System . out . println ( \"WL: Minimized\" ); } public void windowNormalized ( EventObject event ) { System . out . println ( \"WL: Normalized\" ); } public void windowDeactivated ( EventObject event ) { System . out . println ( \"WL: De-activated\" ); } public void windowClosing ( EventObject event ) // never called (?) { System . out . println ( \"WL: Closing\" ); } public void windowClosed ( EventObject event ) { System . out . println ( \"WL: Closed\" ); } // --------- XEventListener method ------------ public void disposing ( EventObject event ) // never called (?) { System . out . println ( \"WL: Disposing\" ); } } // end of DocWindow class The class implements seven methods for XTopWindowListener, and disposing() inherited from XEventListener. The DocWindow object is made the listener for the window by accessing the XExtendedToolkit interface, which is part of the Toolkit service. Toolkit is utilized by Office to create windows, and XExtendedToolkit adds three kinds of listeners: XTopWindowListener, XFocusListener, and the XKeyHandler listener. When an event arrives at a listener method, one of the more useful things to do is to transform it into an XWindow instance: XWindow xWin = Lo . qi ( XWindow . class , event . Source ); It's then possible to access details about the frame, such as its size. Events are fired when GUI.setVisible() is called in the DocWindow() constructor. An opened event is issued, followed by an activated event, triggering calls to windowOpened() and windowActivated(). Rather confusingly, both these methods are called twice. When Lo.closeDoc() is called at the end of the constructor, a single de-activated event is fired, but two closed events are issued. Consequently, there's a single call to windowDeactivated() and two to windowClosed(). Strangely, there's no window closing event trigger of windowClosing(), and Lo.closeOffice() doesn't cause disposing() to fire.","title":"1.  Listening to a Window"},{"location":"04-Listening.html#2-office-manipulation-with-jna","text":"Although XTopWindowListener can detect the minimization and re-activation of the document window, there's no way to trigger these changes from the Office API. Fixing this requires a trip outside Office because I need a library that can manipulate a window controlled by the OS. One very nice API that fits my needs is Java Native Access (JNA, https://github.com/twall/jna/ ), which supports OS programming without writing anything but Java. JNA comes with numerous classes, representing OS data structures, such as window handles and process IDs. The JNA-powered methods in my JNAUtils.java utilities class fall roughly into three groups: functions for accessing windows via their handles, methods for accessing buttons inside windows via their handles, and functions that map between handles and process IDs. In the DocWindow.java example, the document window\u2019s handle is retrieved first, then minimization and re-activation methods change the window: // part of DocWindow.java HWND handle = JNAUtils . getHandle (); System . out . println ( \"Handle: \\\"\" + JNAUtils . handleString ( handle ) + \"\\\"\" ); JNAUtils . winMinimize ( handle ); // triggers minimized and de-activated events Lo . delay ( 3000 ); JNAUtils . winRestore ( handle ); // triggers normalized and activated events Lo . delay ( 3000 ); The calls to Lo.delay() slow down the window changes at run time so the user can see what's happening. JNAUtils.getHandle() employs JNA's User32 library function FindWindow(). It finds the handle associated with a specific application window's class name, which is \"SALFRAME\" for both LibreOffice and OpenOffice. JNAUtils.handleString() converts the HWND handle into a hexadecimal string, which prints nicely. JNAUtils.winMinimize() and JNAUtils.winRestore() call User32.ShowWindow() with different state parameters. The JNA User32 class contains many functions related to window manipulation. For example, it's easy to implement window movement and resizing using SetWindowPos(). However, that functionality is already available in Office's XWindow.setPosSize(). Incidentally, it's possible for Office to access a window\u2019s handle as an integer by means of XSystemDependentWindowPeer (e.g. see the code in GUI.getWindowHandle()), but there are no Office methods which utilize this integer. JNA methods require a HWND instance, so the handle needs to be obtained using JNA.","title":"2.  Office Manipulation with JNA"},{"location":"04-Listening.html#3-detecting-office-termination","text":"Office termination is most easily observed by attaching a listener to the Desktop object, as in DocMonitor.java: public class DocMonitor { public DocMonitor ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); XDesktop xDesktop = Lo . getDesktop (); xDesktop . addTerminateListener ( new XTerminateListener () { public void queryTermination ( EventObject e ) throws TerminationVetoException { System . out . println ( \"TL: Starting Closing\" ); } public void notifyTermination ( EventObject e ) { System . out . println ( \"TL: Finished Closing\" ); } public void disposing ( EventObject e ) { System . out . println ( \"TL: Disposing\" ); } }); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); System . out . println ( \"Waiting for 5 secs before closing doc\u2026\" ); Lo . delay ( 5000 ); Lo . closeDoc ( doc ); System . out . println ( \"Waiting for 5 secs before closing Office\u2026\" ); Lo . delay ( 5000 ); Lo . closeOffice (); } // end of DocMonitor() } An XTerminateListener is attached to the XDesktop instance. The program's output is: > run DocMonitor algs.odp Loading Office... Opening algs.odp Waiting for 5 secs before closing doc... Closing the document Waiting for 5 secs before closing Office... Closing Office TL: Starting Closing TL: Finished Closing Office terminated XTerminateListener\u2019s queryTermination() and notifyTermination() are called at the start and end of the Office closing sequence. As in the DocWindow.java example, disposing() is never triggered.","title":"3.  Detecting Office Termination"},{"location":"04-Listening.html#4-bridge-shutdown-detection","text":"There's another way to detect Office closure: by listening for the shutdown of the UNO bridge between the Java and Office processes. This can be useful if Office crashes independently of your Java code. However, I was only able to get this approach to work when using a socket-based link to Office. The modified parts of DocMonitor.java are: // in DocMonitor() XComponentLoader loader = // Lo.loadOffice(); Lo . loadSocketOffice (); : // more code XComponent bridgeComp = Lo . getBridge (); if ( bridgeComp != null ) { System . out . println ( \"Found bridge\" ); bridgeComp . addEventListener ( new XEventListener () { public void disposing ( EventObject e ) { /* remote bridge has gone down, because office crashed or was terminated. */ System . out . println ( \"Office bridge has gone!!\" ); System . exit ( 1 ); } }); } XComponent doc = Lo . openDoc ( fnm , loader ); : // more code Since the disappearance of the Office bridge is a fatal event, disposing() finishes by calling System.exit() to kill Java. The output of the revised DocMonitor.java is: > run DocMonitor algs.odp Loading Office... Office process created Found bridge Opening algs.odp Waiting for 5 secs before closing doc... Closing the document Waiting for 5 secs before closing Office... Closing Office TL: Starting Closing TL: Finished Closing Office terminated Office bridge has gone!! This output shows that bridge closure follows the call to Lo.closeOffice(), as you'd expect. However, if I make Office crash while DocMonitor is running, then the output becomes: > run DocMonitor algs.odp Loading Office... Office process created Found bridge Opening algs.odp Waiting for 5 secs before closing doc... Office bridge has gone!! I killed Office while the Java program was still running, so it never reached its Lo.closeOffice() call which triggers the XTerminateListener methods. However, the XEventListener attached to the bridge did fire. (If you're wondering, I killed Office by opening the Task manager on my test machine, and stopped the soffice process.)","title":"4.  Bridge Shutdown Detection"},{"location":"04-Listening.html#5-dispatching","text":"This book is about the Java Office API, which manipulates UNO data structures such as services, interfaces, and components. There's an alternative programming style, based on the dispatching of messages to Office. These messages are mostly related to menu items, so, for example, the messages \".uno:Copy\", \".uno:Cut\", \".uno:Paste\", and \".uno:Undo\" duplicate commands in the \"Edit\" menu. The use of messages tends to be most common when writing macros (scripts) in Basic, because Office's built-in Macro recorder automatically converts a user's interaction with menus into dispatches. One drawback of dispatching is that it isn't a complete programming solution. For instance, copying requires the selection of text, which has to be implemented with the Office API. LibreOffice has a comprehensive webpage listing all the dispatch commands ( https://wiki.documentfoundation.org/Development/DispatchCommands ). An older source is the UICommands.ods spreadsheet, put together by Ariel Constenla-Haile in 2010, at https://arielch.fedorapeople.org/devel/ooo/UICommands.ods . Another resource is chapter 10 of \"OpenOffice.org Macros Explained\" by Andrew Pitonyak (free online at https://pitonyak.org/book/ ) Creating a dispatcher in Java is a little complicated since XDispatchProvider and XDispatchHelper instances are needed. XDispatchProvider is obtained from the frame (i.e. window) where the message will be delivered, which is almost always the Desktop's frame (i.e. Office application's window). XDispatchHelper sends the message via its executeDispatch() method. It's also possible to examine the result status in an DispatchResultEvent object, but that seems a bit flakey \u2013 it reports failure when the dispatch works, and raises an exception when the dispatch really fails. The code is wrapped up in Lo.dispatchCmd() , which is called twice in the DispatchTest.java example: public DispatchTest ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 100 ); toggleSlidePane (); Lo . dispatchCmd ( \"HelpIndex\" ); // show online Help Lo . dispatchCmd ( \"Presentation\" ); // start slideshow //Lo.closeDoc(doc); //Lo.closeOffice(); } // end of DispatchTest() The Lo.dispatchCmd() string doesn't require an \".uno\"\" prefix. The first call sends \".uno:HelpIndex\" to open Office's help window, and the second (\".uno:Presentation\") starts an Impress slideshow. This latter message only works if the loaded file is an Impress document. DispatchTest() doesn't close the document or Office at the end, so the user must explicitly exit the slideshow and close the Office application himself by clicking on its close box.","title":"5.  Dispatching"},{"location":"04-Listening.html#6-robot-keys","text":"Another menu-related approach to controlling Office is to programmatically send menu shortcut key strokes to the currently active window. For example, a loaded Impress document is often displayed with a slide selection pane. This can be closed using the menu item View, Slide Pane, which is assigned the shortcut keys ALT-v ALT-l. toggleSlidePane() 'types' these key strokes with the help of Java's Robot class: // in DispatchTest.java private void toggleSlidePane () // send ALT-v and then ALT-l to foreground window; // makes slide pane appear/disappear in Impress { try { Robot robot = new Robot (); robot . setAutoDelay ( 250 ); robot . keyPress ( KeyEvent . VK_ALT ); robot . keyPress ( KeyEvent . VK_V ); robot . keyRelease ( KeyEvent . VK_V ); robot . keyPress ( KeyEvent . VK_L ); robot . keyRelease ( KeyEvent . VK_L ); robot . keyRelease ( KeyEvent . VK_ALT ); } catch ( AWTException e ) { System . out . println ( \"sendkeys slidePane exception: \" + e ); } } // end of toggleSlidePane() This technique has a few drawbacks \u2013 one is that Robot can only send key strokes to the currently active window on the OS' desktop. I've assumed this is Office, because I just made Office visible with a call to GUI.setVisible() back in the DispatchTest() constructor. Of course, the OS can do whatever it likes, such as suddenly pop up an instant messaging window or a software update alert, which would cause the characters to head to the wrong place. Another problem is that toggleSlidePane() is in the dark about the current state of the GUI. If the slide pane is visible then the keys will make it disappear, but if the pane is not currently on-screen then these keys will bring it up. Also, what if the current GUI isn't the one for Impress? Do these combination of keys do something deadly in one of Office's other applications? One nice feature is that there's lots of documentation on keyboard shortcuts for Office in its User guides (downloadable from https://th.libreoffice.org/get-help/documentation/ ), and these can be easily translated into key presses and releases in Robot.","title":"6.  Robot Keys"},{"location":"05%20Part%202%20Writer.html","text":"Part 2 Writer \u00b6","title":"Part 2 Writer"},{"location":"05%20Part%202%20Writer.html#part-2-writer","text":"","title":"Part 2 Writer"},{"location":"05-Text_API_Overview.html","text":"Chapter 5. Text API Overview \u00b6 Topics API Overview; Text Cursors; Extracting Text; Cursor Iteration; Creating Cursors; Creating a Document; Using and Comparing Text Cursors; Inserting/Changing Text in a Document; Text Enumeration; Appending Documents Example folders: \"Text Tests\" and \"Utils\" The next few chapters look at programming with the text document part of the Office API. This chapter begins with a quick overview of the text API, then a detailed look at text cursors for moving about in a document, extracting text, and adding/inserting new text. Text cursors aren't the only way to move around inside a document; it's also possible to iterate over a document by treating it as a sequence of paragraphs. The chapter finishes with a look at how two (or more) text documents can be appended. The online Developer's Guide begins text document programming at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Documents/ (the easiest way of accessing that page is to type loguide writer). It corresponds to Chapter 7 in the printed guide (available at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf ), but the Web material is better structured and formatted. The guide's text programming examples are in TextDocuments.java, downloadable from https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text . Although the code is long, it's well-organized. Some smaller text processing examples are available at https://api.libreoffice.org/examples/examples.html#Java_examples . This chapter (and later ones) assume that you're familiar with Writer, including text concepts such as paragraph styles. If you're not, then I recommend the \"Writer Guide\", a user manual, available at https://libreoffice.org/get-help/documentation/ or https://wiki.documentfoundation.org/Documentation/Publications/ . 1. An Overview of the Text Document API \u00b6 The API is centered around four text document services which subclass OfficeDocument, as shown in Figure 1. Figure 1. The Text Document Services. I'll be concentrating on the TextDocument service, which is documented at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1text_1_1TextDocument.html . Or you can type lodoc TextDocument service , which unfortunately takes you to the IDL page for TextDocument; to reach the documentation, click on \"TextDocument\" under the \"Classes\" heading. The GlobalDocument service in Figure 1 is employed by master documents, such as a book or thesis. A master document is typically made up of links to files holding its parts, such as chapters, bibliography, and appendices. The WebDocument service in Figure 1 is for manipulating web pages, although its also possible to generate HTML files with the TextDocument service. TextDocument, GlobalDocument, and WebDocument are mostly empty because those services don't define any interfaces or properties. The GenericTextDocument service is where the action takes place, as summarized in Figure 2. Figure 2. The Text Document Services, and some Interfaces. The numerous 'Supplier' interfaces in Figure 2 are Office's way of accessing different elements in a document. For example, XStyleFamiliesSupplier manages character, paragraph, and other styles, while XTextTableSupplier deals with tables. I'll be looking at these suppliers in later chapters, which is why they're highlighted, but for now let's only consider the XTextDocument interface at the top right of the GenericTextDocument service box in Figure 2 XTextDocument has a getText() method for returning an XText object. XText supports functionality related to text ranges and positions, cursors, and text contents. It inherits XSimpleText and XTextRange, as indicated in Figure 3. Figure 3. XText and its Superclasses. Text content covers a multitude, such as embedded images, tables, footnotes, and text fields. Many of the suppliers shown in Figure 2 (e.g. XTextTablesSupplier) are for iterating through text content (e.g. accessing the document's tables). I'll concentrate on ordinary text in this chapter, and look at more esoteric content forms in Chapters 7 and 8. A text document can utilize eight different cursors, which fall into two groups, as in Figure 4. Figure 4. Types of Cursor. XTextCursor contains methods for moving around the document, and an instance is often called a model cursor because of its close links to the document's data. A program can create multiple XTextCursor objects if it wants, and can convert an XTextCursor into XParagraphCursor, XSentenceCursor, or XWordCursor. The differences are that while an XTextCursor moves through a document character by character, the others travel in units of paragraphs, sentences, and words. A program may employ a single XTextViewCursor cursor, to represent the cursor the user sees in the Writer application window; for this reason, it's often called the view cursor. XTextViewCursor can be converted into a XLineCursor, XPageCursor, or XScreenCursor object, which allows it to move in terms of lines, pages, or screens. A cursor's location is specified using a text range, which can be the currently selected text, or a position in the document. A text position is a text range that begins and ends at the same point. 2. Extracting Text from a Document \u00b6 The ExtractText.java example opens a document using Lo.openOffice(), and tries to print its text: public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: ExtractText fnm\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } if ( Info . isDocType ( doc , Lo . WRITER_SERVICE )) { XTextDocument textDoc = Write . getTextDoc ( doc ); XTextCursor cursor = Write . getCursor ( textDoc ); String text = Write . getAllText ( cursor ); System . out . println ( \"--------- Text Content --------\" ); System . out . println ( text ); System . out . println ( \"-------------------------------\" ); } else System . out . println ( \"Extraction unsupported for this doc type\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Info.isDocType() tests the document's type by casting it into an XServiceInfo interface. Then it calls XServiceInfo.supportsService() to check the document's service capabilities: public static boolean isDocType ( Object doc , String docType ) // in the Info utility class { XServiceInfo si = Lo . qi ( XServiceInfo . class , doc ); return si . supportsService ( docType ); } The argument type of the document is Object rather than XComponent so that a wider range of objects can be passed to the function for testing. The service names for documents are hard to remember, so they're defined as constants in my Lo class: // in the Lo class public static final String WRITER_SERVICE = \"com.sun.star.text.TextDocument\" ; public static final String BASE_SERVICE = \"com.sun.star.sdb.OfficeDatabaseDocument\" ; public static final String CALC_SERVICE = \"com.sun.star.sheet.SpreadsheetDocument\" ; public static final String DRAW_SERVICE = \"com.sun.star.drawing.DrawingDocument\" ; public static final String IMPRESS_SERVICE = \"com.sun.star.presentation.PresentationDocument\" ; public static final String MATH_SERVICE = \"com.sun.star.formula.FormulaProperties\" ; Write.getTextDoc() uses Lo.qi() to cast the document's XComponent interface into an XTextDocument: // in the Lo class public static final String WRITER_SERVICE = \"com.sun.star.text.TextDocument\" ; public static final String BASE_SERVICE = \"com.sun.star.sdb.OfficeDatabaseDocument\" ; public static final String CALC_SERVICE = \"com.sun.star.sheet.SpreadsheetDocument\" ; public static final String DRAW_SERVICE = \"com.sun.star.drawing.DrawingDocument\" ; public static final String IMPRESS_SERVICE = \"com.sun.star.presentation.PresentationDocument\" ; public static final String MATH_SERVICE = \"com.sun.star.formula.FormulaProperties\" ; TextDocument textDoc = Lo.qi(XTextDocument.class, doc); This may fail (i.e. return null) if the loaded document isn't an instance of the TextDocument service. The casting 'power' of Lo.qi() is confusing \u2013 it depends on the document's service type. All text documents are instances of the TextDocument service (see Figure 2). This means that Lo.qi() can 'switch' between any of the interfaces defined by TextDocument or its superclasses (i.e. the interfaces in GenericTextDocument or OfficeDocument). For instance, the following cast is fine: XStyleFamiliesSupplier xSupplier = Lo . qi ( XStyleFamiliesSupplier . class , doc ); This changes the instance into an XStyleFamiliesSupplier, which can access the document's styles. Alternatively, the following converts the instance into a supplier defined in OfficeDocument: XDocumentPropertiesSupplier xSupplier = Lo . qi ( XDocumentPropertiesSupplier . class , doc ); Most of the examples in this chapter and the next few cast the document to XTextDocument since that interface can access the document's contents as an XText object: XTextDocument textDoc = Lo . qi ( XTextDocument . class , doc ); XText xText = textDoc . getText (); The XText instance can access all the capabilities shown in Figure 3. A common next step is to create a cursor for moving around the document. This is easy since XText inherits XSimpleText which has a createTextCursor() method: XTextCursor textCursor = xText . createTextCursor (); These few lines are so useful that I've put them inside a Write.getCursor() method: public static XTextCursor getCursor ( XTextDocument textDoc ) // get cursor from a text document { XText xText = textDoc . getText (); if ( xText == null ) { System . out . println ( \"Text not found in document\" ); return null ; } else return xText . createTextCursor (); } // end of getCursor() An XTextCursor can be converted into other kinds of model cursors (e.g. XParagraphCursor, XSentenceCursor, XWordCursor; see Figure 4). That's not necessary in for the ExtractText.java example; instead, the XTextCursor is passed to Write.getAllText() to access the text as a sequence of characters: public static String getAllText ( XTextCursor cursor ) { cursor . gotoStart ( false ); cursor . gotoEnd ( true ); String text = cursor . getString (); cursor . gotoEnd ( false ); // to deselect everything in the doc return text ; } // end of getAllText() All cursor movement operations take a boolean argument which specifies whether the movement should also select the text. For example, in getAllText(), cursor.gotoStart(false) shifts the cursor to the start of the text without selecting anything. The subsequent call to cursor.gotoEnd(true) moves the cursor to the end of the text and selects all the text moved over. The call to getString() on the third line returns the selection (i.e. all the text in the document). Two other useful XTextCursor methods are: boolean goLeft ( short charCount , boolean isSelected ) boolean goRight ( short charCount , boolean isSelected ) They move the cursor left or right by a given number of characters, and the boolean argument specifies whether the text moved over is selected. All cursor methods return a boolean result which indicates if the move (and optional selection) was successful. Another method worth knowing is: boolean gotoRange ( XTextRange textRange , boolean isSelected ) gotoRange() takes an XTextRange argument, which represents a selected region or position where the cursor should be moved to. For example, it's possible to find a bookmark in a document, extract its text range/position, and move the cursor to that location with gotoRange(). I'll show code for doing this in Chapter 7. The XTextCursor methods are documented at https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1text_1_1XTextCursor.html (or type lodoc XTextCursor ). A Problem with Write.getAllText() \u00b6 Write.getAllText() may fail if supplied with a very large document because XTextCursor.getString() might be unable to construct a big enough String object. For that reason, it's better to iterate over large documents returning a paragraph of text at a time. These iteration techniques are described next. 3. Cursor Iteration \u00b6 My HighlightText.java example uses paragraph and word cursors (i.e. the XParagraphCursor and XWordCursor interfaces in Figure 4). It also employs the view cursor, an XTextViewCursor instance, to control the Writer application's visible cursor. The main () function of HighlightText : public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run HighlightText <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // make doc visible on-screen showParagraphs ( doc ); System . out . println ( \"Word count: \" + countWords ( doc )); showLines ( doc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() main() calls Write.openDoc() to return the opened document as an XTextDocument instance. If you recall, the previous ExtractText.java example started with an XComponent instance by calling Lo.openDoc(), and then converted it to XTextDocument. Write.openDoc() returns the XTextDocument reference in one go. showParagraphs() moves the visible on-screen cursor through the document, highlighting a paragraph at a time. This requires two cursors \u2013 an instance of XTextViewCursor and a separate XParagraphCursor. The paragraph cursor is capable of moving through the document paragraph-by-paragraph, but it's a model cursor, so invisible to the user looking at the document on-screen. showParagraphs() extracts the start and end positions of each paragraph and uses them to move the view cursor, which is visible. The code for showParagraphs(): private static void showParagraphs ( XTextDocument doc ) { XTextViewCursor tvc = Write . getViewCursor ( doc ); XParagraphCursor paraCursor = Write . getParagraphCursor ( doc ); paraCursor . gotoStart ( false ); // go to start of text; no selection do { paraCursor . gotoEndOfParagraph ( true ); // select 1 paragraph String currPara = paraCursor . getString (); if ( currPara . length () > 0 ) { // move view cursor to highlight current paragraph tvc . gotoRange ( paraCursor . getStart (), false ); tvc . gotoRange ( paraCursor . getEnd (), true ); Lo . wait ( 500 ); // slow down paragraph changing speed } } while ( paraCursor . gotoNextParagraph ( false )); } // end of showParagraphs() The code utilizes two Write utility functions (Write.getViewCursor() and Write.getParagraphCursor()) to create the cursors. The subsequent do-while loop is a common coding pattern for iterating over a text document: paraCursor . gotoStart ( false ); do { paraCursor . gotoEndOfParagraph ( true ); // select 1 paragraph // do something to the selected text range... } while ( paraCursor . gotoNextParagraph ( false )); gotoNextParagraph() tries to move the cursor to the beginning of the next paragraph. If the moves fails (i.e. when the cursor has reached the end of the document), the function returns false, and the loop terminates. The call to gotoEndOfParagraph() at the beginning of the loop moves the cursor to the end of the paragraph and selects its text. Since the cursor was originally at the start of the paragraph, the selection will span that paragraph. XParagraphCursor and the sentence and word cursors inherit XTextCursor, as shown in Figure 5. Figure 5. The Model Cursors Inheritance Hierarchy. Since all these cursors also inherit XTextRange, they can easily access and change their text selections/positions. In the showParagraphs() method above, the two ends of the paragraph are obtained by calling the inherited XTextRange.getStart() and XTextRange.getEnd(), and the positions are used to move the view cursor: XTextViewCursor tvc = Write . getViewCursor ( doc ); : tvc . gotoRange ( paraCursor . getStart (), false ); tvc . gotoRange ( paraCursor . getEnd (), true ); gotoRange() sets the text range/position of the view cursor: the first call moves the cursor to the paragraph's starting position without selecting anything, and the second moves it to the end position, selecting all the text in between. Since this is a view cursor, the selection is visible on-screen, as illustrated in Figure 6. Figure 6. A Selected Paragraph. Note that getStart() and getEnd() do not return integers but collapsed text ranges, which is Office-lingo for a range that starts and ends at the same cursor position. Somewhat confusingly, the XTextViewCursor interface inherits XTextCursor (as shown in Figure 7). This only means that XTextViewCursor supports the same character-based movement and text range operations as the model-based cursor. Figure 7. The XTextViewCursor Inheritance Hierarchy. 4. Creating Cursors \u00b6 An XTextCursor is created by calling Write.getCursor(), which can then be converted into a paragraph, sentence, or word cursor by using Lo.qi(). For example, the Write utility class defines getParagraphCursor() as: public static XParagraphCursor getParagraphCursor ( XTextDocument textDoc ) { XTextCursor cursor = getCursor ( textDoc ); if ( cursor == null ) { System . out . println ( \"Text cursor is null\" ); return null ; } else return Lo . qi ( XParagraphCursor . class , cursor ); } // end of getParagraphCursor() Obtaining the view cursor is a little more tricky since it's only accessible via the document's controller. As described in Chapter 1, section 5 about the FCM relationship, the controller is reached via the document's model, as shown in the first two lines of Write.getViewCursor(): public static XTextViewCursor getViewCursor ( XTextDocument textDoc ) { XModel model = Lo . qi ( XModel . class , textDoc ); XController xController = model . getCurrentController (); // the controller supplies the TextViewCursor XTextViewCursorSupplier supplier = Lo . qi ( XTextViewCursorSupplier . class , xController ); return supplier . getViewCursor (); } // end of getViewCursor() The view cursor isn't directly accessible from the controller; a supplier must be queried, even though there's only one view cursor per document. 4.1. Counting Words \u00b6 countWords() in HightlightText.java shows how to iterate over the document using a word cursor: private static int countWords ( XTextDocument doc ) { XWordCursor wordCursor = Write . getWordCursor ( doc ); wordCursor . gotoStart ( false ); // go to start of text int wordCount = 0 ; String currWord ; do { wordCursor . gotoEndOfWord ( true ); currWord = wordCursor . getString (); if ( currWord . length () > 0 ) wordCount ++ ; } while ( wordCursor . gotoNextWord ( false )); return wordCount ; } // end of countWords() This uses the same kind of do-while loop as showParagraphs() except that the XTextWordCursor methods gotoEndOfWord() and gotoNextWord() control the iteration. Also, there's no need for an XTextViewCursor instance since the selected words aren't shown on the screen. 4.2. Displaying Lines \u00b6 showLines() in HightlightText.java iterates over the document highlighting a line at a time. Don't confuse this with sentence selection because a sentence may consist of several lines on the screen. A sentence is part of the text's organization (i.e. in terms of words, sentences, and paragraphs) while a line is part of the document view (i.e. line, page, screen). This means that XLineCursor is a view cursor, which is obtained by converting XTextViewCursor with Lo.qi(): XTextViewCursor tvc = Write . getViewCursor ( doc ); XLineCursor lineCursor = Lo . qi ( XLineCursor . class , tvc ); The line cursor has limited functionality compared to the model cursors (paragraph, sentence, word). In particular, there's no \"next' function for moving to the next line (unlike gotoNextParagraph() or gotoNextWord()). The screen cursor also lacks this ability, but the page cursor offers jumpToNextPage(). One way of getting around the absence of a 'next' operation is shown in showLines(): private static void showLines ( XTextDocument doc ) { XTextViewCursor tvc = Write . getViewCursor ( doc ); tvc . gotoStart ( false ); // go to start of text XLineCursor lineCursor = Lo . qi ( XLineCursor . class , tvc ); boolean haveText = true ; do { lineCursor . gotoStartOfLine ( false ); lineCursor . gotoEndOfLine ( true ); // select 1 line Lo . wait ( 500 ); // slow down the line changing speed tvc . collapseToEnd (); // make selection disappear haveText = tvc . goRight (( short ) 1 , true ); // move 1 char } while ( haveText ); } // end of showLines() The view cursor is manipulated using the XTextViewCursor object and the XLineCursor line cursor. This is possible since the two references point to the same on-screen cursor. Either one can move it around the display. Inside the loop, XLineCursor's gotoStartOfLine() and gotoEndOfLine() highlight a single line. Then the XTextViewCursor instance deselects the line, by moving the cursor to the end of the selection with collapseToEnd(). At the end of the loop, goRight() tries to move the cursor one character to the right. If goRight() succeeds then the cursor is shifted one position to the first character of the next line. When the loop repeats, this line will be selected. If doRight() fails, then there are no more characters to be read from the document, and the loop finishes. 5. Creating a Document \u00b6 All the examples so far have involved the manipulation of an existing document. The HelloText.java example creates a new text document, containing two short paragraphs, and saves it as \"hello.odt\". The main() function is: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // make the document visible XTextCursor cursor = Write . getCursor ( doc ); cursor . gotoEnd ( false ); // move cursor to end of doc before appending Write . appendPara ( cursor , \"Hello LibreOffice.\\n\" ); Lo . wait ( 1000 ); // slow things down so they can be seen Write . appendPara ( cursor , \"How are you?.\" ); Lo . wait ( 2000 ); Lo . saveDoc ( doc , \"hello.odt\" ); // or use extension doc, docx, rtf, pdf, txt Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Write.createDoc() calls Lo.createDoc() with the text document service name (the Lo.WRITER_STR constant is \"swriter\"). Office creates a TextDocument service with an XComponent interface, which is cast to the XTextDocument interface, and returned: // in the Write class public static XTextDocument createDoc ( XComponentLoader loader ) { XComponent doc = Lo . createDoc ( Lo . WRITER_STR , loader ); return Lo . qi ( XTextDocument . class , doc ); } Text documents are saved using Lo.saveDoc() which was described in Chapter 2. saveDoc() examines the filename's extension to determine its type. The known extensions include doc, docx, rtf, odt, pdf, and txt. Back in HelloText.java, a cursor is needed before text can be added; one is created by calling Write.getCursor(). The call to XTextCursor.gotoEnd() isn't really necessary because the new cursor is pointing to an empty document so is already at its end. It's included to emphasize the assumption by Write.appendPara() (and other Write.appendXXX() functions) that the cursor is positioned at the end of the document before new text is added. Write.appendPara() calls three other methods in the Write utility class: // in the Write class public static int appendPara ( XTextCursor cursor , String text ) { append ( cursor , text ); append ( cursor , ControlCharacter . PARAGRAPH_BREAK ); return getPosition ( cursor ); } The 'append' name is utilized several times in Write \u2013 one version takes a string as its second argument, the other a short representing a control character: // in the Write class public static int append ( XTextCursor cursor , String text ) { cursor . setString ( text ); cursor . gotoEnd ( false ); return getPosition ( cursor ); } // end of append() public static int append ( XTextCursor cursor , short ctrlChar ) { XText xText = cursor . getText (); xText . insertControlCharacter ( cursor , ctrlChar , false ); cursor . gotoEnd ( false ); return getPosition ( cursor ); } The first append() function uses XTextCursor.setString() to add the user-supplied string. The second function employs XTextCursor.insertControlCharacter(). After the addition of the text or character, the cursor is moved to the end of the document, and getPosition() is called to return the cursor's new position as an integer: public static int getPosition ( XTextCursor cursor ) { return ( cursor . getText (). getString ()). length (); } getPosition() is not very robust \u2013 it assumes that getString() will be able to convert the document's text into a string. This may fail if the document is very big (you may recall the same problem with my Write.getAllText() described earlier). Office deals with this size issue by using XTextRange instances, which encapsulate text ranges and positions. Write.getPosition() returns an integer because its easier to understand when you're first learning to program with Office. It's better style to use and compare XTextRanges rather than integer positions, an approach I'll demonstrate in the next section. 6. Using and Comparing Text Cursors \u00b6 My TalkingBook.java example utilizes the third-party library FreeTTS ( https://freetts.sourceforge.net/ ) to convert text into speech. The inner workings of FreeTTS aren't relevant here, so are hidden inside a support class called Speaker. It has three public methods: Speaker(): instantiates a FreeTTS instance \u2013 a male voice say(String s): converts the string s into speech dispose(): closes down the FreeTTS instance TalkingBook employs two text cursors: a paragraph cursor that iterates over the paragraphs in the document, and a sentence cursor that iterates over all the sentences in the current paragraph and passes each sentence to Speaker.say(). FreeTTS is capable of speaking long or short sequences of text, but TalkingBook processes a sentence at a time since this sounds more natural when spoken. The crucial function in TalkingBook.java is speakSentences(): private static void speakSentences ( XTextDocument doc ) { Speaker speaker = new Speaker (); // create FreeTTS voice XTextViewCursor tvc = Write . getViewCursor ( doc ); XParagraphCursor paraCursor = Write . getParagraphCursor ( doc ); paraCursor . gotoStart ( false ); // go to start of text // create range comparer for the entire document XTextRangeCompare comparer = Lo . qi ( XTextRangeCompare . class , doc . getText ()); String currParaStr , currSentStr ; do { paraCursor . gotoEndOfParagraph ( true ); // select 1 paragraph XTextRange endPara = paraCursor . getEnd (); currParaStr = paraCursor . getString (); if ( currParaStr . length () > 0 ) { // set sentence cursor to start of paragraph XTextCursor cursor = paraCursor . getText (). createTextCursorByRange ( paraCursor . getStart ()); XSentenceCursor sc = Lo . qi ( XSentenceCursor . class , cursor ); sc . gotoStartOfSentence ( false ); // goto start do { sc . gotoEndOfSentence ( true ); // select 1 sentence if ( comparer . compareRegionEnds ( endPara , sc . getEnd ()) > 0 ) // has sentence cursor passed end of current paragraph? break ; // move view cursor to highlight current sentence tvc . gotoRange ( sc . getStart (), false ); tvc . gotoRange ( sc . getEnd (), true ); currSentStr = stripNonWordChars ( sc . getString ()); // clean up string to make speech nicer if ( currSentStr . length () > 0 ) speaker . say ( currSentStr ); } while ( sc . gotoNextSentence ( false )); } } while ( paraCursor . gotoNextParagraph ( false )); speaker . dispose (); } // end of speakSentences() speakSentences() comprises two nested loops: the outer loop iterates through the paragraphs, and the inner loop through the sentences in the current paragraph. The sentence cursor is created like so: XTextCursor cursor = paraCursor . getText (). createTextCursorByRange ( paraCursor . getStart ()); XSentenceCursor sc = Lo . qi ( XSentenceCursor . class , cursor ); The XText reference is returned by paraCursor.getText(), and a text cursor is created. createTextCursorByRange() allows the start position of the cursor to be specified. The text cursor is converted into a sentence cursor with Lo.qi(). The tricky aspect of this code is the meaning of paraCursor.getText() which is the XText object that paraCursor utilizes. This is not a single paragraph but the entire text document. Remember that the paragraph cursor is created with: XParagraphCursor paraCursor = Write.getParagraphCursor(doc); This corresponds to: XText xText = doc.getText(); XTextCursor textCursor = xText.createTextCursor(); XParagraphCursor paraCursor = Lo.qi( XParagraphCursor.class, textCursor); Both the paragraph and sentence cursors refer to the entire text document. This means that I cannot code the inner loop using the coding pattern from before. That would result in something like the following: // set sentence cursor to point to start of this paragraph XTextCursor cursor = paraCursor . getText (). createTextCursorByRange ( paraCursor . getStart ()) XSentenceCursor sc = Lo . qi ( XSentenceCursor . class , cursor ); sc . gotoStartOfSentence ( false ); // goto start do { sc . gotoEndOfSentence ( true ); // select 1 sentence // do something with the sentence // : } while ( sc . gotoNextSentence ( false )); Note To further confuse matters, a XText object does not always correspond to the entire text document. For example, a text frame (e.g. like this one) can return an XText object for the text only inside the frame. The problem with the above code fragment is that XSentenceCursor.gotoNextSentence() will keep moving to the next sentence until it reaches the end of the text document. This is not the desired behavior \u2013 what I want is for the loop to terminate when the last sentence of the current paragraph has been processed. We need to compare text ranges, in this case the end of the current sentence with the end of the current paragraph. This capability is handled by the XTextRangeCompare interface. A comparer object is created at the beginning of speakSentence(), initialized to compare ranges that can span the entire document: XTextRangeCompare comparer = Lo . qi ( XTextRangeCompare . class , doc . getText ()); This comparer object is utilized inside the sentence-iterating loop to compare the end of the current paragraph (the endPara text range) with the end of current sentence (the sc.getEnd() text range): if ( comparer . compareRegionEnds ( endPara , sc . getEnd ()) > 0 ) break ; If the sentence ends after the end of the paragraph then compareRegionEnds() returns a positive number, and the inner loop terminates. This approach doesn't suffer from the problem in Write.getPosition() with XTextRange.getString(), and using its length as a position: public static int getPosition ( XTextCursor cursor ) { return ( cursor . getText (). getString ()). length (); Since there's no String object being created by the comparer, there's no way that the instantiation can fail due to the size of the text. 7. Inserting/Changing Text in a Document \u00b6 My ShuffleWords.java example searches a document and changes the words it encounters. Figure 8 shows the program in progress: \"predominates\" has been selected but not yet changed, but all the previous 'big' words have been shuffled. Figure 8. Shuffling of Words. A word shuffle is applied to every word of four letters or more, but only involves the random exchange of the middle letters without changing the first and last characters. The applyShuffle() function which iterates through the words in the input file is similar to countWords() in HighlightText.java. One difference is the use of XText.insertString(): private static void applyShuffle ( XTextDocument doc ) { XText docText = doc . getText (); XWordCursor wordCursor = Write . getWordCursor ( doc ); wordCursor . gotoStart ( false ); // go to start of text XTextViewCursor tvc = Write . getViewCursor ( doc ); String currWord ; do { wordCursor . gotoEndOfWord ( true ); // move the text view cursor, and highlight the current word tvc . gotoRange ( wordCursor . getStart (), false ); tvc . gotoRange ( wordCursor . getEnd (), true ); currWord = wordCursor . getString (). trim (); if ( currWord . length () > 0 ) { Lo . wait ( 250 ); // slow down so user can see selection before change docText . insertString ( wordCursor , midShuffle ( currWord ), true ); } } while ( wordCursor . gotoNextWord ( false )); } // end of applyShuffle() insertString() is located in XSimpleText: void insertString ( XTextRange xRange , String s , boolean willReplace ) The string s is inserted at the cursor's text range position. If willReplace is true then the string replaces the current selection (which is the case in applyShuffle()). midShuffle() shuffles the string in currWord, returning a new word. It doesn't use the Office API, so I won't explain it here. 8. Treating a Document as Paragraphs and Text Portions \u00b6 Another approach for moving around a document involves the XEnumerationAccess interface which treats the document as a series of Paragraph text contents. XEnumerationAccess is an interface in the Text service, which means that an XText reference can be converted into it by using Lo.qi(). These relationships are shown in Figure 9. Figure 9. The Text Service and its Interfaces. The following code fragment utilizes this technique: XText xText = doc . getText (); // get text of document XEnumerationAccess enumAccess = Lo . qi ( XEnumerationAccess . class , xText ); XEnumerationAccess contains a single method, createEnumeration() which creates an enumerator (an instance of XEnumeration). Each element returned from this iterator is a Paragraph text content: // create enumerator over the document text XEnumeration textEnum = enumAccess . createEnumeration (); while ( textEnum . hasMoreElements ()) { // loop through paragraphs XTextContent textCon = Lo . qi ( XTextContent . class , textEnum . nextElement ()); // use the Paragraph text content (textCon) in some way... } Paragraph doesn't support its own interface (i.e. there's no XParagraph), so I've used Lo.qi() to access its XTextContent interface, which belongs to the TextContent subclass. The hierarchy is shown in Figure 10. Figure 10. The Paragraph Text Content Hierarchy. Iterating over a document to access Paragraph text contents doesn't seem much different from iterating over a document using a paragraph cursor, except that the Paragraph service offers a more structured view of a paragraph. In particular, you can use another XEnumerationAccess instance to iterate over a single paragraph, viewing it as a sequence of text portions. The following code illustrates the notion, using the textCon text content from the previous piece of code: if ( ! Info . supportService ( textCon , \"com.sun.star.text.TextTable\" )) { // create enumerator over a paragraph XEnumerationAccess enumAccess = Lo . qi ( XEnumerationAccess . class , textCon ); XEnumeration paraEnum = enumAccess . createEnumeration (); while ( paraEnum . hasMoreElements ()) { // loop through portions XTextRange txtRange = Lo . qi ( XTextRange . class , paraEnum . nextElement ()); // use the text portion (txtRange) in some way... } } The TextTable service is a subclass of Paragraph, and cannot be enumerated. Therefore, I surrounded the paragraph enumerator with an if-test to skip a paragraph if it's really a table. The paragraph enumerator returns text portions, represented by the TextPortion service. TextPortion contains a lot of useful properties which describe the paragraph, but it doesn't have its own interface (such as XTextPortion). However, TextPortion inherits the TextRange service, so I can use Lo.qi() to obtain its XTextRange interface. This hierarchy is shown in Figure 11. Figure 11. The TextPortion Service Hierarchy. TextPortion includes a \"TextPortionType\" property which identifies the type of the portion. Other properties access different kinds of portion data, such as a text field or footnote. For instance, the following prints the text portion type and the string inside the txtRange text portion (txtRange comes from the previous code fragment): System . out . println ( \" \" + Props . getProperty ( txtRange , \"TextPortionType\" ) + \" = \\\"\" + txtRange . getString () + \"\\\"\" ); These code fragments are combined together in my ShowBookText.java example. More details on enumerators and text portions are given in the Developers Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Iterating_over_Text/ (or use loGuide \"Iterating over Text\" ). 9. Appending Documents Together \u00b6 If you need to write a large multi-part document (e.g. a thesis with chapters, appendices, contents page, and an index) then you should utilize a master document, which acts as a repository of links to documents representing the component parts. You can find out about master documents in Chapter 13 of the Writers Guide, at https://wiki.documentfoundation.org/Documentation/Publications/ . However, the complexity of master documents isn't always needed. Often the aim is simply to append one document to the end of another. In that case, the XDocumentInsertable interface, and its insertDocumentFromURL() method is more suitable. My DocsAppend.java example uses XDocumentInsertable.insertDocumentFromURL(). A list of filenames is read from the command line; the first file is opened, and the other files appended to it by appendTextFiles(): // part of DocsAppend.java private static void appendTextFiles ( XTextDocument doc , String [] args ) { XTextCursor cursor = Write . getCursor ( doc ); for ( int i = 1 ; i < args . length ; i ++ ) { /* start at 1 to skip the first file, which has been opened as doc */ try { cursor . gotoEnd ( false ); // Write.pageBreak(cursor); System . out . println ( \"Appending \" + args [ i ] ); XDocumentInsertable inserter = Lo . qi ( XDocumentInsertable . class , cursor ); if ( inserter == null ) System . out . println ( \"Inserter could not be created\" ); else inserter . insertDocumentFromURL ( FileIO . fnmToURL ( args [ i ] ), new PropertyValue [ 0 ] ); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not append \" + args [ i ] + \": \" + e ); } } } // end of appendTextFiles() An XDocumentInsertable instance is obtained by converting the text cursor with UnoRuntime.queryInterface(). XDocumentInsertable.insertDocumentFromURL() requires two arguments \u2013 the URL of the file that's being appended, and an empty property value array.","title":"Chapter 5. Text API Overview"},{"location":"05-Text_API_Overview.html#chapter-5-text-api-overview","text":"Topics API Overview; Text Cursors; Extracting Text; Cursor Iteration; Creating Cursors; Creating a Document; Using and Comparing Text Cursors; Inserting/Changing Text in a Document; Text Enumeration; Appending Documents Example folders: \"Text Tests\" and \"Utils\" The next few chapters look at programming with the text document part of the Office API. This chapter begins with a quick overview of the text API, then a detailed look at text cursors for moving about in a document, extracting text, and adding/inserting new text. Text cursors aren't the only way to move around inside a document; it's also possible to iterate over a document by treating it as a sequence of paragraphs. The chapter finishes with a look at how two (or more) text documents can be appended. The online Developer's Guide begins text document programming at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Documents/ (the easiest way of accessing that page is to type loguide writer). It corresponds to Chapter 7 in the printed guide (available at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf ), but the Web material is better structured and formatted. The guide's text programming examples are in TextDocuments.java, downloadable from https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text . Although the code is long, it's well-organized. Some smaller text processing examples are available at https://api.libreoffice.org/examples/examples.html#Java_examples . This chapter (and later ones) assume that you're familiar with Writer, including text concepts such as paragraph styles. If you're not, then I recommend the \"Writer Guide\", a user manual, available at https://libreoffice.org/get-help/documentation/ or https://wiki.documentfoundation.org/Documentation/Publications/ .","title":"Chapter 5. Text API Overview"},{"location":"05-Text_API_Overview.html#1-an-overview-of-the-text-document-api","text":"The API is centered around four text document services which subclass OfficeDocument, as shown in Figure 1. Figure 1. The Text Document Services. I'll be concentrating on the TextDocument service, which is documented at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1text_1_1TextDocument.html . Or you can type lodoc TextDocument service , which unfortunately takes you to the IDL page for TextDocument; to reach the documentation, click on \"TextDocument\" under the \"Classes\" heading. The GlobalDocument service in Figure 1 is employed by master documents, such as a book or thesis. A master document is typically made up of links to files holding its parts, such as chapters, bibliography, and appendices. The WebDocument service in Figure 1 is for manipulating web pages, although its also possible to generate HTML files with the TextDocument service. TextDocument, GlobalDocument, and WebDocument are mostly empty because those services don't define any interfaces or properties. The GenericTextDocument service is where the action takes place, as summarized in Figure 2. Figure 2. The Text Document Services, and some Interfaces. The numerous 'Supplier' interfaces in Figure 2 are Office's way of accessing different elements in a document. For example, XStyleFamiliesSupplier manages character, paragraph, and other styles, while XTextTableSupplier deals with tables. I'll be looking at these suppliers in later chapters, which is why they're highlighted, but for now let's only consider the XTextDocument interface at the top right of the GenericTextDocument service box in Figure 2 XTextDocument has a getText() method for returning an XText object. XText supports functionality related to text ranges and positions, cursors, and text contents. It inherits XSimpleText and XTextRange, as indicated in Figure 3. Figure 3. XText and its Superclasses. Text content covers a multitude, such as embedded images, tables, footnotes, and text fields. Many of the suppliers shown in Figure 2 (e.g. XTextTablesSupplier) are for iterating through text content (e.g. accessing the document's tables). I'll concentrate on ordinary text in this chapter, and look at more esoteric content forms in Chapters 7 and 8. A text document can utilize eight different cursors, which fall into two groups, as in Figure 4. Figure 4. Types of Cursor. XTextCursor contains methods for moving around the document, and an instance is often called a model cursor because of its close links to the document's data. A program can create multiple XTextCursor objects if it wants, and can convert an XTextCursor into XParagraphCursor, XSentenceCursor, or XWordCursor. The differences are that while an XTextCursor moves through a document character by character, the others travel in units of paragraphs, sentences, and words. A program may employ a single XTextViewCursor cursor, to represent the cursor the user sees in the Writer application window; for this reason, it's often called the view cursor. XTextViewCursor can be converted into a XLineCursor, XPageCursor, or XScreenCursor object, which allows it to move in terms of lines, pages, or screens. A cursor's location is specified using a text range, which can be the currently selected text, or a position in the document. A text position is a text range that begins and ends at the same point.","title":"1.  An Overview of the Text Document API"},{"location":"05-Text_API_Overview.html#2-extracting-text-from-a-document","text":"The ExtractText.java example opens a document using Lo.openOffice(), and tries to print its text: public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: ExtractText fnm\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } if ( Info . isDocType ( doc , Lo . WRITER_SERVICE )) { XTextDocument textDoc = Write . getTextDoc ( doc ); XTextCursor cursor = Write . getCursor ( textDoc ); String text = Write . getAllText ( cursor ); System . out . println ( \"--------- Text Content --------\" ); System . out . println ( text ); System . out . println ( \"-------------------------------\" ); } else System . out . println ( \"Extraction unsupported for this doc type\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Info.isDocType() tests the document's type by casting it into an XServiceInfo interface. Then it calls XServiceInfo.supportsService() to check the document's service capabilities: public static boolean isDocType ( Object doc , String docType ) // in the Info utility class { XServiceInfo si = Lo . qi ( XServiceInfo . class , doc ); return si . supportsService ( docType ); } The argument type of the document is Object rather than XComponent so that a wider range of objects can be passed to the function for testing. The service names for documents are hard to remember, so they're defined as constants in my Lo class: // in the Lo class public static final String WRITER_SERVICE = \"com.sun.star.text.TextDocument\" ; public static final String BASE_SERVICE = \"com.sun.star.sdb.OfficeDatabaseDocument\" ; public static final String CALC_SERVICE = \"com.sun.star.sheet.SpreadsheetDocument\" ; public static final String DRAW_SERVICE = \"com.sun.star.drawing.DrawingDocument\" ; public static final String IMPRESS_SERVICE = \"com.sun.star.presentation.PresentationDocument\" ; public static final String MATH_SERVICE = \"com.sun.star.formula.FormulaProperties\" ; Write.getTextDoc() uses Lo.qi() to cast the document's XComponent interface into an XTextDocument: // in the Lo class public static final String WRITER_SERVICE = \"com.sun.star.text.TextDocument\" ; public static final String BASE_SERVICE = \"com.sun.star.sdb.OfficeDatabaseDocument\" ; public static final String CALC_SERVICE = \"com.sun.star.sheet.SpreadsheetDocument\" ; public static final String DRAW_SERVICE = \"com.sun.star.drawing.DrawingDocument\" ; public static final String IMPRESS_SERVICE = \"com.sun.star.presentation.PresentationDocument\" ; public static final String MATH_SERVICE = \"com.sun.star.formula.FormulaProperties\" ; TextDocument textDoc = Lo.qi(XTextDocument.class, doc); This may fail (i.e. return null) if the loaded document isn't an instance of the TextDocument service. The casting 'power' of Lo.qi() is confusing \u2013 it depends on the document's service type. All text documents are instances of the TextDocument service (see Figure 2). This means that Lo.qi() can 'switch' between any of the interfaces defined by TextDocument or its superclasses (i.e. the interfaces in GenericTextDocument or OfficeDocument). For instance, the following cast is fine: XStyleFamiliesSupplier xSupplier = Lo . qi ( XStyleFamiliesSupplier . class , doc ); This changes the instance into an XStyleFamiliesSupplier, which can access the document's styles. Alternatively, the following converts the instance into a supplier defined in OfficeDocument: XDocumentPropertiesSupplier xSupplier = Lo . qi ( XDocumentPropertiesSupplier . class , doc ); Most of the examples in this chapter and the next few cast the document to XTextDocument since that interface can access the document's contents as an XText object: XTextDocument textDoc = Lo . qi ( XTextDocument . class , doc ); XText xText = textDoc . getText (); The XText instance can access all the capabilities shown in Figure 3. A common next step is to create a cursor for moving around the document. This is easy since XText inherits XSimpleText which has a createTextCursor() method: XTextCursor textCursor = xText . createTextCursor (); These few lines are so useful that I've put them inside a Write.getCursor() method: public static XTextCursor getCursor ( XTextDocument textDoc ) // get cursor from a text document { XText xText = textDoc . getText (); if ( xText == null ) { System . out . println ( \"Text not found in document\" ); return null ; } else return xText . createTextCursor (); } // end of getCursor() An XTextCursor can be converted into other kinds of model cursors (e.g. XParagraphCursor, XSentenceCursor, XWordCursor; see Figure 4). That's not necessary in for the ExtractText.java example; instead, the XTextCursor is passed to Write.getAllText() to access the text as a sequence of characters: public static String getAllText ( XTextCursor cursor ) { cursor . gotoStart ( false ); cursor . gotoEnd ( true ); String text = cursor . getString (); cursor . gotoEnd ( false ); // to deselect everything in the doc return text ; } // end of getAllText() All cursor movement operations take a boolean argument which specifies whether the movement should also select the text. For example, in getAllText(), cursor.gotoStart(false) shifts the cursor to the start of the text without selecting anything. The subsequent call to cursor.gotoEnd(true) moves the cursor to the end of the text and selects all the text moved over. The call to getString() on the third line returns the selection (i.e. all the text in the document). Two other useful XTextCursor methods are: boolean goLeft ( short charCount , boolean isSelected ) boolean goRight ( short charCount , boolean isSelected ) They move the cursor left or right by a given number of characters, and the boolean argument specifies whether the text moved over is selected. All cursor methods return a boolean result which indicates if the move (and optional selection) was successful. Another method worth knowing is: boolean gotoRange ( XTextRange textRange , boolean isSelected ) gotoRange() takes an XTextRange argument, which represents a selected region or position where the cursor should be moved to. For example, it's possible to find a bookmark in a document, extract its text range/position, and move the cursor to that location with gotoRange(). I'll show code for doing this in Chapter 7. The XTextCursor methods are documented at https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1text_1_1XTextCursor.html (or type lodoc XTextCursor ).","title":"2.  Extracting Text from a Document"},{"location":"05-Text_API_Overview.html#a-problem-with-writegetalltext","text":"Write.getAllText() may fail if supplied with a very large document because XTextCursor.getString() might be unable to construct a big enough String object. For that reason, it's better to iterate over large documents returning a paragraph of text at a time. These iteration techniques are described next.","title":"A Problem with Write.getAllText()"},{"location":"05-Text_API_Overview.html#3-cursor-iteration","text":"My HighlightText.java example uses paragraph and word cursors (i.e. the XParagraphCursor and XWordCursor interfaces in Figure 4). It also employs the view cursor, an XTextViewCursor instance, to control the Writer application's visible cursor. The main () function of HighlightText : public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run HighlightText <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // make doc visible on-screen showParagraphs ( doc ); System . out . println ( \"Word count: \" + countWords ( doc )); showLines ( doc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() main() calls Write.openDoc() to return the opened document as an XTextDocument instance. If you recall, the previous ExtractText.java example started with an XComponent instance by calling Lo.openDoc(), and then converted it to XTextDocument. Write.openDoc() returns the XTextDocument reference in one go. showParagraphs() moves the visible on-screen cursor through the document, highlighting a paragraph at a time. This requires two cursors \u2013 an instance of XTextViewCursor and a separate XParagraphCursor. The paragraph cursor is capable of moving through the document paragraph-by-paragraph, but it's a model cursor, so invisible to the user looking at the document on-screen. showParagraphs() extracts the start and end positions of each paragraph and uses them to move the view cursor, which is visible. The code for showParagraphs(): private static void showParagraphs ( XTextDocument doc ) { XTextViewCursor tvc = Write . getViewCursor ( doc ); XParagraphCursor paraCursor = Write . getParagraphCursor ( doc ); paraCursor . gotoStart ( false ); // go to start of text; no selection do { paraCursor . gotoEndOfParagraph ( true ); // select 1 paragraph String currPara = paraCursor . getString (); if ( currPara . length () > 0 ) { // move view cursor to highlight current paragraph tvc . gotoRange ( paraCursor . getStart (), false ); tvc . gotoRange ( paraCursor . getEnd (), true ); Lo . wait ( 500 ); // slow down paragraph changing speed } } while ( paraCursor . gotoNextParagraph ( false )); } // end of showParagraphs() The code utilizes two Write utility functions (Write.getViewCursor() and Write.getParagraphCursor()) to create the cursors. The subsequent do-while loop is a common coding pattern for iterating over a text document: paraCursor . gotoStart ( false ); do { paraCursor . gotoEndOfParagraph ( true ); // select 1 paragraph // do something to the selected text range... } while ( paraCursor . gotoNextParagraph ( false )); gotoNextParagraph() tries to move the cursor to the beginning of the next paragraph. If the moves fails (i.e. when the cursor has reached the end of the document), the function returns false, and the loop terminates. The call to gotoEndOfParagraph() at the beginning of the loop moves the cursor to the end of the paragraph and selects its text. Since the cursor was originally at the start of the paragraph, the selection will span that paragraph. XParagraphCursor and the sentence and word cursors inherit XTextCursor, as shown in Figure 5. Figure 5. The Model Cursors Inheritance Hierarchy. Since all these cursors also inherit XTextRange, they can easily access and change their text selections/positions. In the showParagraphs() method above, the two ends of the paragraph are obtained by calling the inherited XTextRange.getStart() and XTextRange.getEnd(), and the positions are used to move the view cursor: XTextViewCursor tvc = Write . getViewCursor ( doc ); : tvc . gotoRange ( paraCursor . getStart (), false ); tvc . gotoRange ( paraCursor . getEnd (), true ); gotoRange() sets the text range/position of the view cursor: the first call moves the cursor to the paragraph's starting position without selecting anything, and the second moves it to the end position, selecting all the text in between. Since this is a view cursor, the selection is visible on-screen, as illustrated in Figure 6. Figure 6. A Selected Paragraph. Note that getStart() and getEnd() do not return integers but collapsed text ranges, which is Office-lingo for a range that starts and ends at the same cursor position. Somewhat confusingly, the XTextViewCursor interface inherits XTextCursor (as shown in Figure 7). This only means that XTextViewCursor supports the same character-based movement and text range operations as the model-based cursor. Figure 7. The XTextViewCursor Inheritance Hierarchy.","title":"3.  Cursor Iteration"},{"location":"05-Text_API_Overview.html#4-creating-cursors","text":"An XTextCursor is created by calling Write.getCursor(), which can then be converted into a paragraph, sentence, or word cursor by using Lo.qi(). For example, the Write utility class defines getParagraphCursor() as: public static XParagraphCursor getParagraphCursor ( XTextDocument textDoc ) { XTextCursor cursor = getCursor ( textDoc ); if ( cursor == null ) { System . out . println ( \"Text cursor is null\" ); return null ; } else return Lo . qi ( XParagraphCursor . class , cursor ); } // end of getParagraphCursor() Obtaining the view cursor is a little more tricky since it's only accessible via the document's controller. As described in Chapter 1, section 5 about the FCM relationship, the controller is reached via the document's model, as shown in the first two lines of Write.getViewCursor(): public static XTextViewCursor getViewCursor ( XTextDocument textDoc ) { XModel model = Lo . qi ( XModel . class , textDoc ); XController xController = model . getCurrentController (); // the controller supplies the TextViewCursor XTextViewCursorSupplier supplier = Lo . qi ( XTextViewCursorSupplier . class , xController ); return supplier . getViewCursor (); } // end of getViewCursor() The view cursor isn't directly accessible from the controller; a supplier must be queried, even though there's only one view cursor per document.","title":"4.  Creating Cursors"},{"location":"05-Text_API_Overview.html#41-counting-words","text":"countWords() in HightlightText.java shows how to iterate over the document using a word cursor: private static int countWords ( XTextDocument doc ) { XWordCursor wordCursor = Write . getWordCursor ( doc ); wordCursor . gotoStart ( false ); // go to start of text int wordCount = 0 ; String currWord ; do { wordCursor . gotoEndOfWord ( true ); currWord = wordCursor . getString (); if ( currWord . length () > 0 ) wordCount ++ ; } while ( wordCursor . gotoNextWord ( false )); return wordCount ; } // end of countWords() This uses the same kind of do-while loop as showParagraphs() except that the XTextWordCursor methods gotoEndOfWord() and gotoNextWord() control the iteration. Also, there's no need for an XTextViewCursor instance since the selected words aren't shown on the screen.","title":"4.1.  Counting Words"},{"location":"05-Text_API_Overview.html#42-displaying-lines","text":"showLines() in HightlightText.java iterates over the document highlighting a line at a time. Don't confuse this with sentence selection because a sentence may consist of several lines on the screen. A sentence is part of the text's organization (i.e. in terms of words, sentences, and paragraphs) while a line is part of the document view (i.e. line, page, screen). This means that XLineCursor is a view cursor, which is obtained by converting XTextViewCursor with Lo.qi(): XTextViewCursor tvc = Write . getViewCursor ( doc ); XLineCursor lineCursor = Lo . qi ( XLineCursor . class , tvc ); The line cursor has limited functionality compared to the model cursors (paragraph, sentence, word). In particular, there's no \"next' function for moving to the next line (unlike gotoNextParagraph() or gotoNextWord()). The screen cursor also lacks this ability, but the page cursor offers jumpToNextPage(). One way of getting around the absence of a 'next' operation is shown in showLines(): private static void showLines ( XTextDocument doc ) { XTextViewCursor tvc = Write . getViewCursor ( doc ); tvc . gotoStart ( false ); // go to start of text XLineCursor lineCursor = Lo . qi ( XLineCursor . class , tvc ); boolean haveText = true ; do { lineCursor . gotoStartOfLine ( false ); lineCursor . gotoEndOfLine ( true ); // select 1 line Lo . wait ( 500 ); // slow down the line changing speed tvc . collapseToEnd (); // make selection disappear haveText = tvc . goRight (( short ) 1 , true ); // move 1 char } while ( haveText ); } // end of showLines() The view cursor is manipulated using the XTextViewCursor object and the XLineCursor line cursor. This is possible since the two references point to the same on-screen cursor. Either one can move it around the display. Inside the loop, XLineCursor's gotoStartOfLine() and gotoEndOfLine() highlight a single line. Then the XTextViewCursor instance deselects the line, by moving the cursor to the end of the selection with collapseToEnd(). At the end of the loop, goRight() tries to move the cursor one character to the right. If goRight() succeeds then the cursor is shifted one position to the first character of the next line. When the loop repeats, this line will be selected. If doRight() fails, then there are no more characters to be read from the document, and the loop finishes.","title":"4.2.  Displaying Lines"},{"location":"05-Text_API_Overview.html#5-creating-a-document","text":"All the examples so far have involved the manipulation of an existing document. The HelloText.java example creates a new text document, containing two short paragraphs, and saves it as \"hello.odt\". The main() function is: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // make the document visible XTextCursor cursor = Write . getCursor ( doc ); cursor . gotoEnd ( false ); // move cursor to end of doc before appending Write . appendPara ( cursor , \"Hello LibreOffice.\\n\" ); Lo . wait ( 1000 ); // slow things down so they can be seen Write . appendPara ( cursor , \"How are you?.\" ); Lo . wait ( 2000 ); Lo . saveDoc ( doc , \"hello.odt\" ); // or use extension doc, docx, rtf, pdf, txt Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Write.createDoc() calls Lo.createDoc() with the text document service name (the Lo.WRITER_STR constant is \"swriter\"). Office creates a TextDocument service with an XComponent interface, which is cast to the XTextDocument interface, and returned: // in the Write class public static XTextDocument createDoc ( XComponentLoader loader ) { XComponent doc = Lo . createDoc ( Lo . WRITER_STR , loader ); return Lo . qi ( XTextDocument . class , doc ); } Text documents are saved using Lo.saveDoc() which was described in Chapter 2. saveDoc() examines the filename's extension to determine its type. The known extensions include doc, docx, rtf, odt, pdf, and txt. Back in HelloText.java, a cursor is needed before text can be added; one is created by calling Write.getCursor(). The call to XTextCursor.gotoEnd() isn't really necessary because the new cursor is pointing to an empty document so is already at its end. It's included to emphasize the assumption by Write.appendPara() (and other Write.appendXXX() functions) that the cursor is positioned at the end of the document before new text is added. Write.appendPara() calls three other methods in the Write utility class: // in the Write class public static int appendPara ( XTextCursor cursor , String text ) { append ( cursor , text ); append ( cursor , ControlCharacter . PARAGRAPH_BREAK ); return getPosition ( cursor ); } The 'append' name is utilized several times in Write \u2013 one version takes a string as its second argument, the other a short representing a control character: // in the Write class public static int append ( XTextCursor cursor , String text ) { cursor . setString ( text ); cursor . gotoEnd ( false ); return getPosition ( cursor ); } // end of append() public static int append ( XTextCursor cursor , short ctrlChar ) { XText xText = cursor . getText (); xText . insertControlCharacter ( cursor , ctrlChar , false ); cursor . gotoEnd ( false ); return getPosition ( cursor ); } The first append() function uses XTextCursor.setString() to add the user-supplied string. The second function employs XTextCursor.insertControlCharacter(). After the addition of the text or character, the cursor is moved to the end of the document, and getPosition() is called to return the cursor's new position as an integer: public static int getPosition ( XTextCursor cursor ) { return ( cursor . getText (). getString ()). length (); } getPosition() is not very robust \u2013 it assumes that getString() will be able to convert the document's text into a string. This may fail if the document is very big (you may recall the same problem with my Write.getAllText() described earlier). Office deals with this size issue by using XTextRange instances, which encapsulate text ranges and positions. Write.getPosition() returns an integer because its easier to understand when you're first learning to program with Office. It's better style to use and compare XTextRanges rather than integer positions, an approach I'll demonstrate in the next section.","title":"5.  Creating a Document"},{"location":"05-Text_API_Overview.html#6-using-and-comparing-text-cursors","text":"My TalkingBook.java example utilizes the third-party library FreeTTS ( https://freetts.sourceforge.net/ ) to convert text into speech. The inner workings of FreeTTS aren't relevant here, so are hidden inside a support class called Speaker. It has three public methods: Speaker(): instantiates a FreeTTS instance \u2013 a male voice say(String s): converts the string s into speech dispose(): closes down the FreeTTS instance TalkingBook employs two text cursors: a paragraph cursor that iterates over the paragraphs in the document, and a sentence cursor that iterates over all the sentences in the current paragraph and passes each sentence to Speaker.say(). FreeTTS is capable of speaking long or short sequences of text, but TalkingBook processes a sentence at a time since this sounds more natural when spoken. The crucial function in TalkingBook.java is speakSentences(): private static void speakSentences ( XTextDocument doc ) { Speaker speaker = new Speaker (); // create FreeTTS voice XTextViewCursor tvc = Write . getViewCursor ( doc ); XParagraphCursor paraCursor = Write . getParagraphCursor ( doc ); paraCursor . gotoStart ( false ); // go to start of text // create range comparer for the entire document XTextRangeCompare comparer = Lo . qi ( XTextRangeCompare . class , doc . getText ()); String currParaStr , currSentStr ; do { paraCursor . gotoEndOfParagraph ( true ); // select 1 paragraph XTextRange endPara = paraCursor . getEnd (); currParaStr = paraCursor . getString (); if ( currParaStr . length () > 0 ) { // set sentence cursor to start of paragraph XTextCursor cursor = paraCursor . getText (). createTextCursorByRange ( paraCursor . getStart ()); XSentenceCursor sc = Lo . qi ( XSentenceCursor . class , cursor ); sc . gotoStartOfSentence ( false ); // goto start do { sc . gotoEndOfSentence ( true ); // select 1 sentence if ( comparer . compareRegionEnds ( endPara , sc . getEnd ()) > 0 ) // has sentence cursor passed end of current paragraph? break ; // move view cursor to highlight current sentence tvc . gotoRange ( sc . getStart (), false ); tvc . gotoRange ( sc . getEnd (), true ); currSentStr = stripNonWordChars ( sc . getString ()); // clean up string to make speech nicer if ( currSentStr . length () > 0 ) speaker . say ( currSentStr ); } while ( sc . gotoNextSentence ( false )); } } while ( paraCursor . gotoNextParagraph ( false )); speaker . dispose (); } // end of speakSentences() speakSentences() comprises two nested loops: the outer loop iterates through the paragraphs, and the inner loop through the sentences in the current paragraph. The sentence cursor is created like so: XTextCursor cursor = paraCursor . getText (). createTextCursorByRange ( paraCursor . getStart ()); XSentenceCursor sc = Lo . qi ( XSentenceCursor . class , cursor ); The XText reference is returned by paraCursor.getText(), and a text cursor is created. createTextCursorByRange() allows the start position of the cursor to be specified. The text cursor is converted into a sentence cursor with Lo.qi(). The tricky aspect of this code is the meaning of paraCursor.getText() which is the XText object that paraCursor utilizes. This is not a single paragraph but the entire text document. Remember that the paragraph cursor is created with: XParagraphCursor paraCursor = Write.getParagraphCursor(doc); This corresponds to: XText xText = doc.getText(); XTextCursor textCursor = xText.createTextCursor(); XParagraphCursor paraCursor = Lo.qi( XParagraphCursor.class, textCursor); Both the paragraph and sentence cursors refer to the entire text document. This means that I cannot code the inner loop using the coding pattern from before. That would result in something like the following: // set sentence cursor to point to start of this paragraph XTextCursor cursor = paraCursor . getText (). createTextCursorByRange ( paraCursor . getStart ()) XSentenceCursor sc = Lo . qi ( XSentenceCursor . class , cursor ); sc . gotoStartOfSentence ( false ); // goto start do { sc . gotoEndOfSentence ( true ); // select 1 sentence // do something with the sentence // : } while ( sc . gotoNextSentence ( false )); Note To further confuse matters, a XText object does not always correspond to the entire text document. For example, a text frame (e.g. like this one) can return an XText object for the text only inside the frame. The problem with the above code fragment is that XSentenceCursor.gotoNextSentence() will keep moving to the next sentence until it reaches the end of the text document. This is not the desired behavior \u2013 what I want is for the loop to terminate when the last sentence of the current paragraph has been processed. We need to compare text ranges, in this case the end of the current sentence with the end of the current paragraph. This capability is handled by the XTextRangeCompare interface. A comparer object is created at the beginning of speakSentence(), initialized to compare ranges that can span the entire document: XTextRangeCompare comparer = Lo . qi ( XTextRangeCompare . class , doc . getText ()); This comparer object is utilized inside the sentence-iterating loop to compare the end of the current paragraph (the endPara text range) with the end of current sentence (the sc.getEnd() text range): if ( comparer . compareRegionEnds ( endPara , sc . getEnd ()) > 0 ) break ; If the sentence ends after the end of the paragraph then compareRegionEnds() returns a positive number, and the inner loop terminates. This approach doesn't suffer from the problem in Write.getPosition() with XTextRange.getString(), and using its length as a position: public static int getPosition ( XTextCursor cursor ) { return ( cursor . getText (). getString ()). length (); Since there's no String object being created by the comparer, there's no way that the instantiation can fail due to the size of the text.","title":"6.  Using and Comparing Text Cursors"},{"location":"05-Text_API_Overview.html#7-insertingchanging-text-in-a-document","text":"My ShuffleWords.java example searches a document and changes the words it encounters. Figure 8 shows the program in progress: \"predominates\" has been selected but not yet changed, but all the previous 'big' words have been shuffled. Figure 8. Shuffling of Words. A word shuffle is applied to every word of four letters or more, but only involves the random exchange of the middle letters without changing the first and last characters. The applyShuffle() function which iterates through the words in the input file is similar to countWords() in HighlightText.java. One difference is the use of XText.insertString(): private static void applyShuffle ( XTextDocument doc ) { XText docText = doc . getText (); XWordCursor wordCursor = Write . getWordCursor ( doc ); wordCursor . gotoStart ( false ); // go to start of text XTextViewCursor tvc = Write . getViewCursor ( doc ); String currWord ; do { wordCursor . gotoEndOfWord ( true ); // move the text view cursor, and highlight the current word tvc . gotoRange ( wordCursor . getStart (), false ); tvc . gotoRange ( wordCursor . getEnd (), true ); currWord = wordCursor . getString (). trim (); if ( currWord . length () > 0 ) { Lo . wait ( 250 ); // slow down so user can see selection before change docText . insertString ( wordCursor , midShuffle ( currWord ), true ); } } while ( wordCursor . gotoNextWord ( false )); } // end of applyShuffle() insertString() is located in XSimpleText: void insertString ( XTextRange xRange , String s , boolean willReplace ) The string s is inserted at the cursor's text range position. If willReplace is true then the string replaces the current selection (which is the case in applyShuffle()). midShuffle() shuffles the string in currWord, returning a new word. It doesn't use the Office API, so I won't explain it here.","title":"7.  Inserting/Changing Text in a Document"},{"location":"05-Text_API_Overview.html#8-treating-a-document-as-paragraphs-and-text-portions","text":"Another approach for moving around a document involves the XEnumerationAccess interface which treats the document as a series of Paragraph text contents. XEnumerationAccess is an interface in the Text service, which means that an XText reference can be converted into it by using Lo.qi(). These relationships are shown in Figure 9. Figure 9. The Text Service and its Interfaces. The following code fragment utilizes this technique: XText xText = doc . getText (); // get text of document XEnumerationAccess enumAccess = Lo . qi ( XEnumerationAccess . class , xText ); XEnumerationAccess contains a single method, createEnumeration() which creates an enumerator (an instance of XEnumeration). Each element returned from this iterator is a Paragraph text content: // create enumerator over the document text XEnumeration textEnum = enumAccess . createEnumeration (); while ( textEnum . hasMoreElements ()) { // loop through paragraphs XTextContent textCon = Lo . qi ( XTextContent . class , textEnum . nextElement ()); // use the Paragraph text content (textCon) in some way... } Paragraph doesn't support its own interface (i.e. there's no XParagraph), so I've used Lo.qi() to access its XTextContent interface, which belongs to the TextContent subclass. The hierarchy is shown in Figure 10. Figure 10. The Paragraph Text Content Hierarchy. Iterating over a document to access Paragraph text contents doesn't seem much different from iterating over a document using a paragraph cursor, except that the Paragraph service offers a more structured view of a paragraph. In particular, you can use another XEnumerationAccess instance to iterate over a single paragraph, viewing it as a sequence of text portions. The following code illustrates the notion, using the textCon text content from the previous piece of code: if ( ! Info . supportService ( textCon , \"com.sun.star.text.TextTable\" )) { // create enumerator over a paragraph XEnumerationAccess enumAccess = Lo . qi ( XEnumerationAccess . class , textCon ); XEnumeration paraEnum = enumAccess . createEnumeration (); while ( paraEnum . hasMoreElements ()) { // loop through portions XTextRange txtRange = Lo . qi ( XTextRange . class , paraEnum . nextElement ()); // use the text portion (txtRange) in some way... } } The TextTable service is a subclass of Paragraph, and cannot be enumerated. Therefore, I surrounded the paragraph enumerator with an if-test to skip a paragraph if it's really a table. The paragraph enumerator returns text portions, represented by the TextPortion service. TextPortion contains a lot of useful properties which describe the paragraph, but it doesn't have its own interface (such as XTextPortion). However, TextPortion inherits the TextRange service, so I can use Lo.qi() to obtain its XTextRange interface. This hierarchy is shown in Figure 11. Figure 11. The TextPortion Service Hierarchy. TextPortion includes a \"TextPortionType\" property which identifies the type of the portion. Other properties access different kinds of portion data, such as a text field or footnote. For instance, the following prints the text portion type and the string inside the txtRange text portion (txtRange comes from the previous code fragment): System . out . println ( \" \" + Props . getProperty ( txtRange , \"TextPortionType\" ) + \" = \\\"\" + txtRange . getString () + \"\\\"\" ); These code fragments are combined together in my ShowBookText.java example. More details on enumerators and text portions are given in the Developers Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Iterating_over_Text/ (or use loGuide \"Iterating over Text\" ).","title":"8.  Treating a Document as Paragraphs and Text Portions"},{"location":"05-Text_API_Overview.html#9-appending-documents-together","text":"If you need to write a large multi-part document (e.g. a thesis with chapters, appendices, contents page, and an index) then you should utilize a master document, which acts as a repository of links to documents representing the component parts. You can find out about master documents in Chapter 13 of the Writers Guide, at https://wiki.documentfoundation.org/Documentation/Publications/ . However, the complexity of master documents isn't always needed. Often the aim is simply to append one document to the end of another. In that case, the XDocumentInsertable interface, and its insertDocumentFromURL() method is more suitable. My DocsAppend.java example uses XDocumentInsertable.insertDocumentFromURL(). A list of filenames is read from the command line; the first file is opened, and the other files appended to it by appendTextFiles(): // part of DocsAppend.java private static void appendTextFiles ( XTextDocument doc , String [] args ) { XTextCursor cursor = Write . getCursor ( doc ); for ( int i = 1 ; i < args . length ; i ++ ) { /* start at 1 to skip the first file, which has been opened as doc */ try { cursor . gotoEnd ( false ); // Write.pageBreak(cursor); System . out . println ( \"Appending \" + args [ i ] ); XDocumentInsertable inserter = Lo . qi ( XDocumentInsertable . class , cursor ); if ( inserter == null ) System . out . println ( \"Inserter could not be created\" ); else inserter . insertDocumentFromURL ( FileIO . fnmToURL ( args [ i ] ), new PropertyValue [ 0 ] ); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not append \" + args [ i ] + \": \" + e ); } } } // end of appendTextFiles() An XDocumentInsertable instance is obtained by converting the text cursor with UnoRuntime.queryInterface(). XDocumentInsertable.insertDocumentFromURL() requires two arguments \u2013 the URL of the file that's being appended, and an empty property value array.","title":"9.  Appending Documents Together"},{"location":"06-Text_Styles.html","text":"Chapter 6. Text Styles \u00b6 Topics Five Style Families; Properties; Listing Styles; Creating a Style; Applying Styles; Paragraph/Word Styles; Hyperlink Styling; Text Numbering; Headers and Footers Example folders: \"Text Tests\" and \"Utils\" This chapter focuses on how text documents styles can be examined and manipulated. This revolves around the XStyleFamiliesSupplier interface in GenericTextDocument, which is highlighted in Figure 1 (a repeat of Figure 2 in Chapter 5). Figure 1. The Text Document Services, and some Interfaces. XStyleFamiliesSupplier has a getStyleFamilies() method for returning text style families. All these families are stored in an XNameAccess object, as depicted in Figure 2. XNameAccess is one of Office's collection types, and employed when the objects in a collection have names. There's also an XIndexAccess for collections in index order. XNameContainer and XIndexContainer add the ability to insert and remove objects from a collection. Figure 2. Style Families and their Property Sets. Five style family names are used by text documents: \"CharacterStyles\", \"FrameStyles\", \"NumberingStyles\", \"PageStyles\", and \"ParagraphStyles\". The XNameAccess families collection can be accessed with one of those names, and returns a style family. A style family is a modifiable collection of PropertySet objects, stored in an XNameContainer object. Figure 2 shows that if the \"ParagraphStyles\" family is retrieved, it contains property sets labelled \"Header\", \"List\", \"Standard\", and quite a few more. Each property set can format a paragraph, change the text's font, size, and many other attributes. These property sets are called styles. The \"CharacterStyles\" family is a container of property sets (styles) which affect selected sentences, words, or characters in the document. The \"FrameStyles\" container holds property sets (styles) for formatting graphic and text frames. The \"NumberingStyles\" family is for adding numbers or bullets to paragraphs. The \"PageStyles\" family is for formatting pages. The names of the property sets (styles) in the style families can be listed using LibreOffice's GUI. If you create a new text document in Writer, a \"Styles and Formatting\" dialog window appears when you press F11 (or click on the brown spanner icon in the \"Formatting\" toolbar). Within the window you can switch between five icons representing the five style families. Figure 3 shows the list of property set (style) names for the paragraph styles family. They corresponds to the property set names shown in Figure 2. Figure 3. Styles and Formatting Window in Writer. The names listed in the window are the same as the names used in the API, except in two cases: the \"Default Style\" name that appears in the GUI window for \"Paragraph Styles\" and \"Page Styles\" is changed to \"Standard\" in the API. Strangely, the \"Default Style\" name for \"Character Styles\" in the GUI is called \"Default Style\" in the API. Accessing a style (a property set) is a three-step process, shown below. First the style families, then the style family (e.g. \"ParagraphStyle\"), and then the style (e.g. \"Standard\"): // 1. get the style families XStyleFamiliesSupplier xSupplier = Lo . qi ( XStyleFamiliesSupplier . class , doc ); XNameAccess nameAcc = xSupplier . getStyleFamilies (); // 2. get the paragraph style family XNameContainer paraStyleCon = Lo . qi ( XNameContainer . class , nameAcc . getByName ( \"ParagraphStyles\" )); // 3. get the 'standard' style (property set) XPropertySet standardProps = Lo . qi ( XPropertySet . class , paraStyleCon . getByName ( \"Standard\" )); The code that implements this process in the Write utility class is a bit more complicated since the calls to getByName() may raise exceptions if their string arguments are incorrect. The calls to Lo.qi() cast the object returned from a collection into the correct type. 1. What Properties are in a PropertySet? \u00b6 The \"Standard\" name in the \"ParagraphStyles\" style family refers to a property set (style). Each set is a collection of name=value pairs, and there are get and set methods using a name to get/set its value. This is simple enough, but what names should the programmer use? Each property set (style) in the same style family contain the same properties, but with different values. For instance, in Figure 2 the \"Header\", \"Title\", \"Standard\", \"List\", and \"Table\" sets contain the same named properties. The names of the properties used by the sets in a style family can be found in the documentation for their \"XXXStyle\" service. Table 1 summarizes the mapping. Style Family Name Service where Properties are Defined \"CharacterStyles\" CharacterStyle \"FrameStyles\" FrameStyle (??) \"NumberingStyles\" NumberingStyle \"PageStyles\" PageStyle \"ParagraphStyles\" ParagraphStyle Table 1. Properties Information for Each Style Family. The easiest way of finding Office documentation for the services in the second column of Table 1 is with lodoc.bat. For example, the page about CharacterStyle can be found with lodoc CharacterStyle service . The FrameStyle service (full name: com.sun.star.style.FrameStyle) has a \"??\" against it since there's no online documentation for that service, although such a service exists. A style's properties are usually defined across several classes in an inheritance hierarchy. The hierarchies for the five styles are summarized in Figure 4. Figure 4. The Inheritance Hierarchies for the Style Services. Figure 4 shows the hierarchies for the five style services: CharacterStyle, FrameStyle, NumberingStyle, PageStyle, and ParagraphStyle. There's clearly a lot of similarities between them, so I'll focus on CharacterStyle. There are three services containing character style properties: CharacterStyle, Style, and CharacterProperties. If you visit the online documentation for CharacterStyle, the properties are listed under the heading \"Public Attributes\", which is shown in Figure 5. Figure 5. Part of the Online Documentation for CharacterStyle. CharacterStyle defines six properties itself, but there are many more inherited from the Style and CharacterProperties services. If you click on the triangles next to the \"Public Attributes inherited from\" lines, the documentation expands to display those properties. Figure 4 contains two \"(??)\" strings \u2013 one is to indicate that there's no documentation for FrameStyle, so I'm guessing about its inheritance hierarchy. The other \"(??)\" is in the ParagraphStyle hierarchy. The documentation for ParagraphStyle, and the information in the developers guide, indicate that ParagraphStyle inherits only Style and ParagraphCharacter. I believe this to be incorrect, based on my coding with ParagraphStyle (some of which you'll see in the next sections). ParagraphStyle appears to inherits three services: Style, ParagraphCharacter, and CharacterStyle, as indicated in Figure 6. Figure 6. The Paragraph Service and its Superclasses. For more information of the styles API, start in the development guide in the \"Overall Document Features\" section, online at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Overall_Document_Features/ or type loGuide \"Overall Document Features\" The character and paragraph style properties are explained in the \"Formatting\" section: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Formatting/ or type loGuide writer Formatting 2. Listing Styles Information \u00b6 My StylesInfo.java example illustrates some of the Writer and Info utility functions for examining style families and their property sets. The main() function starts by listing the style families names: XTextDocument doc = Write . openDoc ( args [ 0 ] , loader ); // get all the style families for this document String [] styleFamilies = Info . getStyleFamilyNames ( doc ); System . out . println ( \"No. of Style Family Names: \" + styleFamilies . length ); for ( String styleFamily : styleFamilies ) System . out . println ( \" \" + styleFamily ); System . out . println (); The output lists the five family names: No. of Style Family Names: 5 CharacterStyles FrameStyles NumberingStyles PageStyles ParagraphStyles Info.getStyleFamilyNames() starts by casting the document to an XStyleFamiliesSupplier interface. Then the style families XNameAccess collection is obtained by calling XStyleFamiliesSupplier.getStyleFamilies().The family names in that collection are extracted with XNameAccess.getElementName(): public static String [] getStyleFamilyNames ( XComponent doc ) // in the Info class { XStyleFamiliesSupplier xSupplier = Lo . qi ( XStyleFamiliesSupplier . class , doc ); XNameAccess nameAcc = xSupplier . getStyleFamilies (); String [] names = nameAcc . getElementNames (); Arrays . sort ( names ); return names ; } // end of getStyleFamilyNames() Back in StylesInfo.java, the main() function continues by looping through the list of style family names, printing all the style (property set) names in each family: // list all the style names for each style family for ( int i = 0 ; i < styleFamilies . length ; i ++ ) { String styleFamily = styleFamilies [ i ] ; System . out . println (( i + 1 ) + \". \\\"\" + styleFamily + \"\\\" Style Family contains:\" ); String [] styleNames = Info . getStyleNames ( doc , styleFamily ); Lo . printNames ( styleNames ); } The output is lengthy, but informative: ## 1. \"CharacterStyles\" Style Family contains: \"Bullet Symbols\" \"Caption characters\" \"Citation\" \"Default Style\" \"Definition\" \"Drop Caps\" \"Emphasis\" \"Endnote Symbol\" \"Endnote anchor\" \"Example\" \"Footnote Symbol\" \"Footnote anchor\" \"Index Link\" \"Internet link\" \"Line numbering\" \"Main index entry\" \"Numbering Symbols\" \"Page Number\" \"Placeholder\" \"Rubies\" \"Source Text\" \"Strong Emphasis\" \"Teletype\" \"User Entry\" \"Variable\" \"Vertical Numbering Symbols\" \"Visited Internet Link\" ## 2. \"FrameStyles\" Style Family contains containers: \"Formula\" \"Frame\" \"Graphics\" \"Labels\" \"Marginalia\" \"OLE\" \"Watermark\" ## 3. \"NumberingStyles\" Style Family contains containers: \"List 1\" \"List 2\" \"List 3\" \"List 4\" \"List 5\" \"Numbering 1\" \"Numbering 2\" \"Numbering 3\" \"Numbering 4\" \"Numbering 5\" ## 4. \"PageStyles\" Style Family contains containers: \"Endnote\" \"Envelope\" \"First Page\" \"Footnote\" \"HTML\" \"Index\" \"Landscape\" \"Left Page\" \"Right Page\" \"Standard\" ## 5. \"ParagraphStyles\" Style Family contains containers: \"Addressee\" \"Bibliography 1\" \"Bibliography Heading\" \"Caption\" \"Contents 1\" \"Contents 10\" \"Contents 2\" \"Contents 3\" \"Contents 4\" \"Contents 5\" \"Contents 6\" \"Contents 7\" \"Contents 8\" \"Contents 9\" \"Contents Heading\" \"Drawing\" \"Endnote\" \"First line indent\" \"Footer\" \"Footer left\" \"Footer right\" \"Footnote\" \"Frame contents\" \"Hanging indent\" \"Header\" \"Header left\" \"Header right\" \"Heading\" \"Heading 1\" \"Heading 10\" \"Heading 2\" \"Heading 3\" \"Heading 4\" \"Heading 5\" \"Heading 6\" \"Heading 7\" \"Heading 8\" \"Heading 9\" \"Horizontal Line\" \"Illustration\" \"Illustration Index 1\" \"Illustration Index Heading\" \"Index\" \"Index 1\" \"Index 2\" \"Index 3\" \"Index Heading\" \"Index Separator\" \"List\" \"List 1\" \"List 1 Cont.\" \"List 1 End\" \"List 1 Start\" \"List 2\" \"List 2 Cont.\" \"List 2 End\" \"List 2 Start\" \"List 3\" \"List 3 Cont.\" \"List 3 End\" \"List 3 Start\" \"List 4\" \"List 4 Cont.\" \"List 4 End\" \"List 4 Start\" \"List 5\" \"List 5 Cont.\" \"List 5 End\" \"List 5 Start\" \"List Contents\" \"List Heading\" \"List Indent\" \"Marginalia\" \"Numbering 1\" \"Numbering 1 Cont.\" \"Numbering 1 End\" \"Numbering 1 Start\" \"Numbering 2\" \"Numbering 2 Cont.\" \"Numbering 2 End\" \"Numbering 2 Start\" \"Numbering 3\" \"Numbering 3 Cont.\" \"Numbering 3 End\" \"Numbering 3 Start\" \"Numbering 4\" \"Numbering 4 Cont.\" \"Numbering 4 End\" \"Numbering 4 Start\" \"Numbering 5\" \"Numbering 5 Cont.\" \"Numbering 5 End\" \"Numbering 5 Start\" \"Object index 1\" \"Object index heading\" \"Preformatted \"Quotations\" \"Salutation\" \"Sender\" \"Signature\" \"Standard\" \"Subtitle\" \"Table\" \"Table Contents\" \"Table Heading\" \"Table index 1\" \"Table index heading\" \"Text\" \"Text body\" \"Text body indent\" \"Title\" \"User Index 1\" \"User Index 10\" \"User Index 2\" \"User Index 3\" \"User Index 4\" \"User Index 5\" \"User Index 6\" \"User Index 7\" \"User Index 8\" \"User Index 9\" \"User Index Heading\" Info.getStyleNames() retrieves the XNameContainer object for each style family, and extracts its style (property set) names using getElementNames(): public static String [] getStyleNames ( XComponent doc , String familyStyleName ) // in Info.java { XNameContainer styleContainer = getStyleContainer ( doc , familyStyleName ); if ( styleContainer == null ) return null ; else { String [] names = styleContainer . getElementNames (); Arrays . sort ( names ); return names ; } } // end of getStyleNames() The last part of StylesInfo.java lists the properties for a specific property set. Info.getStyleProps() does that: XPropertySet getStyleProps ( XComponent doc , String familyStyleName , String propSetNm ) { XNameContainer styleContainer = getStyleContainer ( doc , familyStyleName ); // container is a collection of named property sets if ( styleContainer == null ) return null ; else { XPropertySet nameProps = null ; try { nameProps = Lo . qi ( XPropertySet . class , styleContainer . getByName ( propSetNm )); } catch ( Exception e ) { System . out . println ( \"Could not access style: \" + e ); } return nameProps ; } } // end of getStyleProps() Its arguments are the document, the style family name, and style (property set) name. A reference to the property set is returned. Accessing the \"Standard\" style (property set) of the \"ParagraphStyle\" family would require: XPropertySet props = Info . getStyleProps ( doc , \"ParagraphStyles\" , \"Standard\" ) The property set can be nicely printed by calling Props.showProps(): Props . showProps ( \"ParagraphStyles \\\"Standard\\\"\" , props ); The output is long, but begins and ends like so: ParagraphStyles \"Standard\" Properties BorderDistance == 0 BottomBorder == com.sun.star.table.BorderLine2@1a8a1dc BottomBorderDistance == 0 BreakType == com.sun.star.style.BreakType@18e5cde Category == 0 CharAutoKerning == true CharBackColor == -1 CharBackTransparent == true : Rsid == Any[Type[unsigned long], 0] SnapToGrid == true StyleInteropGrabBag == [Lcom.sun.star.beans.PropertyValue;@1701da1 TopBorder == com.sun.star.table.BorderLine2@6f3b58 TopBorderDistance == 0 WritingMode == 0 This listing, and in fact any listing of a style from \"ParagraphStyles\", shows that the properties are a mixture of those defined in the Style, ParagraphProperties, and CharacterProperties services. 3. Creating a New Style \u00b6 My StoryCreator.java example adds a new style to the paragraph style family, and uses it to format the document's paragraphs. The new ParagraphStyle service is referenced using one of its interfaces, the usual one being XStyle since all the different style services support it (as shown in Figure 4). For example: // create a new paragraph style XStyle paraStyle = Lo . createInstanceMSF ( XStyle . class , \"com.sun.star.style.ParagraphStyle\" ); Lo.createInstanceMSF()'s second argument is the full name of the service, and the first argument is the interface. All the style services are located in the \"com.sun.star.style\" package. Since I want to change property in this new style, I cast the XStyle interface to XPropertySet: XPropertySet props = Lo . qi ( XPropertySet . class , paraStyle ); A property is modified using setPropertyValue(). props . setPropertyValue ( \"ParaBottomMargin\" , 400 ); props . setPropertyValue ( \"CharFontName\" , \"Times New Roman\" ); props . setPropertyValue ( \"CharHeight\" , 12.0f ); These three properties are defined in one of the 'Properties' classes inherited by ParagraphStyle (as shown in Figure 4). \"ParaBottomMargin\" appears in ParagraphProperties, while \"CharFontName\" and \"CharHeight\" come from CharacterProperties. After setting the style's properties, the new style added to the document's paragraph style family: // access the paragraph style family XNameContainer paraStyles = Info . getStyleContainer ( textDoc , \"ParagraphStyles\" ); // store the style in the style family with the name \"Foo\" paraStyles . insertByName ( \"Foo\" , props ); The style is stored with the name \"Foo\", but any unique name would be good (perhaps one a little more descriptive than \"Foo\" would be better). The style creation code in StoryCreator.java is located in createParaStyle() and follows the code fragment sequence described above: public static boolean createParaStyle ( XTextDocument textDoc , String styleName ) // create a new paragraph container/style called styleName { XNameContainer paraStyles = Info . getStyleContainer ( textDoc , \"ParagraphStyles\" ); if ( paraStyles == null ) return false ; try { // create new paragraph style properties set XStyle paraStyle = Lo . createInstanceMSF ( XStyle . class , \"com.sun.star.style.ParagraphStyle\" ); XPropertySet props = Lo . qi ( XPropertySet . class , paraStyle ); // set some properties props . setPropertyValue ( \"CharFontName\" , \"Times New Roman\" ); props . setPropertyValue ( \"CharHeight\" , 12.0f ); props . setPropertyValue ( \"ParaBottomMargin\" , 400 ); // 4mm, in 100th mm units // set paragraph line spacing to 6mm LineSpacing lineSpacing = new LineSpacing (); lineSpacing . Mode = LineSpacingMode . FIX ; lineSpacing . Height = 600 ; props . setPropertyValue ( \"ParaLineSpacing\" , lineSpacing ); // some more common properties; not all used here /* props.setPropertyValue(\"CharWeight\", com.sun.star.awt.FontWeight.BOLD); props.setPropertyValue(\"CharAutoKerning\", true); props.setPropertyValue(\"ParaAdjust\", ParagraphAdjust.CENTER_value); props.setPropertyValue(\"ParaFirstLineIndent\", 0); props.setPropertyValue(\"BreakType\", BreakType.PAGE_AFTER); */ // store those properties in a container called styleName paraStyles . insertByName ( styleName , props ); return true ; } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not set paragraph style\" ); return false ; } } // end of createParaStyle() The \"ParaLineSpacing\" property is a little more complex than the others since its value isn't a basic type, but a LineSpacing object. The ParagraphProperties documentation for \"ParaLineSpacing\" is shown in Figure 7. Figure 7. The ParaLineSpacing Property in the ParagraphProperties Documentation. Clicking on the \"com::sun: :style::LineSpacing\" return type will load the LineSpacing documentation page into the browser. In StoryCreator.java, createParaStyle() is called like so: XTextDocument doc = Write . createDoc ( loader ); if ( ! createParaStyle ( doc , \"adParagraph\" )){ System . out . println ( \"Could not create new paragraph style\" ); Lo . closeOffice (); return ; } A new style called \"adParagraph\" is added to the paragraph style family. It uses Times New Roman 12pt font, and leaves a 6mm space between paragraphs. 4. Applying Styles to Paragraphs (and Characters) \u00b6 I've added an \"adParagraph\" style to the paragraph style family, but how do I apply that style to some paragraphs in the document? The easiest way is through the document's XTextRange interface. XTextRange is supported by the TextRange service, which inherits ParagraphProperties and CharacterProperties (and several other property classes), as illustrated in Figure 8. Figure 8. The TextRange Service. XTextRange can be cast to XPropertySet to make the properties in ParagraphProperties and CharacterProperties accessible. An existing (or new) paragraph style is applied to a text range by setting its \"ParaStyleName\" property: XTextRange xTextRange = doc . getText (). getStart (); XPropertySet props = Lo . qi ( XPropertySet . class , xTextRange ); props . setProperty ( \"ParaStyleName\" , \"adParagraph\" ); Using Props.setProperty(), simplifies this to: XTextRange xTextRange = doc . getText (). getStart (); Props . setProperty ( xTextRange , \"ParaStyleName\" , \"adParagraph\" ); The code above obtains the text range at the start of the document, and set its paragraph style to \"adParagraph\". Any text added from this position onwards will use that style. This approach is used in StoryCreator.java: the style is set first, then text is added. 5. Cursors and Text Ranges \u00b6 Another technique for applying styles uses a cursor to select a text range. Then the text's properties are accessed through the cursor. All the different kinds of model and view cursor belong to the TextCursor service, and this inherits TextRange. This allows us to extend Figure 8 to become Figure 9. Figure 9. Cursor Access to Text Properties. This hierarchy means that a cursor can access the TextRange service and its text properties. The following code fragment demonstrates the idea: XTextCursor cursor = Write . getCursor ( textDoc ); cursor . gotoEnd ( true ); // select the entire document XPropertySet props = Lo . qi ( XPropertySet . class , cursor ); props . setProperty ( \"ParaStyleName\" , \"adParagraph\" ); Using Props.setProperty(), simplifies this to: XTextCursor cursor = Write . getCursor ( textDoc ); cursor . gotoEnd ( true ); Props . setProperty ( cursor , \"ParaStyleName\" , \"adParagraph\" ); This approach is employed in StoryCreator.java when some paragraphs (such as section headers) need to use a paragraph style other than \"adParagraph\". I'll supply details in a moment. 6. Building a Story Document \u00b6 StoryCreator.java starts by setting the \"adParagraph\" style, then employs readText() to read text from a file and add it to the document: XTextRange xTextRange = doc . getText (). getStart (); Props . setProperty ( xTextRange , \"ParaStyleName\" , \"adParagraph\" ); XTextCursor cursor = Write . getCursor ( doc ); readText ( \"scandal.txt\" , cursor ); Write . endParagraph ( cursor ); readText() assumes the text file has a certain format. For example, \"scandal.txt\" begins like so: Title: A Scandal in Bohemia Author: Sir Arthur Conan Doyle Part I. To Sherlock Holmes she is always THE woman. I have seldom heard him mention her under any other name. In his eyes she eclipses and predominates the whole of her sex. It was not that he felt any emotion akin to love for Irene Adler. All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind. A paragraph is a series of text lines followed by a blank line. But there are exceptions: lines that starts with \"Title: \", \"Author: \" or \"Part \" are treated as headings, and styled differently. When the text above is processed, the resulting document looks like Figure 10. Figure 10. The Output of StoryCreator.java. readText() is implemented using Java's FileReader and BufferedReader: public static void readText ( String fnm , XTextCursor cursor ) /* Write the text in fnm into a Office document. Use current paragraph styling unless the line starts with \"Title: \", \"Author: \", or \"Part \". */ { StringBuilder sb = new StringBuilder ( 0 ); BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( fnm )); System . out . println ( \"Reading text from: \" + fnm ); String line ; while (( line = br . readLine ()) != null ) { // System.out.println(\"<\" + line + \">\"); if ( line . length () == 0 ) { if ( sb . length () > 0 ) Write . appendPara ( cursor , sb . toString ()); sb . setLength ( 0 ); } else if ( line . startsWith ( \"Title: \" )) { Write . appendPara ( cursor , line . substring ( 7 )); Write . stylePrevParagraph ( cursor , \"Title\" ); } else if ( line . startsWith ( \"Author: \" )) { Write . appendPara ( cursor , line . substring ( 8 )); Write . stylePrevParagraph ( cursor , \"Subtitle\" ); } else if ( line . startsWith ( \"Part \" )) { Write . appendPara ( cursor , line ); Write . stylePrevParagraph ( cursor , \"Heading\" ); } else { sb . append ( line + \" \" ); } } if ( sb . length () > 0 ) Write . appendPara ( cursor , sb . toString ()); } catch ( FileNotFoundException ex ) { System . out . println ( \"Could not open: \" + fnm ); } catch ( IOException ex ) { System . out . println ( \"Read error: \" + ex ); } finally { try { if ( br != null ) br . close (); } catch ( IOException ex ) { System . out . println ( \"Problem closing \" + fnm ); } } } // end of readText() The interesting bits are the calls to Write.appendPara() and Write.stylePrevParagraph() which add a paragraph to the document and apply a style to it. For instance: else if ( line . startsWith ( \"Author: \" )) { Write . appendPara ( cursor , line . substring ( 8 )); Write . stylePrevParagraph ( cursor , \"Subtitle\" ); } Write.appendPara() writes the string into the document as a paragraph (the input line without the \"Author: \" substring). Write.stylePrevParagraph() changes the paragraph style from \"adParagraph\" to \"Subtitle\". The hard part of Write.stylePrevParagraph() is making sure that the style change only affects the previous paragraph. Text appended after this line should use \"adParagraph\" styling. public static void stylePrevParagraph ( XTextCursor cursor , Object propVal ) { stylePrevParagraph ( cursor , \"ParaStyleName\" , propVal ); } public static void stylePrevParagraph ( XTextCursor cursor , String propName , Object propVal ) { // save current property Object oldValue = Props . getProperty ( cursor , propName ); // apply property change to previous paragraph XParagraphCursor paraCursor = Lo . qi ( XParagraphCursor . class , cursor ); paraCursor . gotoPreviousParagraph ( true ); // select prev para Props . setProperty ( paraCursor , propName , propVal ); // reset the cursor and property paraCursor . gotoNextParagraph ( false ); Props . setProperty ( cursor , propName , oldValue ); } // end of stylePrevParagraph() The current \"ParaStyleName\" value is stored before changing its value in the selected range. Afterwards, that style name is applied back to the cursor. stylePrevParagraph() changes the XTextCursor into a paragraph cursor so that it's easier to move around across paragraphs. readText() calls Write.stylePrevParagraph() with three style names (\"Title\", \"Subtitle\", and \"Heading\"). I obtained those names from looking at the \"Paragraph Styles\" dialog window in Figure 3. 7. Style Changes to Words and Phrases \u00b6 Aside from changing paragraph styles, it's useful to apply style changes to words or strings inside a paragraph. For example, to highlight a word in bold, or write several words in red italics for emphasis. This is implemented by Write.styleLeft() using a similar approach to Write.stylePrevParagraph(). styleLeft() is passed an integer position which lies to the left of the current cursor position. Character style changes are applied to the text range defined by that distance: public static void styleLeft ( XTextCursor cursor , int pos , String propName , Object propVal ) { // save current property Object oldValue = Props . getProperty ( cursor , propName ); // apply property change to the left of cursor int currPos = getPosition ( cursor ); cursor . goLeft (( short )( currPos - pos ), true ); Props . setProperty ( cursor , propName , propVal ); // reset the cursor and property cursor . goRight (( short )( currPos - pos ), false ); Props . setProperty ( cursor , propName , oldValue ); } // end of styleLeft() An XTextCursor is used to select the range, and the new style is set. Then the cursor is moved back to its old position, and the previous style reapplied. The Write class contain a few support functions that set common styles using styleLeft(): public static void styleLeftBold ( XTextCursor cursor , int pos ) { styleLeft ( cursor , pos , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); } public static void styleLeftItalic ( XTextCursor cursor , int pos ) { styleLeft ( cursor , pos , \"CharPosture\" , com . sun . star . awt . FontSlant . ITALIC ); } public static void styleLeftColor ( XTextCursor cursor , int pos , java . awt . Color col ) { styleLeft ( cursor , pos , \"CharColor\" , Lo . getColorInt ( col )); } public static void styleLeftCode ( XTextCursor cursor , int pos ) // code is text in 10pt Courier New { styleLeft ( cursor , pos , \"CharFontName\" , \"Courier New\" ); styleLeft ( cursor , pos , \"CharHeight\" , 10 ); } The position (the pos value) passed to styleLeft() can be obtained from Write.getPosition(), or as the result of the Write.append() methods. My BuildDoc.java example contains several examples of how to use Write.styleLeft(): // code fragment from BuildDoc.java XTextCursor cursor = Write . getCursor ( doc ); int pos = Write . append ( cursor , \"Some examples of simple text \" ); Write . append ( cursor , \"styles.\\n\" ); Write . styleLeftBold ( cursor , pos ); // bold text back to pos pos = Write . getPosition ( cursor ); Write . appendPara ( cursor , \"This line is written in red italics.\" ); Write . styleLeftColor ( cursor , pos , Color . RED ); // red Write . styleLeftItalic ( cursor , pos ); // italics Write . appendPara ( cursor , \"Back to old style\\n\" ); The resulting text in the document looks like Figure 11. Figure 11. Styled Text. The following fragment from BuildDoc.java applies a 'code' styling to several lines: // code fragment from BuildDoc.java Write . appendPara ( cursor , \"Here's some code:\" ); pos = Write . getPosition ( cursor ); Write . append ( cursor , \"\\npublic class Hello\\n\" ); Write . append ( cursor , \"{\\n\" ); Write . append ( cursor , \" public static void main(String args[]\\n\" ); Write . append ( cursor , \" { System.out.println(\\\"Hello Andrew\\\"); }\\n\" ); Write . appendPara ( cursor , \"} // end of Hello class\\n\" ); Write . styleLeftCode ( cursor , pos ); Figure 12 shows the generated document text. Figure 12. Text with Code Styling. Unfortunately, styleLeft() depend on integer character positions, which are calculated using Write.getPosition(). As I've mentioned before, this method could fail if asked to generate too large a string, and this would cause styleLeft() to die. 8. Hyperlink Styling \u00b6 Text hyperlinks are implemented as styles, using \"HyperLinkURL\", and perhaps \"HyperLinkName\", and \"HyperLinkTarget\". BuildDoc.java shows how the \"HyperLinkURL\" property is set: Write . appendPara ( cursor , \"A link to my JLOP website:\" ); String urlStr = \"https://fivedots.coe.psu.ac.th/~ad/jlop/\" ; pos = Write . getPosition ( cursor ); Write . append ( cursor , urlStr ); Write . styleLeft ( cursor , pos , \"HyperLinkURL\" , urlStr ); Write . endParagraph ( cursor ); When the document is viewed, the text is drawn as a link as in Figure 13. Figure 13. Text Containing a Hypertext Link. If the user control-clicks on the link, then the URL value of \"HyperLinkURL\" will be loaded into the browser. The \"HyperLinkName\" property specifies a link name, which can be used when searching a document. \"HyperLinkTarget\" corresponds to the HTML hypertext target attribute, and has a default value of \"_self\". 9. Text Numbering \u00b6 It's straightforward to number paragraphs by using Write.styleLeft() and the \"NumberingStyleName\" property. The following code from BuildDoc.java, numbers three paragraphs: // code fragment from BuildDoc.java Write . appendPara ( cursor , \"The following points are important:\" ); pos = Write . appendPara ( cursor , \"Have a good breakfast\" ); Write . appendPara ( cursor , \"Have a good lunch\" ); Write . appendPara ( cursor , \"Have a good dinner\\n\" ); Write . styleLeft ( cursor , pos , \"NumberingStyleName\" , \"Numbering 1\" ); The result is shown in Figure 14. Figure 14. Numbered Paragraphs. \"NumberingStyleName\" is a property in ParagraphProperties, and the \"Numbering 1\" style is from the \"Paragraph Styles\" dialog window in Figure 3. Bullets are drawn instead of numbers by changing the style name to \"List 1\" (see Figure 15). Figure 15. Bulleted Paragraphs. One issue with numbered paragraphs is that their default behavior retains the current count when numbering another group of text. For example, a second group of numbered paragraphs appearing in the document after Figure 14 would start at '4'. This is fixed by setting the \"ParaIsNumberingRestart\" property to true: Write . styleLeft ( cursor , pos , \"ParaIsNumberingRestart\" , true ); One large topic I won\u2019t be looking at is document numbering. This includes the numbering of chapter headings and lines. Chapter and line numbering are dealt with differently from most document styles. Instead of being accessed via XStyleFamiliesSupplier, they employ XChapterNumberingSupplier and XNumberFormatsSupplier. For more details, see the development guide: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Line_Numbering_and_Outline_Numbering/ or type loGuide \"Line Numbering\" . 10. Other Style Changes \u00b6 StoryCreator.java illustrates three other styling effects: the creation of a header, setting the page to A4 format, and employing page numbers in the footer. The relevant calls are: // code fragment in StoryCreator.java Write . setHeader ( doc , \"From: \" + args [ 0 ] ); Write . setA4PageFormat ( doc ); Write . setPageNumbers ( doc ); Write.setA4PageFormat() sets the page formatting. Write.setPageNumbers() utilizes text fields, which I'll examine in the \"Text Fields\" section in Chapter 7. Changing the header in Write.setHeader() requires the setting of the \"HeaderIsOn\" boolean in the \"Standard\" page style. Adding text to the header is done via an XText reference. The code for Write.setHeader(): public static void setHeader ( XTextDocument textDoc , String hText ) /* Modify the header via the page style for the document. Put the text on the right hand side in the header in Times New Roman, 10pt */ { XPropertySet props = Info . getStyleProps ( textDoc , \"PageStyles\" , \"Standard\" ); if ( props == null ) { System . out . println ( \"Could not access standard page style\" ); return ; } try { props . setPropertyValue ( \"HeaderIsOn\" , true ); // header is turned on in the document // access the header's XText and cursor XText headerText = Lo . qi ( XText . class , props . getPropertyValue ( \"HeaderText\" )); XTextCursor headerCursor = headerText . createTextCursor (); headerCursor . gotoEnd ( false ); // header is on the rhs and in Times New Roman, 10pt XPropertySet headerProps = Lo . qi ( XPropertySet . class , headerCursor ); headerProps . setPropertyValue ( \"CharFontName\" , \"Times New Roman\" ); headerProps . setPropertyValue ( \"CharHeight\" , 10 ); headerProps . setPropertyValue ( \"ParaAdjust\" , ParagraphAdjust . RIGHT ); headerText . setString ( hText + \"\\n\" ); } catch ( Exception ex ) { System . out . println ( ex ); } } // end of setHeader() The header's XText reference is retrieved via the page style's \"HeaderText\" property, and a cursor is created local to the header: XTextCursor headerCursor = headerText . createTextCursor (); This cursor can only move around inside the header not the entire document. The properties of the header's XText are changed using the cursor, and then the text is added.","title":"Chapter 6. Text Styles"},{"location":"06-Text_Styles.html#chapter-6-text-styles","text":"Topics Five Style Families; Properties; Listing Styles; Creating a Style; Applying Styles; Paragraph/Word Styles; Hyperlink Styling; Text Numbering; Headers and Footers Example folders: \"Text Tests\" and \"Utils\" This chapter focuses on how text documents styles can be examined and manipulated. This revolves around the XStyleFamiliesSupplier interface in GenericTextDocument, which is highlighted in Figure 1 (a repeat of Figure 2 in Chapter 5). Figure 1. The Text Document Services, and some Interfaces. XStyleFamiliesSupplier has a getStyleFamilies() method for returning text style families. All these families are stored in an XNameAccess object, as depicted in Figure 2. XNameAccess is one of Office's collection types, and employed when the objects in a collection have names. There's also an XIndexAccess for collections in index order. XNameContainer and XIndexContainer add the ability to insert and remove objects from a collection. Figure 2. Style Families and their Property Sets. Five style family names are used by text documents: \"CharacterStyles\", \"FrameStyles\", \"NumberingStyles\", \"PageStyles\", and \"ParagraphStyles\". The XNameAccess families collection can be accessed with one of those names, and returns a style family. A style family is a modifiable collection of PropertySet objects, stored in an XNameContainer object. Figure 2 shows that if the \"ParagraphStyles\" family is retrieved, it contains property sets labelled \"Header\", \"List\", \"Standard\", and quite a few more. Each property set can format a paragraph, change the text's font, size, and many other attributes. These property sets are called styles. The \"CharacterStyles\" family is a container of property sets (styles) which affect selected sentences, words, or characters in the document. The \"FrameStyles\" container holds property sets (styles) for formatting graphic and text frames. The \"NumberingStyles\" family is for adding numbers or bullets to paragraphs. The \"PageStyles\" family is for formatting pages. The names of the property sets (styles) in the style families can be listed using LibreOffice's GUI. If you create a new text document in Writer, a \"Styles and Formatting\" dialog window appears when you press F11 (or click on the brown spanner icon in the \"Formatting\" toolbar). Within the window you can switch between five icons representing the five style families. Figure 3 shows the list of property set (style) names for the paragraph styles family. They corresponds to the property set names shown in Figure 2. Figure 3. Styles and Formatting Window in Writer. The names listed in the window are the same as the names used in the API, except in two cases: the \"Default Style\" name that appears in the GUI window for \"Paragraph Styles\" and \"Page Styles\" is changed to \"Standard\" in the API. Strangely, the \"Default Style\" name for \"Character Styles\" in the GUI is called \"Default Style\" in the API. Accessing a style (a property set) is a three-step process, shown below. First the style families, then the style family (e.g. \"ParagraphStyle\"), and then the style (e.g. \"Standard\"): // 1. get the style families XStyleFamiliesSupplier xSupplier = Lo . qi ( XStyleFamiliesSupplier . class , doc ); XNameAccess nameAcc = xSupplier . getStyleFamilies (); // 2. get the paragraph style family XNameContainer paraStyleCon = Lo . qi ( XNameContainer . class , nameAcc . getByName ( \"ParagraphStyles\" )); // 3. get the 'standard' style (property set) XPropertySet standardProps = Lo . qi ( XPropertySet . class , paraStyleCon . getByName ( \"Standard\" )); The code that implements this process in the Write utility class is a bit more complicated since the calls to getByName() may raise exceptions if their string arguments are incorrect. The calls to Lo.qi() cast the object returned from a collection into the correct type.","title":"Chapter 6. Text Styles"},{"location":"06-Text_Styles.html#1-what-properties-are-in-a-propertyset","text":"The \"Standard\" name in the \"ParagraphStyles\" style family refers to a property set (style). Each set is a collection of name=value pairs, and there are get and set methods using a name to get/set its value. This is simple enough, but what names should the programmer use? Each property set (style) in the same style family contain the same properties, but with different values. For instance, in Figure 2 the \"Header\", \"Title\", \"Standard\", \"List\", and \"Table\" sets contain the same named properties. The names of the properties used by the sets in a style family can be found in the documentation for their \"XXXStyle\" service. Table 1 summarizes the mapping. Style Family Name Service where Properties are Defined \"CharacterStyles\" CharacterStyle \"FrameStyles\" FrameStyle (??) \"NumberingStyles\" NumberingStyle \"PageStyles\" PageStyle \"ParagraphStyles\" ParagraphStyle Table 1. Properties Information for Each Style Family. The easiest way of finding Office documentation for the services in the second column of Table 1 is with lodoc.bat. For example, the page about CharacterStyle can be found with lodoc CharacterStyle service . The FrameStyle service (full name: com.sun.star.style.FrameStyle) has a \"??\" against it since there's no online documentation for that service, although such a service exists. A style's properties are usually defined across several classes in an inheritance hierarchy. The hierarchies for the five styles are summarized in Figure 4. Figure 4. The Inheritance Hierarchies for the Style Services. Figure 4 shows the hierarchies for the five style services: CharacterStyle, FrameStyle, NumberingStyle, PageStyle, and ParagraphStyle. There's clearly a lot of similarities between them, so I'll focus on CharacterStyle. There are three services containing character style properties: CharacterStyle, Style, and CharacterProperties. If you visit the online documentation for CharacterStyle, the properties are listed under the heading \"Public Attributes\", which is shown in Figure 5. Figure 5. Part of the Online Documentation for CharacterStyle. CharacterStyle defines six properties itself, but there are many more inherited from the Style and CharacterProperties services. If you click on the triangles next to the \"Public Attributes inherited from\" lines, the documentation expands to display those properties. Figure 4 contains two \"(??)\" strings \u2013 one is to indicate that there's no documentation for FrameStyle, so I'm guessing about its inheritance hierarchy. The other \"(??)\" is in the ParagraphStyle hierarchy. The documentation for ParagraphStyle, and the information in the developers guide, indicate that ParagraphStyle inherits only Style and ParagraphCharacter. I believe this to be incorrect, based on my coding with ParagraphStyle (some of which you'll see in the next sections). ParagraphStyle appears to inherits three services: Style, ParagraphCharacter, and CharacterStyle, as indicated in Figure 6. Figure 6. The Paragraph Service and its Superclasses. For more information of the styles API, start in the development guide in the \"Overall Document Features\" section, online at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Overall_Document_Features/ or type loGuide \"Overall Document Features\" The character and paragraph style properties are explained in the \"Formatting\" section: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Formatting/ or type loGuide writer Formatting","title":"1.  What Properties are in a PropertySet?"},{"location":"06-Text_Styles.html#2-listing-styles-information","text":"My StylesInfo.java example illustrates some of the Writer and Info utility functions for examining style families and their property sets. The main() function starts by listing the style families names: XTextDocument doc = Write . openDoc ( args [ 0 ] , loader ); // get all the style families for this document String [] styleFamilies = Info . getStyleFamilyNames ( doc ); System . out . println ( \"No. of Style Family Names: \" + styleFamilies . length ); for ( String styleFamily : styleFamilies ) System . out . println ( \" \" + styleFamily ); System . out . println (); The output lists the five family names: No. of Style Family Names: 5 CharacterStyles FrameStyles NumberingStyles PageStyles ParagraphStyles Info.getStyleFamilyNames() starts by casting the document to an XStyleFamiliesSupplier interface. Then the style families XNameAccess collection is obtained by calling XStyleFamiliesSupplier.getStyleFamilies().The family names in that collection are extracted with XNameAccess.getElementName(): public static String [] getStyleFamilyNames ( XComponent doc ) // in the Info class { XStyleFamiliesSupplier xSupplier = Lo . qi ( XStyleFamiliesSupplier . class , doc ); XNameAccess nameAcc = xSupplier . getStyleFamilies (); String [] names = nameAcc . getElementNames (); Arrays . sort ( names ); return names ; } // end of getStyleFamilyNames() Back in StylesInfo.java, the main() function continues by looping through the list of style family names, printing all the style (property set) names in each family: // list all the style names for each style family for ( int i = 0 ; i < styleFamilies . length ; i ++ ) { String styleFamily = styleFamilies [ i ] ; System . out . println (( i + 1 ) + \". \\\"\" + styleFamily + \"\\\" Style Family contains:\" ); String [] styleNames = Info . getStyleNames ( doc , styleFamily ); Lo . printNames ( styleNames ); } The output is lengthy, but informative: ## 1. \"CharacterStyles\" Style Family contains: \"Bullet Symbols\" \"Caption characters\" \"Citation\" \"Default Style\" \"Definition\" \"Drop Caps\" \"Emphasis\" \"Endnote Symbol\" \"Endnote anchor\" \"Example\" \"Footnote Symbol\" \"Footnote anchor\" \"Index Link\" \"Internet link\" \"Line numbering\" \"Main index entry\" \"Numbering Symbols\" \"Page Number\" \"Placeholder\" \"Rubies\" \"Source Text\" \"Strong Emphasis\" \"Teletype\" \"User Entry\" \"Variable\" \"Vertical Numbering Symbols\" \"Visited Internet Link\" ## 2. \"FrameStyles\" Style Family contains containers: \"Formula\" \"Frame\" \"Graphics\" \"Labels\" \"Marginalia\" \"OLE\" \"Watermark\" ## 3. \"NumberingStyles\" Style Family contains containers: \"List 1\" \"List 2\" \"List 3\" \"List 4\" \"List 5\" \"Numbering 1\" \"Numbering 2\" \"Numbering 3\" \"Numbering 4\" \"Numbering 5\" ## 4. \"PageStyles\" Style Family contains containers: \"Endnote\" \"Envelope\" \"First Page\" \"Footnote\" \"HTML\" \"Index\" \"Landscape\" \"Left Page\" \"Right Page\" \"Standard\" ## 5. \"ParagraphStyles\" Style Family contains containers: \"Addressee\" \"Bibliography 1\" \"Bibliography Heading\" \"Caption\" \"Contents 1\" \"Contents 10\" \"Contents 2\" \"Contents 3\" \"Contents 4\" \"Contents 5\" \"Contents 6\" \"Contents 7\" \"Contents 8\" \"Contents 9\" \"Contents Heading\" \"Drawing\" \"Endnote\" \"First line indent\" \"Footer\" \"Footer left\" \"Footer right\" \"Footnote\" \"Frame contents\" \"Hanging indent\" \"Header\" \"Header left\" \"Header right\" \"Heading\" \"Heading 1\" \"Heading 10\" \"Heading 2\" \"Heading 3\" \"Heading 4\" \"Heading 5\" \"Heading 6\" \"Heading 7\" \"Heading 8\" \"Heading 9\" \"Horizontal Line\" \"Illustration\" \"Illustration Index 1\" \"Illustration Index Heading\" \"Index\" \"Index 1\" \"Index 2\" \"Index 3\" \"Index Heading\" \"Index Separator\" \"List\" \"List 1\" \"List 1 Cont.\" \"List 1 End\" \"List 1 Start\" \"List 2\" \"List 2 Cont.\" \"List 2 End\" \"List 2 Start\" \"List 3\" \"List 3 Cont.\" \"List 3 End\" \"List 3 Start\" \"List 4\" \"List 4 Cont.\" \"List 4 End\" \"List 4 Start\" \"List 5\" \"List 5 Cont.\" \"List 5 End\" \"List 5 Start\" \"List Contents\" \"List Heading\" \"List Indent\" \"Marginalia\" \"Numbering 1\" \"Numbering 1 Cont.\" \"Numbering 1 End\" \"Numbering 1 Start\" \"Numbering 2\" \"Numbering 2 Cont.\" \"Numbering 2 End\" \"Numbering 2 Start\" \"Numbering 3\" \"Numbering 3 Cont.\" \"Numbering 3 End\" \"Numbering 3 Start\" \"Numbering 4\" \"Numbering 4 Cont.\" \"Numbering 4 End\" \"Numbering 4 Start\" \"Numbering 5\" \"Numbering 5 Cont.\" \"Numbering 5 End\" \"Numbering 5 Start\" \"Object index 1\" \"Object index heading\" \"Preformatted \"Quotations\" \"Salutation\" \"Sender\" \"Signature\" \"Standard\" \"Subtitle\" \"Table\" \"Table Contents\" \"Table Heading\" \"Table index 1\" \"Table index heading\" \"Text\" \"Text body\" \"Text body indent\" \"Title\" \"User Index 1\" \"User Index 10\" \"User Index 2\" \"User Index 3\" \"User Index 4\" \"User Index 5\" \"User Index 6\" \"User Index 7\" \"User Index 8\" \"User Index 9\" \"User Index Heading\" Info.getStyleNames() retrieves the XNameContainer object for each style family, and extracts its style (property set) names using getElementNames(): public static String [] getStyleNames ( XComponent doc , String familyStyleName ) // in Info.java { XNameContainer styleContainer = getStyleContainer ( doc , familyStyleName ); if ( styleContainer == null ) return null ; else { String [] names = styleContainer . getElementNames (); Arrays . sort ( names ); return names ; } } // end of getStyleNames() The last part of StylesInfo.java lists the properties for a specific property set. Info.getStyleProps() does that: XPropertySet getStyleProps ( XComponent doc , String familyStyleName , String propSetNm ) { XNameContainer styleContainer = getStyleContainer ( doc , familyStyleName ); // container is a collection of named property sets if ( styleContainer == null ) return null ; else { XPropertySet nameProps = null ; try { nameProps = Lo . qi ( XPropertySet . class , styleContainer . getByName ( propSetNm )); } catch ( Exception e ) { System . out . println ( \"Could not access style: \" + e ); } return nameProps ; } } // end of getStyleProps() Its arguments are the document, the style family name, and style (property set) name. A reference to the property set is returned. Accessing the \"Standard\" style (property set) of the \"ParagraphStyle\" family would require: XPropertySet props = Info . getStyleProps ( doc , \"ParagraphStyles\" , \"Standard\" ) The property set can be nicely printed by calling Props.showProps(): Props . showProps ( \"ParagraphStyles \\\"Standard\\\"\" , props ); The output is long, but begins and ends like so: ParagraphStyles \"Standard\" Properties BorderDistance == 0 BottomBorder == com.sun.star.table.BorderLine2@1a8a1dc BottomBorderDistance == 0 BreakType == com.sun.star.style.BreakType@18e5cde Category == 0 CharAutoKerning == true CharBackColor == -1 CharBackTransparent == true : Rsid == Any[Type[unsigned long], 0] SnapToGrid == true StyleInteropGrabBag == [Lcom.sun.star.beans.PropertyValue;@1701da1 TopBorder == com.sun.star.table.BorderLine2@6f3b58 TopBorderDistance == 0 WritingMode == 0 This listing, and in fact any listing of a style from \"ParagraphStyles\", shows that the properties are a mixture of those defined in the Style, ParagraphProperties, and CharacterProperties services.","title":"2.  Listing Styles Information"},{"location":"06-Text_Styles.html#3-creating-a-new-style","text":"My StoryCreator.java example adds a new style to the paragraph style family, and uses it to format the document's paragraphs. The new ParagraphStyle service is referenced using one of its interfaces, the usual one being XStyle since all the different style services support it (as shown in Figure 4). For example: // create a new paragraph style XStyle paraStyle = Lo . createInstanceMSF ( XStyle . class , \"com.sun.star.style.ParagraphStyle\" ); Lo.createInstanceMSF()'s second argument is the full name of the service, and the first argument is the interface. All the style services are located in the \"com.sun.star.style\" package. Since I want to change property in this new style, I cast the XStyle interface to XPropertySet: XPropertySet props = Lo . qi ( XPropertySet . class , paraStyle ); A property is modified using setPropertyValue(). props . setPropertyValue ( \"ParaBottomMargin\" , 400 ); props . setPropertyValue ( \"CharFontName\" , \"Times New Roman\" ); props . setPropertyValue ( \"CharHeight\" , 12.0f ); These three properties are defined in one of the 'Properties' classes inherited by ParagraphStyle (as shown in Figure 4). \"ParaBottomMargin\" appears in ParagraphProperties, while \"CharFontName\" and \"CharHeight\" come from CharacterProperties. After setting the style's properties, the new style added to the document's paragraph style family: // access the paragraph style family XNameContainer paraStyles = Info . getStyleContainer ( textDoc , \"ParagraphStyles\" ); // store the style in the style family with the name \"Foo\" paraStyles . insertByName ( \"Foo\" , props ); The style is stored with the name \"Foo\", but any unique name would be good (perhaps one a little more descriptive than \"Foo\" would be better). The style creation code in StoryCreator.java is located in createParaStyle() and follows the code fragment sequence described above: public static boolean createParaStyle ( XTextDocument textDoc , String styleName ) // create a new paragraph container/style called styleName { XNameContainer paraStyles = Info . getStyleContainer ( textDoc , \"ParagraphStyles\" ); if ( paraStyles == null ) return false ; try { // create new paragraph style properties set XStyle paraStyle = Lo . createInstanceMSF ( XStyle . class , \"com.sun.star.style.ParagraphStyle\" ); XPropertySet props = Lo . qi ( XPropertySet . class , paraStyle ); // set some properties props . setPropertyValue ( \"CharFontName\" , \"Times New Roman\" ); props . setPropertyValue ( \"CharHeight\" , 12.0f ); props . setPropertyValue ( \"ParaBottomMargin\" , 400 ); // 4mm, in 100th mm units // set paragraph line spacing to 6mm LineSpacing lineSpacing = new LineSpacing (); lineSpacing . Mode = LineSpacingMode . FIX ; lineSpacing . Height = 600 ; props . setPropertyValue ( \"ParaLineSpacing\" , lineSpacing ); // some more common properties; not all used here /* props.setPropertyValue(\"CharWeight\", com.sun.star.awt.FontWeight.BOLD); props.setPropertyValue(\"CharAutoKerning\", true); props.setPropertyValue(\"ParaAdjust\", ParagraphAdjust.CENTER_value); props.setPropertyValue(\"ParaFirstLineIndent\", 0); props.setPropertyValue(\"BreakType\", BreakType.PAGE_AFTER); */ // store those properties in a container called styleName paraStyles . insertByName ( styleName , props ); return true ; } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not set paragraph style\" ); return false ; } } // end of createParaStyle() The \"ParaLineSpacing\" property is a little more complex than the others since its value isn't a basic type, but a LineSpacing object. The ParagraphProperties documentation for \"ParaLineSpacing\" is shown in Figure 7. Figure 7. The ParaLineSpacing Property in the ParagraphProperties Documentation. Clicking on the \"com::sun: :style::LineSpacing\" return type will load the LineSpacing documentation page into the browser. In StoryCreator.java, createParaStyle() is called like so: XTextDocument doc = Write . createDoc ( loader ); if ( ! createParaStyle ( doc , \"adParagraph\" )){ System . out . println ( \"Could not create new paragraph style\" ); Lo . closeOffice (); return ; } A new style called \"adParagraph\" is added to the paragraph style family. It uses Times New Roman 12pt font, and leaves a 6mm space between paragraphs.","title":"3.  Creating a New Style"},{"location":"06-Text_Styles.html#4-applying-styles-to-paragraphs-and-characters","text":"I've added an \"adParagraph\" style to the paragraph style family, but how do I apply that style to some paragraphs in the document? The easiest way is through the document's XTextRange interface. XTextRange is supported by the TextRange service, which inherits ParagraphProperties and CharacterProperties (and several other property classes), as illustrated in Figure 8. Figure 8. The TextRange Service. XTextRange can be cast to XPropertySet to make the properties in ParagraphProperties and CharacterProperties accessible. An existing (or new) paragraph style is applied to a text range by setting its \"ParaStyleName\" property: XTextRange xTextRange = doc . getText (). getStart (); XPropertySet props = Lo . qi ( XPropertySet . class , xTextRange ); props . setProperty ( \"ParaStyleName\" , \"adParagraph\" ); Using Props.setProperty(), simplifies this to: XTextRange xTextRange = doc . getText (). getStart (); Props . setProperty ( xTextRange , \"ParaStyleName\" , \"adParagraph\" ); The code above obtains the text range at the start of the document, and set its paragraph style to \"adParagraph\". Any text added from this position onwards will use that style. This approach is used in StoryCreator.java: the style is set first, then text is added.","title":"4.  Applying Styles to Paragraphs (and Characters)"},{"location":"06-Text_Styles.html#5-cursors-and-text-ranges","text":"Another technique for applying styles uses a cursor to select a text range. Then the text's properties are accessed through the cursor. All the different kinds of model and view cursor belong to the TextCursor service, and this inherits TextRange. This allows us to extend Figure 8 to become Figure 9. Figure 9. Cursor Access to Text Properties. This hierarchy means that a cursor can access the TextRange service and its text properties. The following code fragment demonstrates the idea: XTextCursor cursor = Write . getCursor ( textDoc ); cursor . gotoEnd ( true ); // select the entire document XPropertySet props = Lo . qi ( XPropertySet . class , cursor ); props . setProperty ( \"ParaStyleName\" , \"adParagraph\" ); Using Props.setProperty(), simplifies this to: XTextCursor cursor = Write . getCursor ( textDoc ); cursor . gotoEnd ( true ); Props . setProperty ( cursor , \"ParaStyleName\" , \"adParagraph\" ); This approach is employed in StoryCreator.java when some paragraphs (such as section headers) need to use a paragraph style other than \"adParagraph\". I'll supply details in a moment.","title":"5.  Cursors and Text Ranges"},{"location":"06-Text_Styles.html#6-building-a-story-document","text":"StoryCreator.java starts by setting the \"adParagraph\" style, then employs readText() to read text from a file and add it to the document: XTextRange xTextRange = doc . getText (). getStart (); Props . setProperty ( xTextRange , \"ParaStyleName\" , \"adParagraph\" ); XTextCursor cursor = Write . getCursor ( doc ); readText ( \"scandal.txt\" , cursor ); Write . endParagraph ( cursor ); readText() assumes the text file has a certain format. For example, \"scandal.txt\" begins like so: Title: A Scandal in Bohemia Author: Sir Arthur Conan Doyle Part I. To Sherlock Holmes she is always THE woman. I have seldom heard him mention her under any other name. In his eyes she eclipses and predominates the whole of her sex. It was not that he felt any emotion akin to love for Irene Adler. All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind. A paragraph is a series of text lines followed by a blank line. But there are exceptions: lines that starts with \"Title: \", \"Author: \" or \"Part \" are treated as headings, and styled differently. When the text above is processed, the resulting document looks like Figure 10. Figure 10. The Output of StoryCreator.java. readText() is implemented using Java's FileReader and BufferedReader: public static void readText ( String fnm , XTextCursor cursor ) /* Write the text in fnm into a Office document. Use current paragraph styling unless the line starts with \"Title: \", \"Author: \", or \"Part \". */ { StringBuilder sb = new StringBuilder ( 0 ); BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( fnm )); System . out . println ( \"Reading text from: \" + fnm ); String line ; while (( line = br . readLine ()) != null ) { // System.out.println(\"<\" + line + \">\"); if ( line . length () == 0 ) { if ( sb . length () > 0 ) Write . appendPara ( cursor , sb . toString ()); sb . setLength ( 0 ); } else if ( line . startsWith ( \"Title: \" )) { Write . appendPara ( cursor , line . substring ( 7 )); Write . stylePrevParagraph ( cursor , \"Title\" ); } else if ( line . startsWith ( \"Author: \" )) { Write . appendPara ( cursor , line . substring ( 8 )); Write . stylePrevParagraph ( cursor , \"Subtitle\" ); } else if ( line . startsWith ( \"Part \" )) { Write . appendPara ( cursor , line ); Write . stylePrevParagraph ( cursor , \"Heading\" ); } else { sb . append ( line + \" \" ); } } if ( sb . length () > 0 ) Write . appendPara ( cursor , sb . toString ()); } catch ( FileNotFoundException ex ) { System . out . println ( \"Could not open: \" + fnm ); } catch ( IOException ex ) { System . out . println ( \"Read error: \" + ex ); } finally { try { if ( br != null ) br . close (); } catch ( IOException ex ) { System . out . println ( \"Problem closing \" + fnm ); } } } // end of readText() The interesting bits are the calls to Write.appendPara() and Write.stylePrevParagraph() which add a paragraph to the document and apply a style to it. For instance: else if ( line . startsWith ( \"Author: \" )) { Write . appendPara ( cursor , line . substring ( 8 )); Write . stylePrevParagraph ( cursor , \"Subtitle\" ); } Write.appendPara() writes the string into the document as a paragraph (the input line without the \"Author: \" substring). Write.stylePrevParagraph() changes the paragraph style from \"adParagraph\" to \"Subtitle\". The hard part of Write.stylePrevParagraph() is making sure that the style change only affects the previous paragraph. Text appended after this line should use \"adParagraph\" styling. public static void stylePrevParagraph ( XTextCursor cursor , Object propVal ) { stylePrevParagraph ( cursor , \"ParaStyleName\" , propVal ); } public static void stylePrevParagraph ( XTextCursor cursor , String propName , Object propVal ) { // save current property Object oldValue = Props . getProperty ( cursor , propName ); // apply property change to previous paragraph XParagraphCursor paraCursor = Lo . qi ( XParagraphCursor . class , cursor ); paraCursor . gotoPreviousParagraph ( true ); // select prev para Props . setProperty ( paraCursor , propName , propVal ); // reset the cursor and property paraCursor . gotoNextParagraph ( false ); Props . setProperty ( cursor , propName , oldValue ); } // end of stylePrevParagraph() The current \"ParaStyleName\" value is stored before changing its value in the selected range. Afterwards, that style name is applied back to the cursor. stylePrevParagraph() changes the XTextCursor into a paragraph cursor so that it's easier to move around across paragraphs. readText() calls Write.stylePrevParagraph() with three style names (\"Title\", \"Subtitle\", and \"Heading\"). I obtained those names from looking at the \"Paragraph Styles\" dialog window in Figure 3.","title":"6.  Building a Story Document"},{"location":"06-Text_Styles.html#7-style-changes-to-words-and-phrases","text":"Aside from changing paragraph styles, it's useful to apply style changes to words or strings inside a paragraph. For example, to highlight a word in bold, or write several words in red italics for emphasis. This is implemented by Write.styleLeft() using a similar approach to Write.stylePrevParagraph(). styleLeft() is passed an integer position which lies to the left of the current cursor position. Character style changes are applied to the text range defined by that distance: public static void styleLeft ( XTextCursor cursor , int pos , String propName , Object propVal ) { // save current property Object oldValue = Props . getProperty ( cursor , propName ); // apply property change to the left of cursor int currPos = getPosition ( cursor ); cursor . goLeft (( short )( currPos - pos ), true ); Props . setProperty ( cursor , propName , propVal ); // reset the cursor and property cursor . goRight (( short )( currPos - pos ), false ); Props . setProperty ( cursor , propName , oldValue ); } // end of styleLeft() An XTextCursor is used to select the range, and the new style is set. Then the cursor is moved back to its old position, and the previous style reapplied. The Write class contain a few support functions that set common styles using styleLeft(): public static void styleLeftBold ( XTextCursor cursor , int pos ) { styleLeft ( cursor , pos , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); } public static void styleLeftItalic ( XTextCursor cursor , int pos ) { styleLeft ( cursor , pos , \"CharPosture\" , com . sun . star . awt . FontSlant . ITALIC ); } public static void styleLeftColor ( XTextCursor cursor , int pos , java . awt . Color col ) { styleLeft ( cursor , pos , \"CharColor\" , Lo . getColorInt ( col )); } public static void styleLeftCode ( XTextCursor cursor , int pos ) // code is text in 10pt Courier New { styleLeft ( cursor , pos , \"CharFontName\" , \"Courier New\" ); styleLeft ( cursor , pos , \"CharHeight\" , 10 ); } The position (the pos value) passed to styleLeft() can be obtained from Write.getPosition(), or as the result of the Write.append() methods. My BuildDoc.java example contains several examples of how to use Write.styleLeft(): // code fragment from BuildDoc.java XTextCursor cursor = Write . getCursor ( doc ); int pos = Write . append ( cursor , \"Some examples of simple text \" ); Write . append ( cursor , \"styles.\\n\" ); Write . styleLeftBold ( cursor , pos ); // bold text back to pos pos = Write . getPosition ( cursor ); Write . appendPara ( cursor , \"This line is written in red italics.\" ); Write . styleLeftColor ( cursor , pos , Color . RED ); // red Write . styleLeftItalic ( cursor , pos ); // italics Write . appendPara ( cursor , \"Back to old style\\n\" ); The resulting text in the document looks like Figure 11. Figure 11. Styled Text. The following fragment from BuildDoc.java applies a 'code' styling to several lines: // code fragment from BuildDoc.java Write . appendPara ( cursor , \"Here's some code:\" ); pos = Write . getPosition ( cursor ); Write . append ( cursor , \"\\npublic class Hello\\n\" ); Write . append ( cursor , \"{\\n\" ); Write . append ( cursor , \" public static void main(String args[]\\n\" ); Write . append ( cursor , \" { System.out.println(\\\"Hello Andrew\\\"); }\\n\" ); Write . appendPara ( cursor , \"} // end of Hello class\\n\" ); Write . styleLeftCode ( cursor , pos ); Figure 12 shows the generated document text. Figure 12. Text with Code Styling. Unfortunately, styleLeft() depend on integer character positions, which are calculated using Write.getPosition(). As I've mentioned before, this method could fail if asked to generate too large a string, and this would cause styleLeft() to die.","title":"7.  Style Changes to Words and Phrases"},{"location":"06-Text_Styles.html#8-hyperlink-styling","text":"Text hyperlinks are implemented as styles, using \"HyperLinkURL\", and perhaps \"HyperLinkName\", and \"HyperLinkTarget\". BuildDoc.java shows how the \"HyperLinkURL\" property is set: Write . appendPara ( cursor , \"A link to my JLOP website:\" ); String urlStr = \"https://fivedots.coe.psu.ac.th/~ad/jlop/\" ; pos = Write . getPosition ( cursor ); Write . append ( cursor , urlStr ); Write . styleLeft ( cursor , pos , \"HyperLinkURL\" , urlStr ); Write . endParagraph ( cursor ); When the document is viewed, the text is drawn as a link as in Figure 13. Figure 13. Text Containing a Hypertext Link. If the user control-clicks on the link, then the URL value of \"HyperLinkURL\" will be loaded into the browser. The \"HyperLinkName\" property specifies a link name, which can be used when searching a document. \"HyperLinkTarget\" corresponds to the HTML hypertext target attribute, and has a default value of \"_self\".","title":"8.  Hyperlink Styling"},{"location":"06-Text_Styles.html#9-text-numbering","text":"It's straightforward to number paragraphs by using Write.styleLeft() and the \"NumberingStyleName\" property. The following code from BuildDoc.java, numbers three paragraphs: // code fragment from BuildDoc.java Write . appendPara ( cursor , \"The following points are important:\" ); pos = Write . appendPara ( cursor , \"Have a good breakfast\" ); Write . appendPara ( cursor , \"Have a good lunch\" ); Write . appendPara ( cursor , \"Have a good dinner\\n\" ); Write . styleLeft ( cursor , pos , \"NumberingStyleName\" , \"Numbering 1\" ); The result is shown in Figure 14. Figure 14. Numbered Paragraphs. \"NumberingStyleName\" is a property in ParagraphProperties, and the \"Numbering 1\" style is from the \"Paragraph Styles\" dialog window in Figure 3. Bullets are drawn instead of numbers by changing the style name to \"List 1\" (see Figure 15). Figure 15. Bulleted Paragraphs. One issue with numbered paragraphs is that their default behavior retains the current count when numbering another group of text. For example, a second group of numbered paragraphs appearing in the document after Figure 14 would start at '4'. This is fixed by setting the \"ParaIsNumberingRestart\" property to true: Write . styleLeft ( cursor , pos , \"ParaIsNumberingRestart\" , true ); One large topic I won\u2019t be looking at is document numbering. This includes the numbering of chapter headings and lines. Chapter and line numbering are dealt with differently from most document styles. Instead of being accessed via XStyleFamiliesSupplier, they employ XChapterNumberingSupplier and XNumberFormatsSupplier. For more details, see the development guide: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Line_Numbering_and_Outline_Numbering/ or type loGuide \"Line Numbering\" .","title":"9.  Text Numbering"},{"location":"06-Text_Styles.html#10-other-style-changes","text":"StoryCreator.java illustrates three other styling effects: the creation of a header, setting the page to A4 format, and employing page numbers in the footer. The relevant calls are: // code fragment in StoryCreator.java Write . setHeader ( doc , \"From: \" + args [ 0 ] ); Write . setA4PageFormat ( doc ); Write . setPageNumbers ( doc ); Write.setA4PageFormat() sets the page formatting. Write.setPageNumbers() utilizes text fields, which I'll examine in the \"Text Fields\" section in Chapter 7. Changing the header in Write.setHeader() requires the setting of the \"HeaderIsOn\" boolean in the \"Standard\" page style. Adding text to the header is done via an XText reference. The code for Write.setHeader(): public static void setHeader ( XTextDocument textDoc , String hText ) /* Modify the header via the page style for the document. Put the text on the right hand side in the header in Times New Roman, 10pt */ { XPropertySet props = Info . getStyleProps ( textDoc , \"PageStyles\" , \"Standard\" ); if ( props == null ) { System . out . println ( \"Could not access standard page style\" ); return ; } try { props . setPropertyValue ( \"HeaderIsOn\" , true ); // header is turned on in the document // access the header's XText and cursor XText headerText = Lo . qi ( XText . class , props . getPropertyValue ( \"HeaderText\" )); XTextCursor headerCursor = headerText . createTextCursor (); headerCursor . gotoEnd ( false ); // header is on the rhs and in Times New Roman, 10pt XPropertySet headerProps = Lo . qi ( XPropertySet . class , headerCursor ); headerProps . setPropertyValue ( \"CharFontName\" , \"Times New Roman\" ); headerProps . setPropertyValue ( \"CharHeight\" , 10 ); headerProps . setPropertyValue ( \"ParaAdjust\" , ParagraphAdjust . RIGHT ); headerText . setString ( hText + \"\\n\" ); } catch ( Exception ex ) { System . out . println ( ex ); } } // end of setHeader() The header's XText reference is retrieved via the page style's \"HeaderText\" property, and a cursor is created local to the header: XTextCursor headerCursor = headerText . createTextCursor (); This cursor can only move around inside the header not the entire document. The properties of the header's XText are changed using the cursor, and then the text is added.","title":"10.  Other Style Changes"},{"location":"07-Non-text_Content.html","text":"Chapter 7. Text Content Other than Strings \u00b6 Topics Accessing Text Content; Text Frames; Embedded Objects (Math Formulae); Text Fields; Text Tables; Bookmarks Example folders: \"Text Tests\" and \"Utils\" Chapter 5 looked at using text cursors to move around inside text documents, adding or extracting text strings. That chapter utilized the XText inheritance hierarchy, which is shown again in Figure 1. Figure 1. XText and its Superclasses. The documents manipulated in Chapter 5 only contained character-based text, but can be a lot more varied, including text frames, embedded objects, graphics, shapes, text fields, tables, bookmarks, text sections, footnotes and endnotes, and more. From the XText service its possible to access the XTextContent interface (see Figure 1), which belongs to the TextContent service. As Figure 2 indicates, that service is the parent of many subclasses which represent different kinds of text document content. Figure 2. The TextContent Service and Some Subclasses. A more complete hierarchy can be found in the documentation for TextContent ( lodoc TextContent service ). The two services highlighted in orange relate to graphical content, which is explained in the next chapter. Table 1 summarizes content types in terms of their services and access methods. Most of the methods are in Supplier interfaces which are part of the GenericTextDocument or OfficeDocument services in Figure 2 of Chapter 5. If the service text is in bold then there's an example of how to manipulate its content later in this chapter. Content Name Service for Creating Content Access Method in Supplier Text Frame TextFrame XNameAccess XTextFrameSupplier. getTextFrames() Embedded Object TextEmbeddedObject XComponent XTextEmbeddedObjectSupplier2. getEmbeddedObject() Graphic Object TextGraphicObject; XNameAccess XTextGraphicObjectsSupplier. getGraphicObjects() Shape text.Shape, drawing.Shape XDrawPage XDrawPageSupplier. or a subclass getDrawPage() Text Field TextField XEnumerationAccess XTextFieldsSupplier. getTextFields() Text Table TextTable XNameAccess XTextTablesSupplier. getTextTables() Bookmark Bookmark XNameAccess XBookmarksSupplier. getBookmarks() Paragraph Paragraph XEnumerationAccess on XText Text Section TextSection XNameAccess XTextSectionsSupplier. getTextSections() Footnote Footnote XIndexAccess XFootnotesSupplier. getFootnotes() End Note Endnote XIndexAccess XEndnotesSupplier.getEndnotes() Reference Mark ReferenceMark XNameAccess XReferenceMarksSupplier. getReferenceMarks() Index DocumentIndex XIndexAccess XDocumentIndexesSupplier. getDocumentIndexes() Link Target LinkTarget XNameAccess XLinkTargetSupplier.getLinks() Redline RedlinePortion XEnumerationAccess XRedlinesSupplier. getRedlines() Content Metadata InContentMetaData XDocumentMetadataAccess Table 1. Creating and Accessing Text Content. Rows 3 and 4 are highlighted to indicate that graphical content is discussed in the next chapter. 1. How to Access Text Content \u00b6 Most of the examples in this chapter create text document content rather than access it. This is mainly because the different access functions work in a similar way, so you don\u2019t need many examples to get the general idea. First the document is converted into a supplier, then its getXXX() method is called (see column 3 of Table 1). For example, accessing the graphic objects in a document (see row 3 of Table 1) requires: // get the graphic objects supplier XTextGraphicObjectsSupplier imsSupplier = Lo . qi ( XTextGraphicObjectsSupplier . class , doc ); // access the graphic objects collection XNameAccess xNameAccess = imsSupplier . getGraphicObjects (); The names associated with the graphic objects in XNameAccess can be extracted with XNameAccess.getElementNames(), and printed: String [] names = xNameAccess . getElementNames (); System . out . println ( \"Number of graphic names: \" + names . length ); Arrays . sort ( names ); // sort them, if you want Lo . printNames ( names ); // useful for printing long lists A particular object in an XNameAccess collection is retrieved with getByName(): XInterface oGraphic = xNameAccess . getByName ( \"foo\" ); // get graphic object called \"foo\" XInterface is the Office equivalent of Java's Object: every interface subclasses XInterface. A common next step is to convert the object into a property set, which makes it possible to lookup the properties stored in the object's service. For instance, the graphic object\u2019s filename or URL can be retrieved using: XPropertySet props = Lo . qi ( XPropertySet . class , oGraphic ); String fnm = ( String ) props . getPropertyValue ( \"GraphicURL\" ); I know the graphic object's URL is stored in the \"GraphicURL\" property from looking at the documentation for the TextGraphicObject service. It can be (almost) directly accessed by typing lodoc TextGraphicObject service ; unfortunately DuckDuckGo chooses the TextGraphicObjects service, and you need to click on the \"TextGraphicObject\" link below the title to get to the required page. It's possible to call setPropertyValue() to change a property: props.setPropertyValue(\"Transparency\", (short)50); What About the Text Content I Don't Cover? Table 1 has many rows without bold entries, which means I won't be looking at them. except for the very brief descriptions here; for more please consult the Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Working_with_Text_Documents/ (or type loGuide \"Working with Text Documents\" ). All the examples in that section are in TextDocuments.java at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text . Text Sections. A text section is a grouping of paragraphs which can be assigned their own style settings. More usefully, a section may be located in another file, which is the mechanism underlying master documents. See: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Sections/ (or type loGuide \"Text Sections\" ). Footnotes and Endnotes. Footnotes and endnotes are blocks of text that appear in the page footers and at the end of a document. They can be treated as XText objects, so manipulated using the same techniques as the main document text. See: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Footnotes_and_Endnotes/ (or type loGuide Footnotes ). Reference Marks. Reference marks can be inserted throughout a document, and then jumped to via GetReference text fields: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Reference_Marks/ (or type loGuide \"Reference Marks\" ). Indexes and Index Marks. Index marks, like reference marks, can be inserted anywhere in a document, but are used to generate indices (collections of information) inside the document. There are several types of index marks used for generating lists of chapter headings (i.e. a book's index), lists of key words, illustrations, tables, and a bibliography. For details see: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Indexes_and_Index_Marks/ (or type loGuide Indexes ). Link Targets. A link target (sometimes called a jump mark) labels a location inside a document. These labels can be included as part of a filename so that the document can be opened at that position. For information, see: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Link_Targets/ (or type loGuide \"Link Targets\" ). Redlines. Redlines are the changes recorded when a user edits a document with track changes turned on. Each of the changes is saved as a text fragment (also called a text portion) inside a redline object. See: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Redline/ (or type loGuide Redline ). 2. Adding a Text Frame to a Document \u00b6 The TextFrame service inherits many of its properties and interfaces, so its inheritance hierarchy is shown in detail in Figure 3. Figure 3. The TextFrame Service Hierarchy. Figure 3 includes two sibling services of TextFrame: TextEmbeddedObject and TextGraphicObject, which I'll discuss a bit later; infact, I'll only get around to TextGraphicObject in the next chapter. The BaseFrameProperties service contains most of the frame size and positional properties, such as \"Width\", \"Height\", and margin and border distance settings. A TextFrame interface can be converted into a text content (i.e. XTextContent) or a shape (i.e. XShape). Typically, the former is used when adding text to the frame, the latter when manipulating the shape of the frame. In my BuildDoc.java example, text frame creation is done by Write.addTextFrame(), with BuildDoc supplying the frame's y-axis coordinate position for its anchor: // code fragment in BuildDoc.java XTextViewCursor tvc = Write . getViewCursor ( doc ); int yPos = tvc . getPosition (). Y ; // y-axis anchor position : // other unrelated code Write . appendPara ( cursor , \"A text frame\" ); Write . addTextFrame ( cursor , yPos , \"This is a newly created text frame.\\n Which is over on the right of the page, next to the code.\" , 4000 , 1500 ); // width x height of frame An anchor specifies how the text content is positioned relative to the ordinary text around it. Anchoring can be relative to a character, paragraph, page, or another frame. Write.addTextFrame() uses page anchoring, which means that BuildDoc must obtain a view cursor, so that an on-screen page position can be calculated. As Figure 4 shows, the text frame is located on the right of the page, with its top edge level with the start of the code listing. Figure 4. Text Frame Position in the Document. In the code fragment above, Write.getViewCursor() creates the view cursor, and XTextViewCursor.getPosition() returns its (x, y) coordinate on the page. The y- coordinate is stored in yPos until after the code listing has been inserted into the document, and then passed to Write.addTextFrame(). Write.addTextFrame() is defined as: public static void addTextFrame ( XTextCursor cursor , int yPos , String text , int width , int height ) { try { XTextFrame xFrame = Lo . createInstanceMSF ( XTextFrame . class , \"com.sun.star.text.TextFrame\" ); if ( xFrame == null ) { System . out . println ( \"Could not create a text frame\" ); return ; } // convert frame to a shape interface; set size XShape tfShape = Lo . qi ( XShape . class , xFrame ); tfShape . setSize ( new Size ( width , height )); // get properties of the frame XPropertySet frameProps = Lo . qi ( XPropertySet . class , xFrame ); // anchor the text frame to the page frameProps . setPropertyValue ( \"AnchorType\" , TextContentAnchorType . AT_PAGE ); frameProps . setPropertyValue ( \"FrameIsAutomaticHeight\" , true ); // will grow if necessary // add a red border around all 4 sides BorderLine border = new BorderLine (); border . OuterLineWidth = 1 ; border . Color = 0xFF0000 ; // red frameProps . setPropertyValue ( \"TopBorder\" , border ); frameProps . setPropertyValue ( \"BottomBorder\" , border ); frameProps . setPropertyValue ( \"LeftBorder\" , border ); frameProps . setPropertyValue ( \"RightBorder\" , border ); // make the text frame blue frameProps . setPropertyValue ( \"BackTransparent\" , false ); // not transparent frameProps . setPropertyValue ( \"BackColor\" , 0xCCCCFF ); // blue // set the horizontal and vertical position frameProps . setPropertyValue ( \"HoriOrient\" , HoriOrientation . RIGHT ); frameProps . setPropertyValue ( \"VertOrient\" , VertOrientation . NONE ); frameProps . setPropertyValue ( \"VertOrientPosition\" , yPos ); // down from top // insert empty text frame into document append ( cursor , xFrame ); endParagraph ( cursor ); // add text to the text frame XText xFrameText = xFrame . getText (); XTextCursor xFrameCursor = xFrameText . createTextCursor (); xFrameText . insertString ( xFrameCursor , text , false ); } catch ( Exception e ) { System . out . println ( \"Insertion of text frame failed: \" + e ); } } // end of addTextFrame() addTextFrame() starts by creating a TextFrame service, and accessing its XTextFrame interface: XTextFrame xFrame = Lo . createInstanceMSF ( XTextFrame . class , \"com.sun.star.text.TextFrame\" ); The service name for a text frame is listed as \"TextFrame\" in row 1 of Table 1, but Lo.createInstanceMSF() requires a fully qualified name. Almost all the text content services, including TextFrame, are in the com.sun.star.text package. The XTextFrame interface is converted into XShape so the frame's dimensions can be set. The interface is also cast to XPropertySet so that various frame properties can be initialized; these properties are defined in the TextFrame and BaseFrameProperties services (see Figure 3). The \"AnchorType\" property uses the AT_PAGE anchor constant to tie the frame to the page. There are five anchor constants: AT_PARAGRAPH, AT_CHARACTER, AS_CHARACTER, AT_PAGE, and AT_FRAME, which are defined in the TextContentAnchorType enumeration. The difference between AT_CHARACTER and AS_CHARACTER relates to how the surrounding text is wrapped around the text content. \"AS\" means that the text content is treated as a single (perhaps very large) character inside the text, while \"AT\" means that the text frame's upper-left corner is positioned at that character location. The frame's page position is dealt with a few lines later by the \"HoriOrient\" and \"VertOrient\" properties. The HoriOrientation and VertOrientation constants are a convenient way of positioning a frame at the corners or edges of the page. However, I use \"VertOrientPosition\" to set the vertical position using the yPos coordinate, and switch off the \"VertOrient\" vertical orientation. Towards the end of Write.addTextFrame(), the frame is added to the document by calling a version of Write.append() that expects an XTextContent object: // in the Write class public static int append ( XTextCursor cursor , XTextContent textContent ) // append text content such as a text frame, table, text field { XText xText = cursor . getText (); xText . insertTextContent ( cursor , textContent , false ); cursor . gotoEnd ( false ); return getPosition ( cursor ); } It utilizes the XText.insertTextContent() method. The last task of Write.addTextFrame(), is to insert some text into the frame. XTextFrame inherits XTextContent, and so has access to the getText() method (see Figure 3). This means that all the text manipulations possible in a document are also possible inside a frame. The ordering of the tasks at the end of addTextFrame() is important. Office prefers that an empty text content be added to the document, and the data inserted afterwards. 3. Adding a Text Embedded Object to a Document \u00b6 Text embedded object content support OLE (Microsoft's Object Linking and Embedding), and is typically used to create a frame linked to an external Office document. Probably, its most popular use is to link to a chart, but I'll delay looking at that until Chapter 33. The best way of getting an idea of what OLE objects are available is to go to the Writer application's Insert menu, Object, \"OLE Object\" dialog. In my version of Office, it lists Office spreadsheet, chart, drawing, presentation, and formula documents, and a range of Microsoft and PDF types. Note that text embedded objects aren't utilized for adding graphics to a document. That's easier to do using the TextGraphicObject or GraphicObjectShape services, which I'll describe next. In this section I'll explain how to insert mathematical formulae into a text document. The example code is in MathQuestions.java, but most of the formula embedding is performed by Write.addFormula(): public static void addFormula ( XTextCursor cursor , String formula ) { try { XTextContent embedContent = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.TextEmbeddedObject\" ); if ( embedContent == null ) { System . out . println ( \"Could not create a formula\" ); return ; } // get property set for the embedded object XPropertySet props = Lo . qi ( XPropertySet . class , embedContent ); // set class ID (type) for object props . setPropertyValue ( \"CLSID\" , Lo . MATH_CLSID ); // anchor object as a character props . setPropertyValue ( \"AnchorType\" , TextContentAnchorType . AS_CHARACTER ); // insert empty object into document append ( cursor , embedContent ); endLine ( cursor ); // access object's model XEmbeddedObjectSupplier2 supp = Lo . qi ( XEmbeddedObjectSupplier2 . class , embedContent ); XComponent oEmbed = supp . getEmbeddedObject (); // insert formula into the object XPropertySet formulaProps = Lo . qi ( XPropertySet . class , oEmbed ); formulaProps . setPropertyValue ( \"Formula\" , formula ); } catch ( Exception e ) { System . out . println ( \"\\\"\" + formula + \"\\\" failed: \" + e ); } } // end of addFormula() A math formula is passed to addFormula() as a string in a format I'll explain shortly. The method begins by creating a TextEmbeddedObject service, and referring to it using the XTextContent interface: XTextContent embedContent = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.TextEmbeddedObject\" ); Details about embedded objects are given in row 2 of Table 1. Unlike TextFrame which has an XTextFrame interface, there's no XTextEmbeddedObject interface for TextEmbeddedObject. This can be confirmed by looking at the TextFrame inheritance hierarchy in Figure 3. There is an XEmbeddedObjectSuppler, but that's for accessing objects, not creating them. Instead I've utilized the XTextContent interface in Lo.createInstanceMSF() because it's the most specific interface available. The XTextContent interface is converted to XPropertySet so the \"CLSID\" and \"AnchorType\" properties can be set. \"CLSID\" is specific to TextEmbeddedObject \u2013 its value is the OLE class ID for the embedded document. The Lo.java utility contains the class ID constants for Office's documents: // in the Lo class public static final String WRITER_CLSID = \"8BC6B165-B1B2-4EDD-aa47-dae2ee689dd6\" ; public static final String CALC_CLSID = \"47BBB4CB-CE4C-4E80-a591-42d9ae74950f\" ; public static final String DRAW_CLSID = \"4BAB8970-8A3B-45B3-991c-cbeeac6bd5e3\" ; public static final String IMPRESS_CLSID = \"9176E48A-637A-4D1F-803b-99d9bfac1047\" ; public static final String MATH_CLSID = \"078B7ABA-54FC-457F-8551-6147e776a997\" ; public static final String CHART_CLSID = \"12DCAE26-281F-416F-a234-c3086127382e\" ; The \"AnchorType\" property is set to AS_CHARACTER so the formula string will be anchored in the document in the same way as a string of characters. As with the text frame in Write.addTextFrame(), an empty text content is added to the document first, then filled with the formula. The embedded object's content is accessed via the XEmbeddedObjectSupplier2 interface which has a get method for obtaining the object: XEmbeddedObjectSupplier2 supp = Lo . qi ( XEmbeddedObjectSupplier2 . class , embedContent ); XComponent oEmbed = supp . getEmbeddedObject (); The properties for this empty object (oEmbed) are accessed, and the formula string is assigned to the \"Formula\" property: XPropertySet formulaProps = Lo.qi(XPropertySet.class, oEmbed); formulaProps.setPropertyValue(\"Formula\", formula); 3.1. What's a Formula String? \u00b6 Although I've explained the working of Write.addFormula(), I haven't explained the format of the formula string that's passed to it. There's a good overview of the notation in the \"Commands Reference\" appendix of Office's \"Math Guide\", available at https://libreoffice.org/get-help/documentation/ For example, the formula string: \"1 {5}over{9} + 3 {5}over{9} = 5 {1}over{9}\" is rendered as: [*** Formula did not render in MarkDown ***] 3.2. Building Formulae \u00b6 MathQuestions.java is mainly a for-loop for randomly generating numbers and constructing simple formulae strings. Ten formulae are added to the document, which is saved as \"mathQuestions.pdf\". The main() function: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } XTextCursor cursor = Write . getCursor ( doc ); Write . appendPara ( cursor , \"Math Questions\" ); Write . stylePrevParagraph ( cursor , \"Heading 1\" ); Write . appendPara ( cursor , \"Solve the formulae for x:\\n\" ); Random r = new Random (); String formula ; for ( int i = 0 ; i < 10 ; i ++ ) { // generate 10 formulae int iA = r . nextInt ( 8 ) + 2 ; // generate some integers int iB = r . nextInt ( 8 ) + 2 ; int iC = r . nextInt ( 9 ) + 1 ; int iD = r . nextInt ( 8 ) + 2 ; int iE = r . nextInt ( 9 ) + 1 ; int iF1 = r . nextInt ( 8 ) + 2 ; int choice = r . nextInt ( 3 ); // decide between 3 formulae if ( choice == 0 ) formula = \"{{{sqrt{\" + iA + \"x}} over \" + iB + \"} + {\" + iC + \" over \" + iD + \"}={\" + iE + \" over \" + iF1 + \"}}\" ; else if ( choice == 1 ) formula = \"{{{\" + iA + \"x} over \" + iB + \"} + {\" + iC + \" over \" + iD + \"}={\" + iE + \" over \" + iF1 + \"}}\" ; else formula = \"{\" + iA + \"x + \" + iB + \" =\" + iC + \"}\" ; Write . addFormula ( cursor , formula ); Write . endParagraph ( cursor ); } Write . append ( cursor , \"Timestamp: \" + Lo . getTimeStamp () + \"\\n\" ); Lo . saveDoc ( doc , \"mathQuestions.pdf\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Figure 5 shows a screenshot of part of mathQuestions.pdf. Figure 5. Math Formulae in a Text Document. 4. Text Fields \u00b6 A text field differs from other text content in that its data is generated dynamically by the document, or by an external source such as a database . Document-generated text fields include text showing the current date, the page number, the total number of pages in the document, and cross-references to other areas in the text. I'll look at three examples: the DateTime, PageNumber, and PageCount text fields. When a text field depends on an external source, there are two fields to initialize: the master field representing the external source, and the dependent field for the data used in the document; only the dependent field is visible. I won't be giving any dependent/master field examples, but there's one in the Development Guide section on text fields, at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Fields/ (or type loGuide \"Text Fields\" ). It utilizes the User master field, which allows the external source to be user-defined data. The code appears in the TextDocuments.java example at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text/ . Different kinds of text field are implemented as subclasses of the TextField service. You can see the complete hierarchy in the online documentation for TextField ( lodoc TextField service ). Figure 6 presents a simplified version. Figure 6. Simplified Hierarchy for the TextField Service. 4.1. The DateTime TextField \u00b6 The BuildDoc.java example ends with a few lines that appear to do the same thing twice: // code fragment from BuildDoc.java Write . appendPara ( cursor , \"\\nTimestamp: \" + Lo . getTimeStamp () + \"\\n\" ); Write . append ( cursor , \"Time (according to office): \" ); Write . appendDateTime ( cursor ); Write . endParagraph ( cursor ); Lo.getTimeStamp() inserts a timestamp (which includes the date and time), and then Write.appendDateTime() inserts the date and time. Although these may seem to be the same, getTimeStamp() adds a string while appendDateTime() creates a text field. The difference becomes apparent if you open the file some time after it was created. Figure 7 shows two screenshots of the time-stamped parts of the document taken after it was first generated, and nearly 50 minutes later. Figure 7. Screenshots of the Timestamps. The text field timestamp is updated each time the file is opened in edit mode (which is the default in Writer). This dynamic updating occurs in all text fields. For example, if you add some pages to a document, all the places in the document that use the PageCount text field will be updated to show the new length. Write.appendDateTime() creates a DateTime service, and returns its XTextField interface (see Figure 6). The TextField service only contains two properties, with most being in the subclass (DateTime in this case). public static int appendDateTime ( XTextCursor cursor ) { XTextField dtField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.DateTime\" ); Props . setProperty ( dtField , \"IsDate\" , true ); // so date is reported append ( cursor , dtField ); append ( cursor , \"; \" ); dtField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.DateTime\" ); Props . setProperty ( dtField , \"IsDate\" , false ); // so time is reported return append ( cursor , dtField ); } // end of appendDateTime() The method adds two DateTime text fields to the document. The first has its \"IsDate\" property set to true, so that the current date is inserted; the second sets \"IsDate\" to false so the current time is shown. 4.2. The PageNumber and PageCount Text Fields \u00b6 I discussed most of StoryCreator.java in Chapter 6 on styles, but skipped over how page numbers were added to the document's page footer. The footer is shown in Figure 8. Figure 8. Page Footer using Text Fields. Write.setPageNumbers() inserts the PageNumber and PageCount text fields into the footer's text area: // in the Write class public static void setPageNumbers ( XTextDocument textDoc ) { // get 'standard' style for page style family XPropertySet props = Info . getStyleProps ( textDoc , \"PageStyles\" , \"Standard\" ); if ( props == null ) { System . out . println ( \"Could not access standard page style\" ); return ; } try { props . setPropertyValue ( \"FooterIsOn\" , Boolean . TRUE ); // footer must be turned on in the document // access the footer as XText XText footerText = Lo . qi ( XText . class , props . getPropertyValue ( \"FooterText\" )); XTextCursor footerCursor = footerText . createTextCursor (); /* set footer text properties via its cursor: font, font size, paragraph orientation */ Props . setProperty ( footerCursor , \"CharFontName\" , \"Times New Roman\" ); Props . setProperty ( footerCursor , \"CharHeight\" , 12.0f ); Props . setProperty ( footerCursor , \"ParaAdjust\" , ParagraphAdjust . CENTER ); // add text fields to the footer append ( footerCursor , getPageNumber ()); append ( footerCursor , \" of \" ); append ( footerCursor , getPageCount ()); } catch ( Exception ex ) { System . out . println ( ex ); } } // end of setPageNumbers() public static XTextField getPageNumber () // return Arabic style number showing current page value { XTextField numField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.PageNumber\" ); Props . setProperty ( numField , \"NumberingType\" , NumberingType . ARABIC ); Props . setProperty ( numField , \"SubType\" , PageNumberType . CURRENT ); return numField ; } public static XTextField getPageCount () // return Arabic style number showing current page count { XTextField pcField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.PageCount\" ); Props . setProperty ( pcField , \"NumberingType\" , NumberingType . ARABIC ); return pcField ; } Write.setPageNumbers() starts by accessing the \"Standard\" property set (style) for the page style family. Via its properties, the method turns on footer functionality and accesses the footer text area as an XText object. An XTextCursor is created for the footer text area, and properties are configured: XText footerText = Lo . qi ( XText . class , props . getPropertyValue ( \"FooterText\" )); XTextCursor footerCursor = footerText . createTextCursor (); Props . setProperty ( footerCursor , \"CharFontName\" , \"Times New Roman\" ); These properties will be applied to the text and text fields added afterwards: append ( footerCursor , getPageNumber ()); append ( footerCursor , \" of \" ); append ( footerCursor , getPageCount ()); getPageNumber() and getPageCount() deal with the properties for the PageNumber and PageCount fields. I found out about them by looking at the documentation for their services (e.g. use lodoc TextField.PageNumber service; \"TextField.\" is needed due to PageNumber being a common word). 5. Adding a Text Table to a Document \u00b6 The MakeTable.java example reads in data about James Bond movies from \"bondMovies.txt\" and stores it as a text table in \"table.odt\". The first few rows are shown in Figure 9. Figure 9. A Bond Movies Table. The \"bondMovies.txt\" file is read by readTable() utilizing standard Java file processing. It returns a list of String arrays: ArrayList < String []> rowsList = readTable ( \"bondMovies.txt\" ); Each line in \"bondMovies.txt\" is converted into a string array by pulling out the substrings delimited by tab characters. readTable() ignores blank lines in the file, and lines beginning with \"//\". Also, I assume that the first row in the list contains the table's header text. The first few lines of \"bondMovies.txt\" are: // https://en.wikipedia.org/wiki/James_Bond#Ian_Fleming_novels Title Year Actor Director Dr. No 1962 Sean Connery Terence Young From Russia with Love 1963 Sean Connery Terence Young Goldfinger 1964 Sean Connery Guy Hamilton Thunderball 1965 Sean Connery Terence Young You Only Live Twice 1967 Sean Connery Lewis Gilbert On Her Majesty's Secret Service 1969 George Lazenby Peter R. Hunt Diamonds Are Forever 1971 Sean Connery Guy Hamilton Live and Let Die 1973 Roger Moore Guy Hamilton The Man with the Golden Gun 1974 Roger Moore Guy Hamilton : The main() function for MakeTable.java is: public static void main ( String args [] ) { ArrayList < String []> rowsList = readTable ( \"bondMovies.txt\" ); if ( rowsList . size () == 0 ) { System . out . println ( \"No data read from bondMovies.txt\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } XTextCursor cursor = Write . getCursor ( doc ); Write . appendPara ( cursor , \"Table of Bond Movies\" ); Write . stylePrevParagraph ( cursor , \"Heading 1\" ); Write . appendPara ( cursor , \"The following table comes from \\\"bondMovies.txt\\\":\\n\" ); Write . addTable ( cursor , rowsList ); Write . endParagraph ( cursor ); Write . append ( cursor , \"Timestamp: \" + Lo . getTimeStamp () + \"\\n\" ); Lo . saveDoc ( doc , \"table.odt\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Write.addTable() does the work of converting the list of rows into a text table. Figure 10 shows the hierarchy for the TextTable service: it's a subclass of TextContent and supports the XTextTable interface. Figure 10. The TextTable Hierarchy. XTextTable contains methods for accessing a table in terms of its rows, columns, and cells. The cells are referred to using names, based on letters for columns and integers for rows, as in Figure 11. Figure 11. The Cell Names in a Table. Write.addTable() uses this naming scheme in the XTextTable.getCellByName() method to assign data to cells: public static void addTable ( XTextCursor cursor , ArrayList < String []> rowsList ) // part of the Write utility class { try { // create a text table XTextTable table = Lo . createInstanceMSF ( XTextTable . class , \"com.sun.star.text.TextTable\" ); if ( table == null ) { System . out . println ( \"Could not create a text table\" ); return ; } // initialize table dimensions int numRows = rowsList . size (); int numCols = ( rowsList . get ( 0 )). length ; if ( numCols > 26 ) { // column labelling goes from 'A' to 'Z' System . out . println ( \"Too many columns: \" + numCols + \"; using first 26\" ); numCols = 26 ; } table . initialize ( numRows , numCols ); // add the table to the document append ( cursor , table ); endParagraph ( cursor ); // set table properties XPropertySet tableProps = Lo . qi ( XPropertySet . class , table ); tableProps . setPropertyValue ( \"BackTransparent\" , false ); // not transparent tableProps . setPropertyValue ( \"BackColor\" , 0xCCCCFF ); // light blue // set color of first row (i.e. the header) to dark blue XTableRows rows = table . getRows (); Props . setProperty ( rows . getByIndex ( 0 ), \"BackColor\" , 0x666694 ); // dark blue // write table header String [] rowData = rowsList . get ( 0 ); for ( int x = 0 ; x < numCols ; x ++ ) setCellHeader ( mkCellName ( x , 1 ), rowData [ x ] , table ); // e.g. \"A1\", \"B1\", \"C1\", etc. // insert table body for ( int y = 1 ; y < numRows ; y ++ ) { // start in 2nd row of list rowData = rowsList . get ( y ); for ( int x = 0 ; x < numCols ; x ++ ) setCellText ( mkCellName ( x , y + 1 ), rowData [ x ] , table ); // e.g. \"A2\", \"B5\", \"C3\", etc. } } catch ( Exception e ) { System . out . println ( \"Table insertion failed:\" + e ); } } // end of addTable() A TextTable service with an XTableText interface is created at the start of addTable(). Then the required number of rows and columns is calculated so that XTextTable.initialize() can be called to specify the table's dimensions. Table-wide properties are set (properties are listed in the TextTable documentation). Note that if \"BackTransparent\" isn't set to false then Office crashes when the program tries to save the document. The color property of the header row is set to dark blue. This requires a call to XTextTable.getRows() to return an XTableRows object representing all the rows. This object inherits XIndexAccess, so the first row is accessed with index 0. The filling of the table with data is performed by two loops. The first deals with adding text to the header row, the second deals with all the other rows. mkCellName() converts an (x, y) integer pair into a cell name like those in Figure 11: public static String mkCellName ( int x , int y ) { return \"\" + (( char )( 'A' + x )) + y ; } Write.setCellHeader() uses TextTable.getCellByName() to access a cell, which is of type XCell. We'll study XCell in Part 4 because it's used for representing cells in a spreadsheet. The Cell service supports both the XCell and XText interfaces, as in Figure 12. Figure 12. The Cell Service. This means that Lo.qi() can convert an XCell instance into XText, which makes the cell's text and properties accessible to a text cursor. Write.setCellHeader() implements these features: private static void setCellHeader ( String cellName , String data , XTextTable table ) // puts text into the named cell of the table, colored white { // convert XCell to XText XText cellText = Lo . qi ( XText . class , table . getCellByName ( cellName )); // create a cursor inside the cell XTextCursor textCursor = cellText . createTextCursor (); Props . setProperty ( textCursor , \"CharColor\" , 0xFFFFFF ); // use white text cellText . setString ( data ); } // end of setCellHeader() The cell's \"CharColor\" property is changed so the inserted text in the header row is white, as in Figure 9. Write.setCellText() is shorter than setCellHeader() because there's no need to change the text's color: private static void setCellText ( String cellName , String data , XTextTable table ) // puts text into the named cell of the table { XText cellText = Lo . qi ( XText . class , table . getCellByName ( cellName )); cellText . setString ( data ); } // end of setCellText() 6. Adding a Bookmark to the Document \u00b6 Write.addBookmark() adds a named bookmark at the current cursor position: public static void addBookmark ( XTextCursor cursor , String name ) { XTextContent bmkContent = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.Bookmark\" ); if ( bmkContent == null ) { System . out . println ( \"Could not create a bookmark\" ); return ; } // convert bookmark content to a named collection XNamed bmksNamed = Lo . qi ( XNamed . class , bmkContent ); bmksNamed . setName ( name ); append ( cursor , bmkContent ); endParagraph ( cursor ); } // end of addBookmark() The Bookmark service doesn't have a specific interface (such as XBookmark), so Lo.createInstanceMSF() returns an XTextContent interface. These services and interfaces are summarized by Figure 13. Figure 13. The Bookmark Service and Interfaces. Bookmark supports XNamed, which allows it to be viewed as a named collection of bookmarks (note the plural). This is useful when searching for a bookmark or adding one, as in the BuildDoc.java example. It calls Write.addBookmark() to add a bookmark called \"ad-Bookmark\" to the document: // code fragment from BuildDoc.java Write . append ( cursor , \"This line ends with a bookmark\" ); Write . addBookmark ( cursor , \"ad-bookmark\" ); Bookmarks, such as \"ad-bookmark\", are not rendered when the document is opened, which means that nothing appears after the \"The line ends with a bookmark.\" string in \"build.odt\". However, bookmarks are listed in Writer's \"Navigator\" window (press F5), as in Figure 14. Figure 14. The Writer Navigator Window. Clicking on the bookmark causes Writer to jump to its location in the document. Using Bookmarks One programming use of bookmarks is for moving a cursor around a document. Just as with real-world bookmarks, you can add one at some important location in a document and jump to that position at a later time. Write.findBookmark() finds a bookmark by name, returning it as an XTextContent instance: public static XTextContent findBookmark ( XTextDocument doc , String bmName ) { XBookmarksSupplier supplier = Lo . qi ( XBookmarksSupplier . class , doc ); if ( supplier == null ) { System . out . println ( \"Bookmark supplier could not be created\" ); return null ; } XNameAccess namedBookmarks = supplier . getBookmarks (); if ( namedBookmarks == null ) { System . out . println ( \"Name access to bookmarks not possible\" ); return null ; } if ( ! namedBookmarks . hasElements ()) { System . out . println ( \"No bookmarks found\" ); return null ; } // find the specified bookmark Object oBookmark = null ; try { oBookmark = namedBookmarks . getByName ( bmName ); } catch ( com . sun . star . uno . Exception e ) {} if ( oBookmark == null ) { System . out . println ( \"Bookmark \\\"\" + bmName + \"\\\" not found\" ); return null ; } // there's no XBookmark, so return XTextContent return Lo . qi ( XTextContent . class , oBookmark ); } // end of findBookmark() findBookmark() can't return an XBookmark object since there's no such interface (see Figure 13), but XTextContent is a good alternative. XTextContent has a getAnchor() method which returns an XTextRange that can be used for positioning a cursor. The following code fragment from BuildDoc.java illustrates the idea: // code fragment from BuildDoc.java XTextContent bookmark = Write . findBookmark ( doc , \"ad-bookmark\" ); XTextRange bmRange = bookmark . getAnchor (); XTextViewCursor viewCursor = Write . getViewCursor ( doc ); viewCursor . gotoRange ( bmRange , false ); The call to gotoRange() moves the view cursor to the \"ad-bookmark\" position, which causes an on-screen change. gotoRange() can be employed with any type of cursor.","title":"Chapter 7. Text Content Other than Strings"},{"location":"07-Non-text_Content.html#chapter-7-text-content-other-than-strings","text":"Topics Accessing Text Content; Text Frames; Embedded Objects (Math Formulae); Text Fields; Text Tables; Bookmarks Example folders: \"Text Tests\" and \"Utils\" Chapter 5 looked at using text cursors to move around inside text documents, adding or extracting text strings. That chapter utilized the XText inheritance hierarchy, which is shown again in Figure 1. Figure 1. XText and its Superclasses. The documents manipulated in Chapter 5 only contained character-based text, but can be a lot more varied, including text frames, embedded objects, graphics, shapes, text fields, tables, bookmarks, text sections, footnotes and endnotes, and more. From the XText service its possible to access the XTextContent interface (see Figure 1), which belongs to the TextContent service. As Figure 2 indicates, that service is the parent of many subclasses which represent different kinds of text document content. Figure 2. The TextContent Service and Some Subclasses. A more complete hierarchy can be found in the documentation for TextContent ( lodoc TextContent service ). The two services highlighted in orange relate to graphical content, which is explained in the next chapter. Table 1 summarizes content types in terms of their services and access methods. Most of the methods are in Supplier interfaces which are part of the GenericTextDocument or OfficeDocument services in Figure 2 of Chapter 5. If the service text is in bold then there's an example of how to manipulate its content later in this chapter. Content Name Service for Creating Content Access Method in Supplier Text Frame TextFrame XNameAccess XTextFrameSupplier. getTextFrames() Embedded Object TextEmbeddedObject XComponent XTextEmbeddedObjectSupplier2. getEmbeddedObject() Graphic Object TextGraphicObject; XNameAccess XTextGraphicObjectsSupplier. getGraphicObjects() Shape text.Shape, drawing.Shape XDrawPage XDrawPageSupplier. or a subclass getDrawPage() Text Field TextField XEnumerationAccess XTextFieldsSupplier. getTextFields() Text Table TextTable XNameAccess XTextTablesSupplier. getTextTables() Bookmark Bookmark XNameAccess XBookmarksSupplier. getBookmarks() Paragraph Paragraph XEnumerationAccess on XText Text Section TextSection XNameAccess XTextSectionsSupplier. getTextSections() Footnote Footnote XIndexAccess XFootnotesSupplier. getFootnotes() End Note Endnote XIndexAccess XEndnotesSupplier.getEndnotes() Reference Mark ReferenceMark XNameAccess XReferenceMarksSupplier. getReferenceMarks() Index DocumentIndex XIndexAccess XDocumentIndexesSupplier. getDocumentIndexes() Link Target LinkTarget XNameAccess XLinkTargetSupplier.getLinks() Redline RedlinePortion XEnumerationAccess XRedlinesSupplier. getRedlines() Content Metadata InContentMetaData XDocumentMetadataAccess Table 1. Creating and Accessing Text Content. Rows 3 and 4 are highlighted to indicate that graphical content is discussed in the next chapter.","title":"Chapter 7. Text Content Other than Strings"},{"location":"07-Non-text_Content.html#1-how-to-access-text-content","text":"Most of the examples in this chapter create text document content rather than access it. This is mainly because the different access functions work in a similar way, so you don\u2019t need many examples to get the general idea. First the document is converted into a supplier, then its getXXX() method is called (see column 3 of Table 1). For example, accessing the graphic objects in a document (see row 3 of Table 1) requires: // get the graphic objects supplier XTextGraphicObjectsSupplier imsSupplier = Lo . qi ( XTextGraphicObjectsSupplier . class , doc ); // access the graphic objects collection XNameAccess xNameAccess = imsSupplier . getGraphicObjects (); The names associated with the graphic objects in XNameAccess can be extracted with XNameAccess.getElementNames(), and printed: String [] names = xNameAccess . getElementNames (); System . out . println ( \"Number of graphic names: \" + names . length ); Arrays . sort ( names ); // sort them, if you want Lo . printNames ( names ); // useful for printing long lists A particular object in an XNameAccess collection is retrieved with getByName(): XInterface oGraphic = xNameAccess . getByName ( \"foo\" ); // get graphic object called \"foo\" XInterface is the Office equivalent of Java's Object: every interface subclasses XInterface. A common next step is to convert the object into a property set, which makes it possible to lookup the properties stored in the object's service. For instance, the graphic object\u2019s filename or URL can be retrieved using: XPropertySet props = Lo . qi ( XPropertySet . class , oGraphic ); String fnm = ( String ) props . getPropertyValue ( \"GraphicURL\" ); I know the graphic object's URL is stored in the \"GraphicURL\" property from looking at the documentation for the TextGraphicObject service. It can be (almost) directly accessed by typing lodoc TextGraphicObject service ; unfortunately DuckDuckGo chooses the TextGraphicObjects service, and you need to click on the \"TextGraphicObject\" link below the title to get to the required page. It's possible to call setPropertyValue() to change a property: props.setPropertyValue(\"Transparency\", (short)50); What About the Text Content I Don't Cover? Table 1 has many rows without bold entries, which means I won't be looking at them. except for the very brief descriptions here; for more please consult the Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Working_with_Text_Documents/ (or type loGuide \"Working with Text Documents\" ). All the examples in that section are in TextDocuments.java at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text . Text Sections. A text section is a grouping of paragraphs which can be assigned their own style settings. More usefully, a section may be located in another file, which is the mechanism underlying master documents. See: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Sections/ (or type loGuide \"Text Sections\" ). Footnotes and Endnotes. Footnotes and endnotes are blocks of text that appear in the page footers and at the end of a document. They can be treated as XText objects, so manipulated using the same techniques as the main document text. See: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Footnotes_and_Endnotes/ (or type loGuide Footnotes ). Reference Marks. Reference marks can be inserted throughout a document, and then jumped to via GetReference text fields: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Reference_Marks/ (or type loGuide \"Reference Marks\" ). Indexes and Index Marks. Index marks, like reference marks, can be inserted anywhere in a document, but are used to generate indices (collections of information) inside the document. There are several types of index marks used for generating lists of chapter headings (i.e. a book's index), lists of key words, illustrations, tables, and a bibliography. For details see: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Indexes_and_Index_Marks/ (or type loGuide Indexes ). Link Targets. A link target (sometimes called a jump mark) labels a location inside a document. These labels can be included as part of a filename so that the document can be opened at that position. For information, see: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Link_Targets/ (or type loGuide \"Link Targets\" ). Redlines. Redlines are the changes recorded when a user edits a document with track changes turned on. Each of the changes is saved as a text fragment (also called a text portion) inside a redline object. See: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Redline/ (or type loGuide Redline ).","title":"1.  How to Access Text Content"},{"location":"07-Non-text_Content.html#2-adding-a-text-frame-to-a-document","text":"The TextFrame service inherits many of its properties and interfaces, so its inheritance hierarchy is shown in detail in Figure 3. Figure 3. The TextFrame Service Hierarchy. Figure 3 includes two sibling services of TextFrame: TextEmbeddedObject and TextGraphicObject, which I'll discuss a bit later; infact, I'll only get around to TextGraphicObject in the next chapter. The BaseFrameProperties service contains most of the frame size and positional properties, such as \"Width\", \"Height\", and margin and border distance settings. A TextFrame interface can be converted into a text content (i.e. XTextContent) or a shape (i.e. XShape). Typically, the former is used when adding text to the frame, the latter when manipulating the shape of the frame. In my BuildDoc.java example, text frame creation is done by Write.addTextFrame(), with BuildDoc supplying the frame's y-axis coordinate position for its anchor: // code fragment in BuildDoc.java XTextViewCursor tvc = Write . getViewCursor ( doc ); int yPos = tvc . getPosition (). Y ; // y-axis anchor position : // other unrelated code Write . appendPara ( cursor , \"A text frame\" ); Write . addTextFrame ( cursor , yPos , \"This is a newly created text frame.\\n Which is over on the right of the page, next to the code.\" , 4000 , 1500 ); // width x height of frame An anchor specifies how the text content is positioned relative to the ordinary text around it. Anchoring can be relative to a character, paragraph, page, or another frame. Write.addTextFrame() uses page anchoring, which means that BuildDoc must obtain a view cursor, so that an on-screen page position can be calculated. As Figure 4 shows, the text frame is located on the right of the page, with its top edge level with the start of the code listing. Figure 4. Text Frame Position in the Document. In the code fragment above, Write.getViewCursor() creates the view cursor, and XTextViewCursor.getPosition() returns its (x, y) coordinate on the page. The y- coordinate is stored in yPos until after the code listing has been inserted into the document, and then passed to Write.addTextFrame(). Write.addTextFrame() is defined as: public static void addTextFrame ( XTextCursor cursor , int yPos , String text , int width , int height ) { try { XTextFrame xFrame = Lo . createInstanceMSF ( XTextFrame . class , \"com.sun.star.text.TextFrame\" ); if ( xFrame == null ) { System . out . println ( \"Could not create a text frame\" ); return ; } // convert frame to a shape interface; set size XShape tfShape = Lo . qi ( XShape . class , xFrame ); tfShape . setSize ( new Size ( width , height )); // get properties of the frame XPropertySet frameProps = Lo . qi ( XPropertySet . class , xFrame ); // anchor the text frame to the page frameProps . setPropertyValue ( \"AnchorType\" , TextContentAnchorType . AT_PAGE ); frameProps . setPropertyValue ( \"FrameIsAutomaticHeight\" , true ); // will grow if necessary // add a red border around all 4 sides BorderLine border = new BorderLine (); border . OuterLineWidth = 1 ; border . Color = 0xFF0000 ; // red frameProps . setPropertyValue ( \"TopBorder\" , border ); frameProps . setPropertyValue ( \"BottomBorder\" , border ); frameProps . setPropertyValue ( \"LeftBorder\" , border ); frameProps . setPropertyValue ( \"RightBorder\" , border ); // make the text frame blue frameProps . setPropertyValue ( \"BackTransparent\" , false ); // not transparent frameProps . setPropertyValue ( \"BackColor\" , 0xCCCCFF ); // blue // set the horizontal and vertical position frameProps . setPropertyValue ( \"HoriOrient\" , HoriOrientation . RIGHT ); frameProps . setPropertyValue ( \"VertOrient\" , VertOrientation . NONE ); frameProps . setPropertyValue ( \"VertOrientPosition\" , yPos ); // down from top // insert empty text frame into document append ( cursor , xFrame ); endParagraph ( cursor ); // add text to the text frame XText xFrameText = xFrame . getText (); XTextCursor xFrameCursor = xFrameText . createTextCursor (); xFrameText . insertString ( xFrameCursor , text , false ); } catch ( Exception e ) { System . out . println ( \"Insertion of text frame failed: \" + e ); } } // end of addTextFrame() addTextFrame() starts by creating a TextFrame service, and accessing its XTextFrame interface: XTextFrame xFrame = Lo . createInstanceMSF ( XTextFrame . class , \"com.sun.star.text.TextFrame\" ); The service name for a text frame is listed as \"TextFrame\" in row 1 of Table 1, but Lo.createInstanceMSF() requires a fully qualified name. Almost all the text content services, including TextFrame, are in the com.sun.star.text package. The XTextFrame interface is converted into XShape so the frame's dimensions can be set. The interface is also cast to XPropertySet so that various frame properties can be initialized; these properties are defined in the TextFrame and BaseFrameProperties services (see Figure 3). The \"AnchorType\" property uses the AT_PAGE anchor constant to tie the frame to the page. There are five anchor constants: AT_PARAGRAPH, AT_CHARACTER, AS_CHARACTER, AT_PAGE, and AT_FRAME, which are defined in the TextContentAnchorType enumeration. The difference between AT_CHARACTER and AS_CHARACTER relates to how the surrounding text is wrapped around the text content. \"AS\" means that the text content is treated as a single (perhaps very large) character inside the text, while \"AT\" means that the text frame's upper-left corner is positioned at that character location. The frame's page position is dealt with a few lines later by the \"HoriOrient\" and \"VertOrient\" properties. The HoriOrientation and VertOrientation constants are a convenient way of positioning a frame at the corners or edges of the page. However, I use \"VertOrientPosition\" to set the vertical position using the yPos coordinate, and switch off the \"VertOrient\" vertical orientation. Towards the end of Write.addTextFrame(), the frame is added to the document by calling a version of Write.append() that expects an XTextContent object: // in the Write class public static int append ( XTextCursor cursor , XTextContent textContent ) // append text content such as a text frame, table, text field { XText xText = cursor . getText (); xText . insertTextContent ( cursor , textContent , false ); cursor . gotoEnd ( false ); return getPosition ( cursor ); } It utilizes the XText.insertTextContent() method. The last task of Write.addTextFrame(), is to insert some text into the frame. XTextFrame inherits XTextContent, and so has access to the getText() method (see Figure 3). This means that all the text manipulations possible in a document are also possible inside a frame. The ordering of the tasks at the end of addTextFrame() is important. Office prefers that an empty text content be added to the document, and the data inserted afterwards.","title":"2.  Adding a Text Frame to a Document"},{"location":"07-Non-text_Content.html#3-adding-a-text-embedded-object-to-a-document","text":"Text embedded object content support OLE (Microsoft's Object Linking and Embedding), and is typically used to create a frame linked to an external Office document. Probably, its most popular use is to link to a chart, but I'll delay looking at that until Chapter 33. The best way of getting an idea of what OLE objects are available is to go to the Writer application's Insert menu, Object, \"OLE Object\" dialog. In my version of Office, it lists Office spreadsheet, chart, drawing, presentation, and formula documents, and a range of Microsoft and PDF types. Note that text embedded objects aren't utilized for adding graphics to a document. That's easier to do using the TextGraphicObject or GraphicObjectShape services, which I'll describe next. In this section I'll explain how to insert mathematical formulae into a text document. The example code is in MathQuestions.java, but most of the formula embedding is performed by Write.addFormula(): public static void addFormula ( XTextCursor cursor , String formula ) { try { XTextContent embedContent = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.TextEmbeddedObject\" ); if ( embedContent == null ) { System . out . println ( \"Could not create a formula\" ); return ; } // get property set for the embedded object XPropertySet props = Lo . qi ( XPropertySet . class , embedContent ); // set class ID (type) for object props . setPropertyValue ( \"CLSID\" , Lo . MATH_CLSID ); // anchor object as a character props . setPropertyValue ( \"AnchorType\" , TextContentAnchorType . AS_CHARACTER ); // insert empty object into document append ( cursor , embedContent ); endLine ( cursor ); // access object's model XEmbeddedObjectSupplier2 supp = Lo . qi ( XEmbeddedObjectSupplier2 . class , embedContent ); XComponent oEmbed = supp . getEmbeddedObject (); // insert formula into the object XPropertySet formulaProps = Lo . qi ( XPropertySet . class , oEmbed ); formulaProps . setPropertyValue ( \"Formula\" , formula ); } catch ( Exception e ) { System . out . println ( \"\\\"\" + formula + \"\\\" failed: \" + e ); } } // end of addFormula() A math formula is passed to addFormula() as a string in a format I'll explain shortly. The method begins by creating a TextEmbeddedObject service, and referring to it using the XTextContent interface: XTextContent embedContent = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.TextEmbeddedObject\" ); Details about embedded objects are given in row 2 of Table 1. Unlike TextFrame which has an XTextFrame interface, there's no XTextEmbeddedObject interface for TextEmbeddedObject. This can be confirmed by looking at the TextFrame inheritance hierarchy in Figure 3. There is an XEmbeddedObjectSuppler, but that's for accessing objects, not creating them. Instead I've utilized the XTextContent interface in Lo.createInstanceMSF() because it's the most specific interface available. The XTextContent interface is converted to XPropertySet so the \"CLSID\" and \"AnchorType\" properties can be set. \"CLSID\" is specific to TextEmbeddedObject \u2013 its value is the OLE class ID for the embedded document. The Lo.java utility contains the class ID constants for Office's documents: // in the Lo class public static final String WRITER_CLSID = \"8BC6B165-B1B2-4EDD-aa47-dae2ee689dd6\" ; public static final String CALC_CLSID = \"47BBB4CB-CE4C-4E80-a591-42d9ae74950f\" ; public static final String DRAW_CLSID = \"4BAB8970-8A3B-45B3-991c-cbeeac6bd5e3\" ; public static final String IMPRESS_CLSID = \"9176E48A-637A-4D1F-803b-99d9bfac1047\" ; public static final String MATH_CLSID = \"078B7ABA-54FC-457F-8551-6147e776a997\" ; public static final String CHART_CLSID = \"12DCAE26-281F-416F-a234-c3086127382e\" ; The \"AnchorType\" property is set to AS_CHARACTER so the formula string will be anchored in the document in the same way as a string of characters. As with the text frame in Write.addTextFrame(), an empty text content is added to the document first, then filled with the formula. The embedded object's content is accessed via the XEmbeddedObjectSupplier2 interface which has a get method for obtaining the object: XEmbeddedObjectSupplier2 supp = Lo . qi ( XEmbeddedObjectSupplier2 . class , embedContent ); XComponent oEmbed = supp . getEmbeddedObject (); The properties for this empty object (oEmbed) are accessed, and the formula string is assigned to the \"Formula\" property: XPropertySet formulaProps = Lo.qi(XPropertySet.class, oEmbed); formulaProps.setPropertyValue(\"Formula\", formula);","title":"3.  Adding a Text Embedded Object to a Document"},{"location":"07-Non-text_Content.html#31-whats-a-formula-string","text":"Although I've explained the working of Write.addFormula(), I haven't explained the format of the formula string that's passed to it. There's a good overview of the notation in the \"Commands Reference\" appendix of Office's \"Math Guide\", available at https://libreoffice.org/get-help/documentation/ For example, the formula string: \"1 {5}over{9} + 3 {5}over{9} = 5 {1}over{9}\" is rendered as: [*** Formula did not render in MarkDown ***]","title":"3.1.  What's a Formula String?"},{"location":"07-Non-text_Content.html#32-building-formulae","text":"MathQuestions.java is mainly a for-loop for randomly generating numbers and constructing simple formulae strings. Ten formulae are added to the document, which is saved as \"mathQuestions.pdf\". The main() function: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } XTextCursor cursor = Write . getCursor ( doc ); Write . appendPara ( cursor , \"Math Questions\" ); Write . stylePrevParagraph ( cursor , \"Heading 1\" ); Write . appendPara ( cursor , \"Solve the formulae for x:\\n\" ); Random r = new Random (); String formula ; for ( int i = 0 ; i < 10 ; i ++ ) { // generate 10 formulae int iA = r . nextInt ( 8 ) + 2 ; // generate some integers int iB = r . nextInt ( 8 ) + 2 ; int iC = r . nextInt ( 9 ) + 1 ; int iD = r . nextInt ( 8 ) + 2 ; int iE = r . nextInt ( 9 ) + 1 ; int iF1 = r . nextInt ( 8 ) + 2 ; int choice = r . nextInt ( 3 ); // decide between 3 formulae if ( choice == 0 ) formula = \"{{{sqrt{\" + iA + \"x}} over \" + iB + \"} + {\" + iC + \" over \" + iD + \"}={\" + iE + \" over \" + iF1 + \"}}\" ; else if ( choice == 1 ) formula = \"{{{\" + iA + \"x} over \" + iB + \"} + {\" + iC + \" over \" + iD + \"}={\" + iE + \" over \" + iF1 + \"}}\" ; else formula = \"{\" + iA + \"x + \" + iB + \" =\" + iC + \"}\" ; Write . addFormula ( cursor , formula ); Write . endParagraph ( cursor ); } Write . append ( cursor , \"Timestamp: \" + Lo . getTimeStamp () + \"\\n\" ); Lo . saveDoc ( doc , \"mathQuestions.pdf\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Figure 5 shows a screenshot of part of mathQuestions.pdf. Figure 5. Math Formulae in a Text Document.","title":"3.2.  Building Formulae"},{"location":"07-Non-text_Content.html#4-text-fields","text":"A text field differs from other text content in that its data is generated dynamically by the document, or by an external source such as a database . Document-generated text fields include text showing the current date, the page number, the total number of pages in the document, and cross-references to other areas in the text. I'll look at three examples: the DateTime, PageNumber, and PageCount text fields. When a text field depends on an external source, there are two fields to initialize: the master field representing the external source, and the dependent field for the data used in the document; only the dependent field is visible. I won't be giving any dependent/master field examples, but there's one in the Development Guide section on text fields, at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Fields/ (or type loGuide \"Text Fields\" ). It utilizes the User master field, which allows the external source to be user-defined data. The code appears in the TextDocuments.java example at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text/ . Different kinds of text field are implemented as subclasses of the TextField service. You can see the complete hierarchy in the online documentation for TextField ( lodoc TextField service ). Figure 6 presents a simplified version. Figure 6. Simplified Hierarchy for the TextField Service.","title":"4.  Text Fields"},{"location":"07-Non-text_Content.html#41-the-datetime-textfield","text":"The BuildDoc.java example ends with a few lines that appear to do the same thing twice: // code fragment from BuildDoc.java Write . appendPara ( cursor , \"\\nTimestamp: \" + Lo . getTimeStamp () + \"\\n\" ); Write . append ( cursor , \"Time (according to office): \" ); Write . appendDateTime ( cursor ); Write . endParagraph ( cursor ); Lo.getTimeStamp() inserts a timestamp (which includes the date and time), and then Write.appendDateTime() inserts the date and time. Although these may seem to be the same, getTimeStamp() adds a string while appendDateTime() creates a text field. The difference becomes apparent if you open the file some time after it was created. Figure 7 shows two screenshots of the time-stamped parts of the document taken after it was first generated, and nearly 50 minutes later. Figure 7. Screenshots of the Timestamps. The text field timestamp is updated each time the file is opened in edit mode (which is the default in Writer). This dynamic updating occurs in all text fields. For example, if you add some pages to a document, all the places in the document that use the PageCount text field will be updated to show the new length. Write.appendDateTime() creates a DateTime service, and returns its XTextField interface (see Figure 6). The TextField service only contains two properties, with most being in the subclass (DateTime in this case). public static int appendDateTime ( XTextCursor cursor ) { XTextField dtField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.DateTime\" ); Props . setProperty ( dtField , \"IsDate\" , true ); // so date is reported append ( cursor , dtField ); append ( cursor , \"; \" ); dtField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.DateTime\" ); Props . setProperty ( dtField , \"IsDate\" , false ); // so time is reported return append ( cursor , dtField ); } // end of appendDateTime() The method adds two DateTime text fields to the document. The first has its \"IsDate\" property set to true, so that the current date is inserted; the second sets \"IsDate\" to false so the current time is shown.","title":"4.1.  The DateTime TextField"},{"location":"07-Non-text_Content.html#42-the-pagenumber-and-pagecount-text-fields","text":"I discussed most of StoryCreator.java in Chapter 6 on styles, but skipped over how page numbers were added to the document's page footer. The footer is shown in Figure 8. Figure 8. Page Footer using Text Fields. Write.setPageNumbers() inserts the PageNumber and PageCount text fields into the footer's text area: // in the Write class public static void setPageNumbers ( XTextDocument textDoc ) { // get 'standard' style for page style family XPropertySet props = Info . getStyleProps ( textDoc , \"PageStyles\" , \"Standard\" ); if ( props == null ) { System . out . println ( \"Could not access standard page style\" ); return ; } try { props . setPropertyValue ( \"FooterIsOn\" , Boolean . TRUE ); // footer must be turned on in the document // access the footer as XText XText footerText = Lo . qi ( XText . class , props . getPropertyValue ( \"FooterText\" )); XTextCursor footerCursor = footerText . createTextCursor (); /* set footer text properties via its cursor: font, font size, paragraph orientation */ Props . setProperty ( footerCursor , \"CharFontName\" , \"Times New Roman\" ); Props . setProperty ( footerCursor , \"CharHeight\" , 12.0f ); Props . setProperty ( footerCursor , \"ParaAdjust\" , ParagraphAdjust . CENTER ); // add text fields to the footer append ( footerCursor , getPageNumber ()); append ( footerCursor , \" of \" ); append ( footerCursor , getPageCount ()); } catch ( Exception ex ) { System . out . println ( ex ); } } // end of setPageNumbers() public static XTextField getPageNumber () // return Arabic style number showing current page value { XTextField numField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.PageNumber\" ); Props . setProperty ( numField , \"NumberingType\" , NumberingType . ARABIC ); Props . setProperty ( numField , \"SubType\" , PageNumberType . CURRENT ); return numField ; } public static XTextField getPageCount () // return Arabic style number showing current page count { XTextField pcField = Lo . createInstanceMSF ( XTextField . class , \"com.sun.star.text.TextField.PageCount\" ); Props . setProperty ( pcField , \"NumberingType\" , NumberingType . ARABIC ); return pcField ; } Write.setPageNumbers() starts by accessing the \"Standard\" property set (style) for the page style family. Via its properties, the method turns on footer functionality and accesses the footer text area as an XText object. An XTextCursor is created for the footer text area, and properties are configured: XText footerText = Lo . qi ( XText . class , props . getPropertyValue ( \"FooterText\" )); XTextCursor footerCursor = footerText . createTextCursor (); Props . setProperty ( footerCursor , \"CharFontName\" , \"Times New Roman\" ); These properties will be applied to the text and text fields added afterwards: append ( footerCursor , getPageNumber ()); append ( footerCursor , \" of \" ); append ( footerCursor , getPageCount ()); getPageNumber() and getPageCount() deal with the properties for the PageNumber and PageCount fields. I found out about them by looking at the documentation for their services (e.g. use lodoc TextField.PageNumber service; \"TextField.\" is needed due to PageNumber being a common word).","title":"4.2.  The PageNumber and PageCount Text Fields"},{"location":"07-Non-text_Content.html#5-adding-a-text-table-to-a-document","text":"The MakeTable.java example reads in data about James Bond movies from \"bondMovies.txt\" and stores it as a text table in \"table.odt\". The first few rows are shown in Figure 9. Figure 9. A Bond Movies Table. The \"bondMovies.txt\" file is read by readTable() utilizing standard Java file processing. It returns a list of String arrays: ArrayList < String []> rowsList = readTable ( \"bondMovies.txt\" ); Each line in \"bondMovies.txt\" is converted into a string array by pulling out the substrings delimited by tab characters. readTable() ignores blank lines in the file, and lines beginning with \"//\". Also, I assume that the first row in the list contains the table's header text. The first few lines of \"bondMovies.txt\" are: // https://en.wikipedia.org/wiki/James_Bond#Ian_Fleming_novels Title Year Actor Director Dr. No 1962 Sean Connery Terence Young From Russia with Love 1963 Sean Connery Terence Young Goldfinger 1964 Sean Connery Guy Hamilton Thunderball 1965 Sean Connery Terence Young You Only Live Twice 1967 Sean Connery Lewis Gilbert On Her Majesty's Secret Service 1969 George Lazenby Peter R. Hunt Diamonds Are Forever 1971 Sean Connery Guy Hamilton Live and Let Die 1973 Roger Moore Guy Hamilton The Man with the Golden Gun 1974 Roger Moore Guy Hamilton : The main() function for MakeTable.java is: public static void main ( String args [] ) { ArrayList < String []> rowsList = readTable ( \"bondMovies.txt\" ); if ( rowsList . size () == 0 ) { System . out . println ( \"No data read from bondMovies.txt\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } XTextCursor cursor = Write . getCursor ( doc ); Write . appendPara ( cursor , \"Table of Bond Movies\" ); Write . stylePrevParagraph ( cursor , \"Heading 1\" ); Write . appendPara ( cursor , \"The following table comes from \\\"bondMovies.txt\\\":\\n\" ); Write . addTable ( cursor , rowsList ); Write . endParagraph ( cursor ); Write . append ( cursor , \"Timestamp: \" + Lo . getTimeStamp () + \"\\n\" ); Lo . saveDoc ( doc , \"table.odt\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Write.addTable() does the work of converting the list of rows into a text table. Figure 10 shows the hierarchy for the TextTable service: it's a subclass of TextContent and supports the XTextTable interface. Figure 10. The TextTable Hierarchy. XTextTable contains methods for accessing a table in terms of its rows, columns, and cells. The cells are referred to using names, based on letters for columns and integers for rows, as in Figure 11. Figure 11. The Cell Names in a Table. Write.addTable() uses this naming scheme in the XTextTable.getCellByName() method to assign data to cells: public static void addTable ( XTextCursor cursor , ArrayList < String []> rowsList ) // part of the Write utility class { try { // create a text table XTextTable table = Lo . createInstanceMSF ( XTextTable . class , \"com.sun.star.text.TextTable\" ); if ( table == null ) { System . out . println ( \"Could not create a text table\" ); return ; } // initialize table dimensions int numRows = rowsList . size (); int numCols = ( rowsList . get ( 0 )). length ; if ( numCols > 26 ) { // column labelling goes from 'A' to 'Z' System . out . println ( \"Too many columns: \" + numCols + \"; using first 26\" ); numCols = 26 ; } table . initialize ( numRows , numCols ); // add the table to the document append ( cursor , table ); endParagraph ( cursor ); // set table properties XPropertySet tableProps = Lo . qi ( XPropertySet . class , table ); tableProps . setPropertyValue ( \"BackTransparent\" , false ); // not transparent tableProps . setPropertyValue ( \"BackColor\" , 0xCCCCFF ); // light blue // set color of first row (i.e. the header) to dark blue XTableRows rows = table . getRows (); Props . setProperty ( rows . getByIndex ( 0 ), \"BackColor\" , 0x666694 ); // dark blue // write table header String [] rowData = rowsList . get ( 0 ); for ( int x = 0 ; x < numCols ; x ++ ) setCellHeader ( mkCellName ( x , 1 ), rowData [ x ] , table ); // e.g. \"A1\", \"B1\", \"C1\", etc. // insert table body for ( int y = 1 ; y < numRows ; y ++ ) { // start in 2nd row of list rowData = rowsList . get ( y ); for ( int x = 0 ; x < numCols ; x ++ ) setCellText ( mkCellName ( x , y + 1 ), rowData [ x ] , table ); // e.g. \"A2\", \"B5\", \"C3\", etc. } } catch ( Exception e ) { System . out . println ( \"Table insertion failed:\" + e ); } } // end of addTable() A TextTable service with an XTableText interface is created at the start of addTable(). Then the required number of rows and columns is calculated so that XTextTable.initialize() can be called to specify the table's dimensions. Table-wide properties are set (properties are listed in the TextTable documentation). Note that if \"BackTransparent\" isn't set to false then Office crashes when the program tries to save the document. The color property of the header row is set to dark blue. This requires a call to XTextTable.getRows() to return an XTableRows object representing all the rows. This object inherits XIndexAccess, so the first row is accessed with index 0. The filling of the table with data is performed by two loops. The first deals with adding text to the header row, the second deals with all the other rows. mkCellName() converts an (x, y) integer pair into a cell name like those in Figure 11: public static String mkCellName ( int x , int y ) { return \"\" + (( char )( 'A' + x )) + y ; } Write.setCellHeader() uses TextTable.getCellByName() to access a cell, which is of type XCell. We'll study XCell in Part 4 because it's used for representing cells in a spreadsheet. The Cell service supports both the XCell and XText interfaces, as in Figure 12. Figure 12. The Cell Service. This means that Lo.qi() can convert an XCell instance into XText, which makes the cell's text and properties accessible to a text cursor. Write.setCellHeader() implements these features: private static void setCellHeader ( String cellName , String data , XTextTable table ) // puts text into the named cell of the table, colored white { // convert XCell to XText XText cellText = Lo . qi ( XText . class , table . getCellByName ( cellName )); // create a cursor inside the cell XTextCursor textCursor = cellText . createTextCursor (); Props . setProperty ( textCursor , \"CharColor\" , 0xFFFFFF ); // use white text cellText . setString ( data ); } // end of setCellHeader() The cell's \"CharColor\" property is changed so the inserted text in the header row is white, as in Figure 9. Write.setCellText() is shorter than setCellHeader() because there's no need to change the text's color: private static void setCellText ( String cellName , String data , XTextTable table ) // puts text into the named cell of the table { XText cellText = Lo . qi ( XText . class , table . getCellByName ( cellName )); cellText . setString ( data ); } // end of setCellText()","title":"5.  Adding a Text Table to a Document"},{"location":"07-Non-text_Content.html#6-adding-a-bookmark-to-the-document","text":"Write.addBookmark() adds a named bookmark at the current cursor position: public static void addBookmark ( XTextCursor cursor , String name ) { XTextContent bmkContent = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.Bookmark\" ); if ( bmkContent == null ) { System . out . println ( \"Could not create a bookmark\" ); return ; } // convert bookmark content to a named collection XNamed bmksNamed = Lo . qi ( XNamed . class , bmkContent ); bmksNamed . setName ( name ); append ( cursor , bmkContent ); endParagraph ( cursor ); } // end of addBookmark() The Bookmark service doesn't have a specific interface (such as XBookmark), so Lo.createInstanceMSF() returns an XTextContent interface. These services and interfaces are summarized by Figure 13. Figure 13. The Bookmark Service and Interfaces. Bookmark supports XNamed, which allows it to be viewed as a named collection of bookmarks (note the plural). This is useful when searching for a bookmark or adding one, as in the BuildDoc.java example. It calls Write.addBookmark() to add a bookmark called \"ad-Bookmark\" to the document: // code fragment from BuildDoc.java Write . append ( cursor , \"This line ends with a bookmark\" ); Write . addBookmark ( cursor , \"ad-bookmark\" ); Bookmarks, such as \"ad-bookmark\", are not rendered when the document is opened, which means that nothing appears after the \"The line ends with a bookmark.\" string in \"build.odt\". However, bookmarks are listed in Writer's \"Navigator\" window (press F5), as in Figure 14. Figure 14. The Writer Navigator Window. Clicking on the bookmark causes Writer to jump to its location in the document. Using Bookmarks One programming use of bookmarks is for moving a cursor around a document. Just as with real-world bookmarks, you can add one at some important location in a document and jump to that position at a later time. Write.findBookmark() finds a bookmark by name, returning it as an XTextContent instance: public static XTextContent findBookmark ( XTextDocument doc , String bmName ) { XBookmarksSupplier supplier = Lo . qi ( XBookmarksSupplier . class , doc ); if ( supplier == null ) { System . out . println ( \"Bookmark supplier could not be created\" ); return null ; } XNameAccess namedBookmarks = supplier . getBookmarks (); if ( namedBookmarks == null ) { System . out . println ( \"Name access to bookmarks not possible\" ); return null ; } if ( ! namedBookmarks . hasElements ()) { System . out . println ( \"No bookmarks found\" ); return null ; } // find the specified bookmark Object oBookmark = null ; try { oBookmark = namedBookmarks . getByName ( bmName ); } catch ( com . sun . star . uno . Exception e ) {} if ( oBookmark == null ) { System . out . println ( \"Bookmark \\\"\" + bmName + \"\\\" not found\" ); return null ; } // there's no XBookmark, so return XTextContent return Lo . qi ( XTextContent . class , oBookmark ); } // end of findBookmark() findBookmark() can't return an XBookmark object since there's no such interface (see Figure 13), but XTextContent is a good alternative. XTextContent has a getAnchor() method which returns an XTextRange that can be used for positioning a cursor. The following code fragment from BuildDoc.java illustrates the idea: // code fragment from BuildDoc.java XTextContent bookmark = Write . findBookmark ( doc , \"ad-bookmark\" ); XTextRange bmRange = bookmark . getAnchor (); XTextViewCursor viewCursor = Write . getViewCursor ( doc ); viewCursor . gotoRange ( bmRange , false ); The call to gotoRange() moves the view cursor to the \"ad-bookmark\" position, which causes an on-screen change. gotoRange() can be employed with any type of cursor.","title":"6.  Adding a Bookmark to the Document"},{"location":"08-Graphic_Content.html","text":"Chapter 8. Graphic Content \u00b6 Topics Graphics; Linked Images/Shapes Example folders: \"Text Tests\" and \"Utils\" Chapter 7 looked at several forms of text document content (e.g. text frames, math formulae, text fields and tables, and bookmarks), as indicated by Figure 1. However the different ways of adding graphical content (corresponding to the services highlighted in orange) are the focus of this chapter Figure 1. The TextContent Service and Some Subclasses. 1. Linking a Graphic Object to a Document \u00b6 Adding an image to a text document follows the same steps as other text content, as shown in Write.addImageLink(): public static void addImageLink ( XTextDocument doc , XTextCursor cursor , String fnm ) { addImageLink ( doc , cursor , fnm , 0 , 0 ); } // 0, 0 means use image's size as width & height public static void addImageLink ( XTextDocument doc , XTextCursor cursor , String fnm , int width , int height ) { try { // create TextContent for graphic XTextContent tgo = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.TextGraphicObject\" ); if ( tgo == null ) { System . out . println ( \"Could not create a text graphic object\" ); return ; } // set anchor and URL properties XPropertySet props = Lo . qi ( XPropertySet . class , tgo ); props . setPropertyValue ( \"AnchorType\" , TextContentAnchorType . AS_CHARACTER ); props . setPropertyValue ( \"GraphicURL\" , FileIO . fnmToURL ( fnm )); // optionally set the width and height if (( width > 0 ) && ( height > 0 )) { props . setPropertyValue ( \"Width\" , width ); props . setPropertyValue ( \"Height\" , height ); } // append image to document, followed by a newline append ( cursor , tgo ); endLine ( cursor ); } catch ( Exception e ) { System . out . println ( \"Insert of \\\"\" + fnm + \"\\\" failed: \" + e ); } } // end of addImageLink() The TextGraphicObject service doesn't offer a XTextGraphicObject interface, so Lo.createInstanceMSF() returns an XTextContext. The interface is also converted to XPropertySet because several properties need to be set. The frame is anchored, and the image's filename is assigned to \"GraphicURL\" (after being changed into a URL). The image's size on the page depends on the dimensions of its enclosing frame, which are set in the \"Width\" and \"Height\" properties: props . setPropertyValue ( \"Width\" , 4500 ); // 45 mm width props . setPropertyValue ( \"Height\" , 4000 ); // 40 mm height The values are in 1/100 mm units, so 4500 is 45 mm or 4.5 cm. If these properties aren't explicitly set then the frame size defaults to being the width and height of the image. In more realistic code, the width and height properties would be calculated as some scale factor of the image's size, as measured in 1/100 mm units not pixels. These dimensions are available if the image file is loaded as an XGraphic object, as shown in Images.getSize100mm(): // in the Images class public static Size getSize100mm ( String imFnm ) { XGraphic graphic = loadGraphicFile ( imFnm ); if ( graphic == null ) return null ; return ( Size ) Props . getProperty ( graphic , \"Size100thMM\" ); } // end of getSize100mm() public static XGraphic loadGraphicFile ( String imFnm ) { // create graphics provider XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); if ( gProvider == null ) { System . out . println ( \"Graphic Provider could not be found\" ); return null ; } // set URL property and query it for XGraphic PropertyValue [] fileProps = Props . makeProps ( \"URL\" , FileIO . fnmToURL ( imFnm )); try { return gProvider . queryGraphic ( fileProps ); } catch ( Exception e ) { System . out . println ( \"Could not load XGraphic from \" + imFnm ); return null ; } } // end of loadGraphicFile() Displaying the image at a scaled size is possible by combining Images.getSize100mm() and Write.addImageLink(): Size imSize = Images . getSize100mm ( imFnm ); int w = ( int ) Math . round ( imSize . Width * 1.5 ); // enlarge by 1.5x int h = ( int ) Math . round ( imSize . Height * 1.5 ); Write . addImageLink ( doc , cursor , imFnm , w , h ); A possible drawback of Write.addImageLink() is that the document only contains a link to the image. This becomes an issue if you save the document in a format other than \".odt\". In particular, when saved as a Word \".doc\" file, the link is lost. 2. Adding a Graphic to a Document as a Shape \u00b6 An alternative to inserting a graphic as a link is to treat it as a shape. Shapes will be discussed at length in Part 3, so I won't go into much detail about them here. One difference between a graphic link and shape is that shapes can be rotated. Shapes can be created using the com.sun.star.text.Shape service, com.sun.star.drawing.Shape, or one of its subclasses, while XDrawPageSupplier.getDrawPage() accesses the shapes in a document. The shape hierarchy is quite extensive (i.e. there are many kinds of shape), so only the parts used here are shown in Figure 2: Figure 2. Part of the Shape Hierarchy. In Figure 2, \"(text) Shape\" refers to the com.sun.star.text.Shape service, while \"(drawing) Shape\" is com.sun.star.drawing.Shape. My examples use GraphicObjectShape to create a shape containing an image, and LineShape to add a line to the document. The XShapeDescriptor interface in com.sun.star.drawing.Shape is a useful way to obtain the name of a shape service. 2.1. Creating an Image Shape \u00b6 The BuildDoc.java example adds an image shape to the document by calling Write.addImageShape(): // code fragment in BuildDoc.java Write . append ( cursor , \"Image as a shape: \" ); Write . addImageShape ( doc , cursor , imFnm ); // image filename Write . endParagraph ( cursor ); Write.addImageShape() comes in two versions: with and without width and height arguments. A shape with no explicitly set width and height properties is rendered as a miniscule image (about 1 mm wide). Call me old-fashioned, but I want to see the graphic, so Write.addImageShape() calculates the picture's dimensions if none are supplied by the user. Another difference between image shape and image link is how the content's \"GraphicURL\" property is employed. The image link version contains its URL, while the image shape's \"GraphicURL\" stores its bitmap as a string. The code for Write.addImageShape(): public static void addImageShape ( XTextDocument doc , XTextCursor cursor , String fnm ) { addImageShape ( doc , cursor , fnm , 0 , 0 ); } /* 0, 0 means that the method must calculate the image's size */ public static void addImageShape ( XTextDocument doc , XTextCursor cursor , String fnm , int width , int height ) { Size imSize ; if (( width > 0 ) && ( height > 0 )) imSize = new Size ( width , height ); else { imSize = Images . getSize100mm ( fnm ); if ( imSize == null ) return ; } try { // create TextContent for the graphic shape XTextContent gos = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.GraphicObjectShape\" ); if ( gos == null ) { System . out . println ( \"Could not create a graphic shape\" ); return ; } // store the image's bitmap in the \"GraphicURL\" property String bitmap = Images . getBitmap ( fnm ); Props . setProperty ( gos , \"GraphicURL\" , bitmap ); // set the shape's size XShape xDrawShape = Lo . qi ( XShape . class , gos ); xDrawShape . setSize ( imSize ); // must be set, or image is tiny // insert image shape into the document, followed by newline append ( cursor , gos ); endLine ( cursor ); } catch ( Exception e ) { System . out . println ( \"Insert of \\\"\" + fnm + \"\\\" failed: \" + e ); } } // end of addImageShape() The image's size is calculated using Images.getSize100mm() if the user doesn't supply a width and height, and is used towards the end of the method. An image shape is created using the GraphicObjectShape service, and its XTextContent interface is converted to XPropertySet for assigning its properties, and to XShape for setting its size (see Figure 2). XShape includes a setSize() method. Images.getBitmap() converts the graphic into a bitmap string. // in the Images utility class public static String getBitmap ( String fnm ) { try { // create a BitmapTable service and named container XNameContainer bitmapContainer = Lo . createInstanceMSF ( XNameContainer . class , \"com.sun.star.drawing.BitmapTable\" ); // insert image into container if ( ! FileIO . isOpenable ( fnm )) return null ; String picURL = FileIO . fnmToURL ( fnm ); if ( picURL == null ) return null ; bitmapContainer . insertByName ( fnm , picURL ); // use the filename as the name of the bitmap // return the bitmap as a string return ( String ) bitmapContainer . getByName ( fnm ); } catch ( Exception e ) { System . out . println ( \"Could not create bitmap for \" + fnm ); return null ; } } // end of getBitmap() getBitmap() uses a BitmapTable service to store the image's file in an XNameContainer. When the bitmap value is retrieved from the container, it can be cast to a string. A named container requires a name be assigned to the bitmap value; I use the image's filename, but any unique string would do. 2.2. Adding Other Graphics to the Document \u00b6 The graphic text content can be any subclass of Shape. In the last section I created a GraphicObjectShape service, and accessed its XTextContent interface: XTextContent gos = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.GraphicObjectShape\" ); In this section I'll use LineShape: XTextContent ls = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.LineShape\" ); The aim is to draw an horizontal line in the document, to act as a divider between paragraphs. The line will be half-a-page wide and centered, like the one in Figure 3 Figure 3. A Graphical Line Divider. The difficult part is calculating the width of the line, which should only extend across half the writing width. This isn't the same as the page width because it doesn't include the left and right margins. The page and margin dimensions are accessible through the \"Standard\" page style, as implemented in Write.getPageTextWidth(): public static int getPageTextWidth ( XTextDocument textDoc ) // get the page's writing width { // access the \"standard\" style in the pages style family XPropertySet props = Info . getStyleProps ( textDoc , \"PageStyles\" , \"Standard\" ); if ( props == null ) { System . out . println ( \"Could not access the standard page style\" ); return 0 ; } // lookup the page and margin widths try { int width = (( Integer ) props . getPropertyValue ( \"Width\" )). intValue (); int leftMargin = (( Integer ) props . getPropertyValue ( \"LeftMargin\" )). intValue (); int rightMargin = (( Integer ) props . getPropertyValue ( \"RightMargin\" )). intValue (); return ( width - ( leftMargin + rightMargin )); // writing width } catch ( Exception e ) { System . out . println ( \"Could not access page dimensions: \" + e ); return 0 ; } } // end of getPageTextWidth() getPageTextWidth() returns the writing width in 1/100 mm units, which is scaled, then passed to Write.addLineDivider(): // code fragment in BuildDoc,java int textWidth = Write . getPageTextWidth ( doc ); Write . addLineDivider ( cursor , ( int ) Math . round ( textWidth * 0.5 ) ); // scale width by 0.5 addLineDivider() creates a LineShape service with an XTextContent interface (see Figure 2). This is converted to XShape so its setSize() method can be passed the line width: public static void addLineDivider ( XTextCursor cursor , int lineWidth ) // in the Writer class { try { // create TextContent for a line XTextContent ls = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.LineShape\" ); if ( ls == null ) { System . out . println ( \"Could not create a line shape\" ); return ; } // set line size XShape lineShape = Lo . qi ( XShape . class , ls ); lineShape . setSize ( new Size ( lineWidth , 0 )); endParagraph ( cursor ); append ( cursor , ls ); // put line in its own paragraph endParagraph ( cursor ); // center the line paragraph stylePrevParagraph ( cursor , \"ParaAdjust\" , com . sun . star . style . ParagraphAdjust . CENTER ); endParagraph ( cursor ); } catch ( Exception e ) { System . out . println ( \"Insertion of graphic line failed\" ); } } // end of addLineDivider() The centering of the line is achieved by placing the shape in its own paragraph, then using Write.stylePrevParagraph() to center it. 3. Accessing Linked Images and Shapes \u00b6 The outcome of running BuildDoc.java is a \"build.odt\" file containing four graphics \u2013 two are linked images, one is an image shape, and the other a line shape. The ExtractGraphics.java example extracts linked graphics from a document, saving them as PNG files. It also prints information about the shapes in the document. When ExtractGraphics is passed \"build.odt\", the following is output: Num. of text graphics: 2 Saving graphic in graphics1.png Image size in pixels: 319 x 274 Saving graphic in graphics2.png Image size in pixels: 319 x 274 Num. of draw shapes: 3 Shape service: FrameShape; z-order: 0 Shape service: com.sun.star.drawing.GraphicObjectShape; z-order: 1 Shape service: com.sun.star.drawing.LineShape; z-order: 2 A user who looked at \"build.odt\" for themselves might say that it contains three images not the two reported by ExtractGraphics. Why the discrepancy? ExtractGraphics.java only saves linked graphics, and only two were added by Write.addImageLink(). The other image was inserted using Write.addImageShape() which creates an image shape. The number of shapes reported by ExtractGraphics.java may also confuse the user \u2013 why are there three rather than two? The only shapes added to the document were an image and a line. The names of the services gives a clue: the second and third shapes are the expected GraphicObjectShape and LineShape, but the first is a text frame (FrameShape) added by Write.addTextFrame(). Although this frame is an instance of the TextFrame service, it's reported as a FrameShape. That's a bit mysterious because there's no FrameShape service in the Office documentation. The main() function of ExtractGraphics.java: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument textDoc = Write . openDoc ( args [ 0 ] , loader ); if ( textDoc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // save text graphics to files ArrayList < XGraphic > pics = Write . getTextGraphics ( textDoc ); if ( pics == null ) return ; System . out . println ( \"\\nNum. of text graphics: \" + pics . size ()); int i = 1 ; for ( XGraphic pic : pics ) { Images . saveGraphic ( pic , \"graphics\" + i + \".png\" , \"png\" ); Size sz = ( Size ) Props . getProperty ( pic , \"SizePixel\" ); System . out . println ( \"Image size in pixels: \" + sz . Width + \" x \" + sz . Height ); i ++ ; } System . out . println (); // report on shapes in the document XDrawPage drawPage = Write . getShapes ( textDoc ); ArrayList < XShape > shapes = Draw . getShapes ( drawPage ); if ( shapes != null ) System . out . println ( \"\\nNum. of draw shapes: \" + shapes . size ()); for ( XShape shape : shapes ) Draw . printShapeInfo ( shape ); System . out . println (); Lo . closeDoc ( textDoc ); Lo . closeOffice (); } // end of main() The first block of code saves text graphic objects as PNGs, and the second reports on shapes. 3.1. Finding and Saving Text Graphics in a Document \u00b6 Write.getTextGraphics() returns a list of XGraphic objects: first it retrieves a collection of the graphic links in the document, then iterates through them creating an XGraphic object for each one: // in the Write class public static ArrayList < XGraphic > getTextGraphics ( XTextDocument textDoc ) { // get all the graphic links XNameAccess xNameAccess = getGraphicLinks ( textDoc ); if ( xNameAccess == null ) return null ; String [] names = xNameAccess . getElementNames (); System . out . println ( \"Number of graphics found: \" + names . length ); // build a list of XGraphic objects, one for each link ArrayList < XGraphic > pics = new ArrayList < XGraphic > (); for ( int i = 0 ; i < names . length ; i ++ ) { Object graphicLink = null ; try { graphicLink = xNameAccess . getByName ( names [ i ] ); } catch ( com . sun . star . uno . Exception e ) {} if ( graphicLink == null ) System . out . println ( \"No graphic found for \" + names [ i ] ); else { XGraphic xGraphic = Images . loadGraphicLink ( graphicLink ); if ( xGraphic != null ) pics . add ( xGraphic ); else System . out . println ( names [ i ] + \" could not be accessed\" ); } } return pics ; } // end of getTextGraphics() Graphic objects are accessed with XTextGraphicObjectsSupplier, as implemented by Write.getGraphicLinks(): // in the Write class public static XNameAccess getGraphicLinks ( XComponent doc ) { XTextGraphicObjectsSupplier imsSupplier = Lo . qi ( XTextGraphicObjectsSupplier . class , doc ); if ( imsSupplier == null ) { System . out . println ( \"Supplier could not be created\" ); return null ; } XNameAccess xNameAccess = imsSupplier . getGraphicObjects (); if ( xNameAccess == null ) { System . out . println ( \"Name access to graphics not possible\" ); return null ; } if ( ! xNameAccess . hasElements ()) { System . out . println ( \"No graphics elements found\" ); return null ; } return xNameAccess ; } // end of getGraphicLinks() Back in Write.getTextGraphics, each graphic is loaded by calling Images.loadGraphicLink(). It loads an image from the URL associated with a link: // in the Images class public static XGraphic loadGraphicLink ( Object graphicLink ) { // create graphic provider XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); if ( gProvider == null ) { System . out . println ( \"Graphic Provider could not be found\" ); return null ; } // set up URL property then load as an XGraphic try { XPropertySet xprops = Lo . qi ( XPropertySet . class , graphicLink ); PropertyValue [] gProps = Props . makeProps ( \"URL\" , ( String ) xprops . getPropertyValue ( \"GraphicURL\" ) ); return gProvider . queryGraphic ( gProps ); } catch ( Exception e ) { System . out . println ( \"Unable to retrieve graphic\" ); return null ; } } // end of loadGraphicLink() Note that the XGraphic is not extracted from the document but loaded from a URL. Back in ExtractGraphics.java, the XGraphic objects are saved as PNG files, and their pixel sizes reported: private static void savePics ( XTextDocument textDoc ) // method in ExtractGraphics.java { ArrayList < XGraphic > pics = Write . getTextGraphics ( textDoc ); if ( pics == null ) return ; System . out . println ( \"No. of graphic retrieved: \" + pics . size ()); int i = 1 ; for ( XGraphic pic : pics ) { Images . saveGraphic ( pic , \"graphics\" + i + \".png\" , \"png\" ); Size sz = ( Size ) Props . getProperty ( pic , \"SizePixel\" ); System . out . println ( \"Image Pixel size: \" + sz . Width + \" x \" + sz . Height ); i ++ ; } } // end of savePics() Images.saveGraphic() utilizes the graphic provider's XGraphicProvider.storeGraphic() method: // in XGraphicProvider void storeGraphic ( XGraphic g , PropertyValue [] props ) { ... } Its second argument is an array of PropertyValue objects, not a PropertySet. My Props.java utility class provides several functions for creating PropertyValue instances, which are a variant of the {name=value} pair idea, but with extra data fields. One such function is: // in Props.java PropertyValue [] makeProps ( String [] nms , Object [] vals ) { ... } It's passed an array of names and values, which are paired up as PropertyValue objects, and returned in an array. In saveGraphic(), these methods are used like so: XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); // set up properties for storing the graphic PropertyValue [] props = Props . makeProps ( \"URL\" , FileIO . fnmToURL ( fnm ), \"MimeType\" , \"image/\" + imFormat ); gProvider . storeGraphic ( pic , props ); The idea is to call XGraphicProvider.saveGraphics() with the \"URL\" and \"MimeType\" properties set \u2013 the URL is for the image file, and the mimetype is an image type (e.g. \"image/png\"). saveGraphic() is coded as: public static void saveGraphic ( XGraphic pic , String fnm , String imFormat ) { // create graphic provider XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); if ( gProvider == null ) { System . out . println ( \"Graphic Provider could not be found\" ); return ; } if ( pic == null ) { System . out . println ( \"Supplied image is null\" ); return ; } // set up properties for storing the graphic PropertyValue [] pngProps = Props . makeProps ( \"URL\" , FileIO . fnmToURL ( fnm ), \"MimeType\" , \"image/\" + imFormat ); try { gProvider . storeGraphic ( pic , pngProps ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to save graphic\" ); } } // end of saveGraphic() Other possible image MIME types include \"gif\", \"jpeg\", \"wmf\", and \"bmp\". For instance, this call will save the image as a GIF: Images.saveGraphic(pic, \"graphics\" + i + \".gif\", \"gif\"); The printed output from saveGraphic() contains another surprise: Num. of text graphics: 2 Saving graphic in graphics1.png Image size in pixels: 319 x 274 Saving graphic in graphics2.png Image size in pixels: 319 x 274 The two saved graphics are the same size, but the second image is bigger inside the document. The discrepancy is because the rendering of the image in the document is bigger, scaled up to fit the enclosing frame; the original image is unchanged. 3.2. Finding the Shapes in a Document \u00b6 The second block of code in ExtractGraphics reports on the shapes found in the document. The relevant code fragment is: // code fragment from ExtractGraphics.java XDrawPage drawPage = Write . getShapes ( textDoc ); ArrayList < XShape > shapes = Draw . getShapes ( drawPage ); if ( shapes != null ) System . out . println ( \"\\nNum. of draw shapes: \" + shapes . size ()); for ( XShape shape : shapes ) Draw . printShapeInfo ( shape ); Shapes are accessed with the XDrawPageSupplier.getDrawPage() method, which returns a single XDrawPage: public static XDrawPage getShapes ( XTextDocument textDoc ) { XDrawPageSupplier drawPageSupplier = Lo . qi ( XDrawPageSupplier . class , textDoc ); if ( drawPageSupplier == null ) { System . out . println ( \"Draw page supplier could not be created\" ); return null ; } return drawPageSupplier . getDrawPage (); } // end of getShapes() XDrawPage's usual role is to represent the canvas in Office's Draw, or a slide in Impress, and so plays an important role in Part 3. Several support functions inside that part's Draw utility class will be used here. XDrawPageSupplier.getDrawPage() returns a single XDrawPage for the entire text document. That doesn't mean that the shapes all have to occur on a single text page, but rather that all the shapes spread across multiple text pages are collected into a single draw page. XDrawPage inherits from XShapes and XindexAccess, as shown in Figure 4, which means that a page can be viewed as a indexed collection of shapes. Figure 4. Partial Inheritance Hierarchy for XDrawPage. Draw.getShapes() uses this idea to iterate through the draw page and store the shapes in a list: // in the Draw class public static ArrayList < XShape > getShapes ( XDrawPage dp ) { if ( dp == null ) { System . out . println ( \"Draw page is null\" ); return null ; } if ( dp . getCount () == 0 ) { System . out . println ( \"Draw page does not contain any shapes\" ); return null ; } // create a shapes list ArrayList < XShape > xShapesList = new ArrayList < XShape > (); try { for ( int j = 0 ; j < dp . getCount (); j ++ ) xShapesList . add ( Lo . qi ( XShape . class , dp . getByIndex ( j ))); } catch ( Exception e ) { System . out . println ( \"Extraction error in draw page\" ); } return xShapesList ; } // end of getShapes() XShape is part of the Shape service, which contains many shape-related properties. XShape inherits XShapeDescriptor, which includes a getShapeType() method for returning the shape type as a string. Figure 5 summarizes these details. Figure 5. The Shape Service and XShape Interface Draw.printShapeInfo() accesses the Shape service associated with an XShape reference, and prints its \"XOrder\" property. This number indicates the order that the shapes were added to the document. public static void printShapeInfo ( XShape xShape ) { Integer nZOrder = ( Integer ) Props . getProperty ( xShape , \"ZOrder\" ); System . out . println ( \" Shape service: \" + xShape . getShapeType () + \"; z-order: \" + nZOrder ); } printShapeInfo() also calls the inherited XShapeDescriptor.getShapeType() method to report the shape's service name. 3.3. Another Way of Accessing Drawing Shapes \u00b6 The XDrawPageSupplier documentation states that this interface is deprecated, although what's meant to replace it isn't clear. My guess is com.sun.star.text.XTextShapesSupplier, although I wasn't able to get it to supply anything. For example, the following always reports that the supplier is null: XTextShapesSupplier shpsSupplier = Lo . qi ( XTextShapesSupplier . class , textDoc ); if ( shpsSupplier == null ) System . out . println ( \"Could not obtain text shapes supplier\" ); else System . out . println ( \"Num. of text shapes: \" + shpsSupplier . getShapes (). getCount ());","title":"Chapter 8. Graphic Content"},{"location":"08-Graphic_Content.html#chapter-8-graphic-content","text":"Topics Graphics; Linked Images/Shapes Example folders: \"Text Tests\" and \"Utils\" Chapter 7 looked at several forms of text document content (e.g. text frames, math formulae, text fields and tables, and bookmarks), as indicated by Figure 1. However the different ways of adding graphical content (corresponding to the services highlighted in orange) are the focus of this chapter Figure 1. The TextContent Service and Some Subclasses.","title":"Chapter 8. Graphic Content"},{"location":"08-Graphic_Content.html#1-linking-a-graphic-object-to-a-document","text":"Adding an image to a text document follows the same steps as other text content, as shown in Write.addImageLink(): public static void addImageLink ( XTextDocument doc , XTextCursor cursor , String fnm ) { addImageLink ( doc , cursor , fnm , 0 , 0 ); } // 0, 0 means use image's size as width & height public static void addImageLink ( XTextDocument doc , XTextCursor cursor , String fnm , int width , int height ) { try { // create TextContent for graphic XTextContent tgo = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.text.TextGraphicObject\" ); if ( tgo == null ) { System . out . println ( \"Could not create a text graphic object\" ); return ; } // set anchor and URL properties XPropertySet props = Lo . qi ( XPropertySet . class , tgo ); props . setPropertyValue ( \"AnchorType\" , TextContentAnchorType . AS_CHARACTER ); props . setPropertyValue ( \"GraphicURL\" , FileIO . fnmToURL ( fnm )); // optionally set the width and height if (( width > 0 ) && ( height > 0 )) { props . setPropertyValue ( \"Width\" , width ); props . setPropertyValue ( \"Height\" , height ); } // append image to document, followed by a newline append ( cursor , tgo ); endLine ( cursor ); } catch ( Exception e ) { System . out . println ( \"Insert of \\\"\" + fnm + \"\\\" failed: \" + e ); } } // end of addImageLink() The TextGraphicObject service doesn't offer a XTextGraphicObject interface, so Lo.createInstanceMSF() returns an XTextContext. The interface is also converted to XPropertySet because several properties need to be set. The frame is anchored, and the image's filename is assigned to \"GraphicURL\" (after being changed into a URL). The image's size on the page depends on the dimensions of its enclosing frame, which are set in the \"Width\" and \"Height\" properties: props . setPropertyValue ( \"Width\" , 4500 ); // 45 mm width props . setPropertyValue ( \"Height\" , 4000 ); // 40 mm height The values are in 1/100 mm units, so 4500 is 45 mm or 4.5 cm. If these properties aren't explicitly set then the frame size defaults to being the width and height of the image. In more realistic code, the width and height properties would be calculated as some scale factor of the image's size, as measured in 1/100 mm units not pixels. These dimensions are available if the image file is loaded as an XGraphic object, as shown in Images.getSize100mm(): // in the Images class public static Size getSize100mm ( String imFnm ) { XGraphic graphic = loadGraphicFile ( imFnm ); if ( graphic == null ) return null ; return ( Size ) Props . getProperty ( graphic , \"Size100thMM\" ); } // end of getSize100mm() public static XGraphic loadGraphicFile ( String imFnm ) { // create graphics provider XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); if ( gProvider == null ) { System . out . println ( \"Graphic Provider could not be found\" ); return null ; } // set URL property and query it for XGraphic PropertyValue [] fileProps = Props . makeProps ( \"URL\" , FileIO . fnmToURL ( imFnm )); try { return gProvider . queryGraphic ( fileProps ); } catch ( Exception e ) { System . out . println ( \"Could not load XGraphic from \" + imFnm ); return null ; } } // end of loadGraphicFile() Displaying the image at a scaled size is possible by combining Images.getSize100mm() and Write.addImageLink(): Size imSize = Images . getSize100mm ( imFnm ); int w = ( int ) Math . round ( imSize . Width * 1.5 ); // enlarge by 1.5x int h = ( int ) Math . round ( imSize . Height * 1.5 ); Write . addImageLink ( doc , cursor , imFnm , w , h ); A possible drawback of Write.addImageLink() is that the document only contains a link to the image. This becomes an issue if you save the document in a format other than \".odt\". In particular, when saved as a Word \".doc\" file, the link is lost.","title":"1.  Linking a Graphic Object to a Document"},{"location":"08-Graphic_Content.html#2-adding-a-graphic-to-a-document-as-a-shape","text":"An alternative to inserting a graphic as a link is to treat it as a shape. Shapes will be discussed at length in Part 3, so I won't go into much detail about them here. One difference between a graphic link and shape is that shapes can be rotated. Shapes can be created using the com.sun.star.text.Shape service, com.sun.star.drawing.Shape, or one of its subclasses, while XDrawPageSupplier.getDrawPage() accesses the shapes in a document. The shape hierarchy is quite extensive (i.e. there are many kinds of shape), so only the parts used here are shown in Figure 2: Figure 2. Part of the Shape Hierarchy. In Figure 2, \"(text) Shape\" refers to the com.sun.star.text.Shape service, while \"(drawing) Shape\" is com.sun.star.drawing.Shape. My examples use GraphicObjectShape to create a shape containing an image, and LineShape to add a line to the document. The XShapeDescriptor interface in com.sun.star.drawing.Shape is a useful way to obtain the name of a shape service.","title":"2.  Adding a Graphic to a Document as a Shape"},{"location":"08-Graphic_Content.html#21-creating-an-image-shape","text":"The BuildDoc.java example adds an image shape to the document by calling Write.addImageShape(): // code fragment in BuildDoc.java Write . append ( cursor , \"Image as a shape: \" ); Write . addImageShape ( doc , cursor , imFnm ); // image filename Write . endParagraph ( cursor ); Write.addImageShape() comes in two versions: with and without width and height arguments. A shape with no explicitly set width and height properties is rendered as a miniscule image (about 1 mm wide). Call me old-fashioned, but I want to see the graphic, so Write.addImageShape() calculates the picture's dimensions if none are supplied by the user. Another difference between image shape and image link is how the content's \"GraphicURL\" property is employed. The image link version contains its URL, while the image shape's \"GraphicURL\" stores its bitmap as a string. The code for Write.addImageShape(): public static void addImageShape ( XTextDocument doc , XTextCursor cursor , String fnm ) { addImageShape ( doc , cursor , fnm , 0 , 0 ); } /* 0, 0 means that the method must calculate the image's size */ public static void addImageShape ( XTextDocument doc , XTextCursor cursor , String fnm , int width , int height ) { Size imSize ; if (( width > 0 ) && ( height > 0 )) imSize = new Size ( width , height ); else { imSize = Images . getSize100mm ( fnm ); if ( imSize == null ) return ; } try { // create TextContent for the graphic shape XTextContent gos = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.GraphicObjectShape\" ); if ( gos == null ) { System . out . println ( \"Could not create a graphic shape\" ); return ; } // store the image's bitmap in the \"GraphicURL\" property String bitmap = Images . getBitmap ( fnm ); Props . setProperty ( gos , \"GraphicURL\" , bitmap ); // set the shape's size XShape xDrawShape = Lo . qi ( XShape . class , gos ); xDrawShape . setSize ( imSize ); // must be set, or image is tiny // insert image shape into the document, followed by newline append ( cursor , gos ); endLine ( cursor ); } catch ( Exception e ) { System . out . println ( \"Insert of \\\"\" + fnm + \"\\\" failed: \" + e ); } } // end of addImageShape() The image's size is calculated using Images.getSize100mm() if the user doesn't supply a width and height, and is used towards the end of the method. An image shape is created using the GraphicObjectShape service, and its XTextContent interface is converted to XPropertySet for assigning its properties, and to XShape for setting its size (see Figure 2). XShape includes a setSize() method. Images.getBitmap() converts the graphic into a bitmap string. // in the Images utility class public static String getBitmap ( String fnm ) { try { // create a BitmapTable service and named container XNameContainer bitmapContainer = Lo . createInstanceMSF ( XNameContainer . class , \"com.sun.star.drawing.BitmapTable\" ); // insert image into container if ( ! FileIO . isOpenable ( fnm )) return null ; String picURL = FileIO . fnmToURL ( fnm ); if ( picURL == null ) return null ; bitmapContainer . insertByName ( fnm , picURL ); // use the filename as the name of the bitmap // return the bitmap as a string return ( String ) bitmapContainer . getByName ( fnm ); } catch ( Exception e ) { System . out . println ( \"Could not create bitmap for \" + fnm ); return null ; } } // end of getBitmap() getBitmap() uses a BitmapTable service to store the image's file in an XNameContainer. When the bitmap value is retrieved from the container, it can be cast to a string. A named container requires a name be assigned to the bitmap value; I use the image's filename, but any unique string would do.","title":"2.1.  Creating an Image Shape"},{"location":"08-Graphic_Content.html#22-adding-other-graphics-to-the-document","text":"The graphic text content can be any subclass of Shape. In the last section I created a GraphicObjectShape service, and accessed its XTextContent interface: XTextContent gos = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.GraphicObjectShape\" ); In this section I'll use LineShape: XTextContent ls = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.LineShape\" ); The aim is to draw an horizontal line in the document, to act as a divider between paragraphs. The line will be half-a-page wide and centered, like the one in Figure 3 Figure 3. A Graphical Line Divider. The difficult part is calculating the width of the line, which should only extend across half the writing width. This isn't the same as the page width because it doesn't include the left and right margins. The page and margin dimensions are accessible through the \"Standard\" page style, as implemented in Write.getPageTextWidth(): public static int getPageTextWidth ( XTextDocument textDoc ) // get the page's writing width { // access the \"standard\" style in the pages style family XPropertySet props = Info . getStyleProps ( textDoc , \"PageStyles\" , \"Standard\" ); if ( props == null ) { System . out . println ( \"Could not access the standard page style\" ); return 0 ; } // lookup the page and margin widths try { int width = (( Integer ) props . getPropertyValue ( \"Width\" )). intValue (); int leftMargin = (( Integer ) props . getPropertyValue ( \"LeftMargin\" )). intValue (); int rightMargin = (( Integer ) props . getPropertyValue ( \"RightMargin\" )). intValue (); return ( width - ( leftMargin + rightMargin )); // writing width } catch ( Exception e ) { System . out . println ( \"Could not access page dimensions: \" + e ); return 0 ; } } // end of getPageTextWidth() getPageTextWidth() returns the writing width in 1/100 mm units, which is scaled, then passed to Write.addLineDivider(): // code fragment in BuildDoc,java int textWidth = Write . getPageTextWidth ( doc ); Write . addLineDivider ( cursor , ( int ) Math . round ( textWidth * 0.5 ) ); // scale width by 0.5 addLineDivider() creates a LineShape service with an XTextContent interface (see Figure 2). This is converted to XShape so its setSize() method can be passed the line width: public static void addLineDivider ( XTextCursor cursor , int lineWidth ) // in the Writer class { try { // create TextContent for a line XTextContent ls = Lo . createInstanceMSF ( XTextContent . class , \"com.sun.star.drawing.LineShape\" ); if ( ls == null ) { System . out . println ( \"Could not create a line shape\" ); return ; } // set line size XShape lineShape = Lo . qi ( XShape . class , ls ); lineShape . setSize ( new Size ( lineWidth , 0 )); endParagraph ( cursor ); append ( cursor , ls ); // put line in its own paragraph endParagraph ( cursor ); // center the line paragraph stylePrevParagraph ( cursor , \"ParaAdjust\" , com . sun . star . style . ParagraphAdjust . CENTER ); endParagraph ( cursor ); } catch ( Exception e ) { System . out . println ( \"Insertion of graphic line failed\" ); } } // end of addLineDivider() The centering of the line is achieved by placing the shape in its own paragraph, then using Write.stylePrevParagraph() to center it.","title":"2.2.  Adding Other Graphics to the Document"},{"location":"08-Graphic_Content.html#3-accessing-linked-images-and-shapes","text":"The outcome of running BuildDoc.java is a \"build.odt\" file containing four graphics \u2013 two are linked images, one is an image shape, and the other a line shape. The ExtractGraphics.java example extracts linked graphics from a document, saving them as PNG files. It also prints information about the shapes in the document. When ExtractGraphics is passed \"build.odt\", the following is output: Num. of text graphics: 2 Saving graphic in graphics1.png Image size in pixels: 319 x 274 Saving graphic in graphics2.png Image size in pixels: 319 x 274 Num. of draw shapes: 3 Shape service: FrameShape; z-order: 0 Shape service: com.sun.star.drawing.GraphicObjectShape; z-order: 1 Shape service: com.sun.star.drawing.LineShape; z-order: 2 A user who looked at \"build.odt\" for themselves might say that it contains three images not the two reported by ExtractGraphics. Why the discrepancy? ExtractGraphics.java only saves linked graphics, and only two were added by Write.addImageLink(). The other image was inserted using Write.addImageShape() which creates an image shape. The number of shapes reported by ExtractGraphics.java may also confuse the user \u2013 why are there three rather than two? The only shapes added to the document were an image and a line. The names of the services gives a clue: the second and third shapes are the expected GraphicObjectShape and LineShape, but the first is a text frame (FrameShape) added by Write.addTextFrame(). Although this frame is an instance of the TextFrame service, it's reported as a FrameShape. That's a bit mysterious because there's no FrameShape service in the Office documentation. The main() function of ExtractGraphics.java: public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument textDoc = Write . openDoc ( args [ 0 ] , loader ); if ( textDoc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // save text graphics to files ArrayList < XGraphic > pics = Write . getTextGraphics ( textDoc ); if ( pics == null ) return ; System . out . println ( \"\\nNum. of text graphics: \" + pics . size ()); int i = 1 ; for ( XGraphic pic : pics ) { Images . saveGraphic ( pic , \"graphics\" + i + \".png\" , \"png\" ); Size sz = ( Size ) Props . getProperty ( pic , \"SizePixel\" ); System . out . println ( \"Image size in pixels: \" + sz . Width + \" x \" + sz . Height ); i ++ ; } System . out . println (); // report on shapes in the document XDrawPage drawPage = Write . getShapes ( textDoc ); ArrayList < XShape > shapes = Draw . getShapes ( drawPage ); if ( shapes != null ) System . out . println ( \"\\nNum. of draw shapes: \" + shapes . size ()); for ( XShape shape : shapes ) Draw . printShapeInfo ( shape ); System . out . println (); Lo . closeDoc ( textDoc ); Lo . closeOffice (); } // end of main() The first block of code saves text graphic objects as PNGs, and the second reports on shapes.","title":"3.  Accessing Linked Images and Shapes"},{"location":"08-Graphic_Content.html#31-finding-and-saving-text-graphics-in-a-document","text":"Write.getTextGraphics() returns a list of XGraphic objects: first it retrieves a collection of the graphic links in the document, then iterates through them creating an XGraphic object for each one: // in the Write class public static ArrayList < XGraphic > getTextGraphics ( XTextDocument textDoc ) { // get all the graphic links XNameAccess xNameAccess = getGraphicLinks ( textDoc ); if ( xNameAccess == null ) return null ; String [] names = xNameAccess . getElementNames (); System . out . println ( \"Number of graphics found: \" + names . length ); // build a list of XGraphic objects, one for each link ArrayList < XGraphic > pics = new ArrayList < XGraphic > (); for ( int i = 0 ; i < names . length ; i ++ ) { Object graphicLink = null ; try { graphicLink = xNameAccess . getByName ( names [ i ] ); } catch ( com . sun . star . uno . Exception e ) {} if ( graphicLink == null ) System . out . println ( \"No graphic found for \" + names [ i ] ); else { XGraphic xGraphic = Images . loadGraphicLink ( graphicLink ); if ( xGraphic != null ) pics . add ( xGraphic ); else System . out . println ( names [ i ] + \" could not be accessed\" ); } } return pics ; } // end of getTextGraphics() Graphic objects are accessed with XTextGraphicObjectsSupplier, as implemented by Write.getGraphicLinks(): // in the Write class public static XNameAccess getGraphicLinks ( XComponent doc ) { XTextGraphicObjectsSupplier imsSupplier = Lo . qi ( XTextGraphicObjectsSupplier . class , doc ); if ( imsSupplier == null ) { System . out . println ( \"Supplier could not be created\" ); return null ; } XNameAccess xNameAccess = imsSupplier . getGraphicObjects (); if ( xNameAccess == null ) { System . out . println ( \"Name access to graphics not possible\" ); return null ; } if ( ! xNameAccess . hasElements ()) { System . out . println ( \"No graphics elements found\" ); return null ; } return xNameAccess ; } // end of getGraphicLinks() Back in Write.getTextGraphics, each graphic is loaded by calling Images.loadGraphicLink(). It loads an image from the URL associated with a link: // in the Images class public static XGraphic loadGraphicLink ( Object graphicLink ) { // create graphic provider XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); if ( gProvider == null ) { System . out . println ( \"Graphic Provider could not be found\" ); return null ; } // set up URL property then load as an XGraphic try { XPropertySet xprops = Lo . qi ( XPropertySet . class , graphicLink ); PropertyValue [] gProps = Props . makeProps ( \"URL\" , ( String ) xprops . getPropertyValue ( \"GraphicURL\" ) ); return gProvider . queryGraphic ( gProps ); } catch ( Exception e ) { System . out . println ( \"Unable to retrieve graphic\" ); return null ; } } // end of loadGraphicLink() Note that the XGraphic is not extracted from the document but loaded from a URL. Back in ExtractGraphics.java, the XGraphic objects are saved as PNG files, and their pixel sizes reported: private static void savePics ( XTextDocument textDoc ) // method in ExtractGraphics.java { ArrayList < XGraphic > pics = Write . getTextGraphics ( textDoc ); if ( pics == null ) return ; System . out . println ( \"No. of graphic retrieved: \" + pics . size ()); int i = 1 ; for ( XGraphic pic : pics ) { Images . saveGraphic ( pic , \"graphics\" + i + \".png\" , \"png\" ); Size sz = ( Size ) Props . getProperty ( pic , \"SizePixel\" ); System . out . println ( \"Image Pixel size: \" + sz . Width + \" x \" + sz . Height ); i ++ ; } } // end of savePics() Images.saveGraphic() utilizes the graphic provider's XGraphicProvider.storeGraphic() method: // in XGraphicProvider void storeGraphic ( XGraphic g , PropertyValue [] props ) { ... } Its second argument is an array of PropertyValue objects, not a PropertySet. My Props.java utility class provides several functions for creating PropertyValue instances, which are a variant of the {name=value} pair idea, but with extra data fields. One such function is: // in Props.java PropertyValue [] makeProps ( String [] nms , Object [] vals ) { ... } It's passed an array of names and values, which are paired up as PropertyValue objects, and returned in an array. In saveGraphic(), these methods are used like so: XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); // set up properties for storing the graphic PropertyValue [] props = Props . makeProps ( \"URL\" , FileIO . fnmToURL ( fnm ), \"MimeType\" , \"image/\" + imFormat ); gProvider . storeGraphic ( pic , props ); The idea is to call XGraphicProvider.saveGraphics() with the \"URL\" and \"MimeType\" properties set \u2013 the URL is for the image file, and the mimetype is an image type (e.g. \"image/png\"). saveGraphic() is coded as: public static void saveGraphic ( XGraphic pic , String fnm , String imFormat ) { // create graphic provider XGraphicProvider gProvider = Lo . createInstanceMCF ( XGraphicProvider . class , \"com.sun.star.graphic.GraphicProvider\" ); if ( gProvider == null ) { System . out . println ( \"Graphic Provider could not be found\" ); return ; } if ( pic == null ) { System . out . println ( \"Supplied image is null\" ); return ; } // set up properties for storing the graphic PropertyValue [] pngProps = Props . makeProps ( \"URL\" , FileIO . fnmToURL ( fnm ), \"MimeType\" , \"image/\" + imFormat ); try { gProvider . storeGraphic ( pic , pngProps ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to save graphic\" ); } } // end of saveGraphic() Other possible image MIME types include \"gif\", \"jpeg\", \"wmf\", and \"bmp\". For instance, this call will save the image as a GIF: Images.saveGraphic(pic, \"graphics\" + i + \".gif\", \"gif\"); The printed output from saveGraphic() contains another surprise: Num. of text graphics: 2 Saving graphic in graphics1.png Image size in pixels: 319 x 274 Saving graphic in graphics2.png Image size in pixels: 319 x 274 The two saved graphics are the same size, but the second image is bigger inside the document. The discrepancy is because the rendering of the image in the document is bigger, scaled up to fit the enclosing frame; the original image is unchanged.","title":"3.1.  Finding and Saving Text Graphics in a Document"},{"location":"08-Graphic_Content.html#32-finding-the-shapes-in-a-document","text":"The second block of code in ExtractGraphics reports on the shapes found in the document. The relevant code fragment is: // code fragment from ExtractGraphics.java XDrawPage drawPage = Write . getShapes ( textDoc ); ArrayList < XShape > shapes = Draw . getShapes ( drawPage ); if ( shapes != null ) System . out . println ( \"\\nNum. of draw shapes: \" + shapes . size ()); for ( XShape shape : shapes ) Draw . printShapeInfo ( shape ); Shapes are accessed with the XDrawPageSupplier.getDrawPage() method, which returns a single XDrawPage: public static XDrawPage getShapes ( XTextDocument textDoc ) { XDrawPageSupplier drawPageSupplier = Lo . qi ( XDrawPageSupplier . class , textDoc ); if ( drawPageSupplier == null ) { System . out . println ( \"Draw page supplier could not be created\" ); return null ; } return drawPageSupplier . getDrawPage (); } // end of getShapes() XDrawPage's usual role is to represent the canvas in Office's Draw, or a slide in Impress, and so plays an important role in Part 3. Several support functions inside that part's Draw utility class will be used here. XDrawPageSupplier.getDrawPage() returns a single XDrawPage for the entire text document. That doesn't mean that the shapes all have to occur on a single text page, but rather that all the shapes spread across multiple text pages are collected into a single draw page. XDrawPage inherits from XShapes and XindexAccess, as shown in Figure 4, which means that a page can be viewed as a indexed collection of shapes. Figure 4. Partial Inheritance Hierarchy for XDrawPage. Draw.getShapes() uses this idea to iterate through the draw page and store the shapes in a list: // in the Draw class public static ArrayList < XShape > getShapes ( XDrawPage dp ) { if ( dp == null ) { System . out . println ( \"Draw page is null\" ); return null ; } if ( dp . getCount () == 0 ) { System . out . println ( \"Draw page does not contain any shapes\" ); return null ; } // create a shapes list ArrayList < XShape > xShapesList = new ArrayList < XShape > (); try { for ( int j = 0 ; j < dp . getCount (); j ++ ) xShapesList . add ( Lo . qi ( XShape . class , dp . getByIndex ( j ))); } catch ( Exception e ) { System . out . println ( \"Extraction error in draw page\" ); } return xShapesList ; } // end of getShapes() XShape is part of the Shape service, which contains many shape-related properties. XShape inherits XShapeDescriptor, which includes a getShapeType() method for returning the shape type as a string. Figure 5 summarizes these details. Figure 5. The Shape Service and XShape Interface Draw.printShapeInfo() accesses the Shape service associated with an XShape reference, and prints its \"XOrder\" property. This number indicates the order that the shapes were added to the document. public static void printShapeInfo ( XShape xShape ) { Integer nZOrder = ( Integer ) Props . getProperty ( xShape , \"ZOrder\" ); System . out . println ( \" Shape service: \" + xShape . getShapeType () + \"; z-order: \" + nZOrder ); } printShapeInfo() also calls the inherited XShapeDescriptor.getShapeType() method to report the shape's service name.","title":"3.2.  Finding the Shapes in a Document"},{"location":"08-Graphic_Content.html#33-another-way-of-accessing-drawing-shapes","text":"The XDrawPageSupplier documentation states that this interface is deprecated, although what's meant to replace it isn't clear. My guess is com.sun.star.text.XTextShapesSupplier, although I wasn't able to get it to supply anything. For example, the following always reports that the supplier is null: XTextShapesSupplier shpsSupplier = Lo . qi ( XTextShapesSupplier . class , textDoc ); if ( shpsSupplier == null ) System . out . println ( \"Could not obtain text shapes supplier\" ); else System . out . println ( \"Num. of text shapes: \" + shpsSupplier . getShapes (). getCount ());","title":"3.3.  Another Way of Accessing Drawing Shapes"},{"location":"09-Text_Search.html","text":"Chapter 9. Text Search and Replace \u00b6 Topics Finding the First Matching Phrase; Replacing all the Matching Words; Finding all Matching Phrases Example folders: \"Text Tests\" and \"Utils\" The GenericTextDocument service supports the XSearchable and XReplaceable interfaces (see Chapter 5, Figure 2), which are the entry points for doing regular expression based search and replace inside a document. XSearchable.createSearchDescriptor() builds a search description (an ordinary string or a regular expression). The search is executed with XSearchable.findAll() or findFirst() and findNext(). XReplaceable works in a similar way but with a replace descriptor which combines a replacement string with the search string. XReplaceable.replaceAll() performs search and replacement, but the XSearchable searching methods are available as well. This is shown in Figure 1. Figure 1. The XSearchable and XReplaceable Interfaces. The following code fragment utilizes the XSearchable and XSearchDescriptor interfaces: XSearchable searchable = Lo . qi ( XSearchable . class , doc ); XSearchDescriptor srchDesc = searchable . createSearchDescriptor (); srchDesc . setSearchString ( \"colou?r\" ); // a regular expression meaning \"color\" or \"colour\" XReplaceable and XReplaceDescriptor objects are configured in a similar way, as shown in the examples. XSearchDescriptor and XReplaceDescriptor contain get and set methods for their strings. But a lot of the search functionality is expressed as properties in their SearchDescriptor and ReplaceDescriptor services. Figure 2 summarizes these arrangements. Figure 2. The SearchDescriptor and ReplaceDescriptor Services. The next code fragment accesses the SearchDescriptor properties, and switches on regular expression searching: XPropertySet srchProps = Lo . qi ( XPropertySet . class , srchDesc ); srchProps . setPropertyValue ( \"SearchRegularExpression\" , true ); Alternatively, Props.setProperty() can be employed: Props . setProperty ( srchDesc , \"SearchRegularExpression\" , true ); Once a search descriptor has been created (i.e. its string is set and any properties configured), then one of the findXXX() methods in XSearchable can be called. For instance, XSearchable.findFirst() returns the text range of the first matching element (or null), as in: XInterface srch = ( XInterface ) searchable . findFirst ( srchDesc ); XTextRange matchTR = Lo . qi ( XTextRange . class , srch ); The example programs, TextReplace.java and ItalicsStyler.java, demonstrate search and replacement. TextReplace.java uses XSearchable to find the first occurrence of a regular expression and XReplaceable to replace multiple occurrences of other words. ItalicsStyler.java calls XSearchable's findAll() to find every occurrence of a phrase. 1. Finding the First Matching Phrase \u00b6 TextReplace.java repeatedly calls XSearchable.findFirst() with regular expressions taken from an array. The first matching phrase for each expression is reported. For instance, the call: String words [] = { \"(G|g)rit\" , \"colou?r\" }; findWords ( doc , words ); prints the following when \"story.doc\" is searched: Searching for first occurrence of \"(G|g)rit\" - found \"Grit\" - on page 1 - at char position: 929 Searching for first occurrence of \"colou?r\" - found \"colour\" - on page 5 - at char position: 10856 Three pieces of information are printed for each match: the text that matched, its page location, and its character position calculated from the start of the document. The character position could be obtained from a text cursor or a text view cursor, but I need a page cursor to access the page number. Therefore the easiest thing to use a text view cursor, and a linked page cursor. The code for findWords(): private static void findWords ( XTextDocument doc , String [] words ) { // get the text view cursor and linked page cursor XTextViewCursor tvc = Write . getViewCursor ( doc ); tvc . gotoStart ( false ); XPageCursor pageCursor = Lo . qi ( XPageCursor . class , tvc ); try { XSearchable searchable = Lo . qi ( XSearchable . class , doc ); XSearchDescriptor srchDesc = searchable . createSearchDescriptor (); for ( int i = 0 ; i < words . length ; i ++ ) { System . out . println ( \"Searching for first occurrence of \\\"\" + words [ i ] + \"\\\"\" ); srchDesc . setSearchString ( words [ i ] ); Props . setProperty ( srchDesc , \"SearchRegularExpression\" , true ); XInterface srch = ( XInterface ) searchable . findFirst ( srchDesc ); if ( srch != null ) { XTextRange matchTR = Lo . qi ( XTextRange . class , srch ); tvc . gotoRange ( matchTR , false ); System . out . println ( \" - found \\\"\" + matchTR . getString () + \"\\\"\" ); System . out . println ( \" - on page \" + pageCursor . getPage ()); tvc . gotoStart ( true ); System . out . println ( \" - at char position: \" + tvc . getString (). length ()); } else System . out . println ( \" - not found\" ); } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of findWords() findWords() creates the text view cursor (tvc), moves it to the start of the document, and links the page cursor to it: XPageCursor pageCursor = Lo . qi ( XPageCursor . class , tvc ); There is only one view cursor in an application, so when the text view cursor moves, so does the page cursor, and vice versa. The XSearchable and XSearchDescriptor interfaces are instantiated, and a for-loop searches for each word in the supplied array. If XSearchable.findFirst() returns a matching text range, it's used by XTextCursor.gotoRange() to update the position of the cursor. After the page position has been printed, the cursor is moved to the start of the document with selection turned on: tvc . gotoStart ( true ); System . out . println ( \" - at char position: \" + tvc . getString (). length ()); This means that tvc.getString() will return all the text from the start of the document to the current matching point, and so length() will return the character position measured from the beginning of the file. As I've mentioned previously, this approach may fail if the size of the string being instantiated is too big. 2. Replacing all the Matching Words \u00b6 TextReplace.java also contains a method called replaceWords(), which takes two string arrays as arguments: // code fragment inside TextReplace.java String ukWords [] = { \"colour\" , \"neighbour\" , \"centre\" , \"behaviour\" , \"metre\" , \"through\" }; String usWords [] = { \"color\" , \"neighbor\" , \"center\" , \"behavior\" , \"meter\" , \"thru\" }; replaceWords ( doc , ukWords , usWords ); replaceWords() cycles through the arrays, replacing all occurrences of the words in the first array (e.g. in ukWords[]) with the corresponding words in the second array (e.g. in usWords[]). For instance, every occurrence of \"colour\" is replaced by \"color\". The output: Change all occurrences of ... colour -> color - no. of changes: 1 neighbour -> neighbor - no. of changes: 2 centre -> center - no. of changes: 2 behaviour -> behavior - no. of changes: 0 metre -> meter - no. of changes: 0 through -> thru - no. of changes: 4 Since replaceWords() doesn't report page and character positions, its code is somewhat shorter than findWords(): private static void replaceWords ( XTextDocument doc , String [] oldWords , String [] newWords ) { XReplaceable replaceable = Lo . qi ( XReplaceable . class , doc ); XReplaceDescriptor replaceDesc = replaceable . createReplaceDescriptor (); System . out . println ( \"Change all occurrences of ...\" ); for ( int i = 0 ; i < oldWords . length ; i ++ ) { System . out . println ( \" \" + oldWords [ i ] + \" -> \" + newWords [ i ] ); replaceDesc . setSearchString ( oldWords [ i ] ); replaceDesc . setReplaceString ( newWords [ i ] ); int numChanges = replaceable . replaceAll ( replaceDesc ); // replace all occurrence of word System . out . println ( \" - no. of changes: \" + numChanges ); } } // end of replaceWords() The XReplaceable and XReplaceDescriptor interfaces are created in a similar way to their search versions. The replace descriptor has two set methods, one for the search string, the other for the replacement string. 3. Finding all Matching Phrases \u00b6 ItalicsStyler.java is supplied with a filename and a string on the command line. For instance: > run ItalicsStyler story.doc scandal The program opens the file and uses the \"search all' method in XSearchable to find all occurrences of the string in the document. The matching strings are italicized and colored red, and the changed document saved as \"italicized.doc\". These changes are not performed using XReplaceable methods. Figure 3 shows a fragment of the resulting document, with the \"scandal\" text in the title and header changed. The search ignores case, so the word in the title (\"Scandal\") was correctly modified. Figure 3. A Fragment of The Italicized Document. The ItalicsStyler program also outputs matching details: Searching for all occurrence of \"scandal\" No. of matches: 5 - found \"scandal\" - on page 1 - starting at char position: 6 - found \"Scandal\" - on page 1 - starting at char position: 2 - found \"scandal\" - on page 6 - starting at char position: 13153 - found \"scandal\" - on page 18 - starting at char position: 38736 - found \"scandal\" - on page 21 - starting at char position: 46425 As with TextReplace.java, the printed details include the page and character positions of the matches. The searching in ItalicsStyler.java is performed by italicizeAll(), which bears a close resemblance to findWords(): private static void italicizeAll ( XTextDocument doc , String phrase ) { // get the text view cursor and linked page cursor XTextViewCursor tvc = Write . getViewCursor ( doc ); tvc . gotoStart ( false ); XPageCursor pageCursor = Lo . qi ( XPageCursor . class , tvc ); try { XSearchable xSearchable = Lo . qi ( XSearchable . class , doc ); XSearchDescriptor srchDesc = xSearchable . createSearchDescriptor (); System . out . println ( \"Searching for all occurrences of \\\"\" + phrase + \"\\\"\" ); int phraseLen = phrase . length (); srchDesc . setSearchString ( phrase ); Props . setProperty ( srchDesc , \"SearchCaseSensitive\" , false ); XIndexAccess matches = xSearchable . findAll ( srchDesc ); System . out . println ( \"No. of matches: \" + matches . getCount ()); for ( int i = 0 ; i < matches . getCount (); i ++ ) { XTextRange matchTR = Lo . qi ( XTextRange . class , matches . getByIndex ( i )); if ( matchTR != null ) { tvc . gotoRange ( matchTR , false ); System . out . println ( \" - found \\\"\" + matchTR . getString () + \"\\\"\" ); System . out . println ( \" - on page \" + pageCursor . getPage ()); tvc . gotoStart ( true ); System . out . println ( \" - starting at char position: \" + ( tvc . getString (). length () - phraseLen )); Props . setProperties ( matchTR , new String [] { \"CharColor\" , \"CharPosture\" }, new Object [] { 0xFF0000 , com . sun . star . awt . FontSlant . ITALIC } ); } } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of italicizeAll() After the search descriptor string has been defined, the \"SearchCaseSensitive\" property in SearchDescriptor is set to false: srchDesc . setSearchString ( phrase ); Props . setProperty ( srchDesc , \"SearchCaseSensitive\" , false ); This allows the search to match text contains both upper and lower case letters, such as \"Scandal\". Many other search variants, such as restricting the search to complete words, and the use of search similarity parameters are described in the SearchDescriptor documentation (loDoc SearchDescriptor service). XSearchable.findAll() returns an XIndexAccess collection, which is examined element-by-element inside a for-loop. The text range for each element is obtained by applying Lo.qi(): XTextRange matchTR = Lo . qiXTextRange . class , matches . getByIndex ( i )); The reporting of the matching page and character position use text view and page cursors in the same way as findWords() in TextReplace.java. XTextRange is part of the TextRange service, which inherits ParagraphProperties and CharacterProperties. These properties are changed to adjust the character color and style of the selected range: Props . setProperties ( matchTR , new String [] { \"CharColor\" , \"CharPosture\" }, new Object [] { 0xFF0000 , com . sun . star . awt . FontSlant . ITALIC } ); This changes the \"CharColor\" and \"CharPosture\" properties to red and italic.","title":"Chapter 9. Text Search and Replace"},{"location":"09-Text_Search.html#chapter-9-text-search-and-replace","text":"Topics Finding the First Matching Phrase; Replacing all the Matching Words; Finding all Matching Phrases Example folders: \"Text Tests\" and \"Utils\" The GenericTextDocument service supports the XSearchable and XReplaceable interfaces (see Chapter 5, Figure 2), which are the entry points for doing regular expression based search and replace inside a document. XSearchable.createSearchDescriptor() builds a search description (an ordinary string or a regular expression). The search is executed with XSearchable.findAll() or findFirst() and findNext(). XReplaceable works in a similar way but with a replace descriptor which combines a replacement string with the search string. XReplaceable.replaceAll() performs search and replacement, but the XSearchable searching methods are available as well. This is shown in Figure 1. Figure 1. The XSearchable and XReplaceable Interfaces. The following code fragment utilizes the XSearchable and XSearchDescriptor interfaces: XSearchable searchable = Lo . qi ( XSearchable . class , doc ); XSearchDescriptor srchDesc = searchable . createSearchDescriptor (); srchDesc . setSearchString ( \"colou?r\" ); // a regular expression meaning \"color\" or \"colour\" XReplaceable and XReplaceDescriptor objects are configured in a similar way, as shown in the examples. XSearchDescriptor and XReplaceDescriptor contain get and set methods for their strings. But a lot of the search functionality is expressed as properties in their SearchDescriptor and ReplaceDescriptor services. Figure 2 summarizes these arrangements. Figure 2. The SearchDescriptor and ReplaceDescriptor Services. The next code fragment accesses the SearchDescriptor properties, and switches on regular expression searching: XPropertySet srchProps = Lo . qi ( XPropertySet . class , srchDesc ); srchProps . setPropertyValue ( \"SearchRegularExpression\" , true ); Alternatively, Props.setProperty() can be employed: Props . setProperty ( srchDesc , \"SearchRegularExpression\" , true ); Once a search descriptor has been created (i.e. its string is set and any properties configured), then one of the findXXX() methods in XSearchable can be called. For instance, XSearchable.findFirst() returns the text range of the first matching element (or null), as in: XInterface srch = ( XInterface ) searchable . findFirst ( srchDesc ); XTextRange matchTR = Lo . qi ( XTextRange . class , srch ); The example programs, TextReplace.java and ItalicsStyler.java, demonstrate search and replacement. TextReplace.java uses XSearchable to find the first occurrence of a regular expression and XReplaceable to replace multiple occurrences of other words. ItalicsStyler.java calls XSearchable's findAll() to find every occurrence of a phrase.","title":"Chapter 9. Text Search and Replace"},{"location":"09-Text_Search.html#1-finding-the-first-matching-phrase","text":"TextReplace.java repeatedly calls XSearchable.findFirst() with regular expressions taken from an array. The first matching phrase for each expression is reported. For instance, the call: String words [] = { \"(G|g)rit\" , \"colou?r\" }; findWords ( doc , words ); prints the following when \"story.doc\" is searched: Searching for first occurrence of \"(G|g)rit\" - found \"Grit\" - on page 1 - at char position: 929 Searching for first occurrence of \"colou?r\" - found \"colour\" - on page 5 - at char position: 10856 Three pieces of information are printed for each match: the text that matched, its page location, and its character position calculated from the start of the document. The character position could be obtained from a text cursor or a text view cursor, but I need a page cursor to access the page number. Therefore the easiest thing to use a text view cursor, and a linked page cursor. The code for findWords(): private static void findWords ( XTextDocument doc , String [] words ) { // get the text view cursor and linked page cursor XTextViewCursor tvc = Write . getViewCursor ( doc ); tvc . gotoStart ( false ); XPageCursor pageCursor = Lo . qi ( XPageCursor . class , tvc ); try { XSearchable searchable = Lo . qi ( XSearchable . class , doc ); XSearchDescriptor srchDesc = searchable . createSearchDescriptor (); for ( int i = 0 ; i < words . length ; i ++ ) { System . out . println ( \"Searching for first occurrence of \\\"\" + words [ i ] + \"\\\"\" ); srchDesc . setSearchString ( words [ i ] ); Props . setProperty ( srchDesc , \"SearchRegularExpression\" , true ); XInterface srch = ( XInterface ) searchable . findFirst ( srchDesc ); if ( srch != null ) { XTextRange matchTR = Lo . qi ( XTextRange . class , srch ); tvc . gotoRange ( matchTR , false ); System . out . println ( \" - found \\\"\" + matchTR . getString () + \"\\\"\" ); System . out . println ( \" - on page \" + pageCursor . getPage ()); tvc . gotoStart ( true ); System . out . println ( \" - at char position: \" + tvc . getString (). length ()); } else System . out . println ( \" - not found\" ); } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of findWords() findWords() creates the text view cursor (tvc), moves it to the start of the document, and links the page cursor to it: XPageCursor pageCursor = Lo . qi ( XPageCursor . class , tvc ); There is only one view cursor in an application, so when the text view cursor moves, so does the page cursor, and vice versa. The XSearchable and XSearchDescriptor interfaces are instantiated, and a for-loop searches for each word in the supplied array. If XSearchable.findFirst() returns a matching text range, it's used by XTextCursor.gotoRange() to update the position of the cursor. After the page position has been printed, the cursor is moved to the start of the document with selection turned on: tvc . gotoStart ( true ); System . out . println ( \" - at char position: \" + tvc . getString (). length ()); This means that tvc.getString() will return all the text from the start of the document to the current matching point, and so length() will return the character position measured from the beginning of the file. As I've mentioned previously, this approach may fail if the size of the string being instantiated is too big.","title":"1.  Finding the First Matching Phrase"},{"location":"09-Text_Search.html#2-replacing-all-the-matching-words","text":"TextReplace.java also contains a method called replaceWords(), which takes two string arrays as arguments: // code fragment inside TextReplace.java String ukWords [] = { \"colour\" , \"neighbour\" , \"centre\" , \"behaviour\" , \"metre\" , \"through\" }; String usWords [] = { \"color\" , \"neighbor\" , \"center\" , \"behavior\" , \"meter\" , \"thru\" }; replaceWords ( doc , ukWords , usWords ); replaceWords() cycles through the arrays, replacing all occurrences of the words in the first array (e.g. in ukWords[]) with the corresponding words in the second array (e.g. in usWords[]). For instance, every occurrence of \"colour\" is replaced by \"color\". The output: Change all occurrences of ... colour -> color - no. of changes: 1 neighbour -> neighbor - no. of changes: 2 centre -> center - no. of changes: 2 behaviour -> behavior - no. of changes: 0 metre -> meter - no. of changes: 0 through -> thru - no. of changes: 4 Since replaceWords() doesn't report page and character positions, its code is somewhat shorter than findWords(): private static void replaceWords ( XTextDocument doc , String [] oldWords , String [] newWords ) { XReplaceable replaceable = Lo . qi ( XReplaceable . class , doc ); XReplaceDescriptor replaceDesc = replaceable . createReplaceDescriptor (); System . out . println ( \"Change all occurrences of ...\" ); for ( int i = 0 ; i < oldWords . length ; i ++ ) { System . out . println ( \" \" + oldWords [ i ] + \" -> \" + newWords [ i ] ); replaceDesc . setSearchString ( oldWords [ i ] ); replaceDesc . setReplaceString ( newWords [ i ] ); int numChanges = replaceable . replaceAll ( replaceDesc ); // replace all occurrence of word System . out . println ( \" - no. of changes: \" + numChanges ); } } // end of replaceWords() The XReplaceable and XReplaceDescriptor interfaces are created in a similar way to their search versions. The replace descriptor has two set methods, one for the search string, the other for the replacement string.","title":"2.  Replacing all the Matching Words"},{"location":"09-Text_Search.html#3-finding-all-matching-phrases","text":"ItalicsStyler.java is supplied with a filename and a string on the command line. For instance: > run ItalicsStyler story.doc scandal The program opens the file and uses the \"search all' method in XSearchable to find all occurrences of the string in the document. The matching strings are italicized and colored red, and the changed document saved as \"italicized.doc\". These changes are not performed using XReplaceable methods. Figure 3 shows a fragment of the resulting document, with the \"scandal\" text in the title and header changed. The search ignores case, so the word in the title (\"Scandal\") was correctly modified. Figure 3. A Fragment of The Italicized Document. The ItalicsStyler program also outputs matching details: Searching for all occurrence of \"scandal\" No. of matches: 5 - found \"scandal\" - on page 1 - starting at char position: 6 - found \"Scandal\" - on page 1 - starting at char position: 2 - found \"scandal\" - on page 6 - starting at char position: 13153 - found \"scandal\" - on page 18 - starting at char position: 38736 - found \"scandal\" - on page 21 - starting at char position: 46425 As with TextReplace.java, the printed details include the page and character positions of the matches. The searching in ItalicsStyler.java is performed by italicizeAll(), which bears a close resemblance to findWords(): private static void italicizeAll ( XTextDocument doc , String phrase ) { // get the text view cursor and linked page cursor XTextViewCursor tvc = Write . getViewCursor ( doc ); tvc . gotoStart ( false ); XPageCursor pageCursor = Lo . qi ( XPageCursor . class , tvc ); try { XSearchable xSearchable = Lo . qi ( XSearchable . class , doc ); XSearchDescriptor srchDesc = xSearchable . createSearchDescriptor (); System . out . println ( \"Searching for all occurrences of \\\"\" + phrase + \"\\\"\" ); int phraseLen = phrase . length (); srchDesc . setSearchString ( phrase ); Props . setProperty ( srchDesc , \"SearchCaseSensitive\" , false ); XIndexAccess matches = xSearchable . findAll ( srchDesc ); System . out . println ( \"No. of matches: \" + matches . getCount ()); for ( int i = 0 ; i < matches . getCount (); i ++ ) { XTextRange matchTR = Lo . qi ( XTextRange . class , matches . getByIndex ( i )); if ( matchTR != null ) { tvc . gotoRange ( matchTR , false ); System . out . println ( \" - found \\\"\" + matchTR . getString () + \"\\\"\" ); System . out . println ( \" - on page \" + pageCursor . getPage ()); tvc . gotoStart ( true ); System . out . println ( \" - starting at char position: \" + ( tvc . getString (). length () - phraseLen )); Props . setProperties ( matchTR , new String [] { \"CharColor\" , \"CharPosture\" }, new Object [] { 0xFF0000 , com . sun . star . awt . FontSlant . ITALIC } ); } } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of italicizeAll() After the search descriptor string has been defined, the \"SearchCaseSensitive\" property in SearchDescriptor is set to false: srchDesc . setSearchString ( phrase ); Props . setProperty ( srchDesc , \"SearchCaseSensitive\" , false ); This allows the search to match text contains both upper and lower case letters, such as \"Scandal\". Many other search variants, such as restricting the search to complete words, and the use of search similarity parameters are described in the SearchDescriptor documentation (loDoc SearchDescriptor service). XSearchable.findAll() returns an XIndexAccess collection, which is examined element-by-element inside a for-loop. The text range for each element is obtained by applying Lo.qi(): XTextRange matchTR = Lo . qiXTextRange . class , matches . getByIndex ( i )); The reporting of the matching page and character position use text view and page cursors in the same way as findWords() in TextReplace.java. XTextRange is part of the TextRange service, which inherits ParagraphProperties and CharacterProperties. These properties are changed to adjust the character color and style of the selected range: Props . setProperties ( matchTR , new String [] { \"CharColor\" , \"CharPosture\" }, new Object [] { 0xFF0000 , com . sun . star . awt . FontSlant . ITALIC } ); This changes the \"CharColor\" and \"CharPosture\" properties to red and italic.","title":"3.  Finding all Matching Phrases"},{"location":"10-Linguistics.html","text":"Chapter 10. The Linguistics API \u00b6 Topics Linguistic Tools; Using the Spell Checker; Using the Thesaurus; Grammar Checking; Guessing the Language used in a String; Spell Checking and Grammar Checking a Document Example folders: \"Lingu Tests\" and \"Utils\" The linguistics API has four main components \u2013 a spell checker, a hyphenator, a thesaurus, and a grammar checker (which Office calls a proof reader). I'll look at how to program using the spell checker, thesaurus, and two grammar checkers, but I'll skip the hyphenator which is easier to use interactively through Office's GUI. However, if you have an urge to hyphenate, then LingusticExamples.java in the Developer's Guide examples contains some code; it can be downloaded from https://api.libreoffice.org/examples/DevelopersGuide/OfficeDev/Linguistic/LinguisticExamples.java . I'll describe two examples, Lingo.java and LingoFile.java. The first lists information about the linguistic services, then uses the spell checker, thesaurus, and grammar checker 'standalone' without having to load an Office document first. LingoFile.java automatically spell checks and grammar checks a complete file, reporting errors without altering the document. One topic I'll be ignoring is how to create and edit the data files used by the linguistic services. For that task, you should have a look at PTG (Proofing Tool GUI) developed by Marco Pinto at https://marcoagpinto.cidadevirtual.pt/proofingtoolgui.html . It's an open source tool for editing Office's dictionary, thesaurus, hyphenation, and autocorrect files. Another area I'll be skipping is the use of events and listeners. Please refer to the \"Linguistics\" sub-section of chapter 6 of the Developer's Guide for details ( loGuide Linguistics ). Listener code can be found in LinguisticExamples.java mentioned above. The linguistic features accessible through Office's GUI are explained in chapter 3 of the \"Writer Guide\", available at https://libreoffice.org/get-help/documentation/ , starting from the section called \"Checking spelling and grammar\". An older information source is the \"Lingucomponent Project\" page at the OpenOffice website, https://openoffice.org/lingucomponent/ , which links to some useful tools, such as alternative grammar checkers. An interesting set of slides by Daniel Naber explaining the state of the project in 2005 can be found at https://danielnaber.de/publications/ , along with more recent material. 1. The Linguistic Tools \u00b6 Lingo.java prints a variety of information about the linguistics services: public static void main ( String args [] ) { Lo . loadOffice (); // print linguistics info Write . dictsInfo (); XLinguProperties linguProps = Write . getLinguProperties (); Props . showProps ( \"Linguistic Manager\" , linguProps ); Info . listExtensions (); // get lingo manager XLinguServiceManager2 lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager2 . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); if ( lingoMgr == null ) { System . out . println ( \"No linguistics manager found\" ); Lo . closeOffice (); return ; } Write . printServicesInfo ( lingoMgr ); : // code for using the services; see later Lo . closeOffice (); } // end of main() 1.1. Dictionary Information \u00b6 Write.dictsInfo() prints brief details about Office's dictionaries: No . of dictionaries : 5 standard . dic ( 1 ); active ; \"\" ; positive en - GB . dic ( 42 ); active ; \"GB\" ; positive en - US . dic ( 42 ); active ; \"US\" ; positive technical . dic ( 258 ); active ; \"\" ; positive IgnoreAllList ( 0 ); active ; \"\" ; positive No . of conversion dictionaries : 0 Each line includes the name of a dictionary, its number of entries, whether it's active (i.e. being used), its locale, and whether it's a positive, negative, or mixed dictionary. A positive dictionary holds correctly spelled words only, while a negative one lists incorrectly spelt words. A mixed dictionary contains both correctly and incorrectly spelt entries. If a dictionary has a locale, such as \"GB\" for en-GB.dic, then it's only utilized during spell checking if its locale matches Office's. The Office locale can be set via the Tools, Options, Language Settings, \"Languages\" dialog shown in Figure 1. Figure 1. The Languages Dialog. Figure 1 shows that my version of Office is using the American English locale, and so en-GB.dic won't be consulted when text is spell checked. Write.dictsInfo() is defined as: // in the Write class public static void dictsInfo () { XSearchableDictionaryList dictList = Lo . createInstanceMCF ( XSearchableDictionaryList . class , \"com.sun.star.linguistic2.DictionaryList\" ); if ( dictList == null ) System . out . println ( \"No list of dictionaries found\" ); else printDictsInfo ( dictList ); XConversionDictionaryList cdList = Lo . createInstanceMCF ( XConversionDictionaryList . class , \"com.sun.star.linguistic2.ConversionDictionaryList\" ); if ( cdList == null ) System . out . println ( \"No list of conversion dictionaries found\" ); else printConDictsInfo ( cdList ); } // end of dictsInfo() It retrieves a conventional dictionary list first (called dictList), and iterates through its dictionaries using printDictsInfo(). Then it obtains the conversion dictionary list (called csList), and iterates over that with printConDictsInfo(). Figure 2 shows the main services and interfaces used by ordinary dictionaries. Figure 2. The DictionaryList and Dictionary Services. Each dictionary in the list has an XDictionary interface which contains methods for accessing and changing its entries. printDictsInfo() retrieves an XDictionary array from the list, and prints out a summary of each dictionary: // in the Write class public static void printDictsInfo ( XSearchableDictionaryList dictList ) { if ( dictList == null ) { System . out . println ( \"Dictionary list is null\" ); return ; } System . out . println ( \"No. of dictionaries: \" + dictList . getCount ()); XDictionary [] dicts = dictList . getDictionaries (); for ( XDictionary dict : dicts ) System . out . println ( \" \" + dict . getName () + \" (\" + dict . getCount () + \"); \" + ( dict . isActive () ? \"active\" : \"na\" ) + \"; \\\"\" + dict . getLocale (). Country + \"\\\"; \" + getDictType ( dict . getDictionaryType ())); System . out . println (); } // end of printDictsInfo() public static String getDictType ( DictionaryType dt ) { if ( dt == DictionaryType . POSITIVE ) return \"positive\" ; else if ( dt == DictionaryType . NEGATIVE ) return \"negative\" ; else if ( dt == DictionaryType . MIXED ) return \"mixed\" ; else return \"??\" ; } // end of getDictType() Conversion dictionaries map words in one language/dialect to corresponding words in another language/dialect. 3 shows that conversion dictionaries are organized in a similar way to ordinary ones. The interfaces for manipulating a conversion dictionary are XConversionDictionary and XConversionPropertyType. Figure 3. The ConversionDictionaryList and ConversionDictionary Services. Write.dictsInfo() calls printConDictsInfo() to print the names of the conversion dictionaries \u2013 by extracting an XNameContainer from the dictionary list, and then pulling a list of the names from the container: // in the Write clas public static void printConDictsInfo ( XConversionDictionaryList cdList ) { if ( cdList == null ) { System . out . println ( \"Conversion Dictionary list is null\" ); return ; } XNameContainer dcCon = cdList . getDictionaryContainer (); String [] dcNames = dcCon . getElementNames (); System . out . println ( \"No. of conversion dictionaries: \" + dcNames . length ); for ( String dcName : dcNames ) System . out . println ( \" \" + dcName ); System . out . println (); } // end of printConDictsInfo() Output similar to Write.dictsInfo() can be viewed via Office's Tools, Options, Language Settings, \"Writing Aids\" dialog, shown in Figure 4. Figure 4. The Writing Aids Dialog. The dictionaries are listed in the second pane of the dialog. Also, at the bottom of the window is a \"Get more dictionaries online\" hyperlink which takes the user to Office's extension website, and displays the \"Dictionary\" category (see Figure 5). Figure 5. The Dictionary Extensions at the LibreOffice Website. The URL of the page in Figure 5 is: https://extensions.libreoffice.org/extension-center?getCategories=Dictionary/ The dictionary category currently has 94 entries, but if you can't find what you're looking for, don't forget the extensions for OpenOffice, at: https://extensions.openoffice.org/ If you're unclear about how to install extensions, the process is explained online at https://wiki.documentfoundation.org/Documentation/HowTo/install_extension/ , or in the \"Installing Extensions\" guide available at https://libreoffice.org/get-help/documentation/ . 1.2. Linguistic Properties \u00b6 Back in the Lingo.java example, Write.getLinguProperties() returns an instance of XLinguProperties, and its properties are printed by calling Props.showProps(): // in Lingo.java XLinguProperties linguProps = Write . getLinguProperties (); Props . showProps ( \"Linguistic Manager\" , linguProps ); The output: Linguistic Manager Properties DefaultLanguage == 0 DefaultLocale == com.sun.star.lang.Locale@1f95c5d DefaultLocale_CJK == com.sun.star.lang.Locale@cd43c2 DefaultLocale_CTL == com.sun.star.lang.Locale@a8f0b4 HyphMinLeading == 2 HyphMinTrailing == 2 HyphMinWordLength == 5 IsGermanPreReform == Any[Type[void], null] IsHyphAuto == false IsHyphSpecial == true IsIgnoreControlCharacters == true IsSpellAuto == false IsSpellCapitalization == true IsSpellHide == Any[Type[void], null] IsSpellInAllLanguages == Any[Type[void], null] IsSpellSpecial == true IsSpellUpperCase == true IsSpellWithDigits == false IsUseDictionaryList == true IsWrapReverse == false These properties are explained in the online documentation for the XLinguProperties interface ( lodoc XLinguProperties ), and also in the Developer's Guide. The properties are spread across several dialogs in Office's GUI, starting from the Tools, Options, \"Language Settings\" menu item. However, most of them are in the \"Options\" pane of the \"Writing Aids\" Dialog in Figure 4. 1.3. Installed Extensions \u00b6 Additional dictionaries, and other language tools such as grammar checkers, are loaded into Office as extensions, so calling Info.listExtensions() can be informative. The output on one of my test machine is: Extensions: 1. ID: org.openoffice.en.hunspell.dictionaries Version: 2011.12.05.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/dict-en 2. ID: French.linguistic.resources.from.Dicollecte.by.OlivierR Version: 5.4.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/dict-fr 3. ID: org.openoffice.languagetool.oxt Version: 3.4 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/uno_packages/cache/uno_packages/ lu4156ef34f.tmp_/LanguageTool-3.4.oxt 4. ID: com.sun.star.comp.Calc.NLPSolver Version: 0.9 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/nlpsolver 5. ID: spanish.es_ANY.dicts.from.rla-es Version: 0.8 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/dict-es 6. ID: com.sun.wiki-publisher Version: 1.2.0 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/wiki-publisher The \"Loc\" entries are the directories or OXT files containing the extensions. Most extensions are placed in the \\share\\extensions folder on Windows. Office can display similar information via its Tools, \"Extension Manager\" dialog, as in Figure 6. Figure 6. The Extension Manager Dialog. The code for Info.listExtensions(): // in the Info class public static void listExtensions () { XPackageInformationProvider pip = getPip (); if ( pip == null ) System . out . println ( \"No package info provider found\" ); else { String [][] extsTable = pip . getExtensionList (); System . out . println ( \"\\nExtensions:\" ); String serviceName ; for ( int i = 0 ; i < extsTable . length ; i ++ ) { System . out . println (( i + 1 ) + \". ID: \" + extsTable [ i ][ 0 ] ); System . out . println ( \" Version: \" + extsTable [ i ][ 1 ] ); System . out . println ( \" Loc: \" + pip . getPackageLocation ( extsTable [ i ][ 0 ] )); System . out . println (); } } } // end of listExtensions() public static XPackageInformationProvider getPip () { return PackageInformationProvider . get ( Lo . getContext ()); } Extensions are accessed via the XPackageInformationProvider interface. 1.4. Examining the Lingu Services \u00b6 The LinguServiceManager provides access to three of the four main linguistic services: the spell checker, the hyphenator, and thesaurus.The proof reader (i.e. the grammar checker) is managed by a separate Proofreader service, which I'll explain later. Figure 7 shows the interfaces accessible from the LinguServiceManager service. Figure 7. The LinguServiceManager Service and Interfaces. In Lingo.java, the LinguServiceManager is instantiated and then Write.printServicesInfo() reports details about its services: // in Lingo.java : // get lingo manager XLinguServiceManager2 lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager2 . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); if ( lingoMgr == null ) { System . out . println ( \"No linguistics manager found\" ); Lo . closeOffice (); return ; } Write . printServicesInfo ( lingoMgr ); Typical output from Write.printServicesInfo(): Available Services: SpellChecker (1): org.openoffice.lingu.MySpellSpellChecker Thesaurus (1): org.openoffice.lingu.new.Thesaurus Hyphenator (1): org.openoffice.lingu.LibHnjHyphenator Proofreader (2): org.languagetool.openoffice.Main org.libreoffice.comp.pyuno.Lightproof.en Configured Services: SpellChecker (1): org.openoffice.lingu.MySpellSpellChecker Thesaurus (1): org.openoffice.lingu.new.Thesaurus Hyphenator (1): org.openoffice.lingu.LibHnjHyphenator Proofreader (1): org.languagetool.openoffice.Main Locales for SpellChecker (43): AR AU BE BO BS BZ CA CA CH CL CO CR CU DO EC ES FR GB GH GT HN IE IN JM LU MC MW MX NA NI NZ PA PE PH PR PY SV TT US UY VE ZA ZW Locales for Thesaurus (43): AR AU BE BO BS BZ CA CA CH CL CO CR CU DO EC ES FR GB GH GT HN IE IN JM LU MC MW MX NA NI NZ PA PE PH PR PY SV TT US UY VE ZA ZW Locales for Hyphenator (43): AR AU BE BO BS BZ CA CA CH CL CO CR CU DO EC ES FR GB GH GT HN IE IN JM LU MC MW MX NA NI NZ PA PE PH PR PY SV TT US UY VE ZA ZW Locales for Proofreader (94): AF AO AR AT AU BE BE BE BO BR BS BY BZ CA CA CD CH CH CH CI CL CM CN CR CU DE DE DK DO EC ES ES ES ES ES FI FR FR GB GH GR GT HN HT IE IN IN IN IR IS IT JM JP KH LI LT LU LU MA MC ML MX MZ NA NI NL NZ PA PE PH PH PL PR PT PY RE RO RU SE SI SK SN SV TT UA US US UY VE ZA ZW The print-out contains three lists: a list of available services, a list of configured services (i.e. ones that are activated inside Office), and a list of the locales available to each service. Figure 7 shows that LinguServiceManager only manages the spell checker, hyphenator, and thesaurus, and yet Write.printServicesInfo() includes information about the proof reader. Somewhat confusingly, although LinguServiceManager cannot instantiate a proof reader it can print information about it. The output shows that two proofreader services are available (org.languagetool.openoffice.Main and org.libreoffice.comp.pyuno.Lightproof.en), but only one is configured (i.e. active). I'll explain this setup when I talk about the proof reader later. The three lists are generated by Write.printServicesInfo() calling Write.printAvailServiceInfo(), Write.printConfigServiceInfo(), and Write.printLocales(): // in the Writer class public static void printServicesInfo ( XLinguServiceManager2 lingoMgr ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English locale System . out . println ( \"Available Services:\" ); printAvailServiceInfo ( lingoMgr , \"SpellChecker\" , loc ); printAvailServiceInfo ( lingoMgr , \"Thesaurus\" , loc ); printAvailServiceInfo ( lingoMgr , \"Hyphenator\" , loc ); printAvailServiceInfo ( lingoMgr , \"Proofreader\" , loc ); System . out . println (); System . out . println ( \"Configured Services:\" ); printConfigServiceInfo ( lingoMgr , \"SpellChecker\" , loc ); printConfigServiceInfo ( lingoMgr , \"Thesaurus\" , loc ); printConfigServiceInfo ( lingoMgr , \"Hyphenator\" , loc ); printConfigServiceInfo ( lingoMgr , \"Proofreader\" , loc ); System . out . println (); printLocales ( \"SpellChecker\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.SpellChecker\" )); printLocales ( \"Thesaurus\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.Thesaurus\" )); printLocales ( \"Hyphenator\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.Hyphenator\" )); printLocales ( \"Proofreader\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.Proofreader\" )); System . out . println (); } // end of printServicesInfo() The choice of services depends on the current locale, so printServicesInfo() begins by creating an American English locale, which matches my version of Office. Write.printAvailServiceInfo() utilizes XLinguServiceManager.getAvailableServices() to retrieve a list of the available services. In a similar way, Write.printConfigServiceInfo() calls XLinguServiceManager.getConfiguredServices(), and printLocales gets an array of Locale objects from XLinguServiceManager.getAvailableLocales(). 2. Using the Spell Checker \u00b6 There's a few examples in Lingo.java of applying the spell checker to individual words: // in Lingo.java XSpellChecker speller = lingoMgr . getSpellChecker (); Write . spellWord ( \"horseback\" , speller ); Write . spellWord ( \"ceurse\" , speller ); Write . spellWord ( \"magisian\" , speller ); Write . spellWord ( \"ellucidate\" , speller ); XLinguServiceManager.getSpellChecker() returns a reference to the spell checker, and Write.spellWord() checks the supplied word. For the code above, the following is printed: * \"ceurse\" is unknown. Try: No. of names: 8 \"curse\" \"course\" \"secateurs\" \"cerise\" \"surcease\" \"secure\" \"cease\" \"Ceausescu\" * \"magisian\" is unknown. Try: No. of names: 7 \"magician\" \"magnesia\" \"Malaysian\" \"mismanage\" \"imagining\" \"mastication\" \"fumigation\" * \"ellucidate\" is unknown. Try: No. of names: 7 \"elucidate\" \"elucidation\" \"hallucinate\" \"pellucid\" \"fluoridate\" \"elasticated\" \"illustrated\" Nothing is reported for \"horseback\" because that's correctly spelt, and spellWord() returns the boolean true. The SpellChecker service and its important interfaces are shown in Figure 8. Figure 8. The SpellChecker Service and Interfaces. Write.spellWord() utilizes XSpellChecker.spell() to find a spelling mistake, then prints the alternative spellings: // in the Write class public static boolean spellWord ( String word , XSpellChecker speller ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English PropertyValue [] props = new PropertyValue [ 0 ] ; XSpellAlternatives alts = speller . spell ( word , loc , props ); if ( alts != null ) { System . out . println ( \"* \\\"\" + word + \"\\\" is unknown. Try:\" ); String [] altWords = alts . getAlternatives (); Lo . printNames ( altWords ); return false ; } else return true ; } // end of spellWord() XSpellChecker.spell() requires a locale and an array of properties, which I've left empty. The properties are those associated with XLinguProperties, which were listed above using Write.getLinguProperties(). Its output shows that \"IsSpellCapitalization\" is presently true, which means that words in all-caps will be checked. The property can be changed to false inside the PropertyValue array passed to XSpellChecker.spell(). For example: PropertyValue [] props = Props . makeProps ( \"IsSpellCapitalization\" , false ); XSpellAlternatives alts = speller . spell ( word , loc , props ); Now an incorrectly spelt word in all-caps, such as \"CEURSE\", will be skipped over. This means that Write.spellWord(\"CEURSE\", speller) should return true. Unfortunately, XSpellChecker.spell() seems to ignore the property array, and still reports \"CEURSE\" as incorrectly spelt. Even a property change performed through the XLinguProperties interface, such as: XLinguProperties linguProps = Write . getLinguProperties (); Props . setProperty ( linguProps , \"IsSpellCapitalization\" , false ); fails to change XSpellChecker.spell()'s behavior. The only way to make a change to the linguistic properties that is acted upon is through the \"Options\" pane in the \"Writing Aids\" dialog, as in Figure 9. Figure 9. Changing the Capitalization Property. Office's default spell checker is Hunspell (from https://hunspell.github.io/ ), and has been part of OpenOffice since v.2, when it replaced MySpell, adding several features such as support for Unicode. The \"MySpell\" name lives on in a few places, such as in the spelling service (org.openoffice.lingu.MySpellSpellChecker). Hunspell offers extra properties in addition to those in the \"Options\" pane of the \"Writing Aids\" dialog. They can be accessed through the Tools, Options, Language Settings, \"English sentence checking\" dialog shown in Figure 10. Figure 10. The English Sentence Checking Dialog. The same dialog can also be reached through the Extension Manager window shown back in Figure 6. Click on the \"English Spelling dictionaries\" extension, and then press the \"Options\" button which appears as in Figure 11. Figure 11. The English Spelling Options Button. Unfortunately, there appears to be no API for accessing these Hunspell options. The best that can be done is to use a dispatch message to open the \"English Sentence Checking\" dialog in Figure 10. This done by calling Write.openSentCheckOptions(): GUI . setVisible ( doc , true ); // Office must be visible... Lo . wait ( 2000 ); Write . openSentCheckOptions (); // for the dialog to appear Write.openSentCheckOptions() uses an \".uno:OptionsTreeDialog\" dispatch along with an URL argument for the dialog's XML definition file: // in the Writer class public static void openSentCheckOptions () // open \"Options - Language Settings - English sentence checking { XPackageInformationProvider pip = Info . getPip (); String langExt = pip . getPackageLocation ( \"org.openoffice.en.hunspell.dictionaries\" ); // System.out.println(\"Lang Ext: \" + langExt); String url = langExt + \"/dialog/en.xdl\" ; PropertyValue [] props = Props . makeProps ( \"OptionsPageURL\" , url ); Lo . dispatchCmd ( \"OptionsTreeDialog\" , props ); Lo . wait ( 2000 ); } // end of openSentCheckOptions() The XML file's location is obtained in two steps. First the ID of the Hunspell service (\"org.openoffice.en.hunspell.dictionaries\") is passed to XPackageInformationProvider.getPackageLocation() to obtain the spell checker's installation folder. Figure 12 shows the directory on my machine. Figure 12. The Hunspell Installation Folder. The directory contains a dialog subdirectory, which holds an XXX.xdl file that defines the dialog's XML structure and data. The \"XXX\" name will be Office's locale language, which in my case is \"en\". The URL required by the \"OptionsTreeDialog\" dispatch is constructed by appending \"/dialog/en.xdl\" to the installation folder string. 3. Using the Thesaurus \u00b6 Lingo.java contains two examples of how to use the thesaurus: // in Lingo.java : XLinguServiceManager2 lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager2 . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); : XThesaurus thesaurus = lingoMgr . getThesaurus (); Write . printMeaning ( \"magician\" , thesaurus ); Write . printMeaning ( \"elucidate\" , thesaurus ); The output from the first call to Write.printMeaning() is: \"magician\" found in thesaurus; number of meanings: 2 1. Meaning: (noun) prestidigitator No. of synonyms: 6 prestidigitator conjurer conjuror illusionist performer (generic term) performing artist (generic term) 2. Meaning: (noun) sorcerer No. of synonyms: 6 sorcerer wizard necromancer thaumaturge thaumaturgist occultist (generic term) XLinguServiceManager2.getThesaurus() returns an instance of XThesaurus whose service and main interfaces are shown in Figure 13. Figure 13. The Thesaurus Service and Interfaces. Write.printMeaning() calls XThesaurus.queryMeanings(), and prints the array of results: public static int printMeaning ( String word , XThesaurus thesaurus ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English PropertyValue [] props = new PropertyValue [ 0 ] ; XMeaning [] meanings = thesaurus . queryMeanings ( word , loc , props ); if ( meanings == null ) { System . out . println ( \"\\\"\" + word + \"\\\" NOT found in thesaurus\\n\" ); return 0 ; } else { System . out . println ( \"\\\"\" + word + \"\\\" found in thesaurus; number of meanings: \" + meanings . length ); for ( int i = 0 ; i < meanings . length ; i ++ ) { System . out . println (( i + 1 ) + \". Meaning: \" + meanings [ i ] . getMeaning ()); String [] synonyms = meanings [ i ] . querySynonyms (); System . out . println ( \" No. of synonyms: \" + synonyms . length ); for ( int k = 0 ; k < synonyms . length ; k ++ ) System . out . println ( \" \" + synonyms [ k ] ); System . out . println (); } return meanings . length ; } } // end of printMeaning() In a similar way to XSpellChecker.spell(), XThesaurus.queryMeanings() requires a locale and an optional array of properties. printMeaning() utilizes American English, and no properties. If you need a non-English thesaurus which isn't part of Office, then look through the dictionary extensions at https://extensions.libreoffice.org/extension-center?getCategories=Dictionary/ ; many include a thesaurus with the dictionary. Thesaurus data is stored as \".idx\" and \".dat\" files in the same directory as the spell checker (i.e. in \\share\\extensions\\dict-en), as can be seen in Figure 13. The files are built from WordNet data ( https://wordnet.princeton.edu/ ), but use a text- based format explained very briefly in Daniel Naber's slides about the Lingucomponent Project (at https://danielnaber.de/publications/ooocon2005-lingucomponent.pdf ). Also, the Lingucomponent website has some C++ code for reading \".idx\" and '.dat\" files (in https://openoffice.org/lingucomponent/MyThes-1.zip ). However, if you want to write code using a thesaurus independently of Office, then I'd suggest programming with one of the many APIs for WordNet; there are currently nine for Java, listed at https://wordnet.princeton.edu/wordnet/related-projects/#Java . 4. Grammar Checking \u00b6 Office's default grammar checker (or proof reader) is Lightproof, a Python application developed by L\u00e1szl\u00f3 N\u00e9meth. Lightproof.py, and its support files, are installed in the same folder as the spell checker and thesaurus; on my machine that's \\share\\extensions\\dict-en. Older versions of Lightproof are available from OpenOffice's extensions website at https://extensions.services.openoffice.org/project/lightproof/ . One reason for downloading the old version is that it contains documentation on adding new grammar rules missing from the version installed in Office. Another way to modify Lightproof's grammar rules is with its editor, which can be obtained from https://extensions.libreoffice.org/extension-center/lightproof-editor/ . There are a number of alternative grammar checkers for Office, including \"After the Deadline\" ( https://afterthedeadline.com/ ) and \"LanguageTool\" ( https://languagetool.org/ ), which are easily added to Office as extensions via the \"Language Tools\" subsection of the website, at https://extensions.libreoffice.org/extension-center?getCategories=Language%20Tools . When I first coded my examples, I used the default Lightproof for grammar checking, but it doesn't have a very extensive set of built-in grammar rules (it seems best at catching punctuation mistakes). I switched to LanguageTool because of its larger set of rules, and its support for many languages. I also like that it can be used as a standalone Java library, separate from Office, and that its site includes lots of documentation. Perhaps its biggest drawback is that it requires Java 8 or later. Another issue is that LanguageTool and Lightproof cannot happily coexist inside Office. Lightproof must be disabled and LanguageTool enabled via the Options, Language Settings, Writing aids, \"Available language modules\" pane at the top of Figure 14. Figure 14. Goodbye Lightproof, hello LanguageTool. I used Write.printServicesInfo() earlier to list the available and configured services. The output included: Available Services: : Proofreader (2): org.languagetool.openoffice.Main org.libreoffice.comp.pyuno.Lightproof.en Configured Services: : Proofreader (1): org.languagetool.openoffice.Main \"org.languagetool.openoffice.Main\" refers to the LanguageTool extension, while \"org.libreoffice.comp.pyuno.Lightproof.en\" is the English version of Lightproof. This information can be used to set the proof reader. LanguageTool is made the default by calling Write.setConfiguredServices() like so: Write . setConfiguredServices ( lingoMgr , \"Proofreader\" , \"org.languagetool.openoffice.Main\" ); Alternatively, Lightproof can be enabled with: Write . setConfiguredServices ( lingoMgr , \"Proofreader\" , \"org.libreoffice.comp.pyuno.Lightproof.en\" ); The code for Write.setConfiguredServices() is: // in the Write class public static void setConfiguredServices ( XLinguServiceManager2 lingoMgr , String service , String implName ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); String [] implNames = { implName }; lingoMgr . setConfiguredServices ( \"com.sun.star.linguistic2.\" + service , loc , implNames ); } // end of setConfiguredServices() The function utilizes XLinguServiceManager.setConfiguredServices() to attach a particular implementation service (e.g. LanguageTool) to a specified linguistic service (e.g. the Proofreader). 4.1. Error Reporting Options \u00b6 The kinds of errors reported by the proof reader can be adjusted through Office's GUI. One configuration pane, used by both Lightproof and LanguageTool, is in the \"English Sentence Checking\" dialog shown back in Figure 10. If you look closely, the first group of check boxes are titled \"Grammar checking\". If you install LanguageTool, Office's Tools menu will be modified to contain a new \"LanguageTool\" submenu shown in Figure 15. Figure 15. The LanguageTool Submenu. The \"Options\" menu item in the \"LanguageTool\" submenu brings up an extensive set of options, reflecting the greater number of grammar rules in the checker (see Figure 16). Figure 16. The LanguageTool Options Dialog. Unfortunately, there seems to be no way to modify these options through Office's Proofreader API. 4.2. Using the Proof Reader \u00b6 In Lingo.java the proof reader is loaded and called like so: // in Lingo.java : XProofreader proofreader = Write . loadProofreader (); System . out . println ( \"Proofing...\" ); int numErrs = Write . proofSentence ( \"i dont have one one dogs.\" , proofreader ); System . out . println ( \"No. of proofing errors: \" + numErrs + \"\\n\" ); The output is: Proofing... G* This sentence does not start with an uppercase letter in: \"i\" Suggested change: \"I\" G* Spelling mistake in: \"dont\" Suggested change: \"don't\" G* Word repetition in: \"one one\" Suggested change: \"one\" No. of proofing errors: 3 The proof reader isn't accessed through the linguistics manager; instead a Proofreader service is created, and its interfaces employed. A simplified view of the services and interfaces are shown in Figure 17. Figure 17. The Proofreader Service and Interfaces. Write.loadProofreader() creates the service: public static XProofreader loadProofreader () { return Lo . createInstanceMCF ( XProofreader . class , \"com.sun.star.linguistic2.Proofreader\" ); } Write.proofSentence() passes a sentence to XProofreader.doProofreading(), and prints the errors inside the returned ProofreadingResult instance: public static int proofSentence ( String sent , XProofreader proofreader ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English PropertyValue [] props = new PropertyValue [ 0 ] ; int numErrs = 0 ; ProofreadingResult prRes = proofreader . doProofreading ( \"1\" , sent , loc , 0 , sent . length (), props ); if ( prRes != null ) { SingleProofreadingError [] errs = prRes . aErrors ; if ( errs . length > 0 ) for ( SingleProofreadingError err : errs ) { printProofError ( sent , err ); numErrs ++ ; } } return numErrs ; } // end of proofSentence() public static void printProofError ( String str , SingleProofreadingError err ) { String errText = str . substring ( err . nErrorStart , err . nErrorStart + err . nErrorLength ); System . out . println ( \"G* \" + err . aShortComment + \" in: \\\"\" + errText + \"\\\"\" ); if ( err . aSuggestions . length > 0 ) System . out . println ( \" Suggested change: \\\"\" + err . aSuggestions [ 0 ] + \"\\\"\" ); System . out . println (); } // end of printProofError() XProofreader.doProofreading() requires a locale and properties array in the same way as the earlier spell checking and thesaurus methods. It also needs two indices for the start and end of the sentence being checked, and a document ID which is used in the error results. The results are returned as an array of SingleProofreadingError objects, one for each detected error. It's worth having a look at the documentation for the SingleProofreadingError class (use lodoc SingleProofreadingError ), since the object contains more information than I've used in Write.printProofError(); for example, the ID of the grammar rule that was 'broken', a full comment string, and multiple suggestions in a String array. Grammar rule IDs are one area where the proof reader API could be improved. The XProofreader interface includes methods for switching on and off rules based on their IDs, but there's no way to find out what these IDs are except by looking at SingleProofreadingError objects. 5. Guessing the Language used in a String \u00b6 An oft overlooked linguistics API feature is the ability to guess the language used in a string, which is implemented by one service, LanguageGuessing, and a single interface, XLanguageGuessing. The documentation for XLanguageGuessing includes a long list of supported languages, including Irish Gaelic, Scots Gaelic, and Manx Gaelic. There are two examples of language guessing in Lingo.java: // in Lingo.java : Locale loc = Write . guessLocale ( \"The rain in Spain stays mainly on the plain.\" ); Write . printLocale ( loc ); if ( loc != null ) System . out . println ( \"Guessed language: \" + loc . Language ); loc = Write . guessLocale ( \"A vaincre sans p\u00e9ril, on triomphe sans gloire.\" ); // To win without risk is a triumph without glory. if ( loc != null ) System . out . println ( \"Guessed language: \" + loc . Language ); The output is: Locale lang: \"English\"; country: \"\"; variant: \"\" Guessed language: en Guessed language: fr Write.guessLocale() creates the service, its interface, and calls XLanguageGuessing.guessPrimaryLanguage(): // in the Writer class public static com . sun . star . lang . Locale guessLocale ( String testStr ) { XLanguageGuessing guesser = Lo . createInstanceMCF ( XLanguageGuessing . class , \"com.sun.star.linguistic2.LanguageGuessing\" ); if ( guesser == null ) { System . out . println ( \"No language guesser found\" ); return null ; } else return guesser . guessPrimaryLanguage ( testStr , 0 , testStr . length ()); } // end of guessLocale() XLanguageGuessing actually guesses a locale rather than a language, and the locale includes information about the language, country and a variant BCP 47 language label. com.sun.star.lang.Locale stores that information as three strings, but XLocale has additional methods for displaying the string codes in longer formats (e.g. \"th\" as \"Thailand\"). Unfortunately, I was unable to get code using XLocale to compile, so fell back to Java's Locale class which includes similar methods. Write.printLocale() converts an Office locale into a Java version, then prints its data in long form: public static void printLocale ( com . sun . star . lang . Locale loc ) { if ( loc != null ) { java . util . Locale jloc = new java . util . Locale ( loc . Language , loc . Country , loc . Variant ); System . out . println ( \"Locale lang: \\\"\" + jloc . getDisplayLanguage () + \"\\\"; country: \\\"\" + jloc . getDisplayCountry () + \"\\\"; variant: \\\"\" + jloc . getDisplayVariant () + \"\\\"\" ); } } // end of printLocale() 6. Spell Checking and Grammar Checking a Document \u00b6 Lingo.java only spell checks individual words, and grammar checks a single sentence. The LingoFile.java example shows how these features can be applied to an entire document. One way to scan every sentence in a document is to combine XParagraphCursor and XSentenceCursor, as in the TalkingBook.java example from Chapter 5, section 6. An outer loop iterates over every paragraph using XParagraphCursor, and an inner loop splits each paragraph into sentences with the help of XSentenceCursor. Initially, I coded LingoFile.java in this way, but found that XSentenceCursor occasionally didn't divide a paragraph into the correct number of sentences; sometimes two sentences were treated as one. So I switched to a combined Office/Java approach \u2013 the outer loop in LingoFile.java still utilizes XParagraphCursor to scan the paragraphs, but the sentences in a paragraph are extracted using a sentence-based BreakIterator. The main() function of LingoFile.java: public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run LingoFile <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // load spell checker, proof reader XSpellChecker speller = Write . loadSpellChecker (); XProofreader proofreader = Write . loadProofreader (); BreakIterator bi = BreakIterator . getSentenceInstance ( java . util . Locale . US ); // iterate through the doc by paragraphs XParagraphCursor paraCursor = Write . getParagraphCursor ( doc ); paraCursor . gotoStart ( false ); // go to start of text String currPara ; do { paraCursor . gotoEndOfParagraph ( true ); // select all of paragraph currPara = paraCursor . getString (); if ( currPara . length () > 0 ) checkSentences ( currPara , bi , speller , proofreader ); } while ( paraCursor . gotoNextParagraph ( false )); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Write.loadSpellChecker() hides the creation of the linguistics manager, and its retrieval of the spell checker: // in the Write class public static XSpellChecker loadSpellChecker () { XLinguServiceManager lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); if ( lingoMgr == null ) { System . out . println ( \"No linguistics manager found\" ); return null ; } else return lingoMgr . getSpellChecker (); } // end of loadSpellChecker() The BreakIterator is instantiated in main () using : BreakIterator bi = BreakIterator . getSentenceInstance ( java . util . Locale . US ); but employed inside checkSentences (), which splits a paragraph into sentences : // in LingoFile.java private static void checkSentences ( String currPara , BreakIterator bi , XSpellChecker speller , XProofreader proofreader ) { System . out . println ( \"\\n>> \" + currPara ); bi . setText ( currPara ); int lastIdx = bi . first (); while ( lastIdx != BreakIterator . DONE ) { int firstIdx = lastIdx ; lastIdx = bi . next (); if ( lastIdx != BreakIterator . DONE ) { String sentence = currPara . substring ( firstIdx , lastIdx ); Write . proofSentence ( sentence , proofreader ); Write . spellSentence ( sentence , speller ); } } } // end of checkSentences() The index positions of the start of the current sentence and the start of the next sentence are stored in firstIdx and lastIdx, and used to extract a substring spanning the current sentence. This is passed to Write.spellSentence() and Write.proofSentence() for spell and proof checking. Write.spellSentence() splits the sentence into an array of words, and calls Write.spellWord() on each one: // in the Write class public static int spellSentence ( String sent , XSpellChecker speller ) { String [] words = sent . split ( \"\\\\W+\" ); // split into words int count = 0 ; boolean isCorrect ; for ( String word : words ) { isCorrect = spellWord ( word , speller ); count = count + ( isCorrect ? 0 : 1 ); } return count ; } // end of spellSentence() The poorly written \"badGrammar.odt\" is shown in Figure 18. Figure 18. Not a Good Example of my Writing Skills. The output from LingoFile.java when given \"badGrammar.odt\": >> I have a dogs. I have one dogs. G* Possible agreement error in: \"a dogs\" Suggested change: \"a dog\" >> I allow of of go home. i dogs. John don\u2019t like dogs. So recieve no cats also. G* Word repetition in: \"of of\" Suggested change: \"of\" G* This sentence does not start with an uppercase letter in: \"i\" Suggested change: \"I\" G* Grammatical problem in: \"dogs\" Suggested change: \"dog\" G* 'Also' at the end of sentence in: \"also\" Suggested change: \"as well\" * \"recieve\" is unknown. Try: No. of names: 8 \"receive\" \"relieve\" \"retrieve\" \"reprieve\" \"reverie\" \"recitative\" \"Recife\" \"reserve\" The grammar errors (those starting with \"G*\") are produced by the LanguageTool proof checker. If the default Lightproof checker is utilized instead, then less errors are found: >> I have a dogs. I have one dogs. >> I allow of of go home. i dogs. John don\u2019t like dogs. So recieve no cats also. G* Word duplication? in: \"of of\" Suggested change: \"of\" G* Missing capitalization? in: \"i\" Suggested change: \"I\" * \"recieve\" is unknown. Try: No. of names: 8 \"receive\" \"relieve\" \"retrieve\" \"reprieve\" \"reverie\" \"recitative\" \"Recife\" \"reserve\" On larger documents, such as the Sherlock Holmes short story in \"bigStory.doc\", it's a good idea to redirect the voluminous output to a temporary file so it can be examined easily. More than half the errors for \"bigStory.doc\" are spurious reports of unpaired quotes. The output can be considerably reduced if LanguageTool's unpaired rule is disabled, via the Options dialog in Figure 16. Figure 19 shows the dialog with the \"Unpaired\" checkbox deselected in the Punctuation section. Figure 19. The LanguageTool Options Dialog with the Unpaired Rule Deselected. The majority of the remaining errors are words unknown to the spell checker, such as names and places, and British English spellings. Most of the grammar errors relate to how direct speech is written. The grammar checker mistakenly reports an error if the direct speech ends with a question mark or exclamation mark without a comma after the quoted text. On balance, I'd say that Sir Arthur Conan Doyle was an excellent speller and grammarian, or his copy editor was.","title":"Chapter 10. The Linguistics API"},{"location":"10-Linguistics.html#chapter-10-the-linguistics-api","text":"Topics Linguistic Tools; Using the Spell Checker; Using the Thesaurus; Grammar Checking; Guessing the Language used in a String; Spell Checking and Grammar Checking a Document Example folders: \"Lingu Tests\" and \"Utils\" The linguistics API has four main components \u2013 a spell checker, a hyphenator, a thesaurus, and a grammar checker (which Office calls a proof reader). I'll look at how to program using the spell checker, thesaurus, and two grammar checkers, but I'll skip the hyphenator which is easier to use interactively through Office's GUI. However, if you have an urge to hyphenate, then LingusticExamples.java in the Developer's Guide examples contains some code; it can be downloaded from https://api.libreoffice.org/examples/DevelopersGuide/OfficeDev/Linguistic/LinguisticExamples.java . I'll describe two examples, Lingo.java and LingoFile.java. The first lists information about the linguistic services, then uses the spell checker, thesaurus, and grammar checker 'standalone' without having to load an Office document first. LingoFile.java automatically spell checks and grammar checks a complete file, reporting errors without altering the document. One topic I'll be ignoring is how to create and edit the data files used by the linguistic services. For that task, you should have a look at PTG (Proofing Tool GUI) developed by Marco Pinto at https://marcoagpinto.cidadevirtual.pt/proofingtoolgui.html . It's an open source tool for editing Office's dictionary, thesaurus, hyphenation, and autocorrect files. Another area I'll be skipping is the use of events and listeners. Please refer to the \"Linguistics\" sub-section of chapter 6 of the Developer's Guide for details ( loGuide Linguistics ). Listener code can be found in LinguisticExamples.java mentioned above. The linguistic features accessible through Office's GUI are explained in chapter 3 of the \"Writer Guide\", available at https://libreoffice.org/get-help/documentation/ , starting from the section called \"Checking spelling and grammar\". An older information source is the \"Lingucomponent Project\" page at the OpenOffice website, https://openoffice.org/lingucomponent/ , which links to some useful tools, such as alternative grammar checkers. An interesting set of slides by Daniel Naber explaining the state of the project in 2005 can be found at https://danielnaber.de/publications/ , along with more recent material.","title":"Chapter 10. The Linguistics API"},{"location":"10-Linguistics.html#1-the-linguistic-tools","text":"Lingo.java prints a variety of information about the linguistics services: public static void main ( String args [] ) { Lo . loadOffice (); // print linguistics info Write . dictsInfo (); XLinguProperties linguProps = Write . getLinguProperties (); Props . showProps ( \"Linguistic Manager\" , linguProps ); Info . listExtensions (); // get lingo manager XLinguServiceManager2 lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager2 . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); if ( lingoMgr == null ) { System . out . println ( \"No linguistics manager found\" ); Lo . closeOffice (); return ; } Write . printServicesInfo ( lingoMgr ); : // code for using the services; see later Lo . closeOffice (); } // end of main()","title":"1.  The Linguistic Tools"},{"location":"10-Linguistics.html#11-dictionary-information","text":"Write.dictsInfo() prints brief details about Office's dictionaries: No . of dictionaries : 5 standard . dic ( 1 ); active ; \"\" ; positive en - GB . dic ( 42 ); active ; \"GB\" ; positive en - US . dic ( 42 ); active ; \"US\" ; positive technical . dic ( 258 ); active ; \"\" ; positive IgnoreAllList ( 0 ); active ; \"\" ; positive No . of conversion dictionaries : 0 Each line includes the name of a dictionary, its number of entries, whether it's active (i.e. being used), its locale, and whether it's a positive, negative, or mixed dictionary. A positive dictionary holds correctly spelled words only, while a negative one lists incorrectly spelt words. A mixed dictionary contains both correctly and incorrectly spelt entries. If a dictionary has a locale, such as \"GB\" for en-GB.dic, then it's only utilized during spell checking if its locale matches Office's. The Office locale can be set via the Tools, Options, Language Settings, \"Languages\" dialog shown in Figure 1. Figure 1. The Languages Dialog. Figure 1 shows that my version of Office is using the American English locale, and so en-GB.dic won't be consulted when text is spell checked. Write.dictsInfo() is defined as: // in the Write class public static void dictsInfo () { XSearchableDictionaryList dictList = Lo . createInstanceMCF ( XSearchableDictionaryList . class , \"com.sun.star.linguistic2.DictionaryList\" ); if ( dictList == null ) System . out . println ( \"No list of dictionaries found\" ); else printDictsInfo ( dictList ); XConversionDictionaryList cdList = Lo . createInstanceMCF ( XConversionDictionaryList . class , \"com.sun.star.linguistic2.ConversionDictionaryList\" ); if ( cdList == null ) System . out . println ( \"No list of conversion dictionaries found\" ); else printConDictsInfo ( cdList ); } // end of dictsInfo() It retrieves a conventional dictionary list first (called dictList), and iterates through its dictionaries using printDictsInfo(). Then it obtains the conversion dictionary list (called csList), and iterates over that with printConDictsInfo(). Figure 2 shows the main services and interfaces used by ordinary dictionaries. Figure 2. The DictionaryList and Dictionary Services. Each dictionary in the list has an XDictionary interface which contains methods for accessing and changing its entries. printDictsInfo() retrieves an XDictionary array from the list, and prints out a summary of each dictionary: // in the Write class public static void printDictsInfo ( XSearchableDictionaryList dictList ) { if ( dictList == null ) { System . out . println ( \"Dictionary list is null\" ); return ; } System . out . println ( \"No. of dictionaries: \" + dictList . getCount ()); XDictionary [] dicts = dictList . getDictionaries (); for ( XDictionary dict : dicts ) System . out . println ( \" \" + dict . getName () + \" (\" + dict . getCount () + \"); \" + ( dict . isActive () ? \"active\" : \"na\" ) + \"; \\\"\" + dict . getLocale (). Country + \"\\\"; \" + getDictType ( dict . getDictionaryType ())); System . out . println (); } // end of printDictsInfo() public static String getDictType ( DictionaryType dt ) { if ( dt == DictionaryType . POSITIVE ) return \"positive\" ; else if ( dt == DictionaryType . NEGATIVE ) return \"negative\" ; else if ( dt == DictionaryType . MIXED ) return \"mixed\" ; else return \"??\" ; } // end of getDictType() Conversion dictionaries map words in one language/dialect to corresponding words in another language/dialect. 3 shows that conversion dictionaries are organized in a similar way to ordinary ones. The interfaces for manipulating a conversion dictionary are XConversionDictionary and XConversionPropertyType. Figure 3. The ConversionDictionaryList and ConversionDictionary Services. Write.dictsInfo() calls printConDictsInfo() to print the names of the conversion dictionaries \u2013 by extracting an XNameContainer from the dictionary list, and then pulling a list of the names from the container: // in the Write clas public static void printConDictsInfo ( XConversionDictionaryList cdList ) { if ( cdList == null ) { System . out . println ( \"Conversion Dictionary list is null\" ); return ; } XNameContainer dcCon = cdList . getDictionaryContainer (); String [] dcNames = dcCon . getElementNames (); System . out . println ( \"No. of conversion dictionaries: \" + dcNames . length ); for ( String dcName : dcNames ) System . out . println ( \" \" + dcName ); System . out . println (); } // end of printConDictsInfo() Output similar to Write.dictsInfo() can be viewed via Office's Tools, Options, Language Settings, \"Writing Aids\" dialog, shown in Figure 4. Figure 4. The Writing Aids Dialog. The dictionaries are listed in the second pane of the dialog. Also, at the bottom of the window is a \"Get more dictionaries online\" hyperlink which takes the user to Office's extension website, and displays the \"Dictionary\" category (see Figure 5). Figure 5. The Dictionary Extensions at the LibreOffice Website. The URL of the page in Figure 5 is: https://extensions.libreoffice.org/extension-center?getCategories=Dictionary/ The dictionary category currently has 94 entries, but if you can't find what you're looking for, don't forget the extensions for OpenOffice, at: https://extensions.openoffice.org/ If you're unclear about how to install extensions, the process is explained online at https://wiki.documentfoundation.org/Documentation/HowTo/install_extension/ , or in the \"Installing Extensions\" guide available at https://libreoffice.org/get-help/documentation/ .","title":"1.1.  Dictionary Information"},{"location":"10-Linguistics.html#12-linguistic-properties","text":"Back in the Lingo.java example, Write.getLinguProperties() returns an instance of XLinguProperties, and its properties are printed by calling Props.showProps(): // in Lingo.java XLinguProperties linguProps = Write . getLinguProperties (); Props . showProps ( \"Linguistic Manager\" , linguProps ); The output: Linguistic Manager Properties DefaultLanguage == 0 DefaultLocale == com.sun.star.lang.Locale@1f95c5d DefaultLocale_CJK == com.sun.star.lang.Locale@cd43c2 DefaultLocale_CTL == com.sun.star.lang.Locale@a8f0b4 HyphMinLeading == 2 HyphMinTrailing == 2 HyphMinWordLength == 5 IsGermanPreReform == Any[Type[void], null] IsHyphAuto == false IsHyphSpecial == true IsIgnoreControlCharacters == true IsSpellAuto == false IsSpellCapitalization == true IsSpellHide == Any[Type[void], null] IsSpellInAllLanguages == Any[Type[void], null] IsSpellSpecial == true IsSpellUpperCase == true IsSpellWithDigits == false IsUseDictionaryList == true IsWrapReverse == false These properties are explained in the online documentation for the XLinguProperties interface ( lodoc XLinguProperties ), and also in the Developer's Guide. The properties are spread across several dialogs in Office's GUI, starting from the Tools, Options, \"Language Settings\" menu item. However, most of them are in the \"Options\" pane of the \"Writing Aids\" Dialog in Figure 4.","title":"1.2.  Linguistic Properties"},{"location":"10-Linguistics.html#13-installed-extensions","text":"Additional dictionaries, and other language tools such as grammar checkers, are loaded into Office as extensions, so calling Info.listExtensions() can be informative. The output on one of my test machine is: Extensions: 1. ID: org.openoffice.en.hunspell.dictionaries Version: 2011.12.05.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/dict-en 2. ID: French.linguistic.resources.from.Dicollecte.by.OlivierR Version: 5.4.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/dict-fr 3. ID: org.openoffice.languagetool.oxt Version: 3.4 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/uno_packages/cache/uno_packages/ lu4156ef34f.tmp_/LanguageTool-3.4.oxt 4. ID: com.sun.star.comp.Calc.NLPSolver Version: 0.9 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/nlpsolver 5. ID: spanish.es_ANY.dicts.from.rla-es Version: 0.8 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/dict-es 6. ID: com.sun.wiki-publisher Version: 1.2.0 Loc: file:///C:/Program%20Files/LibreOffice%205/program/ ../share/extensions/wiki-publisher The \"Loc\" entries are the directories or OXT files containing the extensions. Most extensions are placed in the \\share\\extensions folder on Windows. Office can display similar information via its Tools, \"Extension Manager\" dialog, as in Figure 6. Figure 6. The Extension Manager Dialog. The code for Info.listExtensions(): // in the Info class public static void listExtensions () { XPackageInformationProvider pip = getPip (); if ( pip == null ) System . out . println ( \"No package info provider found\" ); else { String [][] extsTable = pip . getExtensionList (); System . out . println ( \"\\nExtensions:\" ); String serviceName ; for ( int i = 0 ; i < extsTable . length ; i ++ ) { System . out . println (( i + 1 ) + \". ID: \" + extsTable [ i ][ 0 ] ); System . out . println ( \" Version: \" + extsTable [ i ][ 1 ] ); System . out . println ( \" Loc: \" + pip . getPackageLocation ( extsTable [ i ][ 0 ] )); System . out . println (); } } } // end of listExtensions() public static XPackageInformationProvider getPip () { return PackageInformationProvider . get ( Lo . getContext ()); } Extensions are accessed via the XPackageInformationProvider interface.","title":"1.3.  Installed Extensions"},{"location":"10-Linguistics.html#14-examining-the-lingu-services","text":"The LinguServiceManager provides access to three of the four main linguistic services: the spell checker, the hyphenator, and thesaurus.The proof reader (i.e. the grammar checker) is managed by a separate Proofreader service, which I'll explain later. Figure 7 shows the interfaces accessible from the LinguServiceManager service. Figure 7. The LinguServiceManager Service and Interfaces. In Lingo.java, the LinguServiceManager is instantiated and then Write.printServicesInfo() reports details about its services: // in Lingo.java : // get lingo manager XLinguServiceManager2 lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager2 . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); if ( lingoMgr == null ) { System . out . println ( \"No linguistics manager found\" ); Lo . closeOffice (); return ; } Write . printServicesInfo ( lingoMgr ); Typical output from Write.printServicesInfo(): Available Services: SpellChecker (1): org.openoffice.lingu.MySpellSpellChecker Thesaurus (1): org.openoffice.lingu.new.Thesaurus Hyphenator (1): org.openoffice.lingu.LibHnjHyphenator Proofreader (2): org.languagetool.openoffice.Main org.libreoffice.comp.pyuno.Lightproof.en Configured Services: SpellChecker (1): org.openoffice.lingu.MySpellSpellChecker Thesaurus (1): org.openoffice.lingu.new.Thesaurus Hyphenator (1): org.openoffice.lingu.LibHnjHyphenator Proofreader (1): org.languagetool.openoffice.Main Locales for SpellChecker (43): AR AU BE BO BS BZ CA CA CH CL CO CR CU DO EC ES FR GB GH GT HN IE IN JM LU MC MW MX NA NI NZ PA PE PH PR PY SV TT US UY VE ZA ZW Locales for Thesaurus (43): AR AU BE BO BS BZ CA CA CH CL CO CR CU DO EC ES FR GB GH GT HN IE IN JM LU MC MW MX NA NI NZ PA PE PH PR PY SV TT US UY VE ZA ZW Locales for Hyphenator (43): AR AU BE BO BS BZ CA CA CH CL CO CR CU DO EC ES FR GB GH GT HN IE IN JM LU MC MW MX NA NI NZ PA PE PH PR PY SV TT US UY VE ZA ZW Locales for Proofreader (94): AF AO AR AT AU BE BE BE BO BR BS BY BZ CA CA CD CH CH CH CI CL CM CN CR CU DE DE DK DO EC ES ES ES ES ES FI FR FR GB GH GR GT HN HT IE IN IN IN IR IS IT JM JP KH LI LT LU LU MA MC ML MX MZ NA NI NL NZ PA PE PH PH PL PR PT PY RE RO RU SE SI SK SN SV TT UA US US UY VE ZA ZW The print-out contains three lists: a list of available services, a list of configured services (i.e. ones that are activated inside Office), and a list of the locales available to each service. Figure 7 shows that LinguServiceManager only manages the spell checker, hyphenator, and thesaurus, and yet Write.printServicesInfo() includes information about the proof reader. Somewhat confusingly, although LinguServiceManager cannot instantiate a proof reader it can print information about it. The output shows that two proofreader services are available (org.languagetool.openoffice.Main and org.libreoffice.comp.pyuno.Lightproof.en), but only one is configured (i.e. active). I'll explain this setup when I talk about the proof reader later. The three lists are generated by Write.printServicesInfo() calling Write.printAvailServiceInfo(), Write.printConfigServiceInfo(), and Write.printLocales(): // in the Writer class public static void printServicesInfo ( XLinguServiceManager2 lingoMgr ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English locale System . out . println ( \"Available Services:\" ); printAvailServiceInfo ( lingoMgr , \"SpellChecker\" , loc ); printAvailServiceInfo ( lingoMgr , \"Thesaurus\" , loc ); printAvailServiceInfo ( lingoMgr , \"Hyphenator\" , loc ); printAvailServiceInfo ( lingoMgr , \"Proofreader\" , loc ); System . out . println (); System . out . println ( \"Configured Services:\" ); printConfigServiceInfo ( lingoMgr , \"SpellChecker\" , loc ); printConfigServiceInfo ( lingoMgr , \"Thesaurus\" , loc ); printConfigServiceInfo ( lingoMgr , \"Hyphenator\" , loc ); printConfigServiceInfo ( lingoMgr , \"Proofreader\" , loc ); System . out . println (); printLocales ( \"SpellChecker\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.SpellChecker\" )); printLocales ( \"Thesaurus\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.Thesaurus\" )); printLocales ( \"Hyphenator\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.Hyphenator\" )); printLocales ( \"Proofreader\" , lingoMgr . getAvailableLocales ( \"com.sun.star.linguistic2.Proofreader\" )); System . out . println (); } // end of printServicesInfo() The choice of services depends on the current locale, so printServicesInfo() begins by creating an American English locale, which matches my version of Office. Write.printAvailServiceInfo() utilizes XLinguServiceManager.getAvailableServices() to retrieve a list of the available services. In a similar way, Write.printConfigServiceInfo() calls XLinguServiceManager.getConfiguredServices(), and printLocales gets an array of Locale objects from XLinguServiceManager.getAvailableLocales().","title":"1.4.  Examining the Lingu Services"},{"location":"10-Linguistics.html#2-using-the-spell-checker","text":"There's a few examples in Lingo.java of applying the spell checker to individual words: // in Lingo.java XSpellChecker speller = lingoMgr . getSpellChecker (); Write . spellWord ( \"horseback\" , speller ); Write . spellWord ( \"ceurse\" , speller ); Write . spellWord ( \"magisian\" , speller ); Write . spellWord ( \"ellucidate\" , speller ); XLinguServiceManager.getSpellChecker() returns a reference to the spell checker, and Write.spellWord() checks the supplied word. For the code above, the following is printed: * \"ceurse\" is unknown. Try: No. of names: 8 \"curse\" \"course\" \"secateurs\" \"cerise\" \"surcease\" \"secure\" \"cease\" \"Ceausescu\" * \"magisian\" is unknown. Try: No. of names: 7 \"magician\" \"magnesia\" \"Malaysian\" \"mismanage\" \"imagining\" \"mastication\" \"fumigation\" * \"ellucidate\" is unknown. Try: No. of names: 7 \"elucidate\" \"elucidation\" \"hallucinate\" \"pellucid\" \"fluoridate\" \"elasticated\" \"illustrated\" Nothing is reported for \"horseback\" because that's correctly spelt, and spellWord() returns the boolean true. The SpellChecker service and its important interfaces are shown in Figure 8. Figure 8. The SpellChecker Service and Interfaces. Write.spellWord() utilizes XSpellChecker.spell() to find a spelling mistake, then prints the alternative spellings: // in the Write class public static boolean spellWord ( String word , XSpellChecker speller ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English PropertyValue [] props = new PropertyValue [ 0 ] ; XSpellAlternatives alts = speller . spell ( word , loc , props ); if ( alts != null ) { System . out . println ( \"* \\\"\" + word + \"\\\" is unknown. Try:\" ); String [] altWords = alts . getAlternatives (); Lo . printNames ( altWords ); return false ; } else return true ; } // end of spellWord() XSpellChecker.spell() requires a locale and an array of properties, which I've left empty. The properties are those associated with XLinguProperties, which were listed above using Write.getLinguProperties(). Its output shows that \"IsSpellCapitalization\" is presently true, which means that words in all-caps will be checked. The property can be changed to false inside the PropertyValue array passed to XSpellChecker.spell(). For example: PropertyValue [] props = Props . makeProps ( \"IsSpellCapitalization\" , false ); XSpellAlternatives alts = speller . spell ( word , loc , props ); Now an incorrectly spelt word in all-caps, such as \"CEURSE\", will be skipped over. This means that Write.spellWord(\"CEURSE\", speller) should return true. Unfortunately, XSpellChecker.spell() seems to ignore the property array, and still reports \"CEURSE\" as incorrectly spelt. Even a property change performed through the XLinguProperties interface, such as: XLinguProperties linguProps = Write . getLinguProperties (); Props . setProperty ( linguProps , \"IsSpellCapitalization\" , false ); fails to change XSpellChecker.spell()'s behavior. The only way to make a change to the linguistic properties that is acted upon is through the \"Options\" pane in the \"Writing Aids\" dialog, as in Figure 9. Figure 9. Changing the Capitalization Property. Office's default spell checker is Hunspell (from https://hunspell.github.io/ ), and has been part of OpenOffice since v.2, when it replaced MySpell, adding several features such as support for Unicode. The \"MySpell\" name lives on in a few places, such as in the spelling service (org.openoffice.lingu.MySpellSpellChecker). Hunspell offers extra properties in addition to those in the \"Options\" pane of the \"Writing Aids\" dialog. They can be accessed through the Tools, Options, Language Settings, \"English sentence checking\" dialog shown in Figure 10. Figure 10. The English Sentence Checking Dialog. The same dialog can also be reached through the Extension Manager window shown back in Figure 6. Click on the \"English Spelling dictionaries\" extension, and then press the \"Options\" button which appears as in Figure 11. Figure 11. The English Spelling Options Button. Unfortunately, there appears to be no API for accessing these Hunspell options. The best that can be done is to use a dispatch message to open the \"English Sentence Checking\" dialog in Figure 10. This done by calling Write.openSentCheckOptions(): GUI . setVisible ( doc , true ); // Office must be visible... Lo . wait ( 2000 ); Write . openSentCheckOptions (); // for the dialog to appear Write.openSentCheckOptions() uses an \".uno:OptionsTreeDialog\" dispatch along with an URL argument for the dialog's XML definition file: // in the Writer class public static void openSentCheckOptions () // open \"Options - Language Settings - English sentence checking { XPackageInformationProvider pip = Info . getPip (); String langExt = pip . getPackageLocation ( \"org.openoffice.en.hunspell.dictionaries\" ); // System.out.println(\"Lang Ext: \" + langExt); String url = langExt + \"/dialog/en.xdl\" ; PropertyValue [] props = Props . makeProps ( \"OptionsPageURL\" , url ); Lo . dispatchCmd ( \"OptionsTreeDialog\" , props ); Lo . wait ( 2000 ); } // end of openSentCheckOptions() The XML file's location is obtained in two steps. First the ID of the Hunspell service (\"org.openoffice.en.hunspell.dictionaries\") is passed to XPackageInformationProvider.getPackageLocation() to obtain the spell checker's installation folder. Figure 12 shows the directory on my machine. Figure 12. The Hunspell Installation Folder. The directory contains a dialog subdirectory, which holds an XXX.xdl file that defines the dialog's XML structure and data. The \"XXX\" name will be Office's locale language, which in my case is \"en\". The URL required by the \"OptionsTreeDialog\" dispatch is constructed by appending \"/dialog/en.xdl\" to the installation folder string.","title":"2.  Using the Spell Checker"},{"location":"10-Linguistics.html#3-using-the-thesaurus","text":"Lingo.java contains two examples of how to use the thesaurus: // in Lingo.java : XLinguServiceManager2 lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager2 . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); : XThesaurus thesaurus = lingoMgr . getThesaurus (); Write . printMeaning ( \"magician\" , thesaurus ); Write . printMeaning ( \"elucidate\" , thesaurus ); The output from the first call to Write.printMeaning() is: \"magician\" found in thesaurus; number of meanings: 2 1. Meaning: (noun) prestidigitator No. of synonyms: 6 prestidigitator conjurer conjuror illusionist performer (generic term) performing artist (generic term) 2. Meaning: (noun) sorcerer No. of synonyms: 6 sorcerer wizard necromancer thaumaturge thaumaturgist occultist (generic term) XLinguServiceManager2.getThesaurus() returns an instance of XThesaurus whose service and main interfaces are shown in Figure 13. Figure 13. The Thesaurus Service and Interfaces. Write.printMeaning() calls XThesaurus.queryMeanings(), and prints the array of results: public static int printMeaning ( String word , XThesaurus thesaurus ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English PropertyValue [] props = new PropertyValue [ 0 ] ; XMeaning [] meanings = thesaurus . queryMeanings ( word , loc , props ); if ( meanings == null ) { System . out . println ( \"\\\"\" + word + \"\\\" NOT found in thesaurus\\n\" ); return 0 ; } else { System . out . println ( \"\\\"\" + word + \"\\\" found in thesaurus; number of meanings: \" + meanings . length ); for ( int i = 0 ; i < meanings . length ; i ++ ) { System . out . println (( i + 1 ) + \". Meaning: \" + meanings [ i ] . getMeaning ()); String [] synonyms = meanings [ i ] . querySynonyms (); System . out . println ( \" No. of synonyms: \" + synonyms . length ); for ( int k = 0 ; k < synonyms . length ; k ++ ) System . out . println ( \" \" + synonyms [ k ] ); System . out . println (); } return meanings . length ; } } // end of printMeaning() In a similar way to XSpellChecker.spell(), XThesaurus.queryMeanings() requires a locale and an optional array of properties. printMeaning() utilizes American English, and no properties. If you need a non-English thesaurus which isn't part of Office, then look through the dictionary extensions at https://extensions.libreoffice.org/extension-center?getCategories=Dictionary/ ; many include a thesaurus with the dictionary. Thesaurus data is stored as \".idx\" and \".dat\" files in the same directory as the spell checker (i.e. in \\share\\extensions\\dict-en), as can be seen in Figure 13. The files are built from WordNet data ( https://wordnet.princeton.edu/ ), but use a text- based format explained very briefly in Daniel Naber's slides about the Lingucomponent Project (at https://danielnaber.de/publications/ooocon2005-lingucomponent.pdf ). Also, the Lingucomponent website has some C++ code for reading \".idx\" and '.dat\" files (in https://openoffice.org/lingucomponent/MyThes-1.zip ). However, if you want to write code using a thesaurus independently of Office, then I'd suggest programming with one of the many APIs for WordNet; there are currently nine for Java, listed at https://wordnet.princeton.edu/wordnet/related-projects/#Java .","title":"3.  Using the Thesaurus"},{"location":"10-Linguistics.html#4-grammar-checking","text":"Office's default grammar checker (or proof reader) is Lightproof, a Python application developed by L\u00e1szl\u00f3 N\u00e9meth. Lightproof.py, and its support files, are installed in the same folder as the spell checker and thesaurus; on my machine that's \\share\\extensions\\dict-en. Older versions of Lightproof are available from OpenOffice's extensions website at https://extensions.services.openoffice.org/project/lightproof/ . One reason for downloading the old version is that it contains documentation on adding new grammar rules missing from the version installed in Office. Another way to modify Lightproof's grammar rules is with its editor, which can be obtained from https://extensions.libreoffice.org/extension-center/lightproof-editor/ . There are a number of alternative grammar checkers for Office, including \"After the Deadline\" ( https://afterthedeadline.com/ ) and \"LanguageTool\" ( https://languagetool.org/ ), which are easily added to Office as extensions via the \"Language Tools\" subsection of the website, at https://extensions.libreoffice.org/extension-center?getCategories=Language%20Tools . When I first coded my examples, I used the default Lightproof for grammar checking, but it doesn't have a very extensive set of built-in grammar rules (it seems best at catching punctuation mistakes). I switched to LanguageTool because of its larger set of rules, and its support for many languages. I also like that it can be used as a standalone Java library, separate from Office, and that its site includes lots of documentation. Perhaps its biggest drawback is that it requires Java 8 or later. Another issue is that LanguageTool and Lightproof cannot happily coexist inside Office. Lightproof must be disabled and LanguageTool enabled via the Options, Language Settings, Writing aids, \"Available language modules\" pane at the top of Figure 14. Figure 14. Goodbye Lightproof, hello LanguageTool. I used Write.printServicesInfo() earlier to list the available and configured services. The output included: Available Services: : Proofreader (2): org.languagetool.openoffice.Main org.libreoffice.comp.pyuno.Lightproof.en Configured Services: : Proofreader (1): org.languagetool.openoffice.Main \"org.languagetool.openoffice.Main\" refers to the LanguageTool extension, while \"org.libreoffice.comp.pyuno.Lightproof.en\" is the English version of Lightproof. This information can be used to set the proof reader. LanguageTool is made the default by calling Write.setConfiguredServices() like so: Write . setConfiguredServices ( lingoMgr , \"Proofreader\" , \"org.languagetool.openoffice.Main\" ); Alternatively, Lightproof can be enabled with: Write . setConfiguredServices ( lingoMgr , \"Proofreader\" , \"org.libreoffice.comp.pyuno.Lightproof.en\" ); The code for Write.setConfiguredServices() is: // in the Write class public static void setConfiguredServices ( XLinguServiceManager2 lingoMgr , String service , String implName ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); String [] implNames = { implName }; lingoMgr . setConfiguredServices ( \"com.sun.star.linguistic2.\" + service , loc , implNames ); } // end of setConfiguredServices() The function utilizes XLinguServiceManager.setConfiguredServices() to attach a particular implementation service (e.g. LanguageTool) to a specified linguistic service (e.g. the Proofreader).","title":"4.  Grammar Checking"},{"location":"10-Linguistics.html#41-error-reporting-options","text":"The kinds of errors reported by the proof reader can be adjusted through Office's GUI. One configuration pane, used by both Lightproof and LanguageTool, is in the \"English Sentence Checking\" dialog shown back in Figure 10. If you look closely, the first group of check boxes are titled \"Grammar checking\". If you install LanguageTool, Office's Tools menu will be modified to contain a new \"LanguageTool\" submenu shown in Figure 15. Figure 15. The LanguageTool Submenu. The \"Options\" menu item in the \"LanguageTool\" submenu brings up an extensive set of options, reflecting the greater number of grammar rules in the checker (see Figure 16). Figure 16. The LanguageTool Options Dialog. Unfortunately, there seems to be no way to modify these options through Office's Proofreader API.","title":"4.1.  Error Reporting Options"},{"location":"10-Linguistics.html#42-using-the-proof-reader","text":"In Lingo.java the proof reader is loaded and called like so: // in Lingo.java : XProofreader proofreader = Write . loadProofreader (); System . out . println ( \"Proofing...\" ); int numErrs = Write . proofSentence ( \"i dont have one one dogs.\" , proofreader ); System . out . println ( \"No. of proofing errors: \" + numErrs + \"\\n\" ); The output is: Proofing... G* This sentence does not start with an uppercase letter in: \"i\" Suggested change: \"I\" G* Spelling mistake in: \"dont\" Suggested change: \"don't\" G* Word repetition in: \"one one\" Suggested change: \"one\" No. of proofing errors: 3 The proof reader isn't accessed through the linguistics manager; instead a Proofreader service is created, and its interfaces employed. A simplified view of the services and interfaces are shown in Figure 17. Figure 17. The Proofreader Service and Interfaces. Write.loadProofreader() creates the service: public static XProofreader loadProofreader () { return Lo . createInstanceMCF ( XProofreader . class , \"com.sun.star.linguistic2.Proofreader\" ); } Write.proofSentence() passes a sentence to XProofreader.doProofreading(), and prints the errors inside the returned ProofreadingResult instance: public static int proofSentence ( String sent , XProofreader proofreader ) { com . sun . star . lang . Locale loc = new com . sun . star . lang . Locale ( \"en\" , \"US\" , \"\" ); // American English PropertyValue [] props = new PropertyValue [ 0 ] ; int numErrs = 0 ; ProofreadingResult prRes = proofreader . doProofreading ( \"1\" , sent , loc , 0 , sent . length (), props ); if ( prRes != null ) { SingleProofreadingError [] errs = prRes . aErrors ; if ( errs . length > 0 ) for ( SingleProofreadingError err : errs ) { printProofError ( sent , err ); numErrs ++ ; } } return numErrs ; } // end of proofSentence() public static void printProofError ( String str , SingleProofreadingError err ) { String errText = str . substring ( err . nErrorStart , err . nErrorStart + err . nErrorLength ); System . out . println ( \"G* \" + err . aShortComment + \" in: \\\"\" + errText + \"\\\"\" ); if ( err . aSuggestions . length > 0 ) System . out . println ( \" Suggested change: \\\"\" + err . aSuggestions [ 0 ] + \"\\\"\" ); System . out . println (); } // end of printProofError() XProofreader.doProofreading() requires a locale and properties array in the same way as the earlier spell checking and thesaurus methods. It also needs two indices for the start and end of the sentence being checked, and a document ID which is used in the error results. The results are returned as an array of SingleProofreadingError objects, one for each detected error. It's worth having a look at the documentation for the SingleProofreadingError class (use lodoc SingleProofreadingError ), since the object contains more information than I've used in Write.printProofError(); for example, the ID of the grammar rule that was 'broken', a full comment string, and multiple suggestions in a String array. Grammar rule IDs are one area where the proof reader API could be improved. The XProofreader interface includes methods for switching on and off rules based on their IDs, but there's no way to find out what these IDs are except by looking at SingleProofreadingError objects.","title":"4.2.  Using the Proof Reader"},{"location":"10-Linguistics.html#5-guessing-the-language-used-in-a-string","text":"An oft overlooked linguistics API feature is the ability to guess the language used in a string, which is implemented by one service, LanguageGuessing, and a single interface, XLanguageGuessing. The documentation for XLanguageGuessing includes a long list of supported languages, including Irish Gaelic, Scots Gaelic, and Manx Gaelic. There are two examples of language guessing in Lingo.java: // in Lingo.java : Locale loc = Write . guessLocale ( \"The rain in Spain stays mainly on the plain.\" ); Write . printLocale ( loc ); if ( loc != null ) System . out . println ( \"Guessed language: \" + loc . Language ); loc = Write . guessLocale ( \"A vaincre sans p\u00e9ril, on triomphe sans gloire.\" ); // To win without risk is a triumph without glory. if ( loc != null ) System . out . println ( \"Guessed language: \" + loc . Language ); The output is: Locale lang: \"English\"; country: \"\"; variant: \"\" Guessed language: en Guessed language: fr Write.guessLocale() creates the service, its interface, and calls XLanguageGuessing.guessPrimaryLanguage(): // in the Writer class public static com . sun . star . lang . Locale guessLocale ( String testStr ) { XLanguageGuessing guesser = Lo . createInstanceMCF ( XLanguageGuessing . class , \"com.sun.star.linguistic2.LanguageGuessing\" ); if ( guesser == null ) { System . out . println ( \"No language guesser found\" ); return null ; } else return guesser . guessPrimaryLanguage ( testStr , 0 , testStr . length ()); } // end of guessLocale() XLanguageGuessing actually guesses a locale rather than a language, and the locale includes information about the language, country and a variant BCP 47 language label. com.sun.star.lang.Locale stores that information as three strings, but XLocale has additional methods for displaying the string codes in longer formats (e.g. \"th\" as \"Thailand\"). Unfortunately, I was unable to get code using XLocale to compile, so fell back to Java's Locale class which includes similar methods. Write.printLocale() converts an Office locale into a Java version, then prints its data in long form: public static void printLocale ( com . sun . star . lang . Locale loc ) { if ( loc != null ) { java . util . Locale jloc = new java . util . Locale ( loc . Language , loc . Country , loc . Variant ); System . out . println ( \"Locale lang: \\\"\" + jloc . getDisplayLanguage () + \"\\\"; country: \\\"\" + jloc . getDisplayCountry () + \"\\\"; variant: \\\"\" + jloc . getDisplayVariant () + \"\\\"\" ); } } // end of printLocale()","title":"5.  Guessing the Language used in a String"},{"location":"10-Linguistics.html#6-spell-checking-and-grammar-checking-a-document","text":"Lingo.java only spell checks individual words, and grammar checks a single sentence. The LingoFile.java example shows how these features can be applied to an entire document. One way to scan every sentence in a document is to combine XParagraphCursor and XSentenceCursor, as in the TalkingBook.java example from Chapter 5, section 6. An outer loop iterates over every paragraph using XParagraphCursor, and an inner loop splits each paragraph into sentences with the help of XSentenceCursor. Initially, I coded LingoFile.java in this way, but found that XSentenceCursor occasionally didn't divide a paragraph into the correct number of sentences; sometimes two sentences were treated as one. So I switched to a combined Office/Java approach \u2013 the outer loop in LingoFile.java still utilizes XParagraphCursor to scan the paragraphs, but the sentences in a paragraph are extracted using a sentence-based BreakIterator. The main() function of LingoFile.java: public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run LingoFile <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // load spell checker, proof reader XSpellChecker speller = Write . loadSpellChecker (); XProofreader proofreader = Write . loadProofreader (); BreakIterator bi = BreakIterator . getSentenceInstance ( java . util . Locale . US ); // iterate through the doc by paragraphs XParagraphCursor paraCursor = Write . getParagraphCursor ( doc ); paraCursor . gotoStart ( false ); // go to start of text String currPara ; do { paraCursor . gotoEndOfParagraph ( true ); // select all of paragraph currPara = paraCursor . getString (); if ( currPara . length () > 0 ) checkSentences ( currPara , bi , speller , proofreader ); } while ( paraCursor . gotoNextParagraph ( false )); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Write.loadSpellChecker() hides the creation of the linguistics manager, and its retrieval of the spell checker: // in the Write class public static XSpellChecker loadSpellChecker () { XLinguServiceManager lingoMgr = Lo . createInstanceMCF ( XLinguServiceManager . class , \"com.sun.star.linguistic2.LinguServiceManager\" ); if ( lingoMgr == null ) { System . out . println ( \"No linguistics manager found\" ); return null ; } else return lingoMgr . getSpellChecker (); } // end of loadSpellChecker() The BreakIterator is instantiated in main () using : BreakIterator bi = BreakIterator . getSentenceInstance ( java . util . Locale . US ); but employed inside checkSentences (), which splits a paragraph into sentences : // in LingoFile.java private static void checkSentences ( String currPara , BreakIterator bi , XSpellChecker speller , XProofreader proofreader ) { System . out . println ( \"\\n>> \" + currPara ); bi . setText ( currPara ); int lastIdx = bi . first (); while ( lastIdx != BreakIterator . DONE ) { int firstIdx = lastIdx ; lastIdx = bi . next (); if ( lastIdx != BreakIterator . DONE ) { String sentence = currPara . substring ( firstIdx , lastIdx ); Write . proofSentence ( sentence , proofreader ); Write . spellSentence ( sentence , speller ); } } } // end of checkSentences() The index positions of the start of the current sentence and the start of the next sentence are stored in firstIdx and lastIdx, and used to extract a substring spanning the current sentence. This is passed to Write.spellSentence() and Write.proofSentence() for spell and proof checking. Write.spellSentence() splits the sentence into an array of words, and calls Write.spellWord() on each one: // in the Write class public static int spellSentence ( String sent , XSpellChecker speller ) { String [] words = sent . split ( \"\\\\W+\" ); // split into words int count = 0 ; boolean isCorrect ; for ( String word : words ) { isCorrect = spellWord ( word , speller ); count = count + ( isCorrect ? 0 : 1 ); } return count ; } // end of spellSentence() The poorly written \"badGrammar.odt\" is shown in Figure 18. Figure 18. Not a Good Example of my Writing Skills. The output from LingoFile.java when given \"badGrammar.odt\": >> I have a dogs. I have one dogs. G* Possible agreement error in: \"a dogs\" Suggested change: \"a dog\" >> I allow of of go home. i dogs. John don\u2019t like dogs. So recieve no cats also. G* Word repetition in: \"of of\" Suggested change: \"of\" G* This sentence does not start with an uppercase letter in: \"i\" Suggested change: \"I\" G* Grammatical problem in: \"dogs\" Suggested change: \"dog\" G* 'Also' at the end of sentence in: \"also\" Suggested change: \"as well\" * \"recieve\" is unknown. Try: No. of names: 8 \"receive\" \"relieve\" \"retrieve\" \"reprieve\" \"reverie\" \"recitative\" \"Recife\" \"reserve\" The grammar errors (those starting with \"G*\") are produced by the LanguageTool proof checker. If the default Lightproof checker is utilized instead, then less errors are found: >> I have a dogs. I have one dogs. >> I allow of of go home. i dogs. John don\u2019t like dogs. So recieve no cats also. G* Word duplication? in: \"of of\" Suggested change: \"of\" G* Missing capitalization? in: \"i\" Suggested change: \"I\" * \"recieve\" is unknown. Try: No. of names: 8 \"receive\" \"relieve\" \"retrieve\" \"reprieve\" \"reverie\" \"recitative\" \"Recife\" \"reserve\" On larger documents, such as the Sherlock Holmes short story in \"bigStory.doc\", it's a good idea to redirect the voluminous output to a temporary file so it can be examined easily. More than half the errors for \"bigStory.doc\" are spurious reports of unpaired quotes. The output can be considerably reduced if LanguageTool's unpaired rule is disabled, via the Options dialog in Figure 16. Figure 19 shows the dialog with the \"Unpaired\" checkbox deselected in the Punctuation section. Figure 19. The LanguageTool Options Dialog with the Unpaired Rule Deselected. The majority of the remaining errors are words unknown to the spell checker, such as names and places, and British English spellings. Most of the grammar errors relate to how direct speech is written. The grammar checker mistakenly reports an error if the direct speech ends with a question mark or exclamation mark without a comma after the quoted text. On balance, I'd say that Sir Arthur Conan Doyle was an excellent speller and grammarian, or his copy editor was.","title":"6.  Spell Checking and Grammar Checking a Document"},{"location":"11%20Part%203%20Draw%20%26%20Impress.html","text":"Part 3 Draw & Impress \u00b6","title":"Part 3 Draw & Impress"},{"location":"11%20Part%203%20Draw%20%26%20Impress.html#part-3-draw-impress","text":"","title":"Part 3 Draw &amp; Impress"},{"location":"11-Draw_Impress_APIs.html","text":"Chapter 11. Draw/Impress APIs Overview \u00b6 Topics Draw Pages and Master Pages; Draw Page Details; API Hierarchy Code Examples; Shapes in a Drawing; Shapes in a Presentation ; The Slide Show APIs Example folders: \"Draw Tests\" and \"Utils\" This part discusses the APIs for both Draw and Impress since the presentations API is an extension of Office's drawing functionality, adding such things as slide-related shapes (e.g. for the title, subtitle, header, and footer), more data views (e.g. an handout mode), and slide shows. You'll get a good feel for the APIs' capabilities by reading the Draw and Impress user guides, downloadable from https://libreoffice.org/get-help/documentation/ . Details about the APIs can be found in Chapter 9 of the Developer's Guide, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Drawings/Drawing_Documents_and_Presentation_Documents/ (or type loGuide draw ). The guide can also be retrieved as a PDF file from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . The guide's drawing and presentation examples are online at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Drawing , and there's a short Draw example in https://api.libreoffice.org/examples/examples.html#Java_examples . This chapter gives a broad overview of the drawing and presentation APIs, with some small code snippets to illustrate the ideas. Subsequent chapters will return to these features in much more detail. The APIs are organized around three services which subclass OfficeDocument, as depicted in Figure 1. Figure 1. The Drawing and Presentation Document Services. The DrawingDocument service, and most of its related services and interfaces are in Office's com.sun.star.drawing package (or module), which is documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1drawing.html . Or you can reach it using lodoc drawing module reference . The presentation API is mostly located in Office's com.sun.star.presentation package (or module), which is documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1presentation.html . You can also find it with lodoc presentation module reference . Figure 2 shows a more detailed version of Figure 1 which includes some of the interfaces defined by the services. Figure 2. Drawing and Presentation Document Services and Interfaces. The interfaces highlighted in bold in Figure 2 will be discussed in this chapter. The DrawingDocument service is pretty much empty, with the real drawing 'action' in GenericDrawingDocument (which is in the com.sun.star.drawing package). PresentationDocument subclasses GenericDrawingDocument to inherit its drawing capabilities, and adds features for slide shows (via the XPresentationSupplier and XCustomPresntationSupplier interfaces). The word \"presentation\" is a little overloaded in the API \u2013 PresentationDocument corresponds to the slide deck, while XPresentationSupplier.getPresentation() returns an XPresentation object which represents a slide show. 1. Draw Pages and Master Pages \u00b6 A drawing (or presentation) document consists of a series of draw pages, one for each page (or slide) inside the document. Perhaps the most surprising aspect of this is that a Draw document can contain multiple pages. A document can also contain one or more master pages. A master page contains drawing/slide elements which appear on multiple draw page. This idea is probably most familiar from slide presentations where a master page holds the header, footer, and graphics that appear on every slide. As illustrated in Figure 2, GenericDrawingDocument supports an XDrawPagesSupplier interface whose getDrawPages() returns an XDrawPages object. It also has an XMasterPagesSupplier whose getMasterPages() returns the master pages as an object. Office views master pages as special kinds of draw pages, and so getMasterPages() also returns an XDrawPages object. Note the \"s\" in \"XDrawPages\": an XDrawPages object is an indexed container of XDrawPage (no \"s\") objects, as illustrated by Figure 3. Figure 3. The XDrawPages Interface Since XDrawPages inherit XIndexAccess, its elements (pages) can be accessed using index-based lookup (i.e. to return page 0, page 1, etc.). 2. Draw Page Details \u00b6 A draw page is a collection of shapes: often text shapes, such as a title box or a box holding bulleted points. But a shape can be many more things: an ellipse, a polygon, a bitmap, an embedded video, and so on. This \"page as shapes\" notion is implemented by the API hierarchy shown in Figure 4. Figure 4. The API Hierarchy for a Draw Page. XPresentationPage is the interface for a slide's page, but most of its functionality comes from XDrawPage (see lodoc XPresentationPage ). The XDrawPage interface doesn't do much either, except for inheriting XShapes (note the \"s\"). XShapes inherits XIndexAccess, which means that an XShapes object can be manipulated as an indexed sequence of XShape objects. The XDrawPage and XPresentationPage interfaces are supported by services, some of which are shown in Figure 5. These services are in some ways more important than the interfaces, since they contain many properties related to pages and slides. Figure 5. Some of the Draw Page Services. There are two DrawPage services in the Office API, one in the drawing package, and another in the presentation package. This is represented in Figure 5 by including the package names in brackets after the service names. You can access the documentation for these services by typing lodoc drawpage service drawing and lodoc drawpage service presentation . No properties are defined in the drawing DrawPage, instead everything is inherited from GenericDrawPage. I've put \"(??)\" next to the XDrawPage and XPresentationPage interfaces in Figure 5 because they're not listed in the GenericDrawPage and presentation DrawPage services in the documentation, but must be there because of the way that the code works. Also, the documentation for GenericDrawPage lists XShapes as an interface, rather than XDrawPage. 3. API Hierarchy Code Examples \u00b6 Some code snippets will help clarify the hierarchies shown in Figures 2-5. The following lines load a Draw (or Impress) document called \"foo\" as an XComponent object. XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( \"foo\" , loader ); A common next step is to access the draw pages in the document using the XDrawPagesSupplier interface shown in Figure 2: XDrawPagesSupplier supplier = Lo . qi ( XDrawPagesSupplier . class , doc ); XDrawPages pages = supplier . getDrawPages (); This code works whether the document is a sequence of draw pages (i.e. a Draw document) or slides (i.e. an Impress document). Using the ideas shown in Figure 3, a particular draw page is accessed based on its index position. The first draw page in the document is retrieved with: XDrawPage page = Lo . qi ( XDrawPage . class , pages . getByIndex ( 0 )); Pages are numbered from 0, and a newly created document always contains one page. The XDrawPage interface is supported by the GenericDrawPage service (see Figure 5), which holds the page's properties. The following snippet returns the width of the page and its page number: int width = ( Integer ) Props . getProperty ( page , \"Width\" ); int pageNumber = ( Short ) Props . getProperty ( page , \"Number\" ); The \"Width\" and \"Number\" properties are documented in the GenericDrawPage service page at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1GenericDrawPage.html (or use lodoc GenericDrawPage service ). Once a single page has been retrieved, it's possible to access its shapes (as shown in Figure 4). The following code converts the XDrawPage object to XShapes, and accesses the first XShape in its indexed container: XShapes shapes = Lo . qi ( XShapes . class , page ); XShape shape = Lo . qi ( XShape . class , shapes . getByIndex ( 0 )) 4. Shapes in a Drawing \u00b6 Shapes fall into two groups \u2013 drawing shapes that subclass the Shape service in com.sun.star.drawing, and presentation-related shapes which subclass the Shape service in com.sun.star.presentation. The first type are described here, and the presentation shapes in section 5. Figure 6 shows the com.sun.star.drawing Shape service and some of its subclasses. Figure 6. Some of the Drawing Shapes. I'll be explaining many of these shapes in Chapters 13 and 15, but you can probably guess what most of them do \u2013 EllipseShape is for drawing ellipses and circles, LineShape is for lines and arrows, RectangleShape is for rectangles. The two \"??\"s in Figure 6 indicate that those services aren't shown in the online documentation, but appear in examples. The hardest aspect of this hierarchy is searching it for information on a shape's properties. Many general properties are located in the Shape service, so are documented on the Shape page (use lodoc shape service drawing to reach it). More specialized properties are located in the specific shape's service. For instance, RectangleShape has a \"CornerRadius\" property which allows a rectangle's corners to be rounded to make it more button-like. Unfortunately, most shapes inherit a lot more properties than just those in Shape. Figure 7 shows a typical example \u2013 RectangleShape inherits properties from at least eight services (I've not shown the complete hierarchy)! Figure 7. RectangleShape's Properties. Aside from RectangleShape inheriting properties from Shape, it also obtains its fill, shadow, line, and rotation attributes from the FillProperties, ShadowProperties, LineProperties, and RotationDescriptor services. For instance, to make the rectangle red, the \"FillColor\" property, defined in the FillProperties service, must be set. The code for doing this is not complex: Props . setProperty ( shape , \"FillColor\" , 0xFF0000 ); // hexadecimal for red The complication comes in knowing that a property called \"FillColor\" exists. Visit the shape's service documentation (e.g. the RectangleShape page at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1RectangleShape.html , or use lodoc RectangleShape service ), and look inside each inherited Property service until you find the relevant property. If the shape contains some text (e.g. the rectangle has a label inside it), and you want to change one of the text's properties, then you'll need to look in the three property services above the Text service (see Figure 7). Changing text requires that the text be selected first, which takes us back XText and Chapter 5. For example, the text height is changed to 18pt by: XText xText = Lo . qi ( XText . class , shape ); XTextCursor cursor = xText . createTextCursor (); cursor . gotoStart ( false ); cursor . gotoEnd ( true ); // select all text Props . setProperty ( cursor , \"CharHeight\" , 18 ); First the shape is converted into an XText reference so that text selection can be done using a cursor. The \"CharHeight\" property is inherited from the CharacterProperties service. Figure 7 doesn't show all the text property services. For instance, there are also services called CharacterPropertiesComplex and ParagraphPropertiesComplex. 5. Shapes in a Presentation \u00b6 If the document is a slide deck, then presentation-related shapes will be subclasses of the com.sun.star.presentation.Shape service (see the documentation with lodoc shape service presentation ). Some of those shapes are shown in Figure 8. Figure 8. Some of the Presentation Shapes. The com.sun.star.presentation.Shape service doesn't subclass the com.sun.star.drawing.Shape service. Instead, every presentation shape inherits the presentation Shape service and a drawing shape (usually TextShape). This means that all the presentation shapes can be treated as drawing shapes when being manipulated in code. Most of the presentation shapes are special kinds of text shapes. For instance, TitleTextShape and OutlinerShape are text shapes which usually appear automatically when you create a new slide inside Impress \u2013 the slide's title is typed into the TitleTextShape, and bulleted points added to OutlinerShape. This is shown in Figure 9. Figure 9. Two Presentation Shapes in a Slide. Using OutlinerShape as an example, its 'simplified' inheritance hierarchy looks like Figure 10. Figure 10. The OutlinerShape Hierarchy. OutlinerShape has at least nine property services that it inherits. 6. The Slide Show APIs \u00b6 One difference between slides and drawings is that the presentations API supports slide shows. This extra functionality can be seen in Figure 2 since the PresentationDocument service offers an XPresntationSupplier interface which has a getPresentation() method for returning an XPresentation object. Don't be confused by the name \u2013 an XPresentation object represents a slide show. XPresentation offers start() and end() methods for starting and ending a slide show, and the Presentation service contains properties for affecting how the show progresses, as illustrated by Figure 11. Figure 11. The Slide Show Presentation Services. Code for starting a slide show for the \"foo\" document: XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( \"foo\" , loader ); XPresentationSupplier ps = Lo . qi ( XPresentationSupplier . class , doc ); XPresentation show = Lo . qi ( XPresentation . class , ps . getPresentation ()); show . start (); The Presentation service is a bit lacking, so an extended service, Presentation2, was added more recently. It can access an XSlideShowController interface which gives finer-grained control over how the show progresses; I'll give examples later.","title":"Chapter 11. Draw/Impress APIs Overview"},{"location":"11-Draw_Impress_APIs.html#chapter-11-drawimpress-apis-overview","text":"Topics Draw Pages and Master Pages; Draw Page Details; API Hierarchy Code Examples; Shapes in a Drawing; Shapes in a Presentation ; The Slide Show APIs Example folders: \"Draw Tests\" and \"Utils\" This part discusses the APIs for both Draw and Impress since the presentations API is an extension of Office's drawing functionality, adding such things as slide-related shapes (e.g. for the title, subtitle, header, and footer), more data views (e.g. an handout mode), and slide shows. You'll get a good feel for the APIs' capabilities by reading the Draw and Impress user guides, downloadable from https://libreoffice.org/get-help/documentation/ . Details about the APIs can be found in Chapter 9 of the Developer's Guide, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Drawings/Drawing_Documents_and_Presentation_Documents/ (or type loGuide draw ). The guide can also be retrieved as a PDF file from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . The guide's drawing and presentation examples are online at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Drawing , and there's a short Draw example in https://api.libreoffice.org/examples/examples.html#Java_examples . This chapter gives a broad overview of the drawing and presentation APIs, with some small code snippets to illustrate the ideas. Subsequent chapters will return to these features in much more detail. The APIs are organized around three services which subclass OfficeDocument, as depicted in Figure 1. Figure 1. The Drawing and Presentation Document Services. The DrawingDocument service, and most of its related services and interfaces are in Office's com.sun.star.drawing package (or module), which is documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1drawing.html . Or you can reach it using lodoc drawing module reference . The presentation API is mostly located in Office's com.sun.star.presentation package (or module), which is documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1presentation.html . You can also find it with lodoc presentation module reference . Figure 2 shows a more detailed version of Figure 1 which includes some of the interfaces defined by the services. Figure 2. Drawing and Presentation Document Services and Interfaces. The interfaces highlighted in bold in Figure 2 will be discussed in this chapter. The DrawingDocument service is pretty much empty, with the real drawing 'action' in GenericDrawingDocument (which is in the com.sun.star.drawing package). PresentationDocument subclasses GenericDrawingDocument to inherit its drawing capabilities, and adds features for slide shows (via the XPresentationSupplier and XCustomPresntationSupplier interfaces). The word \"presentation\" is a little overloaded in the API \u2013 PresentationDocument corresponds to the slide deck, while XPresentationSupplier.getPresentation() returns an XPresentation object which represents a slide show.","title":"Chapter 11. Draw/Impress APIs Overview"},{"location":"11-Draw_Impress_APIs.html#1-draw-pages-and-master-pages","text":"A drawing (or presentation) document consists of a series of draw pages, one for each page (or slide) inside the document. Perhaps the most surprising aspect of this is that a Draw document can contain multiple pages. A document can also contain one or more master pages. A master page contains drawing/slide elements which appear on multiple draw page. This idea is probably most familiar from slide presentations where a master page holds the header, footer, and graphics that appear on every slide. As illustrated in Figure 2, GenericDrawingDocument supports an XDrawPagesSupplier interface whose getDrawPages() returns an XDrawPages object. It also has an XMasterPagesSupplier whose getMasterPages() returns the master pages as an object. Office views master pages as special kinds of draw pages, and so getMasterPages() also returns an XDrawPages object. Note the \"s\" in \"XDrawPages\": an XDrawPages object is an indexed container of XDrawPage (no \"s\") objects, as illustrated by Figure 3. Figure 3. The XDrawPages Interface Since XDrawPages inherit XIndexAccess, its elements (pages) can be accessed using index-based lookup (i.e. to return page 0, page 1, etc.).","title":"1.  Draw Pages and Master Pages"},{"location":"11-Draw_Impress_APIs.html#2-draw-page-details","text":"A draw page is a collection of shapes: often text shapes, such as a title box or a box holding bulleted points. But a shape can be many more things: an ellipse, a polygon, a bitmap, an embedded video, and so on. This \"page as shapes\" notion is implemented by the API hierarchy shown in Figure 4. Figure 4. The API Hierarchy for a Draw Page. XPresentationPage is the interface for a slide's page, but most of its functionality comes from XDrawPage (see lodoc XPresentationPage ). The XDrawPage interface doesn't do much either, except for inheriting XShapes (note the \"s\"). XShapes inherits XIndexAccess, which means that an XShapes object can be manipulated as an indexed sequence of XShape objects. The XDrawPage and XPresentationPage interfaces are supported by services, some of which are shown in Figure 5. These services are in some ways more important than the interfaces, since they contain many properties related to pages and slides. Figure 5. Some of the Draw Page Services. There are two DrawPage services in the Office API, one in the drawing package, and another in the presentation package. This is represented in Figure 5 by including the package names in brackets after the service names. You can access the documentation for these services by typing lodoc drawpage service drawing and lodoc drawpage service presentation . No properties are defined in the drawing DrawPage, instead everything is inherited from GenericDrawPage. I've put \"(??)\" next to the XDrawPage and XPresentationPage interfaces in Figure 5 because they're not listed in the GenericDrawPage and presentation DrawPage services in the documentation, but must be there because of the way that the code works. Also, the documentation for GenericDrawPage lists XShapes as an interface, rather than XDrawPage.","title":"2.  Draw Page Details"},{"location":"11-Draw_Impress_APIs.html#3-api-hierarchy-code-examples","text":"Some code snippets will help clarify the hierarchies shown in Figures 2-5. The following lines load a Draw (or Impress) document called \"foo\" as an XComponent object. XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( \"foo\" , loader ); A common next step is to access the draw pages in the document using the XDrawPagesSupplier interface shown in Figure 2: XDrawPagesSupplier supplier = Lo . qi ( XDrawPagesSupplier . class , doc ); XDrawPages pages = supplier . getDrawPages (); This code works whether the document is a sequence of draw pages (i.e. a Draw document) or slides (i.e. an Impress document). Using the ideas shown in Figure 3, a particular draw page is accessed based on its index position. The first draw page in the document is retrieved with: XDrawPage page = Lo . qi ( XDrawPage . class , pages . getByIndex ( 0 )); Pages are numbered from 0, and a newly created document always contains one page. The XDrawPage interface is supported by the GenericDrawPage service (see Figure 5), which holds the page's properties. The following snippet returns the width of the page and its page number: int width = ( Integer ) Props . getProperty ( page , \"Width\" ); int pageNumber = ( Short ) Props . getProperty ( page , \"Number\" ); The \"Width\" and \"Number\" properties are documented in the GenericDrawPage service page at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1GenericDrawPage.html (or use lodoc GenericDrawPage service ). Once a single page has been retrieved, it's possible to access its shapes (as shown in Figure 4). The following code converts the XDrawPage object to XShapes, and accesses the first XShape in its indexed container: XShapes shapes = Lo . qi ( XShapes . class , page ); XShape shape = Lo . qi ( XShape . class , shapes . getByIndex ( 0 ))","title":"3.  API Hierarchy Code Examples"},{"location":"11-Draw_Impress_APIs.html#4-shapes-in-a-drawing","text":"Shapes fall into two groups \u2013 drawing shapes that subclass the Shape service in com.sun.star.drawing, and presentation-related shapes which subclass the Shape service in com.sun.star.presentation. The first type are described here, and the presentation shapes in section 5. Figure 6 shows the com.sun.star.drawing Shape service and some of its subclasses. Figure 6. Some of the Drawing Shapes. I'll be explaining many of these shapes in Chapters 13 and 15, but you can probably guess what most of them do \u2013 EllipseShape is for drawing ellipses and circles, LineShape is for lines and arrows, RectangleShape is for rectangles. The two \"??\"s in Figure 6 indicate that those services aren't shown in the online documentation, but appear in examples. The hardest aspect of this hierarchy is searching it for information on a shape's properties. Many general properties are located in the Shape service, so are documented on the Shape page (use lodoc shape service drawing to reach it). More specialized properties are located in the specific shape's service. For instance, RectangleShape has a \"CornerRadius\" property which allows a rectangle's corners to be rounded to make it more button-like. Unfortunately, most shapes inherit a lot more properties than just those in Shape. Figure 7 shows a typical example \u2013 RectangleShape inherits properties from at least eight services (I've not shown the complete hierarchy)! Figure 7. RectangleShape's Properties. Aside from RectangleShape inheriting properties from Shape, it also obtains its fill, shadow, line, and rotation attributes from the FillProperties, ShadowProperties, LineProperties, and RotationDescriptor services. For instance, to make the rectangle red, the \"FillColor\" property, defined in the FillProperties service, must be set. The code for doing this is not complex: Props . setProperty ( shape , \"FillColor\" , 0xFF0000 ); // hexadecimal for red The complication comes in knowing that a property called \"FillColor\" exists. Visit the shape's service documentation (e.g. the RectangleShape page at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1RectangleShape.html , or use lodoc RectangleShape service ), and look inside each inherited Property service until you find the relevant property. If the shape contains some text (e.g. the rectangle has a label inside it), and you want to change one of the text's properties, then you'll need to look in the three property services above the Text service (see Figure 7). Changing text requires that the text be selected first, which takes us back XText and Chapter 5. For example, the text height is changed to 18pt by: XText xText = Lo . qi ( XText . class , shape ); XTextCursor cursor = xText . createTextCursor (); cursor . gotoStart ( false ); cursor . gotoEnd ( true ); // select all text Props . setProperty ( cursor , \"CharHeight\" , 18 ); First the shape is converted into an XText reference so that text selection can be done using a cursor. The \"CharHeight\" property is inherited from the CharacterProperties service. Figure 7 doesn't show all the text property services. For instance, there are also services called CharacterPropertiesComplex and ParagraphPropertiesComplex.","title":"4.  Shapes in a Drawing"},{"location":"11-Draw_Impress_APIs.html#5-shapes-in-a-presentation","text":"If the document is a slide deck, then presentation-related shapes will be subclasses of the com.sun.star.presentation.Shape service (see the documentation with lodoc shape service presentation ). Some of those shapes are shown in Figure 8. Figure 8. Some of the Presentation Shapes. The com.sun.star.presentation.Shape service doesn't subclass the com.sun.star.drawing.Shape service. Instead, every presentation shape inherits the presentation Shape service and a drawing shape (usually TextShape). This means that all the presentation shapes can be treated as drawing shapes when being manipulated in code. Most of the presentation shapes are special kinds of text shapes. For instance, TitleTextShape and OutlinerShape are text shapes which usually appear automatically when you create a new slide inside Impress \u2013 the slide's title is typed into the TitleTextShape, and bulleted points added to OutlinerShape. This is shown in Figure 9. Figure 9. Two Presentation Shapes in a Slide. Using OutlinerShape as an example, its 'simplified' inheritance hierarchy looks like Figure 10. Figure 10. The OutlinerShape Hierarchy. OutlinerShape has at least nine property services that it inherits.","title":"5.  Shapes in a Presentation"},{"location":"11-Draw_Impress_APIs.html#6-the-slide-show-apis","text":"One difference between slides and drawings is that the presentations API supports slide shows. This extra functionality can be seen in Figure 2 since the PresentationDocument service offers an XPresntationSupplier interface which has a getPresentation() method for returning an XPresentation object. Don't be confused by the name \u2013 an XPresentation object represents a slide show. XPresentation offers start() and end() methods for starting and ending a slide show, and the Presentation service contains properties for affecting how the show progresses, as illustrated by Figure 11. Figure 11. The Slide Show Presentation Services. Code for starting a slide show for the \"foo\" document: XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( \"foo\" , loader ); XPresentationSupplier ps = Lo . qi ( XPresentationSupplier . class , doc ); XPresentation show = Lo . qi ( XPresentation . class , ps . getPresentation ()); show . start (); The Presentation service is a bit lacking, so an extended service, Presentation2, was added more recently. It can access an XSlideShowController interface which gives finer-grained control over how the show progresses; I'll give examples later.","title":"6.  The Slide Show APIs"},{"location":"12-Examining_DrawImpress.html","text":"Chapter 12. Examining a Draw/Impress Document \u00b6 Topics Examining Slides/Pages; Page Layers; Styles Example folders: \"Draw Tests\" and \"Utils\" This chapter describes the SlidesInfo.java example, which shows the basics of how to open and display a Draw or Impress file. The code also illustrates how the slides or pages can be examined, including how to retrieve information on their layers and styles. The SlidesInfo.java main() function: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: SlidesInfo <filename>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open the file: \" + args [ 0 ] ); Lo . closeOffice (); return ; } if ( ! Draw . isShapesBased ( doc )) { System . out . println ( \"-- not a drawing or slides presentation\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 1000 ); // need delay or zoom may not work GUI . zoom ( doc , GUI . ENTIRE_PAGE ); // or GUI.OPTIMAL, GUI.PAGE_WIDTH, GUI.ENTIRE_PAGE // GUI.zoomValue(doc, 60); // percentage size System . out . println ( \"\\nNo of slides: \" + Draw . getSlidesCount ( doc ) + \"\\n\" ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); // access first page Size sz = Draw . getSlideSize ( currSlide ); System . out . println ( \"Size of slide (mm): (\" + sz . Width + \", \" + sz . Height + \")\\n\" ); reportLayers ( doc ); reportStyles ( doc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Lo.openDoc() is capable of opening any Office document, and importing documents in other formats, so it's worthwhile checking the resulting XComponent object before progressing. Draw.isShapesBased() returns true if the file holds a Draw or Impress document: // in the Draw class public static boolean isShapesBased ( XComponent doc ) { return Info . isDocType ( doc , Lo . DRAW_SERVICE ) || Info . isDocType ( doc , Lo . IMPRESS_SERVICE ); } The document is made visible on-screen by calling GUI.setVisible(), and the application view is resized so all the drawing (or slide) is visible inside the window. Draw.zoom() can be passed three different constants for showing the entire width of the page, the entire page, or an optimal view that zooms in so all the 'data' on the page is visible without the empty space around it. Alternatively, Draw.zoomValue() allows the user to supply a zooming percentage. These two methods are defined using Lo.dispatchCmd(), which was introduced at the end of Chapter 4: // in the Draw class public static void zoom ( XComponent doc , short view ) { if ( view == OPTIMAL ) Lo . dispatchCmd ( \"ZoomOptimal\" ); else if ( view == PAGE_WIDTH ) Lo . dispatchCmd ( \"ZoomPageWidth\" ); if ( view == ENTIRE_PAGE ) Lo . dispatchCmd ( \"ZoomPage\" ); else { System . out . println ( \"Did not recognize zoom view: \" + view + \"; using optimal\" ); Lo . dispatchCmd ( \"ZoomOptimal\" ); } Lo . delay ( 500 ); } // end of zoom() public static void zoomValue ( XComponent doc , int value ) // zoom to a specific value using a dispatch { String [] zoomLabels = { \"Zoom.Value\" , \"Zoom.ValueSet\" , \"Zoom.Type\" }; Object [] zoomVals = {( short ) value , 28703 , 0 }; Lo . dispatchCmd ( \"Zoom\" , Props . makeProps ( zoomLabels , zoomVals )); Lo . delay ( 500 ); } // end of zoomValue() I found the four dispatch commands (\"ZoomOptimal\", \"ZoomPageWidth\", \"ZoomPage\", and \"Zoom\") by browsing the \"Development/DispatchCommands\" documentation page at https://wiki.documentfoundation.org/Development/DispatchCommands/ . A great offline source is the UICommands.ods spreadsheet, put together by Ariel Constenla- Haile, which can be obtained from https://arielch.fedorapeople.org/devel/ooo/UICommands.ods . Draw.zoomValue() uses the \"Zoom\" dispatch which requires the setting of properties. Its \"Zoom.Type\" parameter can be assigned 0, 1, 2, or 3 which correspond to zooming in terms of percentages, an optimal view, entire page, or page width. Unfortunately, I was only able to get the 0 value to work, which is why the others are handled by Draw.zoom(). The call to Lo.delay() at the end of the zoom methods gives Office time to carry out the zooming before my code does anything else. The same trick is utilized in the main() function, after the call to GUI.setVisible(). 1. Accessing Slides/Pages \u00b6 Most of my Draw class method names include the word 'slide' (e.g. Draw.getSlidesCount(), Draw.getSlide(), Draw.getSlideSize()). That's a bit misleading since most of them will work just as well with Draw or Impress documents. For example, Draw.getSlidesCount() will return 1 when applied to a newly created Draw document. Draw.getSlidesCount() calls Draw.getSlides() which returns an XDrawPages object; XDrawPages supports a getCount() method: // in the Draw class public static int getSlidesCount ( XComponent doc ) { XDrawPages slides = getSlides ( doc ); if ( slides == null ) return 0 ; return slides . getCount (); } // end of getSlidesCount() public static XDrawPages getSlides ( XComponent doc ) // return all the pages as an XDrawPages object { XDrawPagesSupplier supplier = Lo . qi ( XDrawPagesSupplier . class , doc ); if ( supplier == null ) return null ; return supplier . getDrawPages (); } // end of getSlides() getSlides() employs the XDrawPagesSupplier interface which is part of GenericDrawingDocument shown in Figure 2 of Chapter 11. Draw.getSlide() (note: no \"s\") also calls Draw.getSlides(), but treats the XDrawPages object as an indexed container of XDrawPage objects: // in the Draw class public static XDrawPage getSlide ( XComponent doc , int idx ) { return getSlide ( getSlides ( doc ), idx ); } public static XDrawPage getSlide ( XDrawPages slides , int idx ) { XDrawPage slide = null ; try { slide = Lo . qi ( XDrawPage . class , slides . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not get slide \" + idx ); } return slide ; } // end of getSlide() Draw.getSlideSize() returns a com.sun.star.awt.Size object created from looking up the \"Width\" and \"Height\" properties of the supplied slide/page: // in the Draw class public static Size getSlideSize ( XDrawPage xDrawPage ) // get size of the given page (in mm units) { try { XPropertySet props = Lo . qi ( XPropertySet . class , xDrawPage ); if ( props == null ) { System . out . println ( \"No slide properties found\" ); return null ; } int width = ( Integer ) props . getPropertyValue ( \"Width\" ); int height = ( Integer ) props . getPropertyValue ( \"Height\" ); return new Size ( width / 100 , height / 100 ); } catch ( Exception e ) { System . out . println ( \"Could not get page dimensions\" ); return null ; } } // end of getSlideSize() These Width\" and \"Height\" properties are stored in XDrawPage's GenericDrawPage service, shown in Figure 5 of Chapter 11. My Draw class specifies measurements in millimeters rather than Office's 1/100 mm units. For instance, Draw.getSlideSize() would return Office page dimensions of 28000 by 21000 as (280, 210). 2. Page Layers \u00b6 A Draw or Impress page consists of five layers called \"layout\", \"controls\", \"measurelines\", \"background\", and \"backgroundobjects\". The first three are described in the Draw user guide, but\"measurelines\" is called \"Dimension Lines\". Probably \"layout\" is the most important layer since that's where shapes are located. Form controls (e.g. buttons) are added to \"controls\", which is always the top-most layer. \"background\", and \"backgroundobjects\" refer to the master page graphic and any shapes on that page. Each layer can be made visible or invisible independent of the others. It's also possible to create new layers. reportLayers() in SlidesInfo.java prints each layer's properties: // in SlidesInfo.java private static void reportLayers ( XComponent doc ) { XLayerManager lm = Draw . getLayerManager ( doc ); for ( int i = 0 ; i < lm . getCount (); i ++ ) try { Props . showObjProps ( \" Layer \" + i , lm . getByIndex ( i )); } catch ( com . sun . star . uno . Exception e ) {} XLayer layer = Draw . getLayer ( doc , \"backgroundobjects\" ); Props . showObjProps ( \"Background Object Props\" , layer ); } // end of reportLayers() Draw.getLayerManager() obtains an XLayerManager instance which can be treated as an indexed container of XLayer objects. Draw.getLayer() converts the XLayerManager into a named container, so it can be searched by layer name. Typical output from reportLayers() is: Layer 0 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == layout Title == Layer 1 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == background Title == Layer 2 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == backgroundobjects Title == Layer 3 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == controls Title == Layer 4 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == measurelines Title == Background Object Props Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == backgroundobjects Title == Each layer contains six properties. Four are defined by the Layer service; use lodoc layer service drawing to see its documentation. The most useful property is probably \"IsVisible\" which toggles the layer's visibility. 3. Styles \u00b6 Draw and Impress utilize the same style organization as text documents, which was explained in Chapter 6. Figure 1 shows its structure. Figure 1. Draw/Impress Style Families and their Property Sets. The style family names are different from those in text documents. The \"Default\" style family corresponds to the styles defined in a document's default master page. Figure 2 shows this master page in Impress. Figure 2. The Default Master Page in Impress. The master page (also known as a template in Impress' GUI) contains style information related to the title, seven outline levels and background areas (e.g. the date, the footer, and the slide number in Figure 2). Not all the master page styles are shown in Figure 2; for instance, there's a subtitle style, notes area, and a header. If a slide deck is formatted using a master page (Impress template) other than \"Default\", such as \"Inspiration\", then the style family name will be changed accordingly. The \"Inspiration\" family contains the same properties (styles) as \"Default\", but with different values. Details on coding with master pages and Impress templates are given in the MastersUse.java and PointsBuilder.java examples in Chapter 17. The other Draw/Impress style families are \"cell\", \"graphics\" and \"table\". \"table\" and \"cell\" contain styles which affect the colors used to draw a table and its cells. \"graphics\" affects the appearance of shapes. Examples of how to use the \"graphics\" style family are given in the DrawPictures.java example in Chapter 14. The reportStyles() method inside SlidesInfo.java is: private static void reportStyles ( XComponent doc ) // report style information: families, styles, properties { String [] styleNames = Info . getStyleFamilyNames ( doc ); System . out . println ( \"Style Families in this document:\" ); Lo . printNames ( styleNames ); for ( String styleName : styleNames ) { String [] conNames = Info . getStyleNames ( doc , styleName ); System . out . println ( \"Styles in the \\\"\" + styleName + \"\\\" style family:\" ); Lo . printNames ( conNames ); } /* XPropertySet props = Info.getStyleProps(doc, \"Default\", \"outline1\"); XPropertySet props = Info.getStyleProps(doc, \"graphics\", \"objectwitharrow\"); // accessing a style causes Office to crash upon exiting Props.showProps(\"Object Arrow Properties\", props); // long */ } // end of reportStyles() The method prints the names of the style families, and the names of the styles (property sets) inside each family. Typical output is: Style Families in this document: \"Inspiration\" \"cell\" \"graphics\" \"table\" Styles in the \"Inspiration\" style family: \"background\" \"backgroundobjects\" \"notes\" \"outline1\" \"outline2\" \"outline3\" \"outline4\" \"outline5\" \"outline6\" \"outline7\" \"outline8\" \"outline9\" \"subtitle\" \"title\" Styles in the \"cell\" style family: \"blue1\" \"blue2\" \"blue3\" \"bw1\" \"bw2\" \"bw3\" \"default\" \"earth1\" \"earth2\" \"earth3\" \"gray1\" \"gray2\" \"gray3\" \"green1\" \"green2\" \"green3\" \"lightblue1\" \"lightblue2\" \"lightblue3\" \"orange1\" \"orange2\" \"orange3\" \"seetang1\" \"seetang2\" \"seetang3\" \"sun1\" \"sun2\" \"sun3\" \"turquoise1\" \"turquoise2\" \"turquoise3\" \"yellow1\" \"yellow2\" \"yellow3\" Styles in the \"graphics\" style family: \"Object with no fill and no line\" \"headline\" \"headline1\" \"headline2\" \"measure\" \"objectwitharrow\" \"objectwithoutfill\" \"objectwithshadow\" \"standard\" \"text\" \"textbody\" \"textbodyindent\" \"textbodyjustfied\" \"title\" \"title1\" \"title2\" Styles in the \"table\" style family: \"blue\" \"bw\" \"default\" \"earth\" \"green\" \"lightblue\" \"orange\" \"seetang\" \"sun\" \"turquoise\" \"yellow\" The final part of reportStyles() prints the properties for a specified style. The code is commented out for two reasons \u2013 first, the output can be extremely long, but the main reason is that Office has a problem accessing drawing styles. Although Info.getStyleProps() works, allowing style properties to be accessed and changed, Office crashes when the program exits. It's fairly benign since the Office process is fully terminated, but an error message appears on-screen.","title":"Chapter 12. Examining a Draw/Impress Document"},{"location":"12-Examining_DrawImpress.html#chapter-12-examining-a-drawimpress-document","text":"Topics Examining Slides/Pages; Page Layers; Styles Example folders: \"Draw Tests\" and \"Utils\" This chapter describes the SlidesInfo.java example, which shows the basics of how to open and display a Draw or Impress file. The code also illustrates how the slides or pages can be examined, including how to retrieve information on their layers and styles. The SlidesInfo.java main() function: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: SlidesInfo <filename>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open the file: \" + args [ 0 ] ); Lo . closeOffice (); return ; } if ( ! Draw . isShapesBased ( doc )) { System . out . println ( \"-- not a drawing or slides presentation\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 1000 ); // need delay or zoom may not work GUI . zoom ( doc , GUI . ENTIRE_PAGE ); // or GUI.OPTIMAL, GUI.PAGE_WIDTH, GUI.ENTIRE_PAGE // GUI.zoomValue(doc, 60); // percentage size System . out . println ( \"\\nNo of slides: \" + Draw . getSlidesCount ( doc ) + \"\\n\" ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); // access first page Size sz = Draw . getSlideSize ( currSlide ); System . out . println ( \"Size of slide (mm): (\" + sz . Width + \", \" + sz . Height + \")\\n\" ); reportLayers ( doc ); reportStyles ( doc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Lo.openDoc() is capable of opening any Office document, and importing documents in other formats, so it's worthwhile checking the resulting XComponent object before progressing. Draw.isShapesBased() returns true if the file holds a Draw or Impress document: // in the Draw class public static boolean isShapesBased ( XComponent doc ) { return Info . isDocType ( doc , Lo . DRAW_SERVICE ) || Info . isDocType ( doc , Lo . IMPRESS_SERVICE ); } The document is made visible on-screen by calling GUI.setVisible(), and the application view is resized so all the drawing (or slide) is visible inside the window. Draw.zoom() can be passed three different constants for showing the entire width of the page, the entire page, or an optimal view that zooms in so all the 'data' on the page is visible without the empty space around it. Alternatively, Draw.zoomValue() allows the user to supply a zooming percentage. These two methods are defined using Lo.dispatchCmd(), which was introduced at the end of Chapter 4: // in the Draw class public static void zoom ( XComponent doc , short view ) { if ( view == OPTIMAL ) Lo . dispatchCmd ( \"ZoomOptimal\" ); else if ( view == PAGE_WIDTH ) Lo . dispatchCmd ( \"ZoomPageWidth\" ); if ( view == ENTIRE_PAGE ) Lo . dispatchCmd ( \"ZoomPage\" ); else { System . out . println ( \"Did not recognize zoom view: \" + view + \"; using optimal\" ); Lo . dispatchCmd ( \"ZoomOptimal\" ); } Lo . delay ( 500 ); } // end of zoom() public static void zoomValue ( XComponent doc , int value ) // zoom to a specific value using a dispatch { String [] zoomLabels = { \"Zoom.Value\" , \"Zoom.ValueSet\" , \"Zoom.Type\" }; Object [] zoomVals = {( short ) value , 28703 , 0 }; Lo . dispatchCmd ( \"Zoom\" , Props . makeProps ( zoomLabels , zoomVals )); Lo . delay ( 500 ); } // end of zoomValue() I found the four dispatch commands (\"ZoomOptimal\", \"ZoomPageWidth\", \"ZoomPage\", and \"Zoom\") by browsing the \"Development/DispatchCommands\" documentation page at https://wiki.documentfoundation.org/Development/DispatchCommands/ . A great offline source is the UICommands.ods spreadsheet, put together by Ariel Constenla- Haile, which can be obtained from https://arielch.fedorapeople.org/devel/ooo/UICommands.ods . Draw.zoomValue() uses the \"Zoom\" dispatch which requires the setting of properties. Its \"Zoom.Type\" parameter can be assigned 0, 1, 2, or 3 which correspond to zooming in terms of percentages, an optimal view, entire page, or page width. Unfortunately, I was only able to get the 0 value to work, which is why the others are handled by Draw.zoom(). The call to Lo.delay() at the end of the zoom methods gives Office time to carry out the zooming before my code does anything else. The same trick is utilized in the main() function, after the call to GUI.setVisible().","title":"Chapter 12. Examining a Draw/Impress Document"},{"location":"12-Examining_DrawImpress.html#1-accessing-slidespages","text":"Most of my Draw class method names include the word 'slide' (e.g. Draw.getSlidesCount(), Draw.getSlide(), Draw.getSlideSize()). That's a bit misleading since most of them will work just as well with Draw or Impress documents. For example, Draw.getSlidesCount() will return 1 when applied to a newly created Draw document. Draw.getSlidesCount() calls Draw.getSlides() which returns an XDrawPages object; XDrawPages supports a getCount() method: // in the Draw class public static int getSlidesCount ( XComponent doc ) { XDrawPages slides = getSlides ( doc ); if ( slides == null ) return 0 ; return slides . getCount (); } // end of getSlidesCount() public static XDrawPages getSlides ( XComponent doc ) // return all the pages as an XDrawPages object { XDrawPagesSupplier supplier = Lo . qi ( XDrawPagesSupplier . class , doc ); if ( supplier == null ) return null ; return supplier . getDrawPages (); } // end of getSlides() getSlides() employs the XDrawPagesSupplier interface which is part of GenericDrawingDocument shown in Figure 2 of Chapter 11. Draw.getSlide() (note: no \"s\") also calls Draw.getSlides(), but treats the XDrawPages object as an indexed container of XDrawPage objects: // in the Draw class public static XDrawPage getSlide ( XComponent doc , int idx ) { return getSlide ( getSlides ( doc ), idx ); } public static XDrawPage getSlide ( XDrawPages slides , int idx ) { XDrawPage slide = null ; try { slide = Lo . qi ( XDrawPage . class , slides . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not get slide \" + idx ); } return slide ; } // end of getSlide() Draw.getSlideSize() returns a com.sun.star.awt.Size object created from looking up the \"Width\" and \"Height\" properties of the supplied slide/page: // in the Draw class public static Size getSlideSize ( XDrawPage xDrawPage ) // get size of the given page (in mm units) { try { XPropertySet props = Lo . qi ( XPropertySet . class , xDrawPage ); if ( props == null ) { System . out . println ( \"No slide properties found\" ); return null ; } int width = ( Integer ) props . getPropertyValue ( \"Width\" ); int height = ( Integer ) props . getPropertyValue ( \"Height\" ); return new Size ( width / 100 , height / 100 ); } catch ( Exception e ) { System . out . println ( \"Could not get page dimensions\" ); return null ; } } // end of getSlideSize() These Width\" and \"Height\" properties are stored in XDrawPage's GenericDrawPage service, shown in Figure 5 of Chapter 11. My Draw class specifies measurements in millimeters rather than Office's 1/100 mm units. For instance, Draw.getSlideSize() would return Office page dimensions of 28000 by 21000 as (280, 210).","title":"1.  Accessing Slides/Pages"},{"location":"12-Examining_DrawImpress.html#2-page-layers","text":"A Draw or Impress page consists of five layers called \"layout\", \"controls\", \"measurelines\", \"background\", and \"backgroundobjects\". The first three are described in the Draw user guide, but\"measurelines\" is called \"Dimension Lines\". Probably \"layout\" is the most important layer since that's where shapes are located. Form controls (e.g. buttons) are added to \"controls\", which is always the top-most layer. \"background\", and \"backgroundobjects\" refer to the master page graphic and any shapes on that page. Each layer can be made visible or invisible independent of the others. It's also possible to create new layers. reportLayers() in SlidesInfo.java prints each layer's properties: // in SlidesInfo.java private static void reportLayers ( XComponent doc ) { XLayerManager lm = Draw . getLayerManager ( doc ); for ( int i = 0 ; i < lm . getCount (); i ++ ) try { Props . showObjProps ( \" Layer \" + i , lm . getByIndex ( i )); } catch ( com . sun . star . uno . Exception e ) {} XLayer layer = Draw . getLayer ( doc , \"backgroundobjects\" ); Props . showObjProps ( \"Background Object Props\" , layer ); } // end of reportLayers() Draw.getLayerManager() obtains an XLayerManager instance which can be treated as an indexed container of XLayer objects. Draw.getLayer() converts the XLayerManager into a named container, so it can be searched by layer name. Typical output from reportLayers() is: Layer 0 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == layout Title == Layer 1 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == background Title == Layer 2 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == backgroundobjects Title == Layer 3 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == controls Title == Layer 4 Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == measurelines Title == Background Object Props Properties Description == IsLocked == false IsPrintable == true IsVisible == true Name == backgroundobjects Title == Each layer contains six properties. Four are defined by the Layer service; use lodoc layer service drawing to see its documentation. The most useful property is probably \"IsVisible\" which toggles the layer's visibility.","title":"2.  Page Layers"},{"location":"12-Examining_DrawImpress.html#3-styles","text":"Draw and Impress utilize the same style organization as text documents, which was explained in Chapter 6. Figure 1 shows its structure. Figure 1. Draw/Impress Style Families and their Property Sets. The style family names are different from those in text documents. The \"Default\" style family corresponds to the styles defined in a document's default master page. Figure 2 shows this master page in Impress. Figure 2. The Default Master Page in Impress. The master page (also known as a template in Impress' GUI) contains style information related to the title, seven outline levels and background areas (e.g. the date, the footer, and the slide number in Figure 2). Not all the master page styles are shown in Figure 2; for instance, there's a subtitle style, notes area, and a header. If a slide deck is formatted using a master page (Impress template) other than \"Default\", such as \"Inspiration\", then the style family name will be changed accordingly. The \"Inspiration\" family contains the same properties (styles) as \"Default\", but with different values. Details on coding with master pages and Impress templates are given in the MastersUse.java and PointsBuilder.java examples in Chapter 17. The other Draw/Impress style families are \"cell\", \"graphics\" and \"table\". \"table\" and \"cell\" contain styles which affect the colors used to draw a table and its cells. \"graphics\" affects the appearance of shapes. Examples of how to use the \"graphics\" style family are given in the DrawPictures.java example in Chapter 14. The reportStyles() method inside SlidesInfo.java is: private static void reportStyles ( XComponent doc ) // report style information: families, styles, properties { String [] styleNames = Info . getStyleFamilyNames ( doc ); System . out . println ( \"Style Families in this document:\" ); Lo . printNames ( styleNames ); for ( String styleName : styleNames ) { String [] conNames = Info . getStyleNames ( doc , styleName ); System . out . println ( \"Styles in the \\\"\" + styleName + \"\\\" style family:\" ); Lo . printNames ( conNames ); } /* XPropertySet props = Info.getStyleProps(doc, \"Default\", \"outline1\"); XPropertySet props = Info.getStyleProps(doc, \"graphics\", \"objectwitharrow\"); // accessing a style causes Office to crash upon exiting Props.showProps(\"Object Arrow Properties\", props); // long */ } // end of reportStyles() The method prints the names of the style families, and the names of the styles (property sets) inside each family. Typical output is: Style Families in this document: \"Inspiration\" \"cell\" \"graphics\" \"table\" Styles in the \"Inspiration\" style family: \"background\" \"backgroundobjects\" \"notes\" \"outline1\" \"outline2\" \"outline3\" \"outline4\" \"outline5\" \"outline6\" \"outline7\" \"outline8\" \"outline9\" \"subtitle\" \"title\" Styles in the \"cell\" style family: \"blue1\" \"blue2\" \"blue3\" \"bw1\" \"bw2\" \"bw3\" \"default\" \"earth1\" \"earth2\" \"earth3\" \"gray1\" \"gray2\" \"gray3\" \"green1\" \"green2\" \"green3\" \"lightblue1\" \"lightblue2\" \"lightblue3\" \"orange1\" \"orange2\" \"orange3\" \"seetang1\" \"seetang2\" \"seetang3\" \"sun1\" \"sun2\" \"sun3\" \"turquoise1\" \"turquoise2\" \"turquoise3\" \"yellow1\" \"yellow2\" \"yellow3\" Styles in the \"graphics\" style family: \"Object with no fill and no line\" \"headline\" \"headline1\" \"headline2\" \"measure\" \"objectwitharrow\" \"objectwithoutfill\" \"objectwithshadow\" \"standard\" \"text\" \"textbody\" \"textbodyindent\" \"textbodyjustfied\" \"title\" \"title1\" \"title2\" Styles in the \"table\" style family: \"blue\" \"bw\" \"default\" \"earth\" \"green\" \"lightblue\" \"orange\" \"seetang\" \"sun\" \"turquoise\" \"yellow\" The final part of reportStyles() prints the properties for a specified style. The code is commented out for two reasons \u2013 first, the output can be extremely long, but the main reason is that Office has a problem accessing drawing styles. Although Info.getStyleProps() works, allowing style properties to be accessed and changed, Office crashes when the program exits. It's fairly benign since the Office process is fully terminated, but an error message appears on-screen.","title":"3.  Styles"},{"location":"13-Basic_Shapes.html","text":"Chapter 13. Drawing Basic Shapes \u00b6 Topics A Black Dashed Line; A Red Ellipse; Filled Rectangles; Text; Shape Names; A Transparent Circle and a Polar Line; A Math Formula as an OLE Shape; Polygons; Multiple Lines, Partial Elipses Example folders: \"Draw Tests\" and \"Utils\" This chapter contains an assortment of basic shape creation examples, including the following: simple shapes: line, ellipse, rectangle, text; shape fills: solid, gradients, hatching, bitmaps; an OLE shape (a math formulae); polygons, multiple lines, partial ellipses. The examples come from two files, DrawPicture.java and AnimBicycle.java. The main() function of DrawPicture.java: public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createDrawDoc ( loader ); if ( doc == null ) { System . out . println ( \"Draw doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 1000 ); // need delay or zoom may not work GUI . zoom ( doc , GUI . ENTIRE_PAGE ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); //access first page drawShapes ( currSlide ); Draw . drawFormula ( currSlide , \"func e^{i %pi} + 1 = 0\" , 23 , 20 , 20 , 40 ); // animShapes(currSlide); // explained in Chapter 9 XShape s = Draw . findShapeByName ( currSlide , \"text1\" ); Draw . reportPosSize ( s ); Lo . saveDoc ( doc , \"picture.odg\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() DrawPicture.java creates a new Draw document, and finishes by saving it to the file \"picture.odg\": XComponent doc = Draw . createDrawDoc ( loader ); : // add shapes to the document : Lo . saveDoc ( doc , \"picture.odg\" ); // \"odg\" is Draw's extension Aside from saving Office formats, Lo.saveDoc() recognizes other graphical forms based on the filename extension (e.g. a document saved to \"picture.png\" will create a PNG file). Draw.createDrawDoc() is a wrapper around Lo.createDoc() to create a Draw document: public static XComponent createDrawDoc ( XComponentLoader loader ) { return Lo . createDoc ( \"sdraw\" , loader ); } There's also Draw.createImpressDoc(): public static XComponent createImpressDoc ( XComponentLoader loader ) { return Lo . createDoc ( \"simpress\" , loader ); } 1. Drawing Shapes \u00b6 The drawShapes() method inside DrawPictures.java draws the six shapes shown in Figure 1. Figure 1. The Six Shapes Drawn by drawShapes(). Almost every Draw method call Draw.makeShape() which creates a shape instance and sets its size and position on the page: // in the Draw class public static XShape makeShape ( String shapeType , int x , int y , int width , int height ) { XShape shape = null ; try { shape = Lo . createInstanceMSF ( XShape . class , \"com.sun.star.drawing.\" + shapeType ); shape . setPosition ( new Point ( x * 100 , y * 100 ) ); shape . setSize ( new Size ( width * 100 , height * 100 ) ); } catch ( Exception e ) { System . out . println ( \"Unable to create shape: \" + shapeType ); } return shape ; } // end of makeShape() The method assumes that the shape is defined inside the com.sun.star.drawing package, i.e. that it's a shape which subclasses com.sun.star.drawing.Shape, like those in Figure 6 of Chapter 11. The code converts the supplied (x, y) coordinate, width, and height from millimeters to Office's 1/100 mm values. The exact meaning of the position and the size of a shape is a little tricky. If its width and height are positive, then the position is the top-left corner of the rectangle defined by those dimensions. However, the user can supply negative dimensions, which means that \"top-left corner\" may be on the right or bottom of the rectangle (see Figure 2(a)). Office handles this by storing the rectangle with a new top-left point, so all the dimensions can be positive (see Figure 2(b)). Figure 2. How Office Stores a Shape with a Negative Height. This means that your code should not assume that the position and size of a shape remain unchanged after being set with XShape.setPosition() and XShape.setSize(). makeShape() is called by Draw.addShape() which adds the generated shape to the page. It also check if the (x, y) coordinate is located on the page. If it isn't, warnPosition() prints a warning message. // in the Draw class public static XShape addShape ( XDrawPage slide , String shapeType , int x , int y , int width , int height ) { warnsPosition ( slide , x , y ); XShape shape = makeShape ( shapeType , x , y , width , height ); if ( shape != null ) slide . add ( shape ); return shape ; } // end of addShape() drawShapes() in the DrawPicture.java example is shown below. It creates the six shapes shown in Figure 1. // in DrawPicture.java private static void drawShapes ( XDrawPage currSlide ) { // black dashed line; uses (x1, y1) (x2, y2) XShape line1 = Draw . drawLine ( currSlide , 50 , 50 , 200 , 200 ); Props . setProperty ( line1 , \"LineColor\" , 0x000000 ); // black Draw . setDashedLine ( line1 , true ); // Lo.delay(2000); // to reduce the speed of the change // Draw.setDashedLine(line1, false); // red ellipse; uses (x, y) width, height XShape circle1 = Draw . drawEllipse ( currSlide , 100 , 100 , 75 , 25 ); Props . setProperty ( circle1 , \"FillColor\" , 0xFF0000 ); // rectangle with different fills; uses (x, y) width, height XShape rect1 = Draw . drawRectangle ( currSlide , 70 , 70 , 25 , 50 ); // Props.setProperty(rect1, \"FillColor\", 0x00FF00); // green // Draw.setGradientColor(rect1, \"Gradient 4\"); // \"Radial red/yellow\"); // Draw.setGradientColor(rect1, java.awt.Color.GREEN, java . awt . Color . RED ); // Draw.setHatchingColor(rect1, \"Red crossed 45 degrees\"); // Draw.setBitmapColor(rect1, \"Roses\"); Draw . setBitmapFileColor ( rect1 , \"crazy_blue.jpg\" ); // text defined using (x, y), width, height [size] XShape text1 = Draw . drawText ( currSlide , \"Hello LibreOffice\" , 120 , 120 , 60 , 30 , 24 ); Props . setProperty ( text1 , \"Name\" , \"text1\" ); Props . showProps ( \"TextShape's Text Properties\" , Draw . getTextProperties ( text1 )); // gray transparent circle; uses (x,y), radius XShape circle2 = Draw . drawCircle ( currSlide , 40 , 150 , 20 ); Props . setProperty ( circle2 , \"FillColor\" , Lo . getColorInt ( java . awt . Color . GRAY )); Draw . setTransparency ( circle2 , 25 ); // thick line; uses (x,y), angle clockwise from x-axis, length XShape line2 = Draw . drawPolarLine ( currSlide , 60 , 200 , 45 , 100 ); Props . setProperty ( line2 , \"LineWidth\" , 300 ); // 3mm } // end of drawShapes() There's a number of variations possible for each shape, represented by commented out code. The following sections look at how the six shapes are drawn. 2. A Black Dashed Line \u00b6 Draw.drawLine() calls Draw.addShape() to create a com.sun.star.drawing.LineShape instance. In common with other shapes, a line is defined in terms of its enclosing rectangle, represented by its top-left corner, width, and height. Draw.drawLine() allows the programmer to define the line using its endpoints: // in the Draw class public static XShape drawLine ( XDrawPage slide , int x1 , int y1 , int x2 , int y2 ) { // make sure size is non-zero if (( x1 == x2 ) && ( y1 == y2 )) { System . out . println ( \"Line is a point\" ); return null ; } int width = x2 - x1 ; // may be negative int height = y2 - y1 ; // may be negative return addShape ( slide , \"LineShape\" , x1 , y1 , width , height ); } // end of drawLine() As mentioned above, Office will store a shape with a modified position and size if one or both of its dimensions is negative. As an example, consider if Draw.drawLine() is called with the coordinates (10,20) and (20,10). The call to addShape() would be passed a positive width (10mm) and a negative height (-10mm). This would be drawn as in Figure 3(a) but would be stored using the shape position and size in Figure 3\u00a9. Figure 3. How a Line with a Negative Height is Stored as a Shape. This kind of transformation may be important if your code modifies a shape after it has been added to the slide, as my animation examples do in the next chapter. Back in DrawPicture.java's drawShapes(), the line's properties are adjusted. The hardest part of this is finding the property's name in the API documentation, because properties are typically defined across multiple services, including LineShape, Shape, FillProperties, ShadowProperties, LineProperties, and RotationDescriptor. If the property is related to the shape's text then you should check TextProperties, CharacterProperties, and ParagraphProperties as well. Figure 7 of Chapter 11 shows the situation for RectangleShape, and its much the same for other shapes. You should start looking in the documentation for the shape (i.e. use lodoc LineShape drawing ), and move up the hierarchy. You can click on the inheritance diagram at the top of the page (e.g. like the one in Figure 4) to look in the different services. Figure 4. The LineShape Inheritance Diagram in the LibreOffice Online Documentation. drawShapes() will color the line black and make it dashed, which suggests that I should examine the LineProperties class. Its relevant properties are \"LineColor\" for color and \"LineStyle\" and \"LineDash\" for creating dashes, as in Figure 5. Figure 5. Relevant Properties in the LineProperties Class. Line color can be set with a single call to Props.setProperty(), but line dashing is a little more complicated, so is handled by Draw.setDashedLine(): // in drawShapes() in DrawPicture.java Props . setProperty ( line1 , \"LineColor\" , 0x000000 ); // black Draw . setDashedLine ( line1 , true ); The color parameter for \"LineColor\" is an RGB hexadecimal. There are other ways of defining color, which I'll explain in a moment. Draw.setDashedLine() has to assign a LineStyle object to \"LineStyle\" and a LineDash object to \"LineDash\". The line style is easily set since LineStyle is an enumeration with three possible values. A LineDash object requires more work: // in the Draw class public static void setDashedLine ( XShape shape , boolean isDashed ) { // create a LineDash object LineDash ld = new LineDash (); ld . Dots = 0 ; ld . DotLen = 100 ; // dashes only; no dots ld . Dashes = 5 ; ld . DashLen = 200 ; ld . Distance = 200 ; // set the properties for the line XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { if ( isDashed ) { // draw a dashed line props . setPropertyValue ( \"LineStyle\" , LineStyle . DASH ); props . setPropertyValue ( \"LineDash\" , ld ); } else // draw a solid line props . setPropertyValue ( \"LineStyle\" , LineStyle . SOLID ); } catch ( Exception e ) { System . out . println ( \"Could not set dashed line property\" ); } } // end of setDashedLine() setDashedLine() can be used to toggle a line's dashes on or off. 3. A Red Ellipse \u00b6 A red ellipse is drawn using: // in drawShapes() in DrawPicture.java XShape circle1 = Draw . drawEllipse ( currSlide , 100 , 100 , 75 , 25 ); Props . setProperty ( circle1 , \"FillColor\" , 0xFF0000 ); Draw.drawEllipse() is similar to drawLine() except that an EllipseShape is created by Draw.addShape(): // in the Draw class public static XShape drawEllipse ( XDrawPage slide , int x , int y , int width , int height ) { return addShape ( slide , \"EllipseShape\" , x , y , width , height ); } I want to fill the circle with a solid color, which suggests the setting of a property in FillProperties. A visit to the online documentation for EllipseShape reveals an inheritance diagram like the one in Figure 6. Figure 6. The EllipseShape Inheritance Diagram in the LibreOffice Online Documentation. Clicking on the FillProperties rectangle jumps to its documentation, which lists a \"FillColor\" property (see Figure 7). Figure 7. Relevant Properties in the FillProperties Class. Both the \"FillColor\" and \"FillStyle\" properties should be set, but the default value for \"FillStyle\" is already FillStyle.SOLID, which is what's needed. 4. A Rectangle with a Variety of Fills \u00b6 The rectangle example in drawShapes() comes in six different colors: // in drawShapes() in DrawPicture.java // rectangle with different fills XShape rect1 = Draw . drawRectangle ( currSlide , 70 , 70 , 25 , 50 ); // Props.setProperty(rect1, \"FillColor\", 0x00FF00); // green // Draw.setGradientColor(rect1, \"Gradient 4\"); // \"Radial red/yellow\"); // Draw.setGradientColor(rect1, java.awt.Color.GREEN, java . awt . Color . RED ); // Draw.setHatchingColor(rect1, \"Red crossed 45 degrees\"); // Draw.setBitmapColor(rect1, \"Roses\"); Draw . setBitmapFileColor ( rect1 , \"crazy_blue.jpg\" ); They're shown in Figure 8. Figure 8. Six Ways of Filling a Rectangle. 4.1. Gradient Color \u00b6 The second example in Figure 8 (\"gradient color\") is implemented using Draw.setGradientColor(): // in the Draw class public static void setGradientColor ( XShape shape , String name ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . GRADIENT ); props . setPropertyValue ( \"FillGradientName\" , name ); } catch ( com . sun . star . lang . IllegalArgumentException e ) { System . out . println ( \"\\\"\" + name + \"\\\" is not a recognized gradient color name\" ); } catch ( Exception e ) { System . out . println ( \"Could not set to \\\"\" + name + \"\\\"\" ); } } // end of setGradientColor() The hardest part of using this function is determining what name value to pass to the \"FillGradientName\" property (e.g. \"Gradient 4\" in the call in drawShapes()). The easiest solution is to fire up Office's Draw application, and check out the gradient names listed in the \"Line and Filling\" toolbar. Figure 9 shows what happens when the user selects a shape and chooses the \"Gradient\" menu item from the combo box. Figure 9. The Gradient Names in LibreOffice. If you supply a name which is not in Figure 9's list, then \"Linear blue/white\" is used instead. 4.2. Gradient AWT Color \u00b6 The third example in Figure 8 shows what happens when you define your own gradient and angle of change. In drawShapes(), the call is: Draw . setGradientColor ( rect1 , java . awt . Color . GREEN , java . awt . Color . RED ); This creates a gradient change from green to red downwards through the shape. Draw.setGradientColor() calls a four argument version of itself which specifies the gradient angle: // in the Draw class public static void setGradientColor ( XShape shape , java . awt . Color startColor , java . awt . Color endColor ) { setGradientColor ( shape , startColor , endColor , 0 ); } public static void setGradientColor ( XShape shape , java . awt . Color startColor , java . awt . Color endColor , int angle ) /* if angle == 90 then the gradient changes from the left to the right side of the shape */ { // create Gradient object Gradient grad = new Gradient (); grad . Style = GradientStyle . LINEAR ; grad . StartColor = Lo . getColorInt ( startColor ); grad . EndColor = Lo . getColorInt ( endColor ); grad . Angle = ( short )( angle * 10 ); // in 1/10 degree units grad . Border = 0 ; grad . XOffset = 0 ; grad . YOffset = 0 ; grad . StartIntensity = 100 ; grad . EndIntensity = 100 ; grad . StepCount = 10 ; XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . GRADIENT ); props . setPropertyValue ( \"FillGradient\" , grad ); } catch ( Exception e ) { System . out . println ( \"Could not set gradient colors\" ); } } // end of setGradientColor() setGradientColor() sets the properties \"FillStyle\" and \"FillGradient\". The latter requires a Gradient object, which is documented in the FillProperties class, as shown in Figure 10. Figure 10. The \"FillGradient\" Property in the FillProperties Class. The online documentation for FillProperties can be reached using lodoc FillProperties service reference. Clicking on the \"com::sun: :awt::Gradient\" name in Figure 10 loads its documentation, which lists ten fields that need to be set. The colors passed to Draw.setGradientColor() are the Java AWT constants for red and green (java.awt.Color.RED and java.awt.Color.GREEN), but any Color objects could be used. They're converted to hexadecimals by Lo.getColorInt(): public static int getColorInt ( java . awt . Color color ) // return the color as an integer, ignoring the alpha channel { if ( color == null ) { System . out . println ( \"No color supplied\" ); return 0 ; } else return ( color . getRGB () & 0xffffff ); } // end of getColorInt() 4.3. Hatching \u00b6 The fourth fill in Figure 8 employs hatching. In drawShapes(), the call is: Draw . setHatchingColor ( rect1 , \"Red crossed 45 degrees\" ); Draw.setHatchingColor() is: public static void setHatchingColor ( XShape shape , String name ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . HATCH ); props . setPropertyValue ( \"FillHatchName\" , name ); } catch ( com . sun . star . lang . IllegalArgumentException e ) { System . out . println ( \"\\\"\" + name + \"\\\" not a hatching name\" ); } catch ( Exception e ) { System . out . println ( \"Could not set color \\\"\" + name + \"\\\"\" ); } } // end of setHatchingColor() This function is much the same as setGradientColor() except that it utilizes \"FillHatchName\" rather than \"FillGradientName\", and the fill style is set to FillStyle.HATCH. Suitable hatching names can be found by looking at the relevant list in Draw's \"Line and Filling\" toolbar. Figure 11 shows the \"Hatching\" menu item. Figure 11. The Hatching Names in LibreOffice. 4.4. Bitmap Color \u00b6 The fifth rectangle fill in Figure 8 utilizes a bitmap color: Draw . setBitmapColor ( rect1 , \"Roses\" ); The function is: public static void setBitmapColor ( XShape shape , String name ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . BITMAP ); props . setPropertyValue ( \"FillBitmapName\" , name ); } catch ( com . sun . star . lang . IllegalArgumentException e ) { System . out . println ( \"\\\"\" + name + \"\\\" is not a bitmap\" ); } catch ( Exception e ) { System . out . println ( \"Could not set to \\\"\" + name + \"\\\"\" ); } } // end of setBitmapColor() This is also similar to setGradientColor() and setHatchingColor() but uses a different \"FillStyle\" value, and assigns a name to \"FillBitmapName\". As you might have guessed by now, the best source for these names is the \"Line and Filling\" toolbar shown in Figure 12. Figure 12. The Bitmap Names in LibreOffice. 4.5. Bitmap File Color \u00b6 The final fill in Figure 8 loads a bitmap from \"crazy_blue.jpg\": Draw.setBitmapFileColor(rect1, \"crazy_blue.jpg\"); setBitmapFileColor() is: public static void setBitmapFileColor ( XShape shape , String fnm ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . BITMAP ); props . setPropertyValue ( \"FillBitmapURL\" , FileIO . fnmToURL ( fnm )); } catch ( Exception e ) { System . out . println ( \"Could not set color \\\"\" + fnm + \"\\\"\" ); } } // end of setBitmapFileColor() The \"FillBitmapURL\" property requires a URL, so the filename is converted by FileIO.fnmToURL(). 5. Text \u00b6 The \"Hello LibreOffice\" text shape in Figure 1 is created by calling Draw.drawText(): XShape text1 = Draw . drawText ( currSlide , \"Hello LibreOffice\" , 120 , 120 , 60 , 30 , 24 ); The first four numerical parameters define the shape's bounding rectangle in terms of its top-left coordinate, width, and height. The fifth, optional number specifies a font size (in this case, 24pt). drawText() calls addShape() with \"TextShape\": // in the Draw class public static XShape drawText ( XDrawPage slide , String msg , int x , int y , int width , int height , int fontSize ) { XShape shape = addShape ( slide , \"TextShape\" , x , y , width , height ); addText ( shape , msg , fontSize ); return shape ; } // end of drawText() addText() adds the message to the shape, and sets its font size: public static void addText ( XShape shape , String msg , int fontSize ) { XText xText = Lo . qi ( XText . class , shape ); XTextCursor cursor = xText . createTextCursor (); cursor . gotoEnd ( false ); if ( fontSize > 0 ) Props . setProperty ( cursor , \"CharHeight\" , fontSize ); XTextRange range = Lo . qi ( XTextRange . class , cursor ); range . setString ( msg ); } // end of addText() The shape is converted into an XText reference, and the text range selected with a cursor. The \"CharHeight\" property comes from the CharacterProperties service, which is inherited by the Text service (as shown in Figure 7 of Chapter 11). Some Help with Text Properties \u00b6 The text-related properties for a shape can be accessed with Draw.getTextProperties(): public static XPropertySet getTextProperties ( XShape xShape ) { XText xText = Lo . qi ( XText . class , xShape ); XTextCursor cursor = xText . createTextCursor (); cursor . gotoStart ( false ); cursor . gotoEnd ( true ); XTextRange xTextRange = Lo . qi ( XTextRange . class , cursor ); return Lo . qi ( XPropertySet . class , xTextRange ); } // end of getTextProperties() drawShapes() in DrawPicture.java calls Draw.getTextProperties() on the text1 TextShape, and prints all its properties: // in drawShapes() in DrawPicture.java Props . showProps ( \"TextShape's Text Properties\" , Draw . getTextProperties ( text1 )); The output is long, but includes the line: CharHeight == 24.0 which indicates that the font size was correctly changed by the earlier call to Draw.drawText(). 6. Using a Shape Name \u00b6 Immediately after the call to Draw.drawText(), the shape's name is set: // in drawShapes() in DrawPicture.java Props . setProperty ( text1 , \"Name\" , \"text1\" ); The \"Name\" property, which is defined in the Shape class, is a useful way of referring to a shape. The main() function of DrawPicture.java passes a name to Draw.findShapeByName(): // in main() in DrawPicture.java XShape s = Draw . findShapeByName ( currSlide , \"text1\" ); Draw . reportPosSize ( s ); Draw . findShapeByName () iterates through a list of shapes extracted from the slide , and returns the shape with the supplied name : // in the Draw class public static XShape findShapeByName ( XDrawPage slide , String shapeName ) { ArrayList < XShape > shapes = getShapes ( slide ); if ( shapes == null ) { System . out . println ( \"No shapes were found in the draw page\" ); return null ; } for ( XShape shape : shapes ) { String nm = ( String ) Props . getProperty ( shape , \"Name\" ); if ( shapeName . equals ( nm )) return shape ; } System . out . println ( \"No shape named \\\"\" + shapeName + \"\\\"\" ); return null ; } // end of findShapeByName() Draw.getShapes() builds a list of shapes by iterating through the XDrawPage object as an indexed container of shapes: // in the Draw class public static ArrayList < XShape > getShapes ( XDrawPage slide ) { if ( slide == null ) { System . out . println ( \"Slide is null\" ); return null ; } if ( slide . getCount () == 0 ) { System . out . println ( \"Slide does not contain any shapes\" ); return null ; } ArrayList < XShape > xShapesList = new ArrayList < XShape > (); try { for ( int j = 0 ; j < slide . getCount (); j ++ ) xShapesList . add ( Lo . qi ( XShape . class , slide . getByIndex ( j ))); } catch ( Exception e ) { System . out . println ( \"Shapes extraction error in slide\" ); } return xShapesList ; } // end of getShapes() Draw.reportPosSize() prints some brief information about a shape, including its name, shape type, position, and size: // in the Draw class public static void reportPosSize ( XShape shape ) { if ( shape == null ) { System . out . println ( \"The shape is null\" ); return ; } System . out . println ( \"Shape name: \" + Props . getProperty ( shape , \"Name\" )); System . out . println ( \" Type: \" + shape . getShapeType ()); Point pt = shape . getPosition (); Size sz = shape . getSize (); System . out . println ( \" Position/size: (\" + pt . X / 100 + \", \" + pt . Y / 100 + \") / (\" + sz . Width / 100 + \", \" + sz . Height / 100 + \")\" ); } // end of reportPosSize() XShape.getShapeType() returns the class name of the shape as a string (in this case, \"com.sun.star.drawing.TextShape\"). 7. A Transparent Circle and a Polar Line \u00b6 The last two shapes created by DrawPicture.java's drawShapes() are a gray transparent circle and a polar line. // in drawShapes() in DrawPicture.java // gray transparent circle; uses (x,y), radius XShape circle2 = Draw . drawCircle ( currSlide , 40 , 150 , 20 ); Props . setProperty ( circle2 , \"FillColor\" , Lo . getColorInt ( java . awt . Color . GRAY )); Draw . setTransparency ( circle2 , 25 ); // thick line; uses (x,y), angle clockwise from x-axis, length XShape line2 = Draw . drawPolarLine ( currSlide , 60 , 200 , 45 , 100 ); Props . setProperty ( line2 , \"LineWidth\" , 300 ); // 3mm A polar line is one defined using polar coordinates, which specifies the coordinate of one end of the line, and the angle and length of the line from that point. Draw.drawCircle() uses an EllipseShape, and Draw.drawPolarLine() converts the polar values into two coordinates so Draw.drawLine() can be called. 8. A Math formula as an OLE Shape \u00b6 Draw/Impress documents can include OLE objects through OLE2Shape, which allows a shape to link to an external document. Probably the most popular kind of OLE shape is the chart, but I'll delay a detailed discussion of that topic until Part 5, although there is a code snippet below. The best way of finding out what OLE objects are available is to go to Draw's (or Impress') Insert menu, Object, \"OLE Object\" dialog. It lists Office spreadsheet, chart, drawing, presentation, and formula documents, and a range of Microsoft and PDF types (when you click on \"Further objects\"). The DrawPicture.java OLE example displays a mathematical formula, as in Figure 13. Figure 13. A Math Formula in a Draw Document. DrawPicture.java renders the formula by calling Draw.addFormula(), which hides the tricky aspects of instatiating the OLE shape: // in main() in DrawPicture.java Draw . drawFormula ( currSlide , \"func e^{i %pi} + 1 = 0\" , 23 , 20 , 20 , 40 ); The second argument is a formula string, written using Office's Math notation. For an overview, see the \"Commands Reference\" appendix of the \"Math Guide\", available from https://libreoffice.org/get-help/documentation/ . Draw.drawFormula() is coded as: public static XShape drawFormula ( XDrawPage slide , String formula , int x , int y , int width , int height ) { XShape shape = addShape ( slide , \"OLE2Shape\" , x , y , width , height ); Props . setProperty ( shape , \"CLSID\" , Lo . MATH_CLSID ); // a formula XModel model = Lo . qi ( XModel . class , Props . getProperty ( shape , \"Model\" ) ); Props . setProperty ( model , \"Formula\" , formula ); // from FormulaProperties return shape ; } // end of drawFormula() OLE2Shape uses a \"CLSID\" property to hold the class ID of the OLE object. Setting this property affects the shape's model (data format), which is stored in the \"Model\" property. drawFormula() casts this property to XModel and, since the model represents formula data, it has a \"Formula\" property where the formula string is stored. Creating Other Kinds of OLE Shape \u00b6 The use of a \"Formula\" property in Draw.drawFormula() only works for an OLE shape representing a formula. How are other kinds of data stored? The first step is to set the OLE shape's class ID to the correct value, which will affect its \"Model\" property. A short list of class ID constants are included at the start of the Lo utility class, along with a few commented out IDs which I haven\u2019t tested. Creating an OLE2Shape for a chart begins like so : XShape shape = addShape ( slide , \"OLE2Shape\" , x , y , width , height ); Props . setProperty ( shape , \"CLSID\" , Lo . CHART_CLSID ); // a chart XModel model = Lo . qi ( XModel . class , Props . getProperty ( shape , \"Model\" ) ); Online information on how to use XModel to store a chart, a graphic, or something else, is pretty sparse. I've found the best start is to list the services that support the XModel reference. This is done by calling Info.showServices(): Info . showServices ( \"OLE2Shape Model\" , model ); For the version of model in drawFormula(), it reports: OLE2Shape Model Supported Services (2) \"com.sun.star.document.OfficeDocument\" \"com.sun.star.formula.FormulaProperties\" This gives a strong hint to look inside the FormulaProperties service, to find a property for storing the formula string. A look at the documentation ( lodoc FormulaProperties service ) reveals a \"Formula\" property, which I used in drawFormula(). When the model refers to chart data, the same call to Info.showServices() prints: OLE2Shape Model Supported Services (3) \"com.sun.star.chart.ChartDocument\" \"com.sun.star.chart2.ChartDocument\" \"com.sun.star.document.OfficeDocument\" The com.sun.star.chart2 package is the newer way of manipulating charts, which suggests that the XModel interfaces should be converted to an interface of com.sun.star.chart2.ChartDocument. The most useful is XChartDocument, which is obtained via: XChartDocument chartDoc = Lo.qi(XChartDocument.class, model); XChartDocument supports a rich set of chart manipulation methods. I'll return to charts in Part 5. 9. Polygons \u00b6 The main() function of AnimBicycle.java calls Draw.drawPolygon() twice to create regular polygons for a square and pentagon: // in AnimBicycle.java XShape square = Draw.drawPolygon(currSlide, 125, 125, 25, 4); // (x,y), radius, no. of sides Props.setProperty(square, \"FillColor\", 0x3fe694); // pale green XShape pentagon = Draw.drawPolygon(currSlide, 150, 75, 5); // (x,y), no. of sides // radius uses a default value Props.setProperty(pentagon, \"FillColor\", 0xe7b9c7); // purple The polygons can be seen in Figure 14. Figure 14. Bicycle and Shapes. Draw.drawPolygon() is: // in the Draw class public static XShape drawPolygon(XDrawPage slide, int x, int y, int radius, int nSides) { XShape polygon = addShape(slide, \"PolyPolygonShape\", 0, 0, 0, 0); // for shapes formed by one or more polygons Point[] pts = genPolygonPoints(x, y, radius, nSides); Point[][] polys = new Point[][] {pts}; // an array of Point arrays, one Point array for each polygon Props.setProperty(polygon, \"PolyPolygon\", polys); return polygon; } // end of drawPolygon() drawPolygon() creates a \"PolyPolygonShape\" shape which is designed to store multiple polygons. This is why the polys data structure instantiated at the end of drawPolygon() is an array of points arrays, since the shape's \"PolyPolygon\" property can hold multiple point arrays. However, drawPolygon() only creates a single points array by calling genPolygonPoints(). A points array defining the four points of a square could be: Point[] pts = new Point[4]; pts[0] = new Point(4000, 1200); pts[1] = new Point(4000, 2000); pts[2] = new Point(5000, 2000); pts[3] = new Point(5000, 1200); Note that the coordinates of each point use Office's 1/100 mm units. genPolygonPoints() generates a points array for a regular polygon based on the coordinate of the center of the polygon, the distance from the center to each point (the shape's radius), and the required number of sides: private static Point [] genPolygonPoints ( int x , int y , int radius , int nSides ) { if ( nSides < 3 ) { System . out . println ( \"Too few sides; must be 3 or more\" ); nSides = 3 ; } else if ( nSides > 30 ) { System . out . println ( \"Too many sides; must be 30 or less\" ); nSides = 30 ; } Point [] pts = new Point [ nSides ] ; double angleStep = Math . PI / nSides ; for ( int i = 0 ; i < nSides ; i ++ ) { pts [ i ] = new Point ( ( int ) Math . round ( x * 100 + radius * 100 * Math . cos ( i * 2 * angleStep )), ( int ) Math . round ( y * 100 + radius * 100 * Math . sin ( i * 2 * angleStep )) ); } return pts ; } // end of genPolygonPoints() 10. Mult-line Shapes \u00b6 A PolyLineShape can hold multiple line paths, where a path is a sequence of connected lines. Draw.drawLines() only creates a single line path, based on being passed arrays of x- and y- axis coordinates. For example, the following code in AnimBicycle creates the crossed lines at the top-left of Figure 14: // in AnimBicycle.java int [] xs = { 10 , 30 , 10 , 30 }; int [] ys = { 10 , 100 , 100 , 10 }; Draw . drawLines ( currSlide , xs , ys ); Draw.drawLines() is: // in the Draw class public static XShape drawLines ( XDrawPage slide , int [] xs , int [] ys ) { if ( xs . length != ys . length ) { System . out . println ( \"The two arrays must be the same length\" ); return null ; } int numPoints = xs . length ; Point [] pts = new Point [ numPoints ] ; for ( int i = 0 ; i < numPoints ; i ++ ) pts [ i ] = new Point ( xs [ i ]* 100 , ys [ i ]* 100 ); //in 1/100 mm units Point [][] linePaths = new Point [][] { pts }; // an array of Point arrays, one Point array for each line path XShape polyLine = addShape ( slide , \"PolyLineShape\" , 0 , 0 , 0 , 0 ); // for a shape formed from multiple line paths Props . setProperty ( polyLine , \"PolyPolygon\" , linePaths ); return polyLine ; } // end of drawLines() drawLines() creates an array of Point arrays which is stored in the PolyLineShape property called \"PolyPolygon\". However, drawLines() only adds a single points array to the linePaths data structure since only one line path is being created. 11. Partial Ellipses \u00b6 EllipseShape contains a \"CircleKind\" property that determines whether the entire ellipse should be drawn, or only a portion of it. The properties \"CircleStartAngle\" and \"CircleEndAngle\" define the angles where the solid part of the ellipse starts and finishes. Zero degrees is the positive x-axis, and the angle increase in 1/100 degrees units counter-clockwise around the center of the ellipse. AnimBicycle.java contains the following example: // in AnimBicycle.java XShape pie = Draw . drawEllipse ( currSlide , 30 , slideSize . Width - 100 , 40 , 20 ); Props . setProperty ( pie , \"CircleStartAngle\" , 9000 ); // 90 degrees ccw Props . setProperty ( pie , \"CircleEndAngle\" , 36000 ); // 360 degrees ccw Props . setProperty ( pie , \"CircleKind\" , CircleKind . SECTION ); // CircleKind.CUT, CircleKind.ARC This creates the blue partial ellipse shown at the bottom left of Figure 14. Figure 15 shows the different results when \"CircleKind\" is set to CircleKind.SECTION, CircleKind.CUT, and CircleKind.ARC. Figure 15. Different Types of Partial Ellipse","title":"Chapter 13. Drawing Basic Shapes"},{"location":"13-Basic_Shapes.html#chapter-13-drawing-basic-shapes","text":"Topics A Black Dashed Line; A Red Ellipse; Filled Rectangles; Text; Shape Names; A Transparent Circle and a Polar Line; A Math Formula as an OLE Shape; Polygons; Multiple Lines, Partial Elipses Example folders: \"Draw Tests\" and \"Utils\" This chapter contains an assortment of basic shape creation examples, including the following: simple shapes: line, ellipse, rectangle, text; shape fills: solid, gradients, hatching, bitmaps; an OLE shape (a math formulae); polygons, multiple lines, partial ellipses. The examples come from two files, DrawPicture.java and AnimBicycle.java. The main() function of DrawPicture.java: public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createDrawDoc ( loader ); if ( doc == null ) { System . out . println ( \"Draw doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 1000 ); // need delay or zoom may not work GUI . zoom ( doc , GUI . ENTIRE_PAGE ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); //access first page drawShapes ( currSlide ); Draw . drawFormula ( currSlide , \"func e^{i %pi} + 1 = 0\" , 23 , 20 , 20 , 40 ); // animShapes(currSlide); // explained in Chapter 9 XShape s = Draw . findShapeByName ( currSlide , \"text1\" ); Draw . reportPosSize ( s ); Lo . saveDoc ( doc , \"picture.odg\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() DrawPicture.java creates a new Draw document, and finishes by saving it to the file \"picture.odg\": XComponent doc = Draw . createDrawDoc ( loader ); : // add shapes to the document : Lo . saveDoc ( doc , \"picture.odg\" ); // \"odg\" is Draw's extension Aside from saving Office formats, Lo.saveDoc() recognizes other graphical forms based on the filename extension (e.g. a document saved to \"picture.png\" will create a PNG file). Draw.createDrawDoc() is a wrapper around Lo.createDoc() to create a Draw document: public static XComponent createDrawDoc ( XComponentLoader loader ) { return Lo . createDoc ( \"sdraw\" , loader ); } There's also Draw.createImpressDoc(): public static XComponent createImpressDoc ( XComponentLoader loader ) { return Lo . createDoc ( \"simpress\" , loader ); }","title":"Chapter 13. Drawing Basic Shapes"},{"location":"13-Basic_Shapes.html#1-drawing-shapes","text":"The drawShapes() method inside DrawPictures.java draws the six shapes shown in Figure 1. Figure 1. The Six Shapes Drawn by drawShapes(). Almost every Draw method call Draw.makeShape() which creates a shape instance and sets its size and position on the page: // in the Draw class public static XShape makeShape ( String shapeType , int x , int y , int width , int height ) { XShape shape = null ; try { shape = Lo . createInstanceMSF ( XShape . class , \"com.sun.star.drawing.\" + shapeType ); shape . setPosition ( new Point ( x * 100 , y * 100 ) ); shape . setSize ( new Size ( width * 100 , height * 100 ) ); } catch ( Exception e ) { System . out . println ( \"Unable to create shape: \" + shapeType ); } return shape ; } // end of makeShape() The method assumes that the shape is defined inside the com.sun.star.drawing package, i.e. that it's a shape which subclasses com.sun.star.drawing.Shape, like those in Figure 6 of Chapter 11. The code converts the supplied (x, y) coordinate, width, and height from millimeters to Office's 1/100 mm values. The exact meaning of the position and the size of a shape is a little tricky. If its width and height are positive, then the position is the top-left corner of the rectangle defined by those dimensions. However, the user can supply negative dimensions, which means that \"top-left corner\" may be on the right or bottom of the rectangle (see Figure 2(a)). Office handles this by storing the rectangle with a new top-left point, so all the dimensions can be positive (see Figure 2(b)). Figure 2. How Office Stores a Shape with a Negative Height. This means that your code should not assume that the position and size of a shape remain unchanged after being set with XShape.setPosition() and XShape.setSize(). makeShape() is called by Draw.addShape() which adds the generated shape to the page. It also check if the (x, y) coordinate is located on the page. If it isn't, warnPosition() prints a warning message. // in the Draw class public static XShape addShape ( XDrawPage slide , String shapeType , int x , int y , int width , int height ) { warnsPosition ( slide , x , y ); XShape shape = makeShape ( shapeType , x , y , width , height ); if ( shape != null ) slide . add ( shape ); return shape ; } // end of addShape() drawShapes() in the DrawPicture.java example is shown below. It creates the six shapes shown in Figure 1. // in DrawPicture.java private static void drawShapes ( XDrawPage currSlide ) { // black dashed line; uses (x1, y1) (x2, y2) XShape line1 = Draw . drawLine ( currSlide , 50 , 50 , 200 , 200 ); Props . setProperty ( line1 , \"LineColor\" , 0x000000 ); // black Draw . setDashedLine ( line1 , true ); // Lo.delay(2000); // to reduce the speed of the change // Draw.setDashedLine(line1, false); // red ellipse; uses (x, y) width, height XShape circle1 = Draw . drawEllipse ( currSlide , 100 , 100 , 75 , 25 ); Props . setProperty ( circle1 , \"FillColor\" , 0xFF0000 ); // rectangle with different fills; uses (x, y) width, height XShape rect1 = Draw . drawRectangle ( currSlide , 70 , 70 , 25 , 50 ); // Props.setProperty(rect1, \"FillColor\", 0x00FF00); // green // Draw.setGradientColor(rect1, \"Gradient 4\"); // \"Radial red/yellow\"); // Draw.setGradientColor(rect1, java.awt.Color.GREEN, java . awt . Color . RED ); // Draw.setHatchingColor(rect1, \"Red crossed 45 degrees\"); // Draw.setBitmapColor(rect1, \"Roses\"); Draw . setBitmapFileColor ( rect1 , \"crazy_blue.jpg\" ); // text defined using (x, y), width, height [size] XShape text1 = Draw . drawText ( currSlide , \"Hello LibreOffice\" , 120 , 120 , 60 , 30 , 24 ); Props . setProperty ( text1 , \"Name\" , \"text1\" ); Props . showProps ( \"TextShape's Text Properties\" , Draw . getTextProperties ( text1 )); // gray transparent circle; uses (x,y), radius XShape circle2 = Draw . drawCircle ( currSlide , 40 , 150 , 20 ); Props . setProperty ( circle2 , \"FillColor\" , Lo . getColorInt ( java . awt . Color . GRAY )); Draw . setTransparency ( circle2 , 25 ); // thick line; uses (x,y), angle clockwise from x-axis, length XShape line2 = Draw . drawPolarLine ( currSlide , 60 , 200 , 45 , 100 ); Props . setProperty ( line2 , \"LineWidth\" , 300 ); // 3mm } // end of drawShapes() There's a number of variations possible for each shape, represented by commented out code. The following sections look at how the six shapes are drawn.","title":"1.  Drawing Shapes"},{"location":"13-Basic_Shapes.html#2-a-black-dashed-line","text":"Draw.drawLine() calls Draw.addShape() to create a com.sun.star.drawing.LineShape instance. In common with other shapes, a line is defined in terms of its enclosing rectangle, represented by its top-left corner, width, and height. Draw.drawLine() allows the programmer to define the line using its endpoints: // in the Draw class public static XShape drawLine ( XDrawPage slide , int x1 , int y1 , int x2 , int y2 ) { // make sure size is non-zero if (( x1 == x2 ) && ( y1 == y2 )) { System . out . println ( \"Line is a point\" ); return null ; } int width = x2 - x1 ; // may be negative int height = y2 - y1 ; // may be negative return addShape ( slide , \"LineShape\" , x1 , y1 , width , height ); } // end of drawLine() As mentioned above, Office will store a shape with a modified position and size if one or both of its dimensions is negative. As an example, consider if Draw.drawLine() is called with the coordinates (10,20) and (20,10). The call to addShape() would be passed a positive width (10mm) and a negative height (-10mm). This would be drawn as in Figure 3(a) but would be stored using the shape position and size in Figure 3\u00a9. Figure 3. How a Line with a Negative Height is Stored as a Shape. This kind of transformation may be important if your code modifies a shape after it has been added to the slide, as my animation examples do in the next chapter. Back in DrawPicture.java's drawShapes(), the line's properties are adjusted. The hardest part of this is finding the property's name in the API documentation, because properties are typically defined across multiple services, including LineShape, Shape, FillProperties, ShadowProperties, LineProperties, and RotationDescriptor. If the property is related to the shape's text then you should check TextProperties, CharacterProperties, and ParagraphProperties as well. Figure 7 of Chapter 11 shows the situation for RectangleShape, and its much the same for other shapes. You should start looking in the documentation for the shape (i.e. use lodoc LineShape drawing ), and move up the hierarchy. You can click on the inheritance diagram at the top of the page (e.g. like the one in Figure 4) to look in the different services. Figure 4. The LineShape Inheritance Diagram in the LibreOffice Online Documentation. drawShapes() will color the line black and make it dashed, which suggests that I should examine the LineProperties class. Its relevant properties are \"LineColor\" for color and \"LineStyle\" and \"LineDash\" for creating dashes, as in Figure 5. Figure 5. Relevant Properties in the LineProperties Class. Line color can be set with a single call to Props.setProperty(), but line dashing is a little more complicated, so is handled by Draw.setDashedLine(): // in drawShapes() in DrawPicture.java Props . setProperty ( line1 , \"LineColor\" , 0x000000 ); // black Draw . setDashedLine ( line1 , true ); The color parameter for \"LineColor\" is an RGB hexadecimal. There are other ways of defining color, which I'll explain in a moment. Draw.setDashedLine() has to assign a LineStyle object to \"LineStyle\" and a LineDash object to \"LineDash\". The line style is easily set since LineStyle is an enumeration with three possible values. A LineDash object requires more work: // in the Draw class public static void setDashedLine ( XShape shape , boolean isDashed ) { // create a LineDash object LineDash ld = new LineDash (); ld . Dots = 0 ; ld . DotLen = 100 ; // dashes only; no dots ld . Dashes = 5 ; ld . DashLen = 200 ; ld . Distance = 200 ; // set the properties for the line XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { if ( isDashed ) { // draw a dashed line props . setPropertyValue ( \"LineStyle\" , LineStyle . DASH ); props . setPropertyValue ( \"LineDash\" , ld ); } else // draw a solid line props . setPropertyValue ( \"LineStyle\" , LineStyle . SOLID ); } catch ( Exception e ) { System . out . println ( \"Could not set dashed line property\" ); } } // end of setDashedLine() setDashedLine() can be used to toggle a line's dashes on or off.","title":"2.  A Black Dashed Line"},{"location":"13-Basic_Shapes.html#3-a-red-ellipse","text":"A red ellipse is drawn using: // in drawShapes() in DrawPicture.java XShape circle1 = Draw . drawEllipse ( currSlide , 100 , 100 , 75 , 25 ); Props . setProperty ( circle1 , \"FillColor\" , 0xFF0000 ); Draw.drawEllipse() is similar to drawLine() except that an EllipseShape is created by Draw.addShape(): // in the Draw class public static XShape drawEllipse ( XDrawPage slide , int x , int y , int width , int height ) { return addShape ( slide , \"EllipseShape\" , x , y , width , height ); } I want to fill the circle with a solid color, which suggests the setting of a property in FillProperties. A visit to the online documentation for EllipseShape reveals an inheritance diagram like the one in Figure 6. Figure 6. The EllipseShape Inheritance Diagram in the LibreOffice Online Documentation. Clicking on the FillProperties rectangle jumps to its documentation, which lists a \"FillColor\" property (see Figure 7). Figure 7. Relevant Properties in the FillProperties Class. Both the \"FillColor\" and \"FillStyle\" properties should be set, but the default value for \"FillStyle\" is already FillStyle.SOLID, which is what's needed.","title":"3.  A Red Ellipse"},{"location":"13-Basic_Shapes.html#4-a-rectangle-with-a-variety-of-fills","text":"The rectangle example in drawShapes() comes in six different colors: // in drawShapes() in DrawPicture.java // rectangle with different fills XShape rect1 = Draw . drawRectangle ( currSlide , 70 , 70 , 25 , 50 ); // Props.setProperty(rect1, \"FillColor\", 0x00FF00); // green // Draw.setGradientColor(rect1, \"Gradient 4\"); // \"Radial red/yellow\"); // Draw.setGradientColor(rect1, java.awt.Color.GREEN, java . awt . Color . RED ); // Draw.setHatchingColor(rect1, \"Red crossed 45 degrees\"); // Draw.setBitmapColor(rect1, \"Roses\"); Draw . setBitmapFileColor ( rect1 , \"crazy_blue.jpg\" ); They're shown in Figure 8. Figure 8. Six Ways of Filling a Rectangle.","title":"4.  A Rectangle with a Variety of Fills"},{"location":"13-Basic_Shapes.html#41-gradient-color","text":"The second example in Figure 8 (\"gradient color\") is implemented using Draw.setGradientColor(): // in the Draw class public static void setGradientColor ( XShape shape , String name ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . GRADIENT ); props . setPropertyValue ( \"FillGradientName\" , name ); } catch ( com . sun . star . lang . IllegalArgumentException e ) { System . out . println ( \"\\\"\" + name + \"\\\" is not a recognized gradient color name\" ); } catch ( Exception e ) { System . out . println ( \"Could not set to \\\"\" + name + \"\\\"\" ); } } // end of setGradientColor() The hardest part of using this function is determining what name value to pass to the \"FillGradientName\" property (e.g. \"Gradient 4\" in the call in drawShapes()). The easiest solution is to fire up Office's Draw application, and check out the gradient names listed in the \"Line and Filling\" toolbar. Figure 9 shows what happens when the user selects a shape and chooses the \"Gradient\" menu item from the combo box. Figure 9. The Gradient Names in LibreOffice. If you supply a name which is not in Figure 9's list, then \"Linear blue/white\" is used instead.","title":"4.1.  Gradient Color"},{"location":"13-Basic_Shapes.html#42-gradient-awt-color","text":"The third example in Figure 8 shows what happens when you define your own gradient and angle of change. In drawShapes(), the call is: Draw . setGradientColor ( rect1 , java . awt . Color . GREEN , java . awt . Color . RED ); This creates a gradient change from green to red downwards through the shape. Draw.setGradientColor() calls a four argument version of itself which specifies the gradient angle: // in the Draw class public static void setGradientColor ( XShape shape , java . awt . Color startColor , java . awt . Color endColor ) { setGradientColor ( shape , startColor , endColor , 0 ); } public static void setGradientColor ( XShape shape , java . awt . Color startColor , java . awt . Color endColor , int angle ) /* if angle == 90 then the gradient changes from the left to the right side of the shape */ { // create Gradient object Gradient grad = new Gradient (); grad . Style = GradientStyle . LINEAR ; grad . StartColor = Lo . getColorInt ( startColor ); grad . EndColor = Lo . getColorInt ( endColor ); grad . Angle = ( short )( angle * 10 ); // in 1/10 degree units grad . Border = 0 ; grad . XOffset = 0 ; grad . YOffset = 0 ; grad . StartIntensity = 100 ; grad . EndIntensity = 100 ; grad . StepCount = 10 ; XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . GRADIENT ); props . setPropertyValue ( \"FillGradient\" , grad ); } catch ( Exception e ) { System . out . println ( \"Could not set gradient colors\" ); } } // end of setGradientColor() setGradientColor() sets the properties \"FillStyle\" and \"FillGradient\". The latter requires a Gradient object, which is documented in the FillProperties class, as shown in Figure 10. Figure 10. The \"FillGradient\" Property in the FillProperties Class. The online documentation for FillProperties can be reached using lodoc FillProperties service reference. Clicking on the \"com::sun: :awt::Gradient\" name in Figure 10 loads its documentation, which lists ten fields that need to be set. The colors passed to Draw.setGradientColor() are the Java AWT constants for red and green (java.awt.Color.RED and java.awt.Color.GREEN), but any Color objects could be used. They're converted to hexadecimals by Lo.getColorInt(): public static int getColorInt ( java . awt . Color color ) // return the color as an integer, ignoring the alpha channel { if ( color == null ) { System . out . println ( \"No color supplied\" ); return 0 ; } else return ( color . getRGB () & 0xffffff ); } // end of getColorInt()","title":"4.2.  Gradient AWT Color"},{"location":"13-Basic_Shapes.html#43-hatching","text":"The fourth fill in Figure 8 employs hatching. In drawShapes(), the call is: Draw . setHatchingColor ( rect1 , \"Red crossed 45 degrees\" ); Draw.setHatchingColor() is: public static void setHatchingColor ( XShape shape , String name ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . HATCH ); props . setPropertyValue ( \"FillHatchName\" , name ); } catch ( com . sun . star . lang . IllegalArgumentException e ) { System . out . println ( \"\\\"\" + name + \"\\\" not a hatching name\" ); } catch ( Exception e ) { System . out . println ( \"Could not set color \\\"\" + name + \"\\\"\" ); } } // end of setHatchingColor() This function is much the same as setGradientColor() except that it utilizes \"FillHatchName\" rather than \"FillGradientName\", and the fill style is set to FillStyle.HATCH. Suitable hatching names can be found by looking at the relevant list in Draw's \"Line and Filling\" toolbar. Figure 11 shows the \"Hatching\" menu item. Figure 11. The Hatching Names in LibreOffice.","title":"4.3.  Hatching"},{"location":"13-Basic_Shapes.html#44-bitmap-color","text":"The fifth rectangle fill in Figure 8 utilizes a bitmap color: Draw . setBitmapColor ( rect1 , \"Roses\" ); The function is: public static void setBitmapColor ( XShape shape , String name ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . BITMAP ); props . setPropertyValue ( \"FillBitmapName\" , name ); } catch ( com . sun . star . lang . IllegalArgumentException e ) { System . out . println ( \"\\\"\" + name + \"\\\" is not a bitmap\" ); } catch ( Exception e ) { System . out . println ( \"Could not set to \\\"\" + name + \"\\\"\" ); } } // end of setBitmapColor() This is also similar to setGradientColor() and setHatchingColor() but uses a different \"FillStyle\" value, and assigns a name to \"FillBitmapName\". As you might have guessed by now, the best source for these names is the \"Line and Filling\" toolbar shown in Figure 12. Figure 12. The Bitmap Names in LibreOffice.","title":"4.4.  Bitmap Color"},{"location":"13-Basic_Shapes.html#45-bitmap-file-color","text":"The final fill in Figure 8 loads a bitmap from \"crazy_blue.jpg\": Draw.setBitmapFileColor(rect1, \"crazy_blue.jpg\"); setBitmapFileColor() is: public static void setBitmapFileColor ( XShape shape , String fnm ) { XPropertySet props = Lo . qi ( XPropertySet . class , shape ); try { props . setPropertyValue ( \"FillStyle\" , FillStyle . BITMAP ); props . setPropertyValue ( \"FillBitmapURL\" , FileIO . fnmToURL ( fnm )); } catch ( Exception e ) { System . out . println ( \"Could not set color \\\"\" + fnm + \"\\\"\" ); } } // end of setBitmapFileColor() The \"FillBitmapURL\" property requires a URL, so the filename is converted by FileIO.fnmToURL().","title":"4.5.  Bitmap File Color"},{"location":"13-Basic_Shapes.html#5-text","text":"The \"Hello LibreOffice\" text shape in Figure 1 is created by calling Draw.drawText(): XShape text1 = Draw . drawText ( currSlide , \"Hello LibreOffice\" , 120 , 120 , 60 , 30 , 24 ); The first four numerical parameters define the shape's bounding rectangle in terms of its top-left coordinate, width, and height. The fifth, optional number specifies a font size (in this case, 24pt). drawText() calls addShape() with \"TextShape\": // in the Draw class public static XShape drawText ( XDrawPage slide , String msg , int x , int y , int width , int height , int fontSize ) { XShape shape = addShape ( slide , \"TextShape\" , x , y , width , height ); addText ( shape , msg , fontSize ); return shape ; } // end of drawText() addText() adds the message to the shape, and sets its font size: public static void addText ( XShape shape , String msg , int fontSize ) { XText xText = Lo . qi ( XText . class , shape ); XTextCursor cursor = xText . createTextCursor (); cursor . gotoEnd ( false ); if ( fontSize > 0 ) Props . setProperty ( cursor , \"CharHeight\" , fontSize ); XTextRange range = Lo . qi ( XTextRange . class , cursor ); range . setString ( msg ); } // end of addText() The shape is converted into an XText reference, and the text range selected with a cursor. The \"CharHeight\" property comes from the CharacterProperties service, which is inherited by the Text service (as shown in Figure 7 of Chapter 11).","title":"5.  Text"},{"location":"13-Basic_Shapes.html#some-help-with-text-properties","text":"The text-related properties for a shape can be accessed with Draw.getTextProperties(): public static XPropertySet getTextProperties ( XShape xShape ) { XText xText = Lo . qi ( XText . class , xShape ); XTextCursor cursor = xText . createTextCursor (); cursor . gotoStart ( false ); cursor . gotoEnd ( true ); XTextRange xTextRange = Lo . qi ( XTextRange . class , cursor ); return Lo . qi ( XPropertySet . class , xTextRange ); } // end of getTextProperties() drawShapes() in DrawPicture.java calls Draw.getTextProperties() on the text1 TextShape, and prints all its properties: // in drawShapes() in DrawPicture.java Props . showProps ( \"TextShape's Text Properties\" , Draw . getTextProperties ( text1 )); The output is long, but includes the line: CharHeight == 24.0 which indicates that the font size was correctly changed by the earlier call to Draw.drawText().","title":"Some Help with Text Properties"},{"location":"13-Basic_Shapes.html#6-using-a-shape-name","text":"Immediately after the call to Draw.drawText(), the shape's name is set: // in drawShapes() in DrawPicture.java Props . setProperty ( text1 , \"Name\" , \"text1\" ); The \"Name\" property, which is defined in the Shape class, is a useful way of referring to a shape. The main() function of DrawPicture.java passes a name to Draw.findShapeByName(): // in main() in DrawPicture.java XShape s = Draw . findShapeByName ( currSlide , \"text1\" ); Draw . reportPosSize ( s ); Draw . findShapeByName () iterates through a list of shapes extracted from the slide , and returns the shape with the supplied name : // in the Draw class public static XShape findShapeByName ( XDrawPage slide , String shapeName ) { ArrayList < XShape > shapes = getShapes ( slide ); if ( shapes == null ) { System . out . println ( \"No shapes were found in the draw page\" ); return null ; } for ( XShape shape : shapes ) { String nm = ( String ) Props . getProperty ( shape , \"Name\" ); if ( shapeName . equals ( nm )) return shape ; } System . out . println ( \"No shape named \\\"\" + shapeName + \"\\\"\" ); return null ; } // end of findShapeByName() Draw.getShapes() builds a list of shapes by iterating through the XDrawPage object as an indexed container of shapes: // in the Draw class public static ArrayList < XShape > getShapes ( XDrawPage slide ) { if ( slide == null ) { System . out . println ( \"Slide is null\" ); return null ; } if ( slide . getCount () == 0 ) { System . out . println ( \"Slide does not contain any shapes\" ); return null ; } ArrayList < XShape > xShapesList = new ArrayList < XShape > (); try { for ( int j = 0 ; j < slide . getCount (); j ++ ) xShapesList . add ( Lo . qi ( XShape . class , slide . getByIndex ( j ))); } catch ( Exception e ) { System . out . println ( \"Shapes extraction error in slide\" ); } return xShapesList ; } // end of getShapes() Draw.reportPosSize() prints some brief information about a shape, including its name, shape type, position, and size: // in the Draw class public static void reportPosSize ( XShape shape ) { if ( shape == null ) { System . out . println ( \"The shape is null\" ); return ; } System . out . println ( \"Shape name: \" + Props . getProperty ( shape , \"Name\" )); System . out . println ( \" Type: \" + shape . getShapeType ()); Point pt = shape . getPosition (); Size sz = shape . getSize (); System . out . println ( \" Position/size: (\" + pt . X / 100 + \", \" + pt . Y / 100 + \") / (\" + sz . Width / 100 + \", \" + sz . Height / 100 + \")\" ); } // end of reportPosSize() XShape.getShapeType() returns the class name of the shape as a string (in this case, \"com.sun.star.drawing.TextShape\").","title":"6.  Using a Shape Name"},{"location":"13-Basic_Shapes.html#7-a-transparent-circle-and-a-polar-line","text":"The last two shapes created by DrawPicture.java's drawShapes() are a gray transparent circle and a polar line. // in drawShapes() in DrawPicture.java // gray transparent circle; uses (x,y), radius XShape circle2 = Draw . drawCircle ( currSlide , 40 , 150 , 20 ); Props . setProperty ( circle2 , \"FillColor\" , Lo . getColorInt ( java . awt . Color . GRAY )); Draw . setTransparency ( circle2 , 25 ); // thick line; uses (x,y), angle clockwise from x-axis, length XShape line2 = Draw . drawPolarLine ( currSlide , 60 , 200 , 45 , 100 ); Props . setProperty ( line2 , \"LineWidth\" , 300 ); // 3mm A polar line is one defined using polar coordinates, which specifies the coordinate of one end of the line, and the angle and length of the line from that point. Draw.drawCircle() uses an EllipseShape, and Draw.drawPolarLine() converts the polar values into two coordinates so Draw.drawLine() can be called.","title":"7.  A Transparent Circle and a Polar Line"},{"location":"13-Basic_Shapes.html#8-a-math-formula-as-an-ole-shape","text":"Draw/Impress documents can include OLE objects through OLE2Shape, which allows a shape to link to an external document. Probably the most popular kind of OLE shape is the chart, but I'll delay a detailed discussion of that topic until Part 5, although there is a code snippet below. The best way of finding out what OLE objects are available is to go to Draw's (or Impress') Insert menu, Object, \"OLE Object\" dialog. It lists Office spreadsheet, chart, drawing, presentation, and formula documents, and a range of Microsoft and PDF types (when you click on \"Further objects\"). The DrawPicture.java OLE example displays a mathematical formula, as in Figure 13. Figure 13. A Math Formula in a Draw Document. DrawPicture.java renders the formula by calling Draw.addFormula(), which hides the tricky aspects of instatiating the OLE shape: // in main() in DrawPicture.java Draw . drawFormula ( currSlide , \"func e^{i %pi} + 1 = 0\" , 23 , 20 , 20 , 40 ); The second argument is a formula string, written using Office's Math notation. For an overview, see the \"Commands Reference\" appendix of the \"Math Guide\", available from https://libreoffice.org/get-help/documentation/ . Draw.drawFormula() is coded as: public static XShape drawFormula ( XDrawPage slide , String formula , int x , int y , int width , int height ) { XShape shape = addShape ( slide , \"OLE2Shape\" , x , y , width , height ); Props . setProperty ( shape , \"CLSID\" , Lo . MATH_CLSID ); // a formula XModel model = Lo . qi ( XModel . class , Props . getProperty ( shape , \"Model\" ) ); Props . setProperty ( model , \"Formula\" , formula ); // from FormulaProperties return shape ; } // end of drawFormula() OLE2Shape uses a \"CLSID\" property to hold the class ID of the OLE object. Setting this property affects the shape's model (data format), which is stored in the \"Model\" property. drawFormula() casts this property to XModel and, since the model represents formula data, it has a \"Formula\" property where the formula string is stored.","title":"8.  A Math formula as an OLE Shape"},{"location":"13-Basic_Shapes.html#creating-other-kinds-of-ole-shape","text":"The use of a \"Formula\" property in Draw.drawFormula() only works for an OLE shape representing a formula. How are other kinds of data stored? The first step is to set the OLE shape's class ID to the correct value, which will affect its \"Model\" property. A short list of class ID constants are included at the start of the Lo utility class, along with a few commented out IDs which I haven\u2019t tested. Creating an OLE2Shape for a chart begins like so : XShape shape = addShape ( slide , \"OLE2Shape\" , x , y , width , height ); Props . setProperty ( shape , \"CLSID\" , Lo . CHART_CLSID ); // a chart XModel model = Lo . qi ( XModel . class , Props . getProperty ( shape , \"Model\" ) ); Online information on how to use XModel to store a chart, a graphic, or something else, is pretty sparse. I've found the best start is to list the services that support the XModel reference. This is done by calling Info.showServices(): Info . showServices ( \"OLE2Shape Model\" , model ); For the version of model in drawFormula(), it reports: OLE2Shape Model Supported Services (2) \"com.sun.star.document.OfficeDocument\" \"com.sun.star.formula.FormulaProperties\" This gives a strong hint to look inside the FormulaProperties service, to find a property for storing the formula string. A look at the documentation ( lodoc FormulaProperties service ) reveals a \"Formula\" property, which I used in drawFormula(). When the model refers to chart data, the same call to Info.showServices() prints: OLE2Shape Model Supported Services (3) \"com.sun.star.chart.ChartDocument\" \"com.sun.star.chart2.ChartDocument\" \"com.sun.star.document.OfficeDocument\" The com.sun.star.chart2 package is the newer way of manipulating charts, which suggests that the XModel interfaces should be converted to an interface of com.sun.star.chart2.ChartDocument. The most useful is XChartDocument, which is obtained via: XChartDocument chartDoc = Lo.qi(XChartDocument.class, model); XChartDocument supports a rich set of chart manipulation methods. I'll return to charts in Part 5.","title":"Creating Other Kinds of OLE Shape"},{"location":"13-Basic_Shapes.html#9-polygons","text":"The main() function of AnimBicycle.java calls Draw.drawPolygon() twice to create regular polygons for a square and pentagon: // in AnimBicycle.java XShape square = Draw.drawPolygon(currSlide, 125, 125, 25, 4); // (x,y), radius, no. of sides Props.setProperty(square, \"FillColor\", 0x3fe694); // pale green XShape pentagon = Draw.drawPolygon(currSlide, 150, 75, 5); // (x,y), no. of sides // radius uses a default value Props.setProperty(pentagon, \"FillColor\", 0xe7b9c7); // purple The polygons can be seen in Figure 14. Figure 14. Bicycle and Shapes. Draw.drawPolygon() is: // in the Draw class public static XShape drawPolygon(XDrawPage slide, int x, int y, int radius, int nSides) { XShape polygon = addShape(slide, \"PolyPolygonShape\", 0, 0, 0, 0); // for shapes formed by one or more polygons Point[] pts = genPolygonPoints(x, y, radius, nSides); Point[][] polys = new Point[][] {pts}; // an array of Point arrays, one Point array for each polygon Props.setProperty(polygon, \"PolyPolygon\", polys); return polygon; } // end of drawPolygon() drawPolygon() creates a \"PolyPolygonShape\" shape which is designed to store multiple polygons. This is why the polys data structure instantiated at the end of drawPolygon() is an array of points arrays, since the shape's \"PolyPolygon\" property can hold multiple point arrays. However, drawPolygon() only creates a single points array by calling genPolygonPoints(). A points array defining the four points of a square could be: Point[] pts = new Point[4]; pts[0] = new Point(4000, 1200); pts[1] = new Point(4000, 2000); pts[2] = new Point(5000, 2000); pts[3] = new Point(5000, 1200); Note that the coordinates of each point use Office's 1/100 mm units. genPolygonPoints() generates a points array for a regular polygon based on the coordinate of the center of the polygon, the distance from the center to each point (the shape's radius), and the required number of sides: private static Point [] genPolygonPoints ( int x , int y , int radius , int nSides ) { if ( nSides < 3 ) { System . out . println ( \"Too few sides; must be 3 or more\" ); nSides = 3 ; } else if ( nSides > 30 ) { System . out . println ( \"Too many sides; must be 30 or less\" ); nSides = 30 ; } Point [] pts = new Point [ nSides ] ; double angleStep = Math . PI / nSides ; for ( int i = 0 ; i < nSides ; i ++ ) { pts [ i ] = new Point ( ( int ) Math . round ( x * 100 + radius * 100 * Math . cos ( i * 2 * angleStep )), ( int ) Math . round ( y * 100 + radius * 100 * Math . sin ( i * 2 * angleStep )) ); } return pts ; } // end of genPolygonPoints()","title":"9.  Polygons"},{"location":"13-Basic_Shapes.html#10-mult-line-shapes","text":"A PolyLineShape can hold multiple line paths, where a path is a sequence of connected lines. Draw.drawLines() only creates a single line path, based on being passed arrays of x- and y- axis coordinates. For example, the following code in AnimBicycle creates the crossed lines at the top-left of Figure 14: // in AnimBicycle.java int [] xs = { 10 , 30 , 10 , 30 }; int [] ys = { 10 , 100 , 100 , 10 }; Draw . drawLines ( currSlide , xs , ys ); Draw.drawLines() is: // in the Draw class public static XShape drawLines ( XDrawPage slide , int [] xs , int [] ys ) { if ( xs . length != ys . length ) { System . out . println ( \"The two arrays must be the same length\" ); return null ; } int numPoints = xs . length ; Point [] pts = new Point [ numPoints ] ; for ( int i = 0 ; i < numPoints ; i ++ ) pts [ i ] = new Point ( xs [ i ]* 100 , ys [ i ]* 100 ); //in 1/100 mm units Point [][] linePaths = new Point [][] { pts }; // an array of Point arrays, one Point array for each line path XShape polyLine = addShape ( slide , \"PolyLineShape\" , 0 , 0 , 0 , 0 ); // for a shape formed from multiple line paths Props . setProperty ( polyLine , \"PolyPolygon\" , linePaths ); return polyLine ; } // end of drawLines() drawLines() creates an array of Point arrays which is stored in the PolyLineShape property called \"PolyPolygon\". However, drawLines() only adds a single points array to the linePaths data structure since only one line path is being created.","title":"10. Mult-line Shapes"},{"location":"13-Basic_Shapes.html#11-partial-ellipses","text":"EllipseShape contains a \"CircleKind\" property that determines whether the entire ellipse should be drawn, or only a portion of it. The properties \"CircleStartAngle\" and \"CircleEndAngle\" define the angles where the solid part of the ellipse starts and finishes. Zero degrees is the positive x-axis, and the angle increase in 1/100 degrees units counter-clockwise around the center of the ellipse. AnimBicycle.java contains the following example: // in AnimBicycle.java XShape pie = Draw . drawEllipse ( currSlide , 30 , slideSize . Width - 100 , 40 , 20 ); Props . setProperty ( pie , \"CircleStartAngle\" , 9000 ); // 90 degrees ccw Props . setProperty ( pie , \"CircleEndAngle\" , 36000 ); // 360 degrees ccw Props . setProperty ( pie , \"CircleKind\" , CircleKind . SECTION ); // CircleKind.CUT, CircleKind.ARC This creates the blue partial ellipse shown at the bottom left of Figure 14. Figure 15 shows the different results when \"CircleKind\" is set to CircleKind.SECTION, CircleKind.CUT, and CircleKind.ARC. Figure 15. Different Types of Partial Ellipse","title":"11.  Partial Ellipses"},{"location":"14-Animation.html","text":"Chapter 14. Animation \u00b6 Topics Circle Movement; Line Rotation; Animating an Image; The Gallery Module Example folders: \"Draw Tests\" and \"Utils\" DrawPicture.java contains a commented-out call to animShapes() which shows how to animate a circle and a line. There's a second animation example in AnimBicycle.java which translates and rotates a bicycle image. The chapter ends with a brief outline of the com.sun.star.gallery module. 1. Animating a Circle and a Line \u00b6 animShapes() in DrawPicture.java implements two animation loops that work in a similar manner. Inside a loop, a shape is drawn, the function (and program) sleeps for a brief period, then the shape's position, size, or properties are updated, and the loop repeats. The first animation loop moves a circle across the page from left to right, reducing its radius at the same time. The second loop rotates a line counter-clockwise while changing its length. The animShapes() code: // in DrawPicture.java private static void animShapes ( XDrawPage currSlide ) { // reduce circle size and move to the right int xc = 40 ; int yc = 150 ; int radius = 40 ; XShape circle = null ; for ( int i = 0 ; i < 20 ; i ++ ) { if ( circle != null ) currSlide . remove ( circle ); circle = Draw . drawCircle ( currSlide , xc , yc , radius ); // (x-center, y-center, radius) Lo . delay ( 200 ); xc += 5 ; // move right radius *= 0.95 ; // reduce size } // rotate line counter-clockwise, and change length int x2 = 140 ; int y2 = 110 ; XShape line = null ; for ( int i = 0 ; i <= 25 ; i ++ ) { if ( line != null ) currSlide . remove ( line ); line = Draw . drawLine ( currSlide , 40 , 100 , x2 , y2 ); Lo . delay ( 200 ); x2 -= 4 ; y2 -= 4 ; } } // end of animShapes() The shape (circle or line) is changed by removing the current version from the page and inserting a new updated instance. This means that a lot of objects are created and removed in a short amount of time. The alternative approach, which retains the shape and only update its properties, is used in the bicycle animation explained next. 2. Animating an Image \u00b6 The AnimBicycle.java example moves a bicycle image to the right and rotates it counter-clockwise. Figure 1 shows the page after the animation has finished. Figure 1. Animated Bicycle and Shapes. The animation is performed by animateBike(): private static void animateBike ( XDrawPage currSlide ) { String fnm = Info . getGalleryDir () + \"/transportation/Bicycle-Blue.png\" ; XShape shape = Draw . drawImage ( currSlide , fnm , 60 , 100 , 90 , 50 ); // (x,y), width, height if ( shape == null ) { System . out . println ( \"Bike shape not created\" ); return ; } Point pt = Draw . getPosition ( shape ); int angle = Draw . getRotation ( shape ); for ( int i = 0 ; i <= 18 ; i ++ ) { Draw . setPosition ( shape , pt . X + ( i * 5 ), pt . Y ); // move right Draw . setRotation ( shape , angle + ( i * 5 )); // rotates Lo . delay ( 200 ); } System . out . println ( \"Final Angle: \" + Draw . getRotation ( shape )); Draw . printMatrix ( Draw . getTransformation ( shape )); } // end of animateBike() The image comes from Office\u2019s Gallery collection whose location is returned by Info.getGalleryDir(). There are several gallery locations that Office might use, but getGalleryDir() returns the main one, which is /share/gallery/. This directory divides the collection into a number of subdirectories, and the bicycle is in transportation/Bicycle-Blue.png. The animation loop in animateBike() is similar to the ones in animShapes(), using Lo.delay() to space out changes over time. However, instead of creating a new shape on each iteration, a single GraphicObjectShape is created by Draw.drawImage() before the loop starts. Inside the loop, that shape\u2019s position and orientation are repeatedly updated by Draw.setPosition() and Draw.setRotation(). 2.1. Drawing the Image \u00b6 There are several versions of Draw.drawImage(); the main one is: // in the Draw class public static XShape drawImage ( XDrawPage slide , String imFnm , int x , int y , int width , int height ) // units in mm's { System . out . println ( \"Adding the picture \\\"\" + imFnm + \"\\\"\" ); XShape imShape = addShape ( slide , \"GraphicObjectShape\" , x , y , width , height ); setImage ( imShape , imFnm ); setLineStyle ( imShape , LineStyle . NONE ); // so no border around the image return imShape ; } // end of drawImage() public static void setImage ( XShape shape , String imFnm ) { String bitmap = Images . getBitmap ( imFnm ); Props . setProperty ( shape , \"GraphicURL\" , bitmap ); // embed bitmap from image file } // end of setImage() drawImage() uses the supplied (x, y) position, width, and height to create an empty GraphicObjectShape. An image is added by setImage(), which loads a bitmap from a file, and assigns it to the shape's \"GraphicURL\" property. By using a bitmap, the image is embedded in the document. Alternatively, a URL could be assigned to \"GraphicURL\", causing the document's image to be a link back to its original file. That version is coded using: Props . setProperty ( shape , \"GraphicURL\" , FileIO . fnmToURL ( imFnm )); // link to image file A second version of Draw.drawImage() doesn't require width and height arguments \u2013 they're obtained from the image\u2019s dimensions: // in the Draw class public static XShape drawImage ( XDrawPage slide , String imFnm , int x , int y ) // units in mm's { Size imSize = Images . getSize100mm ( imFnm ); // in 1/100 mm units if ( imSize == null ) { System . out . println ( \"Could not calculate size of \" + imFnm ); return null ; } else return drawImage ( slide , imFnm , x , y , imSize . Width / 100 , imSize . Height / 100 ); } // end of drawImage() The image\u2019s size is returned in 1/100 mm units by Images.getSize100mm(). It loads the image as an XGraphic object so that its \"Size100thMM\" property can be examined: // in the Images class public static Size getSize100mm ( String imFnm ) { XGraphic graphic = loadGraphicFile ( imFnm ); if ( graphic == null ) return null ; return ( Size ) Props . getProperty ( graphic , \"Size100thMM\" ); } // end of getSize100mm() This approach isn\u2019t very efficient since it means that the image is being loaded twice, once as an XGraphic object by getSize100mm(), and also as a bitmap by setImage(). 2.2. Updating the Bike\u2019s Position and Orientation \u00b6 The animateBike() animation uses Draw methods for getting and setting the shape\u2019s position and orientation: // in the Draw class public static Point getPosition ( XShape shape ) { Point pt = shape . getPosition (); return new Point ( pt . X / 100 , pt . Y / 100 ); // convert to mm } public static void setPosition ( XShape shape , int x , int y ) { shape . setPosition ( new Point ( x * 100 , y * 100 )); } public static int getRotation ( XShape shape ) { return (( Integer ) Props . getProperty ( shape , \"RotateAngle\" )) / 100 ; } public static void setRotation ( XShape shape , int angle ) { Props . setProperty ( shape , \"RotateAngle\" , angle * 100 ); } The position is accessed and changed using the XShape methods getPosition() and setPosition(), with the only complication being the changes of millimeters into 1/100 mm units, and vice versa. Rotation is handled by getting and setting the shape's\"RotateAngle\" property, which is inherited from the RotationDescriptor class. The angle is expressed in \"1/100 of a degree\" units (e.g. 4500 rather than 45 degrees), and a positive rotation is counter- clockwise. One issue is that RotationDescriptor is deprecated; the modern programmer is encouraged to rotate a shape using the matrix associated with the \"Transformation\" property. The Draw class has are two support functions for \"Transformation\": one extracts the matrix from a shape, and the other prints it: public static HomogenMatrix3 getTransformation ( XShape shape ) /* Returns a transformation matrix, which seems to represent a clockwise rotation: cos(t) sin(t) x -sin(t) cos(t) y 0 0 1 */ { return ( HomogenMatrix3 ) Props . getProperty ( shape , \"Transformation\" ); } // end of getTransformation() public static void printMatrix ( HomogenMatrix3 mat ) { System . out . println ( \"Transformation Matrix:\" ); System . out . printf ( \"\\t%10.2f\\t%10.2f\\t%10.2f\\n\" , mat . Line1 . Column1 , mat . Line1 . Column2 , mat . Line1 . Column3 ); System . out . printf ( \"\\t%10.2f\\t%10.2f\\t%10.2f\\n\" , mat . Line2 . Column1 , mat . Line2 . Column2 , mat . Line2 . Column3 ); System . out . printf ( \"\\t%10.2f\\t%10.2f\\t%10.2f\\n\" , mat . Line3 . Column1 , mat . Line3 . Column2 , mat . Line3 . Column3 ); double radAngle = Math . atan2 ( mat . Line2 . Column1 , mat . Line1 . Column1 ); // sin(t), cos(t) int currAngle = ( int ) Math . round ( Math . toDegrees ( radAngle )); System . out . println ( \" Current angle: \" + currAngle ); System . out . println (); } // end of printMatrix() These methods are called at the end of animateBike(): // in animateBike() in AnimBicycle.java Draw . printMatrix ( Draw . getTransformation ( shape )); The output is: Transformation Matrix: 0.00 5001.00 15383.00 -9001.00 0.00 10235.00 0.00 0.00 1.00 Current angle: -90 These numbers suggests that the transformation was a clockwise rotation, but the calls to Draw.setRotation() in the earlier animation loop made the bicycle turn counter- clockwise. This discrepancy led me to stay with the deprecated approach for shape rotation. 3. Another Way to Access the Gallery \u00b6 There's an alternative way to obtain gallery images based around themes and items, implemented by the com.sun.star.gallery module (see lodoc Gallery module ). Subdirectories of gallery/ are themes (e.g. there's a transportation theme), and the files in those directories are items. The three interfaces in the module are: XGalleryThemeProvider, XGalleryTheme, and XGalleryItem. XGalleryThemeProvider represents the gallery/ directory as a sequence of named XGalleryTheme objects, as shown in Figure 2. Figure 2. The GalleryThemeProvider Service. A XGalleryTheme represents the file contents of a subdirectory (such as transportation/) as a container of indexed XGalleryItem objects, which is depicted in Figure 3. Figure 3. The GalleryTheme Service. Each XGalleryItem represents a file, which may be a graphic or some other resource, such as an audio file. The details about each item (file) are stored as properties which are defined in the GalleryItem service (see lodoc GalleryItem service ). The Gallery.java utility class helps access the gallery in this way, and GalleryInfo.java contains some examples of its use: public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); // list all gallery themes (i.e. the sub-dirs below gallery/) Gallery . reportGallerys (); System . out . println (); // list all items for the Transportation theme // i.e. list all the files in gallery/transportation Gallery . reportGalleryItems ( \"Transportation\" ); System . out . println (); // find an item that has \"bicycle\" as part of its name // in the Transportation theme XGalleryItem gItem = Gallery . findGalleryItem ( \"Transportation\" , \"bicycle\" ); System . out . println (); // print out the item's properties Gallery . reportGalleryItem ( gItem ); Lo . closeOffice (); } // end of main() Gallery.reportGallerys() gives details about 14 themes, Gallery.reportGalleryItems() prints the names of the 14 items (files) in the transportation theme. Gallery.findGalleryItem() searches that theme for an item name containing \"bicycle\", and Gallery.reportGalleryItem() reports its details: Gallery item information: Fnm: \"Bicycle-Blue.png\" Path: \"C:\\Program Files\\LibreOffice 5\\share\\gallery \\transportation\\Bicycle-Blue.png\" Title: \"\" Type: graphic","title":"Chapter 14. Animation"},{"location":"14-Animation.html#chapter-14-animation","text":"Topics Circle Movement; Line Rotation; Animating an Image; The Gallery Module Example folders: \"Draw Tests\" and \"Utils\" DrawPicture.java contains a commented-out call to animShapes() which shows how to animate a circle and a line. There's a second animation example in AnimBicycle.java which translates and rotates a bicycle image. The chapter ends with a brief outline of the com.sun.star.gallery module.","title":"Chapter 14. Animation"},{"location":"14-Animation.html#1-animating-a-circle-and-a-line","text":"animShapes() in DrawPicture.java implements two animation loops that work in a similar manner. Inside a loop, a shape is drawn, the function (and program) sleeps for a brief period, then the shape's position, size, or properties are updated, and the loop repeats. The first animation loop moves a circle across the page from left to right, reducing its radius at the same time. The second loop rotates a line counter-clockwise while changing its length. The animShapes() code: // in DrawPicture.java private static void animShapes ( XDrawPage currSlide ) { // reduce circle size and move to the right int xc = 40 ; int yc = 150 ; int radius = 40 ; XShape circle = null ; for ( int i = 0 ; i < 20 ; i ++ ) { if ( circle != null ) currSlide . remove ( circle ); circle = Draw . drawCircle ( currSlide , xc , yc , radius ); // (x-center, y-center, radius) Lo . delay ( 200 ); xc += 5 ; // move right radius *= 0.95 ; // reduce size } // rotate line counter-clockwise, and change length int x2 = 140 ; int y2 = 110 ; XShape line = null ; for ( int i = 0 ; i <= 25 ; i ++ ) { if ( line != null ) currSlide . remove ( line ); line = Draw . drawLine ( currSlide , 40 , 100 , x2 , y2 ); Lo . delay ( 200 ); x2 -= 4 ; y2 -= 4 ; } } // end of animShapes() The shape (circle or line) is changed by removing the current version from the page and inserting a new updated instance. This means that a lot of objects are created and removed in a short amount of time. The alternative approach, which retains the shape and only update its properties, is used in the bicycle animation explained next.","title":"1.  Animating a Circle and a Line"},{"location":"14-Animation.html#2-animating-an-image","text":"The AnimBicycle.java example moves a bicycle image to the right and rotates it counter-clockwise. Figure 1 shows the page after the animation has finished. Figure 1. Animated Bicycle and Shapes. The animation is performed by animateBike(): private static void animateBike ( XDrawPage currSlide ) { String fnm = Info . getGalleryDir () + \"/transportation/Bicycle-Blue.png\" ; XShape shape = Draw . drawImage ( currSlide , fnm , 60 , 100 , 90 , 50 ); // (x,y), width, height if ( shape == null ) { System . out . println ( \"Bike shape not created\" ); return ; } Point pt = Draw . getPosition ( shape ); int angle = Draw . getRotation ( shape ); for ( int i = 0 ; i <= 18 ; i ++ ) { Draw . setPosition ( shape , pt . X + ( i * 5 ), pt . Y ); // move right Draw . setRotation ( shape , angle + ( i * 5 )); // rotates Lo . delay ( 200 ); } System . out . println ( \"Final Angle: \" + Draw . getRotation ( shape )); Draw . printMatrix ( Draw . getTransformation ( shape )); } // end of animateBike() The image comes from Office\u2019s Gallery collection whose location is returned by Info.getGalleryDir(). There are several gallery locations that Office might use, but getGalleryDir() returns the main one, which is /share/gallery/. This directory divides the collection into a number of subdirectories, and the bicycle is in transportation/Bicycle-Blue.png. The animation loop in animateBike() is similar to the ones in animShapes(), using Lo.delay() to space out changes over time. However, instead of creating a new shape on each iteration, a single GraphicObjectShape is created by Draw.drawImage() before the loop starts. Inside the loop, that shape\u2019s position and orientation are repeatedly updated by Draw.setPosition() and Draw.setRotation().","title":"2.  Animating an Image"},{"location":"14-Animation.html#21-drawing-the-image","text":"There are several versions of Draw.drawImage(); the main one is: // in the Draw class public static XShape drawImage ( XDrawPage slide , String imFnm , int x , int y , int width , int height ) // units in mm's { System . out . println ( \"Adding the picture \\\"\" + imFnm + \"\\\"\" ); XShape imShape = addShape ( slide , \"GraphicObjectShape\" , x , y , width , height ); setImage ( imShape , imFnm ); setLineStyle ( imShape , LineStyle . NONE ); // so no border around the image return imShape ; } // end of drawImage() public static void setImage ( XShape shape , String imFnm ) { String bitmap = Images . getBitmap ( imFnm ); Props . setProperty ( shape , \"GraphicURL\" , bitmap ); // embed bitmap from image file } // end of setImage() drawImage() uses the supplied (x, y) position, width, and height to create an empty GraphicObjectShape. An image is added by setImage(), which loads a bitmap from a file, and assigns it to the shape's \"GraphicURL\" property. By using a bitmap, the image is embedded in the document. Alternatively, a URL could be assigned to \"GraphicURL\", causing the document's image to be a link back to its original file. That version is coded using: Props . setProperty ( shape , \"GraphicURL\" , FileIO . fnmToURL ( imFnm )); // link to image file A second version of Draw.drawImage() doesn't require width and height arguments \u2013 they're obtained from the image\u2019s dimensions: // in the Draw class public static XShape drawImage ( XDrawPage slide , String imFnm , int x , int y ) // units in mm's { Size imSize = Images . getSize100mm ( imFnm ); // in 1/100 mm units if ( imSize == null ) { System . out . println ( \"Could not calculate size of \" + imFnm ); return null ; } else return drawImage ( slide , imFnm , x , y , imSize . Width / 100 , imSize . Height / 100 ); } // end of drawImage() The image\u2019s size is returned in 1/100 mm units by Images.getSize100mm(). It loads the image as an XGraphic object so that its \"Size100thMM\" property can be examined: // in the Images class public static Size getSize100mm ( String imFnm ) { XGraphic graphic = loadGraphicFile ( imFnm ); if ( graphic == null ) return null ; return ( Size ) Props . getProperty ( graphic , \"Size100thMM\" ); } // end of getSize100mm() This approach isn\u2019t very efficient since it means that the image is being loaded twice, once as an XGraphic object by getSize100mm(), and also as a bitmap by setImage().","title":"2.1.  Drawing the Image"},{"location":"14-Animation.html#22-updating-the-bikes-position-and-orientation","text":"The animateBike() animation uses Draw methods for getting and setting the shape\u2019s position and orientation: // in the Draw class public static Point getPosition ( XShape shape ) { Point pt = shape . getPosition (); return new Point ( pt . X / 100 , pt . Y / 100 ); // convert to mm } public static void setPosition ( XShape shape , int x , int y ) { shape . setPosition ( new Point ( x * 100 , y * 100 )); } public static int getRotation ( XShape shape ) { return (( Integer ) Props . getProperty ( shape , \"RotateAngle\" )) / 100 ; } public static void setRotation ( XShape shape , int angle ) { Props . setProperty ( shape , \"RotateAngle\" , angle * 100 ); } The position is accessed and changed using the XShape methods getPosition() and setPosition(), with the only complication being the changes of millimeters into 1/100 mm units, and vice versa. Rotation is handled by getting and setting the shape's\"RotateAngle\" property, which is inherited from the RotationDescriptor class. The angle is expressed in \"1/100 of a degree\" units (e.g. 4500 rather than 45 degrees), and a positive rotation is counter- clockwise. One issue is that RotationDescriptor is deprecated; the modern programmer is encouraged to rotate a shape using the matrix associated with the \"Transformation\" property. The Draw class has are two support functions for \"Transformation\": one extracts the matrix from a shape, and the other prints it: public static HomogenMatrix3 getTransformation ( XShape shape ) /* Returns a transformation matrix, which seems to represent a clockwise rotation: cos(t) sin(t) x -sin(t) cos(t) y 0 0 1 */ { return ( HomogenMatrix3 ) Props . getProperty ( shape , \"Transformation\" ); } // end of getTransformation() public static void printMatrix ( HomogenMatrix3 mat ) { System . out . println ( \"Transformation Matrix:\" ); System . out . printf ( \"\\t%10.2f\\t%10.2f\\t%10.2f\\n\" , mat . Line1 . Column1 , mat . Line1 . Column2 , mat . Line1 . Column3 ); System . out . printf ( \"\\t%10.2f\\t%10.2f\\t%10.2f\\n\" , mat . Line2 . Column1 , mat . Line2 . Column2 , mat . Line2 . Column3 ); System . out . printf ( \"\\t%10.2f\\t%10.2f\\t%10.2f\\n\" , mat . Line3 . Column1 , mat . Line3 . Column2 , mat . Line3 . Column3 ); double radAngle = Math . atan2 ( mat . Line2 . Column1 , mat . Line1 . Column1 ); // sin(t), cos(t) int currAngle = ( int ) Math . round ( Math . toDegrees ( radAngle )); System . out . println ( \" Current angle: \" + currAngle ); System . out . println (); } // end of printMatrix() These methods are called at the end of animateBike(): // in animateBike() in AnimBicycle.java Draw . printMatrix ( Draw . getTransformation ( shape )); The output is: Transformation Matrix: 0.00 5001.00 15383.00 -9001.00 0.00 10235.00 0.00 0.00 1.00 Current angle: -90 These numbers suggests that the transformation was a clockwise rotation, but the calls to Draw.setRotation() in the earlier animation loop made the bicycle turn counter- clockwise. This discrepancy led me to stay with the deprecated approach for shape rotation.","title":"2.2.  Updating the Bike\u2019s Position and Orientation"},{"location":"14-Animation.html#3-another-way-to-access-the-gallery","text":"There's an alternative way to obtain gallery images based around themes and items, implemented by the com.sun.star.gallery module (see lodoc Gallery module ). Subdirectories of gallery/ are themes (e.g. there's a transportation theme), and the files in those directories are items. The three interfaces in the module are: XGalleryThemeProvider, XGalleryTheme, and XGalleryItem. XGalleryThemeProvider represents the gallery/ directory as a sequence of named XGalleryTheme objects, as shown in Figure 2. Figure 2. The GalleryThemeProvider Service. A XGalleryTheme represents the file contents of a subdirectory (such as transportation/) as a container of indexed XGalleryItem objects, which is depicted in Figure 3. Figure 3. The GalleryTheme Service. Each XGalleryItem represents a file, which may be a graphic or some other resource, such as an audio file. The details about each item (file) are stored as properties which are defined in the GalleryItem service (see lodoc GalleryItem service ). The Gallery.java utility class helps access the gallery in this way, and GalleryInfo.java contains some examples of its use: public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); // list all gallery themes (i.e. the sub-dirs below gallery/) Gallery . reportGallerys (); System . out . println (); // list all items for the Transportation theme // i.e. list all the files in gallery/transportation Gallery . reportGalleryItems ( \"Transportation\" ); System . out . println (); // find an item that has \"bicycle\" as part of its name // in the Transportation theme XGalleryItem gItem = Gallery . findGalleryItem ( \"Transportation\" , \"bicycle\" ); System . out . println (); // print out the item's properties Gallery . reportGalleryItem ( gItem ); Lo . closeOffice (); } // end of main() Gallery.reportGallerys() gives details about 14 themes, Gallery.reportGalleryItems() prints the names of the 14 items (files) in the transportation theme. Gallery.findGalleryItem() searches that theme for an item name containing \"bicycle\", and Gallery.reportGalleryItem() reports its details: Gallery item information: Fnm: \"Bicycle-Blue.png\" Path: \"C:\\Program Files\\LibreOffice 5\\share\\gallery \\transportation\\Bicycle-Blue.png\" Title: \"\" Type: graphic","title":"3.  Another Way to Access the Gallery"},{"location":"15-Complex_Shapes.html","text":"Chapter 15. Complex Shapes \u00b6 Topics Connecting Two Rectangles; Shape Composition (grouping, binding, and combining); Combining with Dispatches; Undoing Composition; Bezier Curves (simple and complex) Example folders: \"Draw Tests\" and \"Utils\" This chapter looks at three complex topics involving shapes: connecting rectangles, shape composition, and drawing Bezier curves. 1. Connecting Two Rectangles \u00b6 A line can be drawn between two shapes using a LineShape. But it's much easier to join the shapes with a ConnectorShape, which can be attached precisely by linking its two ends to glue points on the shapes. Glue points are the little blue circles which appear on a shape when you use connectors in Draw. They occur in the middle of the upper, lower, left, and right sides of the shape, although it's possible to create extra ones. By default a connector is drawn using multiple horizontal and vertical lines. It's possible to change this to a curve, a single line, or a connection made up of multiple lines which are mostly horizontal and vertical. Figure 1 shows the four types linking the same two rectangles. Figure 1. Different Styles of Connector. Grouper.java contains code for generating the top-left example in Figure 1: // Grouper.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createDrawDoc ( loader ); if ( doc == null ) { System . out . println ( \"Draw doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 1000 ); // need delay or zoom may not occur GUI . zoom ( doc , GUI . ENTIRE_PAGE ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); //access first page System . out . println ( \"\\nConnecting rectangles ...\" ); XNameContainer gStyles = Info . getStyleContainer ( doc , \"graphics\" ); connectRectangles ( currSlide , gStyles ); : // code for grouping, binding, and combining shape, : // discussed later Lo . saveDoc ( doc , \"grouper.odg\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } The connectRectangles() function creates two labeled rectangles, and links them with a standard connector. The connector starts on the bottom edge of the green rectangle and finishes at the top edge of the blue one (as shown in the top-left of Figure 1). The method also prints out some information about the glue points of the blue rectangle. // in Grouper.java private static void connectRectangles ( XDrawPage currSlide , XNameContainer gStyles ) { // dark green rectangle with shadow and text XShape greenRect = Draw . drawRectangle ( currSlide , 70 , 180 , 50 , 25 ); Props . setProperty ( greenRect , \"FillColor\" , Lo . getColorInt ( java . awt . Color . GREEN . darker ())); Props . setProperty ( greenRect , \"Shadow\" , true ); Draw . addText ( greenRect , \"Green Rect\" ); // (blue, the default color) rectangle with shadow and text XShape blueRect = Draw . drawRectangle ( currSlide , 140 , 220 , 50 , 25 ); Props . setProperty ( blueRect , \"Shadow\" , true ); Draw . addText ( blueRect , \"Blue Rect\" ); // connect the two rectangles; from the first shape to the second XShape connShape = Draw . addConnector ( currSlide , greenRect , Draw . CONNECT_BOTTOM , blueRect , Draw . CONNECT_TOP ); // Draw.setStyle(connShape, gStyles, \"objectwitharrow\"); Props . setProperty ( connShape , \"LineWidth\" , 100 ); // 1mm Props . setProperty ( connShape , \"FillColor\" , 7512015 ); // dark blue // report the glue points for the blue rectangle GluePoint2 [] gps = Draw . getGluePoints ( blueRect ); if ( gps != null ) { System . out . println ( \"Glue Points for blue rectangle\" ); for ( int i = 0 ; i < gps . length ; i ++ ) { Point pos = gps [ i ] . Position ; System . out . println ( \" Glue point \" + i + \": (\" + pos . X + \", \" + pos . Y + \")\" ); } } } // end of connectRectangles() Note that Draw.addText() is used to label the shapes. Draw.addConnector() links the two rectangles based on glue point names supplied as arguments. These names are defined in the Draw class: // in the Draw class public static final int CONNECT_TOP = 0 ; public static final int CONNECT_RIGHT = 1 ; public static final int CONNECT_BOTTOM = 2 ; public static final int CONNECT_LEFT = 3 ; Draw.addConnector() creates a ConnectorShape object and sets several of its properties. A simplified inheritance hierarchy for ConnectorShape is shown in Figure 2, with the parts important for connectors drawn in red. Figure 2. The ConnectorShape Hierarchy. Unlike many shapes, such as the RectangleShape, ConnectorShape doesn't have a FillProperties class; instead it has ConnectorProperties (see lodoc ConnectorProperties), which holds most of the properties used by Draw.addConnector(). addConnector() is defined as: // in the Draw class public static XShape addConnector ( XDrawPage slide , XShape shape1 , int fromConnect , XShape shape2 , int toConnect ) { XShape xConnector = addShape ( slide , \"ConnectorShape\" , 0 , 0 , 0 , 0 ); XPropertySet props = Lo . qi ( XPropertySet . class , xConnector ); try { props . setPropertyValue ( \"StartShape\" , shape1 ); props . setPropertyValue ( \"StartGluePointIndex\" , fromConnect ); props . setPropertyValue ( \"EndShape\" , shape2 ); props . setPropertyValue ( \"EndGluePointIndex\" , toConnect ); props . setPropertyValue ( \"EdgeKind\" , ConnectorType . STANDARD ); // STANDARD, CURVE, LINE, LINES } catch ( Exception e ) { System . out . println ( \"Could not connect the shapes\" ); } return xConnector ; } // end of addConnectorShape() Draw.addShape() is called with a (0,0) position, zero width and height. The real position and dimensions of the connector are set via its properties. \"StartShape\" and \"StartGluePointIndex\" specify the starting shape and its glue point, and \"EndShape\" and \"EndGluePointIndex\" define the ending shape and its glue point. \"EdgeKind\" specifies one of the connection types from Figure 1. Grouper.java's connectRectangles() has some code for retrieving an array of glue points for a shape: // in connectRectangles() in Grouper.java GluePoint2 [] gps = Draw . getGluePoints ( blueRect ); Draw.getGluePoints() converts the shape into an XGluePointsSupplier, and calls its getGluePoints() method to retrieve an indexed container of GluePoint2 objects. To simplify the access to the points data, this structure is returned as an array: public static GluePoint2 [] getGluePoints ( XShape shape ) { XGluePointsSupplier gpSupp = Lo . qi ( XGluePointsSupplier . class , shape ); XIndexContainer gluePts = gpSupp . getGluePoints (); int numGPs = gluePts . getCount (); // should be 4 by default if ( numGPs == 0 ) { System . out . println ( \"No glue points for this shape\" ); return null ; } GluePoint2 [] gps = new GluePoint2 [ numGPs ] ; for ( int i = 0 ; i < numGPs ; i ++ ) { try { gps [ i ] = Lo . qi ( GluePoint2 . class , gluePts . getByIndex ( i )); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not access glue point \" + i ); } } return gps ; } // end of getGluePoints() connectRectangles() doesn't do much with this data, aside from printing out each glue points coordinate. They're specified in 1/100 mm units relative to the center of the shape. Figure 1 shows that connectors don't have arrows, but this can be remedied by changing the connector's graphics style. The \"graphics\" style family is obtained by Info.getStyleContainer(), and passed to connectRectangles(): // in main() of Grouper.java XNameContainer gStyles = Info . getStyleContainer ( doc , \"graphics\" ); connectRectangles ( currSlide , gStyles ); Inside connectRectangles(), the connector's graphic style is changed to use arrows: // in connectRectangles() of Grouper.java Draw . setStyle ( connShape , gStyles , \"objectwitharrow\" ); Props . setProperty ( connShape , \"LineWidth\" , 50 ); // 0.5 mm Props . setProperty ( connShape , \"FillColor\" , 7512015 ); // dark blue The \"objectwitharrow\" style creates thick black arrows, with the head at the 'from' end of the connector (i.e. pointing at the green rectangle in my example). The line width can be adjusted by setting the shape's \"LineWidth\" property (which is defined in the LineProperties class), and its color with \"FillColor\". However, the change to \"FillColor\" has no effect for some reason, and so the arrow remains black, as shown in Figure 3. Figure 3. A Connector with an Arrow. The arrow head is too big and extends too far over the shape. This can be modified by changing the arrow name assigned to the connector's \"LineStartName\" property, and by setting \"LineStartCenter \" to false. The place to find names for arrow heads is the Line dialog box in LibreOffice's \"Line and Filling\" toolbar. The names appear in the \"Start styles\" combobox, as shown in Figure 4. Figure 4. The Arrow Styles in LibreOffice. If the properties are set to: // in connectRectangles() of Grouper.java Props . setProperty ( connShape , \"LineStartCenter\" , false ); Props . setProperty ( connShape , \"LineStartName\" , \"Short line arrow\" ); then the arrow head changes to that shown in Figure 5. Figure 5. A More Beautiful Arrow. An arrow can be added to the other end of the connector by adjusting its \"LineEndCenter\" and \"LineEndName\" properties. I found out about these \"objectwitharrow\" style properties by listing its property set returned by Info.getStyleProps(): // in main() of Grouper.java // print the \"objectwitharrow\" style in the \"graphics\" style family Props . showObjProps ( \"Objects with Arrow Graphics Style\" , Info . getStyleProps ( doc , \"graphics\" , \"objectwitharrow\" )); Alternatively, you can browse through the LineProperties class inherited by ConnectorShape (shown in Figure 2; use lodoc LineProperties ). There's a drawback to calling Info.getStyleProps() \u2013 it causes Office to crash when the Grouper.java exits. Office doesn't leave behind a zombie process, but an error message appears on-screen. 2. Shape Composition \u00b6 Office supports three kinds of shape composition for converting multiple shapes into a single shape. The new shape is automatically added to the page, and the old shapes are removed. The three techniques are: grouping: the shapes form a single shape without being changed in any way. Office has two mechanisms for grouping: the ShapeGroup shape and the deprecated XShapeGrouper interface; binding: this is similar to grouping, but also draws connector lines between the original shapes; combining: the new shape is built by changing the original shapes if they overlap each other. Office supports four combination styles, called merging, subtraction, intersection, and combination (the default). Grouper.java illustrates these techniques: // in main() of Grouper.java // : Size slideSize = Draw . getSlideSize ( currSlide ); int width = 40 ; int height = 20 ; int x = ( slideSize . Width * 3 ) / 4 - width / 2 ; int y1 = 20 ; int y2 = slideSize . Height / 2 - ( y1 + height ); // so separated // int y2 = 30; // so overlapping // create two ellipses, s1 and s2 XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); Draw . showShapesInfo ( currSlide ); // group/bind/combine the ellipses groupEllipses ( currSlide , s1 , s2 ); // bindEllipses(currSlide, s1, s2); // combineEllipses(currSlide, s1, s2); Draw . showShapesInfo ( currSlide ); // 2. combine some rectangles XShape compShape = combineRects ( doc , currSlide ); Draw . showShapesInfo ( currSlide ); Lo . delay ( 2000 ); // delay so user can see composition : Two ellipses are created, and positioned at the top-right of the page. Draw.showShapesInfo() is called to supply information about all the shapes on the page: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.EllipseShape; z-order: 3 Shape service: com.sun.star.drawing.EllipseShape; z-order: 4 The two rectangles and the connector listed first are the results of calling connectRectangles() earlier in Grouper.java. The two ellipses were just created in the code snipper given above. 2.1. Grouping Shapes \u00b6 Grouper.java calls groupEllipses() to group the two ellipses: // in Grouper.java XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); groupEllipses ( currSlide , s1 , s2 ); groupElllipses() is: // in Grouper.java private static void groupEllipses ( XDrawPage currSlide , XShape s1 , XShape s2 ) { XShape shapeGroup = Draw . addShape ( currSlide , \"GroupShape\" , 0 , 0 , 0 , 0 ); XShapes shapes = Lo . qi ( XShapes . class , shapeGroup ); shapes . add ( s1 ); shapes . add ( s2 ); } // end of groupEllipses() The GroupShape is converted to an XShapes interface so the two ellipses can be added to it. Note that GroupShape has no position or size; they are determined from the added shapes. An alternative approach for grouping is the deprecated XShapeGrouper, but it requires a few more lines of coding. An example can be found in the Developer's Guide, at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Drawings/Grouping,_Combining_and_Binding/ (use loguide \"Grouping, Combining and Binding\" ). The on-screen result of groupEllipses() is that the two ellipses become a single shape, as poorly shown in Figure 6. Figure 6. The Grouped Ellipses. There's no noticeable difference from two ellipses until you click on one of them, which causes both to be selected as a single shape. The change is better shown by a second call to Draw.showShapesInfo(), which reports: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.GroupShape; z-order: 3 The two ellipses have disappeared, replaced by a single GroupShape. 2.2. Binding Shapes \u00b6 Instead of groupEllipses(), it's possible to call bindEllipses() in Grouper.java: // in Grouper.java XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); bindEllipses ( currSlide , s1 , s2 ); The function is defined as: // in Grouper.java private static void bindEllipses ( XDrawPage currSlide , XShape s1 , XShape s2 ) { XShapes shapes = Lo . createInstanceMCF ( XShapes . class , \"com.sun.star.drawing.ShapeCollection\" ); shapes . add ( s1 ); shapes . add ( s2 ); XShapeBinder binder = Lo . qi ( XShapeBinder . class , currSlide ); binder . bind ( shapes ); } // end of bindEllipses() An empty XShapes shape is created, then filled with the component shapes. The shapes inside XShapes are converted into a single object XShapeBinder.bind(). The result is like the grouped ellipses but with a connector linking the shapes, as in Figure 7. Figure 7. The Bound Ellipses. The result is also visible in a call to Draw.showShapesInfo(): Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 The two ellipses have been replaced by a closed Bezier shape. In my opinion, it's easier to link shapes explicitly with connectors, using code like that in connectRectangles() from section 1. If the result needs to be a single shape, then grouping (not binding) can be applied to the shapes and the connector. 2.3. Combining Shapes with XShapeCombiner \u00b6 Grouper.java calls combineEllipse() to combine the two ellipses: // in Grouper.java XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); combineEllipses ( currSlide , s1 , s2 ); combineEllipses() employs the XShapeCombiner interface, which is used in the same way as XShapeBinder: // in Grouper.java private static void combineEllipses ( XDrawPage currSlide , XShape s1 , XShape s2 ) { XShapes shapes = Lo . createInstanceMCF ( XShapes . class , \"com.sun.star.drawing.ShapeCollection\" ); shapes . add ( s1 ); shapes . add ( s2 ); XShapeCombiner combiner = Lo . qi ( XShapeCombiner . class , currSlide ); combiner . combine ( shapes ); } // end of combineEllipses() The combined shape only differs from grouping if the two ellipses are initially overlapping. Figure 8 shows that the interesecting areas of the two shapes is removed from the combination. Figure 8. Combining Shapes with XShapeCombiner. The result is also visible in a call to Draw.showShapesInfo(): Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 The two ellipses have again been replaced by a closed Bezier shape . 2.4. Richer Shape Combination by Dispatch \u00b6 The drawback of XShapeCombiner that it only supports combination, not merging, subtraction, or intersection. I had to implement those effects by using dispatches, as shown in combineRects() in Grouper.java: // in Grouper.java private static XShape combineRects ( XComponent doc , XDrawPage currSlide ) { System . out . println ( \"\\nCombining rectangles ...\" ); XShape r1 = Draw . drawRectangle ( currSlide , 50 , 20 , 40 , 20 ); XShape r2 = Draw . drawRectangle ( currSlide , 70 , 25 , 40 , 20 ); XShapes shapes = Lo . createInstanceMCF ( XShapes . class , \"com.sun.star.drawing.ShapeCollection\" ); shapes . add ( r1 ); shapes . add ( r2 ); return Draw . combineShape ( doc , shapes , Draw . COMBINE ); // Draw.MERGE, Draw.SUBTRACT, Draw.INTERSECT, Draw.COMBINE } // end of combineRects() The dispatching is performed by Draw.combineShape(), which is passed an array of XShapes and a constant representing one of the four combining techniques. Figure 9 shows the results when the two rectangles created in combineRects() are combined in the different ways. Figure 9. The Four Ways of Combining Shapes. The merging change in Figure 9 is a bit subtle \u2013 notice that there's no black outline between the rectangles after merging; the merged object is a single shape. When combineRects() returns, Draw.showShapesInfo() reports: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 Shape service: com.sun.star.drawing.PolyPolygonShape; z-order: 4 The combined shape is a PolyPolygonShape, which means that the shape is created from multiple polygons. One tricky aspect of combining shapes with dispatches is that the shapes must be selected prior to the dispatch being sent. After the dispatch has been processed, the selection will have been changed to contain only the single new shape. This approach is implemented in combineShape(): public static XShape combineShape ( XComponent doc , XShapes shapes , int combineOp ) { // select the shapes for the dispatch to apply to XSelectionSupplier selSupp = Lo . qi ( XSelectionSupplier . class , GUI . getCurrentController ( doc )); selSupp . select ( shapes ); if ( combineOp == MERGE ) Lo . dispatchCmd ( \"Merge\" ); else if ( combineOp == INTERSECT ) Lo . dispatchCmd ( \"Intersect\" ); else if ( combineOp == SUBTRACT ) Lo . dispatchCmd ( \"Substract\" ); // misspelt! else if ( combineOp == COMBINE ) Lo . dispatchCmd ( \"Combine\" ); else { System . out . println ( \"Did not recognize op: \" + combineOp + \"; using merge\" ); Lo . dispatchCmd ( \"Merge\" ); } Lo . delay ( 500 ); // give time for dispatch to be processed // extract the new single shape from the modified selection XShapes xs = Lo . qi ( XShapes . class , selSupp . getSelection ()); XShape combinedShape = null ; try { combinedShape = Lo . qi ( XShape . class , xs . getByIndex ( 0 )); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not get combined shape\" ); } return combinedShape ; } // end of combineShape() The shapes are selected by adding them to an XSelectionSupplier. The requested dispatch is sent to the selection, and then the function briefly sleeps to ensure that the dispatch has been processed. An XShapes object is obtained from the changed selection, and the new PolyPolygonShape is extracted and returned. 3. Undoing a Grouping/Binding/Combining \u00b6 Any shapes which have been grouped, bound, or combined can be ungrouped, unbound, or uncombined. On screen the separated shapes will look the same as before, but may not have the same shape types as the originals. The main() function of Grouper.java shows how the combination of the two rectangles can be undone: // in Grouper.java : XShape compShape = combineRects ( doc , currSlide ); : XShapeCombiner combiner = Lo . qi ( XShapeCombiner . class , currSlide ); combiner . split ( compShape ); // split the rectangles Draw . showShapesInfo ( currSlide ); The combined rectangles shape is passed to XShapeCombiner.split() which removes the combined shape from the slide, replacing it by its components. Draw.showShapesInfo() shows this result: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 Shape service: com.sun.star.drawing.PolyPolygonShape; z-order: 4 Shape service: com.sun.star.drawing.PolyPolygonShape; z-order: 5 The last two shapes listed are the separated rectangles, but represented now by two PolyPolygonShapes. XShapeCombiner.split() only works on shapes that were combined using a \"COMBINE\" dispatch. Shapes that were composed using merging, subtraction, or intersection, can not be separated. For grouped and bound shapes, the methods for breaking apart a shape are XShapeGrouper.ungroup() and XShapeBinder.unbind(). For example: XShapeGrouper grouper = Lo . qi ( XShapeGrouper . class , currSlide ); grouper . ungroup ( compShape ); 4. Bezier Curves \u00b6 The simplest Bezier curve is defined using four coordinates, as in Figure 10. Figure 10. A Cubic Bezier Curve. P0 and P3 are the start and end points of the curve (also called nodes or anchors), and P1 and P2 are control points, which specify how the curve bends between the start and finish. A curve using four points in this way is a cubic Bezier curve, the default type in Office. The code for generating Figure 10 is in drawCurve() in BezierBuilder.java: // in drawCurve() in BezierBuilder.java private static XShape drawCurve ( XDrawPage currSlide ) { Point [] pathPts = new Point [ 4 ] ; PolygonFlags [] pathFlags = new PolygonFlags [ 4 ] ; pathPts [ 0 ] = new Point ( 1000 , 2500 ); pathFlags [ 0 ] = PolygonFlags . NORMAL ; pathPts [ 1 ] = new Point ( 1000 , 1000 ); // control point pathFlags [ 1 ] = PolygonFlags . CONTROL ; pathPts [ 2 ] = new Point ( 4000 , 1000 ); // control point pathFlags [ 2 ] = PolygonFlags . CONTROL ; pathPts [ 3 ] = new Point ( 4000 , 2500 ); pathFlags [ 3 ] = PolygonFlags . NORMAL ; return Draw . drawBezier ( currSlide , pathPts , pathFlags , true ); } // end of drawCurve() Most of the curve generation is done by Draw.drawBezier(), but the programmer must still define two arrays and a boolean. The pathPts[] array holds the four coordinates, and pathFlags[] specify their types. The final boolean argument of Draw.drawBezier() indicates whether the generated curve is to be open or closed. Figure 11 shows how the curve is rendered. Figure 11. The Drawn Bezier Curve. Draw.drawBezier() uses the isOpen boolean to decide whether to create an OpenBezierShape or a ClosedBezierShape. Then it fills a PolyPolygonBezierCoords data structure with the coordinates and flags before assigning the structure to the shape's \"PolyPolygonBezier\" property: public static XShape drawBezier ( XDrawPage slide , Point [] pts , PolygonFlags [] flags , boolean isOpen ) { if ( pts . length != flags . length ) { System . out . println ( \"Mismatch in lengths of points and flags array\" ); return null ; } String bezierType = isOpen ? \"OpenBezierShape\" : \"ClosedBezierShape\" ; XShape bezierPoly = addShape ( slide , bezierType , 0 , 0 , 0 , 0 ); // create space for one Bezier shape PolyPolygonBezierCoords aCoords = new PolyPolygonBezierCoords (); // for shapes formed by one *or more* Bezier polygons aCoords . Coordinates = new Point [ 1 ][] ; aCoords . Flags = new PolygonFlags [ 1 ][] ; aCoords . Coordinates [ 0 ] = pts ; aCoords . Flags [ 0 ] = flags ; Props . setProperty ( bezierPoly , \"PolyPolygonBezier\" , aCoords ); return bezierPoly ; } // end of drawBezier() A PolyPolygonBezierCoords object can store multiple Bezier curves, but Draw.drawBezier() only assigns one curve to it. Each curve is defined by an array of coordinates and a set of flags. 4.1. Drawing a Simple Bezier \u00b6 The hard part of writing drawCurve() in BezierBuilder.java is knowing what coordinates to put into pathPts[]. Probably the 'easiest' solution is to use a SVG editor to draw the curve by hand, and then extract the coordinates from the generated file. As the quotes around 'easiest' suggest, this isn't actually that easy since a curve can be much more complex than my example. A real example may be composed from multiple curves, straight lines, quadratic Bezier sub-curves (i.e. ones which use only a single control point between anchors), arcs, and smoothing. The official specification can be found at https://w3.org/TR/SVG/paths.html , and there are many tutorials on the topic, such as https://svgbasics.com/curves.html and https://w3schools.com/svg/svg_path.asp . Even if you're careful and only draw curves like mine, the generated SVG is not quite the same as the coordinates used by Office's PolyPolygonBezierCoords. However, the translation is fairly straightforward, once you've done one or two. One good online site for drawing simple curves is https://blogs.sitepointstatic.com/examples/tech/svg-curves/cubic-curve.html , developed by Craig Buckler. It restricts you to manipulating a curve made up of two anchors and two controls, like mine, and displays the corresponding SVG path data, as in Figure 12. Figure 11. Drawing a Curve Online. Figure 12 is a bit small \u2013 the path data at the top-right is: The path contains two operations: \"M\" and \"C\". \"M\" moves the drawing point to a specified coordinate (in this case (100, 250)). The \"C\" is followed by three coordinates: (100,100), (400, 100), and (400, 250). The first two are the control points and the last is the end point of the curve. There's no start point since the result of the \"M\" operation is used by default. Translating this to Office coordinates means using the \"M\" coordinate as the start point, and applying some scaling of the values to make the curve visible on the page. Remember that Office uses 1/100 mm units for drawing. A simple scale factor is to multiply all the numbers by 10, producing: (1000, 2500), (1000,1000), (4000, 1000), and (4000, 2500). These are the numbers in Figure 10, and utilized by drawCurve() in BezierBuilder.java. 4.2. Drawing a Complicated Bezier Curve \u00b6 What if you want to draw a curve of more than four points? I use Office's Draw application to draw the curve manually, save it as an SVG file, and then extract the path coordinates from that file. I use Draw because it generates path coordinates using 1/100 mm units, which saves me from having to do any scaling. You might be thinking that if Draw can generate SVG data then why not just import that data as a Bezier curve into the code? Unfortunately, this isn't quite possible at present \u2013 it's true that you can import an SVG file into Office, but it's stored as an image. In particular, it's available as a GraphicObjectShape not a OpenBezierShape or a ClosedBezierShape. This means that you cannot examine or change its points. As an example of my approach, consider the complex curve in Figure 13 which I drew in Draw and exported as an SVG file. Figure 13. A Complex Bezier Curve, manually produced in Draw. Details on how to draw Bezier curves are explained in the Draw user guide, at the end of section 11 on advanced techniques. The SVG file format is XML-based, so the saved file can be opened by a text editor. The coordinate information for this OpenBezierShape is near the end of the file: <g class=\"com.sun.star.drawing.OpenBezierShape\"> <g id=\"id3\"> <path fill=\"none\" stroke=\"rgb(0,0,0)\" d=\"M 5586,13954 C 5713,13954 4443,2905 8253,7477 12063,12049 8634,19415 15619,10906 22604,2397 11682,1381 10285,6334 8888,11287 21207,21447 8253,17002 - 4701,12557 11174,15986 11174,15986\"/> </g> </g> The path consists of a single \"M\" operation, and a long \"C\" operation, which should be read as a series of cubic Bezier curves. Each curve in the \"C\" list is made from three coordinates, since the start point is implicitly given by the initial \"M\" move or the end point of the previous curve in the list. Copy the data and save it as two lines in a text file (e.g. in bpts2.txt): M 5586 , 13954 C 5713 , 13954 4443 , 2905 8253 , 7477 12063 , 12049 8634 , 19415 15619 , 10906 22604 , 2397 11682 , 1381 10285 , 6334 8888 , 11287 21207 , 21447 8253 , 17002 - 4701 , 12557 11174 , 15986 11174 , 15986 BuildBezier.java contains some functions for reading in this data and building the arrays required by Draw.drawBezier(). So when the following is called: run BezierBuilder bpts2 . txt the curve shown in Figure 14 appears on a page. Figure 14. The Curve Drawn by BuildBezier.java The BuildBezier.java data-reading functions can only handle a single \"M\" and \"C\" operation. If the curve you draw has straight lines, arcs, smoothing, or multiple parts, then the SVG file will contain operations that my code cannot process. However, the data-reading functions do recognize the \"Z\" operation, which specifies that the curve should be closed. If \"Z\" is added as a new line at the end of the bpts2.txt, then the closed Bezier curve in Figure 15 is generated. Figure 15. The Closed Curve Drawn by BuildBezier.java","title":"Chapter 15. Complex Shapes"},{"location":"15-Complex_Shapes.html#chapter-15-complex-shapes","text":"Topics Connecting Two Rectangles; Shape Composition (grouping, binding, and combining); Combining with Dispatches; Undoing Composition; Bezier Curves (simple and complex) Example folders: \"Draw Tests\" and \"Utils\" This chapter looks at three complex topics involving shapes: connecting rectangles, shape composition, and drawing Bezier curves.","title":"Chapter 15. Complex Shapes"},{"location":"15-Complex_Shapes.html#1-connecting-two-rectangles","text":"A line can be drawn between two shapes using a LineShape. But it's much easier to join the shapes with a ConnectorShape, which can be attached precisely by linking its two ends to glue points on the shapes. Glue points are the little blue circles which appear on a shape when you use connectors in Draw. They occur in the middle of the upper, lower, left, and right sides of the shape, although it's possible to create extra ones. By default a connector is drawn using multiple horizontal and vertical lines. It's possible to change this to a curve, a single line, or a connection made up of multiple lines which are mostly horizontal and vertical. Figure 1 shows the four types linking the same two rectangles. Figure 1. Different Styles of Connector. Grouper.java contains code for generating the top-left example in Figure 1: // Grouper.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createDrawDoc ( loader ); if ( doc == null ) { System . out . println ( \"Draw doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 1000 ); // need delay or zoom may not occur GUI . zoom ( doc , GUI . ENTIRE_PAGE ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); //access first page System . out . println ( \"\\nConnecting rectangles ...\" ); XNameContainer gStyles = Info . getStyleContainer ( doc , \"graphics\" ); connectRectangles ( currSlide , gStyles ); : // code for grouping, binding, and combining shape, : // discussed later Lo . saveDoc ( doc , \"grouper.odg\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } The connectRectangles() function creates two labeled rectangles, and links them with a standard connector. The connector starts on the bottom edge of the green rectangle and finishes at the top edge of the blue one (as shown in the top-left of Figure 1). The method also prints out some information about the glue points of the blue rectangle. // in Grouper.java private static void connectRectangles ( XDrawPage currSlide , XNameContainer gStyles ) { // dark green rectangle with shadow and text XShape greenRect = Draw . drawRectangle ( currSlide , 70 , 180 , 50 , 25 ); Props . setProperty ( greenRect , \"FillColor\" , Lo . getColorInt ( java . awt . Color . GREEN . darker ())); Props . setProperty ( greenRect , \"Shadow\" , true ); Draw . addText ( greenRect , \"Green Rect\" ); // (blue, the default color) rectangle with shadow and text XShape blueRect = Draw . drawRectangle ( currSlide , 140 , 220 , 50 , 25 ); Props . setProperty ( blueRect , \"Shadow\" , true ); Draw . addText ( blueRect , \"Blue Rect\" ); // connect the two rectangles; from the first shape to the second XShape connShape = Draw . addConnector ( currSlide , greenRect , Draw . CONNECT_BOTTOM , blueRect , Draw . CONNECT_TOP ); // Draw.setStyle(connShape, gStyles, \"objectwitharrow\"); Props . setProperty ( connShape , \"LineWidth\" , 100 ); // 1mm Props . setProperty ( connShape , \"FillColor\" , 7512015 ); // dark blue // report the glue points for the blue rectangle GluePoint2 [] gps = Draw . getGluePoints ( blueRect ); if ( gps != null ) { System . out . println ( \"Glue Points for blue rectangle\" ); for ( int i = 0 ; i < gps . length ; i ++ ) { Point pos = gps [ i ] . Position ; System . out . println ( \" Glue point \" + i + \": (\" + pos . X + \", \" + pos . Y + \")\" ); } } } // end of connectRectangles() Note that Draw.addText() is used to label the shapes. Draw.addConnector() links the two rectangles based on glue point names supplied as arguments. These names are defined in the Draw class: // in the Draw class public static final int CONNECT_TOP = 0 ; public static final int CONNECT_RIGHT = 1 ; public static final int CONNECT_BOTTOM = 2 ; public static final int CONNECT_LEFT = 3 ; Draw.addConnector() creates a ConnectorShape object and sets several of its properties. A simplified inheritance hierarchy for ConnectorShape is shown in Figure 2, with the parts important for connectors drawn in red. Figure 2. The ConnectorShape Hierarchy. Unlike many shapes, such as the RectangleShape, ConnectorShape doesn't have a FillProperties class; instead it has ConnectorProperties (see lodoc ConnectorProperties), which holds most of the properties used by Draw.addConnector(). addConnector() is defined as: // in the Draw class public static XShape addConnector ( XDrawPage slide , XShape shape1 , int fromConnect , XShape shape2 , int toConnect ) { XShape xConnector = addShape ( slide , \"ConnectorShape\" , 0 , 0 , 0 , 0 ); XPropertySet props = Lo . qi ( XPropertySet . class , xConnector ); try { props . setPropertyValue ( \"StartShape\" , shape1 ); props . setPropertyValue ( \"StartGluePointIndex\" , fromConnect ); props . setPropertyValue ( \"EndShape\" , shape2 ); props . setPropertyValue ( \"EndGluePointIndex\" , toConnect ); props . setPropertyValue ( \"EdgeKind\" , ConnectorType . STANDARD ); // STANDARD, CURVE, LINE, LINES } catch ( Exception e ) { System . out . println ( \"Could not connect the shapes\" ); } return xConnector ; } // end of addConnectorShape() Draw.addShape() is called with a (0,0) position, zero width and height. The real position and dimensions of the connector are set via its properties. \"StartShape\" and \"StartGluePointIndex\" specify the starting shape and its glue point, and \"EndShape\" and \"EndGluePointIndex\" define the ending shape and its glue point. \"EdgeKind\" specifies one of the connection types from Figure 1. Grouper.java's connectRectangles() has some code for retrieving an array of glue points for a shape: // in connectRectangles() in Grouper.java GluePoint2 [] gps = Draw . getGluePoints ( blueRect ); Draw.getGluePoints() converts the shape into an XGluePointsSupplier, and calls its getGluePoints() method to retrieve an indexed container of GluePoint2 objects. To simplify the access to the points data, this structure is returned as an array: public static GluePoint2 [] getGluePoints ( XShape shape ) { XGluePointsSupplier gpSupp = Lo . qi ( XGluePointsSupplier . class , shape ); XIndexContainer gluePts = gpSupp . getGluePoints (); int numGPs = gluePts . getCount (); // should be 4 by default if ( numGPs == 0 ) { System . out . println ( \"No glue points for this shape\" ); return null ; } GluePoint2 [] gps = new GluePoint2 [ numGPs ] ; for ( int i = 0 ; i < numGPs ; i ++ ) { try { gps [ i ] = Lo . qi ( GluePoint2 . class , gluePts . getByIndex ( i )); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not access glue point \" + i ); } } return gps ; } // end of getGluePoints() connectRectangles() doesn't do much with this data, aside from printing out each glue points coordinate. They're specified in 1/100 mm units relative to the center of the shape. Figure 1 shows that connectors don't have arrows, but this can be remedied by changing the connector's graphics style. The \"graphics\" style family is obtained by Info.getStyleContainer(), and passed to connectRectangles(): // in main() of Grouper.java XNameContainer gStyles = Info . getStyleContainer ( doc , \"graphics\" ); connectRectangles ( currSlide , gStyles ); Inside connectRectangles(), the connector's graphic style is changed to use arrows: // in connectRectangles() of Grouper.java Draw . setStyle ( connShape , gStyles , \"objectwitharrow\" ); Props . setProperty ( connShape , \"LineWidth\" , 50 ); // 0.5 mm Props . setProperty ( connShape , \"FillColor\" , 7512015 ); // dark blue The \"objectwitharrow\" style creates thick black arrows, with the head at the 'from' end of the connector (i.e. pointing at the green rectangle in my example). The line width can be adjusted by setting the shape's \"LineWidth\" property (which is defined in the LineProperties class), and its color with \"FillColor\". However, the change to \"FillColor\" has no effect for some reason, and so the arrow remains black, as shown in Figure 3. Figure 3. A Connector with an Arrow. The arrow head is too big and extends too far over the shape. This can be modified by changing the arrow name assigned to the connector's \"LineStartName\" property, and by setting \"LineStartCenter \" to false. The place to find names for arrow heads is the Line dialog box in LibreOffice's \"Line and Filling\" toolbar. The names appear in the \"Start styles\" combobox, as shown in Figure 4. Figure 4. The Arrow Styles in LibreOffice. If the properties are set to: // in connectRectangles() of Grouper.java Props . setProperty ( connShape , \"LineStartCenter\" , false ); Props . setProperty ( connShape , \"LineStartName\" , \"Short line arrow\" ); then the arrow head changes to that shown in Figure 5. Figure 5. A More Beautiful Arrow. An arrow can be added to the other end of the connector by adjusting its \"LineEndCenter\" and \"LineEndName\" properties. I found out about these \"objectwitharrow\" style properties by listing its property set returned by Info.getStyleProps(): // in main() of Grouper.java // print the \"objectwitharrow\" style in the \"graphics\" style family Props . showObjProps ( \"Objects with Arrow Graphics Style\" , Info . getStyleProps ( doc , \"graphics\" , \"objectwitharrow\" )); Alternatively, you can browse through the LineProperties class inherited by ConnectorShape (shown in Figure 2; use lodoc LineProperties ). There's a drawback to calling Info.getStyleProps() \u2013 it causes Office to crash when the Grouper.java exits. Office doesn't leave behind a zombie process, but an error message appears on-screen.","title":"1.  Connecting Two Rectangles"},{"location":"15-Complex_Shapes.html#2-shape-composition","text":"Office supports three kinds of shape composition for converting multiple shapes into a single shape. The new shape is automatically added to the page, and the old shapes are removed. The three techniques are: grouping: the shapes form a single shape without being changed in any way. Office has two mechanisms for grouping: the ShapeGroup shape and the deprecated XShapeGrouper interface; binding: this is similar to grouping, but also draws connector lines between the original shapes; combining: the new shape is built by changing the original shapes if they overlap each other. Office supports four combination styles, called merging, subtraction, intersection, and combination (the default). Grouper.java illustrates these techniques: // in main() of Grouper.java // : Size slideSize = Draw . getSlideSize ( currSlide ); int width = 40 ; int height = 20 ; int x = ( slideSize . Width * 3 ) / 4 - width / 2 ; int y1 = 20 ; int y2 = slideSize . Height / 2 - ( y1 + height ); // so separated // int y2 = 30; // so overlapping // create two ellipses, s1 and s2 XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); Draw . showShapesInfo ( currSlide ); // group/bind/combine the ellipses groupEllipses ( currSlide , s1 , s2 ); // bindEllipses(currSlide, s1, s2); // combineEllipses(currSlide, s1, s2); Draw . showShapesInfo ( currSlide ); // 2. combine some rectangles XShape compShape = combineRects ( doc , currSlide ); Draw . showShapesInfo ( currSlide ); Lo . delay ( 2000 ); // delay so user can see composition : Two ellipses are created, and positioned at the top-right of the page. Draw.showShapesInfo() is called to supply information about all the shapes on the page: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.EllipseShape; z-order: 3 Shape service: com.sun.star.drawing.EllipseShape; z-order: 4 The two rectangles and the connector listed first are the results of calling connectRectangles() earlier in Grouper.java. The two ellipses were just created in the code snipper given above.","title":"2.  Shape Composition"},{"location":"15-Complex_Shapes.html#21-grouping-shapes","text":"Grouper.java calls groupEllipses() to group the two ellipses: // in Grouper.java XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); groupEllipses ( currSlide , s1 , s2 ); groupElllipses() is: // in Grouper.java private static void groupEllipses ( XDrawPage currSlide , XShape s1 , XShape s2 ) { XShape shapeGroup = Draw . addShape ( currSlide , \"GroupShape\" , 0 , 0 , 0 , 0 ); XShapes shapes = Lo . qi ( XShapes . class , shapeGroup ); shapes . add ( s1 ); shapes . add ( s2 ); } // end of groupEllipses() The GroupShape is converted to an XShapes interface so the two ellipses can be added to it. Note that GroupShape has no position or size; they are determined from the added shapes. An alternative approach for grouping is the deprecated XShapeGrouper, but it requires a few more lines of coding. An example can be found in the Developer's Guide, at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Drawings/Grouping,_Combining_and_Binding/ (use loguide \"Grouping, Combining and Binding\" ). The on-screen result of groupEllipses() is that the two ellipses become a single shape, as poorly shown in Figure 6. Figure 6. The Grouped Ellipses. There's no noticeable difference from two ellipses until you click on one of them, which causes both to be selected as a single shape. The change is better shown by a second call to Draw.showShapesInfo(), which reports: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.GroupShape; z-order: 3 The two ellipses have disappeared, replaced by a single GroupShape.","title":"2.1.  Grouping Shapes"},{"location":"15-Complex_Shapes.html#22-binding-shapes","text":"Instead of groupEllipses(), it's possible to call bindEllipses() in Grouper.java: // in Grouper.java XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); bindEllipses ( currSlide , s1 , s2 ); The function is defined as: // in Grouper.java private static void bindEllipses ( XDrawPage currSlide , XShape s1 , XShape s2 ) { XShapes shapes = Lo . createInstanceMCF ( XShapes . class , \"com.sun.star.drawing.ShapeCollection\" ); shapes . add ( s1 ); shapes . add ( s2 ); XShapeBinder binder = Lo . qi ( XShapeBinder . class , currSlide ); binder . bind ( shapes ); } // end of bindEllipses() An empty XShapes shape is created, then filled with the component shapes. The shapes inside XShapes are converted into a single object XShapeBinder.bind(). The result is like the grouped ellipses but with a connector linking the shapes, as in Figure 7. Figure 7. The Bound Ellipses. The result is also visible in a call to Draw.showShapesInfo(): Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 The two ellipses have been replaced by a closed Bezier shape. In my opinion, it's easier to link shapes explicitly with connectors, using code like that in connectRectangles() from section 1. If the result needs to be a single shape, then grouping (not binding) can be applied to the shapes and the connector.","title":"2.2.  Binding Shapes"},{"location":"15-Complex_Shapes.html#23-combining-shapes-with-xshapecombiner","text":"Grouper.java calls combineEllipse() to combine the two ellipses: // in Grouper.java XShape s1 = Draw . drawEllipse ( currSlide , x , y1 , width , height ); XShape s2 = Draw . drawEllipse ( currSlide , x , y2 , width , height ); combineEllipses ( currSlide , s1 , s2 ); combineEllipses() employs the XShapeCombiner interface, which is used in the same way as XShapeBinder: // in Grouper.java private static void combineEllipses ( XDrawPage currSlide , XShape s1 , XShape s2 ) { XShapes shapes = Lo . createInstanceMCF ( XShapes . class , \"com.sun.star.drawing.ShapeCollection\" ); shapes . add ( s1 ); shapes . add ( s2 ); XShapeCombiner combiner = Lo . qi ( XShapeCombiner . class , currSlide ); combiner . combine ( shapes ); } // end of combineEllipses() The combined shape only differs from grouping if the two ellipses are initially overlapping. Figure 8 shows that the interesecting areas of the two shapes is removed from the combination. Figure 8. Combining Shapes with XShapeCombiner. The result is also visible in a call to Draw.showShapesInfo(): Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 The two ellipses have again been replaced by a closed Bezier shape .","title":"2.3.  Combining Shapes with XShapeCombiner"},{"location":"15-Complex_Shapes.html#24-richer-shape-combination-by-dispatch","text":"The drawback of XShapeCombiner that it only supports combination, not merging, subtraction, or intersection. I had to implement those effects by using dispatches, as shown in combineRects() in Grouper.java: // in Grouper.java private static XShape combineRects ( XComponent doc , XDrawPage currSlide ) { System . out . println ( \"\\nCombining rectangles ...\" ); XShape r1 = Draw . drawRectangle ( currSlide , 50 , 20 , 40 , 20 ); XShape r2 = Draw . drawRectangle ( currSlide , 70 , 25 , 40 , 20 ); XShapes shapes = Lo . createInstanceMCF ( XShapes . class , \"com.sun.star.drawing.ShapeCollection\" ); shapes . add ( r1 ); shapes . add ( r2 ); return Draw . combineShape ( doc , shapes , Draw . COMBINE ); // Draw.MERGE, Draw.SUBTRACT, Draw.INTERSECT, Draw.COMBINE } // end of combineRects() The dispatching is performed by Draw.combineShape(), which is passed an array of XShapes and a constant representing one of the four combining techniques. Figure 9 shows the results when the two rectangles created in combineRects() are combined in the different ways. Figure 9. The Four Ways of Combining Shapes. The merging change in Figure 9 is a bit subtle \u2013 notice that there's no black outline between the rectangles after merging; the merged object is a single shape. When combineRects() returns, Draw.showShapesInfo() reports: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 Shape service: com.sun.star.drawing.PolyPolygonShape; z-order: 4 The combined shape is a PolyPolygonShape, which means that the shape is created from multiple polygons. One tricky aspect of combining shapes with dispatches is that the shapes must be selected prior to the dispatch being sent. After the dispatch has been processed, the selection will have been changed to contain only the single new shape. This approach is implemented in combineShape(): public static XShape combineShape ( XComponent doc , XShapes shapes , int combineOp ) { // select the shapes for the dispatch to apply to XSelectionSupplier selSupp = Lo . qi ( XSelectionSupplier . class , GUI . getCurrentController ( doc )); selSupp . select ( shapes ); if ( combineOp == MERGE ) Lo . dispatchCmd ( \"Merge\" ); else if ( combineOp == INTERSECT ) Lo . dispatchCmd ( \"Intersect\" ); else if ( combineOp == SUBTRACT ) Lo . dispatchCmd ( \"Substract\" ); // misspelt! else if ( combineOp == COMBINE ) Lo . dispatchCmd ( \"Combine\" ); else { System . out . println ( \"Did not recognize op: \" + combineOp + \"; using merge\" ); Lo . dispatchCmd ( \"Merge\" ); } Lo . delay ( 500 ); // give time for dispatch to be processed // extract the new single shape from the modified selection XShapes xs = Lo . qi ( XShapes . class , selSupp . getSelection ()); XShape combinedShape = null ; try { combinedShape = Lo . qi ( XShape . class , xs . getByIndex ( 0 )); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not get combined shape\" ); } return combinedShape ; } // end of combineShape() The shapes are selected by adding them to an XSelectionSupplier. The requested dispatch is sent to the selection, and then the function briefly sleeps to ensure that the dispatch has been processed. An XShapes object is obtained from the changed selection, and the new PolyPolygonShape is extracted and returned.","title":"2.4.  Richer Shape Combination by Dispatch"},{"location":"15-Complex_Shapes.html#3-undoing-a-groupingbindingcombining","text":"Any shapes which have been grouped, bound, or combined can be ungrouped, unbound, or uncombined. On screen the separated shapes will look the same as before, but may not have the same shape types as the originals. The main() function of Grouper.java shows how the combination of the two rectangles can be undone: // in Grouper.java : XShape compShape = combineRects ( doc , currSlide ); : XShapeCombiner combiner = Lo . qi ( XShapeCombiner . class , currSlide ); combiner . split ( compShape ); // split the rectangles Draw . showShapesInfo ( currSlide ); The combined rectangles shape is passed to XShapeCombiner.split() which removes the combined shape from the slide, replacing it by its components. Draw.showShapesInfo() shows this result: Draw Page shapes: Shape service: com.sun.star.drawing.RectangleShape; z-order: 0 Shape service: com.sun.star.drawing.RectangleShape; z-order: 1 Shape service: com.sun.star.drawing.ConnectorShape; z-order: 2 Shape service: com.sun.star.drawing.ClosedBezierShape; z-order: 3 Shape service: com.sun.star.drawing.PolyPolygonShape; z-order: 4 Shape service: com.sun.star.drawing.PolyPolygonShape; z-order: 5 The last two shapes listed are the separated rectangles, but represented now by two PolyPolygonShapes. XShapeCombiner.split() only works on shapes that were combined using a \"COMBINE\" dispatch. Shapes that were composed using merging, subtraction, or intersection, can not be separated. For grouped and bound shapes, the methods for breaking apart a shape are XShapeGrouper.ungroup() and XShapeBinder.unbind(). For example: XShapeGrouper grouper = Lo . qi ( XShapeGrouper . class , currSlide ); grouper . ungroup ( compShape );","title":"3.  Undoing a Grouping/Binding/Combining"},{"location":"15-Complex_Shapes.html#4-bezier-curves","text":"The simplest Bezier curve is defined using four coordinates, as in Figure 10. Figure 10. A Cubic Bezier Curve. P0 and P3 are the start and end points of the curve (also called nodes or anchors), and P1 and P2 are control points, which specify how the curve bends between the start and finish. A curve using four points in this way is a cubic Bezier curve, the default type in Office. The code for generating Figure 10 is in drawCurve() in BezierBuilder.java: // in drawCurve() in BezierBuilder.java private static XShape drawCurve ( XDrawPage currSlide ) { Point [] pathPts = new Point [ 4 ] ; PolygonFlags [] pathFlags = new PolygonFlags [ 4 ] ; pathPts [ 0 ] = new Point ( 1000 , 2500 ); pathFlags [ 0 ] = PolygonFlags . NORMAL ; pathPts [ 1 ] = new Point ( 1000 , 1000 ); // control point pathFlags [ 1 ] = PolygonFlags . CONTROL ; pathPts [ 2 ] = new Point ( 4000 , 1000 ); // control point pathFlags [ 2 ] = PolygonFlags . CONTROL ; pathPts [ 3 ] = new Point ( 4000 , 2500 ); pathFlags [ 3 ] = PolygonFlags . NORMAL ; return Draw . drawBezier ( currSlide , pathPts , pathFlags , true ); } // end of drawCurve() Most of the curve generation is done by Draw.drawBezier(), but the programmer must still define two arrays and a boolean. The pathPts[] array holds the four coordinates, and pathFlags[] specify their types. The final boolean argument of Draw.drawBezier() indicates whether the generated curve is to be open or closed. Figure 11 shows how the curve is rendered. Figure 11. The Drawn Bezier Curve. Draw.drawBezier() uses the isOpen boolean to decide whether to create an OpenBezierShape or a ClosedBezierShape. Then it fills a PolyPolygonBezierCoords data structure with the coordinates and flags before assigning the structure to the shape's \"PolyPolygonBezier\" property: public static XShape drawBezier ( XDrawPage slide , Point [] pts , PolygonFlags [] flags , boolean isOpen ) { if ( pts . length != flags . length ) { System . out . println ( \"Mismatch in lengths of points and flags array\" ); return null ; } String bezierType = isOpen ? \"OpenBezierShape\" : \"ClosedBezierShape\" ; XShape bezierPoly = addShape ( slide , bezierType , 0 , 0 , 0 , 0 ); // create space for one Bezier shape PolyPolygonBezierCoords aCoords = new PolyPolygonBezierCoords (); // for shapes formed by one *or more* Bezier polygons aCoords . Coordinates = new Point [ 1 ][] ; aCoords . Flags = new PolygonFlags [ 1 ][] ; aCoords . Coordinates [ 0 ] = pts ; aCoords . Flags [ 0 ] = flags ; Props . setProperty ( bezierPoly , \"PolyPolygonBezier\" , aCoords ); return bezierPoly ; } // end of drawBezier() A PolyPolygonBezierCoords object can store multiple Bezier curves, but Draw.drawBezier() only assigns one curve to it. Each curve is defined by an array of coordinates and a set of flags.","title":"4.  Bezier Curves"},{"location":"15-Complex_Shapes.html#41-drawing-a-simple-bezier","text":"The hard part of writing drawCurve() in BezierBuilder.java is knowing what coordinates to put into pathPts[]. Probably the 'easiest' solution is to use a SVG editor to draw the curve by hand, and then extract the coordinates from the generated file. As the quotes around 'easiest' suggest, this isn't actually that easy since a curve can be much more complex than my example. A real example may be composed from multiple curves, straight lines, quadratic Bezier sub-curves (i.e. ones which use only a single control point between anchors), arcs, and smoothing. The official specification can be found at https://w3.org/TR/SVG/paths.html , and there are many tutorials on the topic, such as https://svgbasics.com/curves.html and https://w3schools.com/svg/svg_path.asp . Even if you're careful and only draw curves like mine, the generated SVG is not quite the same as the coordinates used by Office's PolyPolygonBezierCoords. However, the translation is fairly straightforward, once you've done one or two. One good online site for drawing simple curves is https://blogs.sitepointstatic.com/examples/tech/svg-curves/cubic-curve.html , developed by Craig Buckler. It restricts you to manipulating a curve made up of two anchors and two controls, like mine, and displays the corresponding SVG path data, as in Figure 12. Figure 11. Drawing a Curve Online. Figure 12 is a bit small \u2013 the path data at the top-right is: The path contains two operations: \"M\" and \"C\". \"M\" moves the drawing point to a specified coordinate (in this case (100, 250)). The \"C\" is followed by three coordinates: (100,100), (400, 100), and (400, 250). The first two are the control points and the last is the end point of the curve. There's no start point since the result of the \"M\" operation is used by default. Translating this to Office coordinates means using the \"M\" coordinate as the start point, and applying some scaling of the values to make the curve visible on the page. Remember that Office uses 1/100 mm units for drawing. A simple scale factor is to multiply all the numbers by 10, producing: (1000, 2500), (1000,1000), (4000, 1000), and (4000, 2500). These are the numbers in Figure 10, and utilized by drawCurve() in BezierBuilder.java.","title":"4.1.  Drawing a Simple Bezier"},{"location":"15-Complex_Shapes.html#42-drawing-a-complicated-bezier-curve","text":"What if you want to draw a curve of more than four points? I use Office's Draw application to draw the curve manually, save it as an SVG file, and then extract the path coordinates from that file. I use Draw because it generates path coordinates using 1/100 mm units, which saves me from having to do any scaling. You might be thinking that if Draw can generate SVG data then why not just import that data as a Bezier curve into the code? Unfortunately, this isn't quite possible at present \u2013 it's true that you can import an SVG file into Office, but it's stored as an image. In particular, it's available as a GraphicObjectShape not a OpenBezierShape or a ClosedBezierShape. This means that you cannot examine or change its points. As an example of my approach, consider the complex curve in Figure 13 which I drew in Draw and exported as an SVG file. Figure 13. A Complex Bezier Curve, manually produced in Draw. Details on how to draw Bezier curves are explained in the Draw user guide, at the end of section 11 on advanced techniques. The SVG file format is XML-based, so the saved file can be opened by a text editor. The coordinate information for this OpenBezierShape is near the end of the file: <g class=\"com.sun.star.drawing.OpenBezierShape\"> <g id=\"id3\"> <path fill=\"none\" stroke=\"rgb(0,0,0)\" d=\"M 5586,13954 C 5713,13954 4443,2905 8253,7477 12063,12049 8634,19415 15619,10906 22604,2397 11682,1381 10285,6334 8888,11287 21207,21447 8253,17002 - 4701,12557 11174,15986 11174,15986\"/> </g> </g> The path consists of a single \"M\" operation, and a long \"C\" operation, which should be read as a series of cubic Bezier curves. Each curve in the \"C\" list is made from three coordinates, since the start point is implicitly given by the initial \"M\" move or the end point of the previous curve in the list. Copy the data and save it as two lines in a text file (e.g. in bpts2.txt): M 5586 , 13954 C 5713 , 13954 4443 , 2905 8253 , 7477 12063 , 12049 8634 , 19415 15619 , 10906 22604 , 2397 11682 , 1381 10285 , 6334 8888 , 11287 21207 , 21447 8253 , 17002 - 4701 , 12557 11174 , 15986 11174 , 15986 BuildBezier.java contains some functions for reading in this data and building the arrays required by Draw.drawBezier(). So when the following is called: run BezierBuilder bpts2 . txt the curve shown in Figure 14 appears on a page. Figure 14. The Curve Drawn by BuildBezier.java The BuildBezier.java data-reading functions can only handle a single \"M\" and \"C\" operation. If the curve you draw has straight lines, arcs, smoothing, or multiple parts, then the SVG file will contain operations that my code cannot process. However, the data-reading functions do recognize the \"Z\" operation, which specifies that the curve should be closed. If \"Z\" is added as a new line at the end of the bpts2.txt, then the closed Bezier curve in Figure 15 is generated. Figure 15. The Closed Curve Drawn by BuildBezier.java","title":"4.2.  Drawing a Complicated Bezier Curve"},{"location":"16-Making_Slides.html","text":"Chapter 16. Making Slides \u00b6 Topics Creating Slides: title, subtitle, bullets, images, video, buttons; Shape Animations; Dispatch Shapes (special symbols, block arrows, 3D shapes, flowchart elements, callouts, and stars); Slide Viewing Example folders: \"Draw Tests\" and \"Utils\" The MakeSlides.java example creates a deck of five slides, illustrating different aspects of slide generation: Slide 1. A slide combining a title and subtitle (see Figure 3); Slide 2. A slide with a title, bullet points, and an image (see Figure 4); Slide 3. A slide with a title, and an embedded video which plays automatically when that slide appears during a slide show (see Figure 6); Slide 4. A slide with an ellipse and a rounded rectangle acting as buttons. During a slide show, clicking on the ellipse starts a video playing in an external viewer. Clicking on the rounded rectangle causes the slide show to jump to the first slide in the deck (see Figure 7); Slide 5. This slide contains eight shapes generated using dispatches, including special symbols, block arrows, 3D shapes, flowchart elements, callouts, and stars (see Figure 9). MakeSlides.java creates a slide deck, adds the five slides to it, and finishes by saving the presentation in \"makeslides.odp\": public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createImpressDoc ( loader ); // Impress doc if ( doc == null ) { System . out . println ( \"Impress doc creation failed\" ); Lo . closeOffice (); return ; } // first slide: title + subtitle XDrawPage currSlide = Draw . getSlide ( doc , 0 ); Draw . showShapesInfo ( currSlide ); Draw . titleSlide ( currSlide , \"Java-Generated Slides\" , \"Using LibreOffice\" ); Draw . showShapesInfo ( currSlide ); // second slide (bullets and image) currSlide = Draw . addSlide ( doc ); doBullets ( currSlide ); // third slide: title and video currSlide = Draw . addSlide ( doc ); Draw . titleOnlySlide ( currSlide , \"Clock Video\" ); Draw . drawMedia ( currSlide , \"clock.avi\" , 20 , 70 , 50 , 50 ); // fourth slide: buttons currSlide = Draw . addSlide ( doc ); buttonShapes ( currSlide ); // fifth slide: shapes created with dispatches dispatchShapes ( doc ); System . out . println ( \"Total no. of slides: \" + Draw . getSlidesCount ( doc )); Lo . saveDoc ( doc , \"makeslides.odp\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The five slides are explained in the following sections. 1. The First Slide (Title and Subtitle) \u00b6 Draw.createImpressDoc() calls Lo.createDoc(), supplying it with the Impress document string type: // in the Draw class public static XComponent createImpressDoc ( XComponentLoader loader ) { return Lo . createDoc ( \"simpress\" , loader ); } This creates a new slide deck with one slide whose layout depends on Impress' default settings. Figure 1 shows the usual layout when a user starts Impress. Figure 1. The Default New Slide in Impress. The slide contains two empty presentation shapes \u2013 the text rectangle at the top is a TitleTextShape, and the larger rectangle below is a SubTitleShape. This first slide, which is at index position 0 in the deck, can be referred to by calling Draw.getSlide(): XDrawPage currSlide = Draw . getSlide ( doc , 0 ); This is the same method used to get the first page in a Draw document, so I won't go through it again. The XDrawPage object can be examined by calling Draw.showShapesInfo() which lists all the shapes (both draw and presentation ones) on the slide: // in Draw public static void showShapesInfo ( XDrawPage dp ) { System . out . println ( \"Draw Page shapes:\" ); ArrayList < XShape > shapes = getShapes ( dp ); if ( shapes != null ) { for ( XShape shape : shapes ) showShapeInfo ( shape ); } } // end of showShapesInfo() public static void showShapeInfo ( XShape xShape ) { System . out . println ( \" Shape service: \" + xShape . getShapeType () + \"; z-order: \" + getZOrder ( xShape )); } // end of showShapeInfo() public static int getZOrder ( XShape shape ) { return ( Integer ) Props . getProperty ( shape , \"ZOrder\" ); } Draw.showShapesInfo() output for the first slide is: Draw Page shapes: Shape service: com.sun.star.presentation.TitleTextShape; z-order: 0 Shape service: com.sun.star.presentation.SubtitleShape; z-order: 1 Obviously, the default layout sometimes isn't the one we want. One solution would be to delete the unnecessary shapes on the slide, then add the shapes that we do want. A better approach is the programming equivalent of selecting a different slide layout. This is implemented as several Draw methods, called titleSlide(), bulletsSlide(), titleOnlySlide(), and blankSlide(), which change the slide's layout to those shown in Figure 2. Figure 2. Slide Layout Methods. A title/subtitle layout is used for the first slide by calling: Draw . titleSlide ( currSlide , \"Java-Generated Slides\" , \"Using LibreOffice\" ); It generates the slide shown in Figure 3. Figure 3. The Title and Subtitle Slide. Having a Draw.titleSlide() method may seem a bit silly since we've seen that the first slide already uses this layout (e.g. in Figure 1). That's true for my Impress setup, but may not be the case for other installations with different configurations. The other layouts shown on the right of Figure 1 could also be implemented as Draw methods, but the four in Figure 2 seem most useful. They set the \"Layout\" property in the DrawPage service in the com.sun.star.presentation module (not the one in the drawing module). The documentation for DrawPage (use lodoc DrawPage presentation service ) only says that \"Layout\" stores a short; it doesn't list the possible values or how they correspond to layouts. However, there is a list at the excellent Japanese Office website, https://openoffice3.web.fc2.com/OOoBasic_Impress.html#OOoIPLy01a , which I used as the basis of the layout constants in my Draw class: // in Draw public static final int LAYOUT_TITLE_SUB = 0 ; // title, and subtitle below (the default, usually) public static final int LAYOUT_TITLE_BULLETS = 1 ; // the usual one you want public static final int LAYOUT_TITLE_CHART = 2 ; public static final int LAYOUT_TITLE_2CONTENT = 3 ; // 2 boxes: 1x2 (row x column), 1 row public static final int LAYOUT_TITLE_CONTENT_CHART = 4 ; public static final int LAYOUT_TITLE_CONTENT_CLIP = 6 ; public static final int LAYOUT_TITLE_CHART_CONTENT = 7 ; public static final int LAYOUT_TITLE_TABLE = 8 ; public static final int LAYOUT_TITLE_CLIP_CONTENT = 9 ; public static final int LAYOUT_TITLE_CONTENT_OBJECT = 10 ; public static final int LAYOUT_TITLE_OBJECT = 11 ; public static final int LAYOUT_TITLE_CONTENT_2CONTENT = 12 ; // 3 boxes in 2 columns: 1 in first col, 2 in second public static final int LAYOUT_TITLE_OBJECT_CONTENT = 13 ; public static final int LAYOUT_TITLE_CONTENT_OVER_CONTENT = 14 ; // 2 boxes: 2x1, 1 column public static final int LAYOUT_TITLE_2CONTENT_CONTENT = 15 ; // 3 boxes in 2 columns: 2 in first col, 1 in second public static final int LAYOUT_TITLE_2CONTENT_OVER_CONTENT = 16 ; // 3 boxes on 2 rows: 2 on first row, 1 on second public static final int LAYOUT_TITLE_CONTENT_OVER_OBJECT = 17 ; public static final int LAYOUT_TITLE_4OBJECT = 18 ; // 4 boxes: 2x2 public static final int LAYOUT_TITLE_ONLY = 19 ; // title only; no body shape public static final int LAYOUT_BLANK = 20 ; public static final int LAYOUT_VTITLE_VTEXT_CHART = 27 ; // vertical title, vertical text, and chart public static final int LAYOUT_VTITLE_VTEXT = 28 ; public static final int LAYOUT_TITLE_VTEXT = 29 ; public static final int LAYOUT_TITLE_VTEXT_CLIP = 30 ; public static final int LAYOUT_CENTERED_TEXT = 32 ; public static final int LAYOUT_TITLE_4CONTENT = 33 ; // 4 boxes: 2x2 public static final int LAYOUT_TITLE_6CONTENT = 34 ; // 6 boxes: 2x3 The four constants highlighted above are used by the Draw methods described next. Draw.titleSlide() starts by setting the slide's \"Layout\" property to LAYOUT_TITLE_SUB: // in Draw public static void titleSlide ( XDrawPage currSlide , String title , String subTitle ) { Props . setProperty ( currSlide , \"Layout\" , LAYOUT_TITLE_SUB ); // title and subtitle // add the title text to the title shape XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); XText textField = Lo . qi ( XText . class , xs ); textField . setString ( title ); // add the subtitle text to the subtitle shape xs = Draw . findShapeByType ( currSlide , Draw . SUBTITLE_TEXT ); textField = Lo . qi ( XText . class , xs ); textField . setString ( subTitle ); } // end of titleSlide() This changes the slide's layout to an empty TitleTextShape and SubtitleShape. The functions adds title and subtitle strings to these shapes, and returns. The tricky part is obtaining a reference to a particular shape so it can be modified. One (bad) solution is to use the index ordering of the shapes on the slide, which is displayed by Draw.showShapesInfo(). It turns out that TitleTextShape is first (i.e. at index 0), and SubtitleShape second. This can be used to write the following code: XShapes xShapes = Lo . qi ( XShapes . class , currSlide ); XShape titleShape = Lo . qi ( XShape . class , xShapes . getByIndex ( 0 )); XShape subTitleShape = Lo . qi ( XShape . class , xShapes . getByIndex ( 1 )); This is a bit hacky, so I coded Draw.findShapeByType() instead, which searches for a shape based on its type: // in Draw public static XShape findShapeByType ( XDrawPage slide , String shapeType ) { ArrayList < XShape > shapes = getShapes ( slide ); if ( shapes == null ) { System . out . println ( \"No shapes were found in the draw page\" ); return null ; } for ( XShape shape : shapes ) { if ( shapeType . equals ( shape . getShapeType ())) return shape ; } System . out . println ( \"No shape found of type \\\"\" + shapeType + \"\\\"\" ); return null ; } // end of findShapeByType() I added constants to the Draw class so the programmer wouldn't have to remember long shape type names: // in Draw public static final String TITLE_TEXT = \"com.sun.star.presentation.TitleTextShape\" ; public static final String SUBTITLE_TEXT = \"com.sun.star.presentation.SubtitleShape\" ; public static final String BULLETS_TEXT = \"com.sun.star.presentation.OutlinerShape\"; This allows me to find the title shape by calling: XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); 2. The Second Slide (Title, Bullets, and Image) \u00b6 The second slide uses a title and bullet points layout, with an image added at the bottom right corner. The relevant lines in MakeSlides.java are: // in main() in MakeSlides.java... currSlide = Draw . addSlide ( doc ); doBullets ( currSlide ); The result is shown in Figure 4. Figure 4. A Slide with a Title, Bullet Points, and an Image. The slide is created by doBullets() in MakeSlides.java: // in MakeSlides.java private static void doBullets ( XDrawPage currSlide ) { XText body = Draw . bulletsSlide ( currSlide , \"What is an Algorithm?\" ); // bullet levels are 0, 1, 2,... Draw . addBullet ( body , 0 , \"An algorithm is a finite set of unambiguous instructions for solving a problem.\" ); Draw . addBullet ( body , 1 , \"An algorithm is correct if on all legitimate inputs, it outputs the right answer in a finite amount of time\" ); Draw . addBullet ( body , 0 , \"Can be expressed as\" ); Draw . addBullet ( body , 1 , \"pseudocode\" ); Draw . addBullet ( body , 1 , \"flow charts\" ); Draw . addBullet ( body , 1 , \"text in a natural language (e.g. English)\" ); Draw . addBullet ( body , 1 , \"computer code\" ); // add the image XShape im = Draw . drawImageOffset ( currSlide , \"skinner.png\" , 0.6 , 0.5 ); // in bottom right corner, and scaled if necessary Draw . moveToBottom ( currSlide , im ); //move pic below slide text } // end of doBullets() Draw.bulletsSlide() works in a similar way to Draw.titleSlide() \u2013 first the slide's layout is set, then the presentation shapes are found and modified: // in Draw public static XText bulletsSlide ( XDrawPage currSlide , String title ) { Props . setProperty ( currSlide , \"Layout\" , LAYOUT_TITLE_BULLETS ); // add the title text to the title shape XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); XText textField = Lo . qi ( XText . class , xs ); textField . setString ( title ); // return a reference to the bullet text area xs = Draw . findShapeByType ( currSlide , Draw . BULLETS_TEXT ); return Lo . qi ( XText . class , xs ); } // end of bulletsSlide() The Draw.LAYOUT_TITLE_BULLETS constant changes the slide's layout to contain two presentation shapes \u2013 a TitleTextShape at the top, and an OutlinerShape beneath it (as in the second picture in Figure 2). Draw.bulletsSlide() calls Draw.findShapeByType() twice to find these shapes, but it does nothing to the OutlinerShape itself, returning it as an XText reference. This allows text to be inserted into the shape by other code (i.e. by Draw.addBullet()). 2.1. Adding Bullets to a Text Area \u00b6 Draw.addBullet() converts the shape's XText reference into an XTextRange, which offers a setString() method: public static void addBullet ( XText bullsText , int level , String text ) { // access the end of the bullets text XTextRange tr = Lo . qi ( XTextRange . class , bullsText ). getEnd (); // set the bullet's level Props . setProperty ( tr , \"NumberingLevel\" ,( short ) level ); tr . setString ( text + \"\\n\" ); // add the text } // end of addBullet() As explained in Chapter 5, XTextRange is part of the TextRange service which inherits both paragraph and character property classes, as indicated by Figure 5. Figure 5. The TextRange Service. A look through the ParagraphProperties documentation reveals a \"NumberingLevel\" property which affects the displayed bullet level (use lodoc ParagraphProperties ). Another way of finding out about the properties associated with XTextRange is to use my Props.showObjProps() to list all of them: Props . showObjProps ( \"TextRange in OutlinerShape\" , tr ); The bullet text is added with XTextRange.setString(). A newline is added to the text before the set, to ensure that the string is treated as a complete paragraph. The drawback is that the newline causes an extra bullet symbol to be drawn after the real bullet points. This can be seen in Figure 4, at the bottom of the slide. (Principal Skinner is pointing at it.) 2.2. Offsetting an Image \u00b6 The AnimBicycle.java example in Chapter 14 employed a version of Draw.drawImage() based around specifying an (x, y) position on the page and a width and height for the image frame. Draw.drawImageOffset() used here is a variant which specifies its position in terms of fractional offsets from the top-left corner of the slide. For example: XShape im = Draw . drawImageOffset ( currSlide , \"skinner.png\" , 0.6 , 0.5 ); The last two arguments mean that the image's top-left corner will be placed at a point that is 0.6 of the slide's width across and 0.5 of its height down. drawImageOffset() also scales the image so that it doesn't extend beyond the right and bottom edges of the slide. The scaling is the same along both dimensions so the picture isn't distorted. The code for Draw.drawImageOffset(): // in Draw public static XShape drawImageOffset ( XDrawPage slide , String imFnm , double xOffset , double yOffset ) { if (( xOffset < 0 ) || ( xOffset >= 1 )) { System . out . println ( \"xOffset should be between 0-1; using 0.5\" ); xOffset = 0.5 ; } if (( yOffset < 0 ) || ( yOffset >= 1 )) { System . out . println ( \"yOffset should be between 0-1; using 0.5\" ); yOffset = 0.5 ; } Size slideSize = Draw . getSlideSize ( slide ); // in mm units if ( slideSize == null ) { System . out . println ( \"Image drawing cannot proceed\" ); return null ; } int x = ( int ) Math . round ( slideSize . Width * xOffset ); //in mm units int y = ( int ) Math . round ( slideSize . Height * yOffset ); int maxWidth = slideSize . Width - x ; int maxHeight = slideSize . Height - y ; Size imSize = Images . calcScale ( imFnm , maxWidth , maxHeight ); return drawImage ( slide , imFnm , x , y , imSize . Width , imSize . Height ); } // end of drawImageOffset() drawImageOffset() uses the slide's size to determine an (x, y) position for the image, and its width and height. Images.calcScale() calculates the best width and height for the image frame such that the image will be drawn entirely on the slide: // in the Images class public static Size calcScale ( String fnm , int maxWidth , int maxHeight ) { Size imSize = Images . getSize100mm ( fnm ); // in 1/100 mm units if ( imSize == null ) return null ; // calculate the scale factors to obtain these maximums double widthScale = (( double ) maxWidth * 100 ) / imSize . Width ; double heightScale = (( double ) maxHeight * 100 ) / imSize . Height ; // use the smallest scale factor double scaleFactor = ( widthScale < heightScale ) ? widthScale : heightScale ; // calculate new dimensions for the image int w = ( int ) Math . round ( imSize . Width * scaleFactor / 100 ); int h = ( int ) Math . round ( imSize . Height * scaleFactor / 100 ); return new Size ( w , h ); } // end of calcScale() calcScale() uses Images.getSize100mm() to retrieve the size of the image in 1/100 mm units, and then a scale factor is calculated for both the width and height. This is used to set the image frame's dimensions when the graphic is loaded by drawImage(). 3. The Third Slide (Title and Video) \u00b6 The third slide consists of a title shape and a video frame, which looks like Figure 6. Figure 6. A Slide Containing a Video Frame. When this slide appears in a slide show, the video will automatically start playing. The code for generating this slide is: // main() of MakeSlides.java... currSlide = Draw . addSlide ( doc ); Draw . titleOnlySlide ( currSlide , \"Clock Video\" ); Draw . drawMedia ( currSlide , \"clock.avi\" , 20 , 70 , 50 , 50 ); Draw.titleOnlySlide() works in a similar way to titleSlide() and bulletsSlide(): // in Draw public static void titleOnlySlide ( XDrawPage currSlide , String header ) { Props . setProperty ( currSlide , \"Layout\" , LAYOUT_TITLE_ONLY ); // title only; no body shape // add the text to the title shape XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); XText textField = Lo . qi ( XText . class , xs ); textField . setString ( header ); } // end of titleOnlySlide() The MediaShape service doesn't appear in the Office documentation. Perhaps one reason for its absence is that the shape behaves a little 'erratically'. In particular, although MakeSlides.java successfully builds a slide deck containing the video, Office crashes upon exiting. Also, when the deck is run as a slide show, the video frame is sometimes incorrectly placed, although the video plays correctly. Draw.drawMedia() is defined as: // in Draw public static XShape drawMedia ( XDrawPage slide , String fnm , int x , int y , int width , int height ) // causes Office to crash on exiting { XShape shape = addShape ( slide , \"MediaShape\" , x , y , width , height ); // Props.showObjProps(\"Shape\", shape); System . out . println ( \"Loading media: \\\"\" + fnm + \"\\\"\" ); Props . setProperty ( shape , \"MediaURL\" , FileIO . fnmToURL ( fnm )); Props . setProperty ( shape , \"Loop\" , true ); return shape ; } // end of drawMedia() In the absence of documentation, I used Props.showObjProps() to list the properties for the MediaShape: Props . showObjProps ( \"Shape\" , shape ); The \"MediaURL\" property requires a file in URL format, and \"Loop\" is a boolean for making the animation play repeatedly. Office supports the AVI and WMV video formats, but not MP4. 4. The Fourth Slide (Title and Buttons) \u00b6 The fourth slide has two 'buttons' \u2013 an ellipse which starts a video playing in an external application, and a rounded rectangle which makes the presentation jump to the first slide. These actions are both implemented using the \"OnClick\" property for presentation shapes. Figure 7 shows how the slide looks. Figure 7. A Slide with Two 'Buttons'. The relevant code in main() of MakeSlides.java is: currSlide = Draw . addSlide ( doc ); buttonShapes ( currSlide ); This button approach to playing a video doesn't suffer from the strange behavior when using MediaShape on the third slide. The buttonShapes() method in MakeSlides.java creates the slide: // in MakeSlides.java private static void buttonShapes ( XDrawPage currSlide ) { Draw . titleOnlySlide ( currSlide , \"Wildlife Video Via Button\" ); // button in the center of the slide com . sun . star . awt . Size sz = Draw . getSlideSize ( currSlide ); int width = 80 ; int height = 40 ; XShape ellipse = Draw . drawEllipse ( currSlide , ( sz . Width - width ) / 2 , ( sz . Height - height ) / 2 , width , height ); Draw . addText ( ellipse , \"Start Video\" , 30 ); Props . setProperty ( ellipse , \"OnClick\" , ClickAction . DOCUMENT ); Props . setProperty ( ellipse , \"Bookmark\" , FileIO . fnmToURL ( \"wildlife.wmv\" )); // draw a rounded rectangle with text XShape button = Draw . drawRectangle ( currSlide , sz . Width - width - 5 , sz . Height - height - 5 , width , height ); Draw . addText ( button , \"Click to go\\nto Slide 1\" ); Draw . setGradientColor ( button , \"Radial red/yellow\" ); Props . setProperty ( button , \"CornerRadius\" , 300 ); // 1/100 mm units Props . setProperty ( button , \"OnClick\" , ClickAction . FIRSTPAGE ); // clicking makes the presentation jump to first slide } // end of buttonShapes() A minor point of interest is that a rounded rectangle is a RectangleShape, but with its \"CornerRadius\" property set. The more important part of the method is the two uses of the \"OnClick\" property from the presentation Shape class. Clicking on the ellipse executes the video file \"wildlife.wmv\". This requires \"OnClick\" to be assigned the ClickAction.DOCUMENT constant, and \"Bookmark\" to refer to the file as an URL. Clicking on the rounded rectangle causes the slide show to jump back to the first page. This needs \"OnClick\" to be set to ClickAction.FIRSTPAGE. Several other forms of click action are listed in Table 1. ClickAction Name Effect NONE No action is performed on the click. Animation and fade effects are also switched off. PREVPAGE The presentation jumps to the previous page. NEXTPAGE The presentation jumps to the next page. FIRSTPAGE The presentation continues with the first page. LASTPAGE The presentation continues with the last page. BOOKMARK The presentation jumps to a bookmark. DOCUMENT The presentation jumps to another document. INVISIBLE The object renders itself invisible after a click. SOUND A sound is played after a click. VERB An OLE verb is performed on this object. VANISH The object vanishes with its effect. PROGRAM Another program is executed after a click. MACRO An Office macro is executed after the click. STOPPRESENTATION The presentation is stopped after the click. Table 1. ClickAction Effects. Table 1 shows that it's possible to jump to various places in a slide show, and also execute macros and external programs. In both cases, the \"Bookmark\" property is used to specify the URL of the macro or program. For example, the following will invoke Windows' calculator when the button is pressed: Props . setProperty ( button , \"OnClick\" , ClickAction . PROGRAM ); Props . setProperty ( button , \"Bookmark\" , FileIO . fnmToURL ( System . getenv ( \"SystemRoot\" ) + \"\\\\System32\\\\calc.exe\" ) ); \"Bookmark\" requires an absolute path to the application, converted to URL form. The ClickAction documentation can be reached using lodoc ClickAction , which loads the IDL webpage for the enumeration. Clicking on the \"ClickAction\" enum name takes you to a table very like the one in Table 1. 5. Shape Animation \u00b6 Shape animations are performed during a slide show, and are regulated through three presentation Shape properties: \"Effect\", \"Speed\" and \"TextEffect\". \"Effect\" can be assigned a large range of animation effects, which are defined as constants in the AnimationEffect enumeration. Use lodoc AnimationEffect to reach the presentation Shape service, then browse for its \"Effect\" property. Alternatively, you can find details in the com.sun.star.presentation module (use lodoc presentation module ). Another nice summary, in the form of a large table, is in the Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Drawings/Animations_and_Interactions/ (use loGuide \"Animations and Interactions\" ). Figure 8 shows part of that table. Figure 8. Part of the AnimationEffect Constants Table in the Developer's Guide. There are two broad groups of effects: those that move a shape onto the slide when the page appears, and fade effects that make a shape gradually appear in a given spot. The following code fragment makes the ellipse on the fourth slide fade into view, starting with the bottom of the shape: // in buttonShapes() in MakeSlides.java Props . setProperty ( ellipse , \"Effect\" , AnimationEffect . FADE_FROM_BOTTOM ); Props . setProperty ( ellipse , \"Speed\" , AnimationSpeed . SLOW ); The animation speed can be set to AnimationSpeed.SLOW, AnimationSpeed.MEDIUM, or AnimationSpeed.FAST. Unfortunately, there seems to be a problem saving these effects in the presentation file (\"makeSlides.odp\") created by MakeSlides.java. When that file is opened as a slide show, no animation effects occur \u2013 the ellipse is simply displayed. It seems that the shape animation properties are not saved to the ODP file, because when the ellipse is examined inside Impress, its \"Custom Animation\" task pane is empty. More Complex Shape Animations \u00b6 If you browse chapter 9 of the Impress user's guide on slide shows, its animation capabilities extend well beyond the constants in AnimationEffect. These features are available through the XAnimationNode interface, which is obtained like so: XAnimationNodeSupplier nodeSupp = Lo . qi ( XAnimationNodeSupplier . class , slide ); XAnimationNode slideNode = nodeSupp . getAnimationNode (); XAnimationNode allows a programmer much finer control over animation timings and animation paths for shapes. XAnimationNode is part of the large com.sun.star.animations package (see lodoc animations module ). I won't be use XAnimationNode here. 6. The Fifth Slide (Various Dispatch Shapes) \u00b6 The fifth slide is a hacky, slow solution for generating the numerous shapes in Impress' GUI which have no corresponding classes in the API. The approach uses dispatch commands, JNA, and Java's Robot class (first described back in Chapter 4). The resulting slide is shown in Figure 9. Figure 9. Shapes Created by Dispatch Commands. The shapes in Figure 9 are just a few of the many available via Impress' \"Drawing Toolbar\", shown in Figure 10. The relevant menus are labeled and their sub-menus are shown beneath the toolbar. Figure 10. The Shapes Available from the Drawing Toolbar. Each sub-menu shape has a name which appears in a tooltip when the cursor is placed over the shape's icon. This text turns out to be very useful when writing the dispatch commands. There's also a \"3D-Objects\" toolbar which offers the shapes in Figure 11. Figure 11. The 3D-Objects Toolbar. Some of these 3D shapes are available in the API as undocumented Shape subclasses, but I was unable to programmatically resize the shapes to make them visible. The only way I could get them to appear at a reasonable size was by creating them with dispatch commands. Although there's no mention of these custom and 3D shapes in the Developer's Guide, their dispatch commands do appear in the UICommands.ods spreadsheet (available from https://arielch.fedorapeople.org/devel/ooo/UICommands.ods ). They're also mentioned, in less detail, in the online documentation for Impress dispatches at https://wiki.documentfoundation.org/Development/DispatchCommands#Impress_slots_.28sdslots.29 . It's quite easy to match up the tooltip names in the GUI with the dispatch names. For example, the smiley face in the Symbol shapes menu is called \"Smiley Face\" in the GUI and \".uno:SymbolShapes.smiley\" in the UICommands spreadsheet. MakeSlides.java generates the eight shapes in Figure 9 by calling dispatchShapes(): // in MakeSlides.java private static void dispatchShapes ( XComponent doc ) { XDrawPage currSlide = Draw . addSlide ( doc ); Draw . titleOnlySlide ( currSlide , \"Dispatched Shapes\" ); GUI . setVisible ( doc , true ); Lo . wait ( 1000 ); Draw . gotoPage ( doc , currSlide ); System . out . println ( \"Viewing Slide number: \" + Draw . getSlideNumber ( Draw . getViewedPage ( doc ))); // first row XShape dShape = Draw . addDispatchShape ( currSlide , \"BasicShapes.diamond\" , 20 , 60 , 50 , 30 ); Draw . addDispatchShape ( currSlide , \"HalfSphere\" , 80 , 60 , 50 , 30 ); // 3D dShape = Draw . addDispatchShape ( currSlide , \"CalloutShapes.cloud-callout\" , 140 , 60 , 50 , 30 ); Draw . setBitmapColor ( dShape , \"Sky\" ); dShape = Draw . addDispatchShape ( currSlide , \"FlowChartShapes.flowchart-card\" , 200 , 60 , 50 , 30 ); Draw . setHatchingColor ( dShape , \"Black -45 degrees\" ); // second row dShape = Draw . addDispatchShape ( currSlide , \"StarShapes.star12\" , 20 , 140 , 40 , 40 ); Draw . setGradientColor ( dShape , \"Radial red/yellow\" ); Props . setProperty ( dShape , \"LineStyle\" , LineStyle . NONE ); // no outline dShape = Draw . addDispatchShape ( currSlide , \"SymbolShapes.heart\" , 80 , 140 , 40 , 40 ); Props . setProperty ( dShape , \"FillColor\" , 0xFF0000 ); Draw . addDispatchShape ( currSlide , \"ArrowShapes.left-right-arrow\" , 140 , 140 , 50 , 30 ); // Block Arrow sub-menu dShape = Draw . addDispatchShape ( currSlide , \"Cyramid\" , 200 , 120 , 50 , 50 ); // 3D pyramid, misspelt Draw . setBitmapColor ( dShape , \"Stone\" ); Draw . showShapesInfo ( currSlide ); } // end of dispatchShapes() A title-only slide is created, followed by eight calls to Draw.addDispatchShape() to create two rows of four shapes in Figure 9. 6.1. Viewing the Fifth Slide \u00b6 Draw.addDispatchShape() requires the fifth slide to be the active, visible window on- screen. This necessitates a call to GUI.setVisible() to make the document visible, but that isn't quite enough. Making the document visible causes the first slide to be displayed, not the fifth one. Impress offers many ways of viewing slides, which are implemented in the API as view classes that inherit the Controller service. The inheritance structure is shown in Figure 12. Figure 12. Impress View Classes. When a Draw or Impress document is being edited, the view is DrawingDocumentDrawView, which supports a number of useful properties, such as \"ZoomType\" and \"VisibleArea\". Its XDrawView interface is employed for getting and setting the current page displayed in this view. Draw.gotoPage() gets the XController interface for the document, and converts it to XDrawView so the visible page can be set: // in Draw public static void gotoPage ( XComponent doc , XDrawPage page ) { XController ctrl = GUI . getCurrentController ( doc ); gotoPage ( ctrl , page ); } // end of jumpToPage() public static void gotoPage ( XController ctrl , XDrawPage page ) { XDrawView xDrawView = Lo . qi ( XDrawView . class , ctrl ); xDrawView . setCurrentPage ( page ); } // end of gotoPage() After the call to Draw.gotoPage(), the specified draw page will be visible on-screen, and so receive any dispatch commands. Draw.getViewedPage() returns a reference to the currently viewed page by calling XDrawView.getCurrentPage(): // in Draw public static XDrawPage getViewedPage ( XComponent doc ) { XController ctrl = GUI . getCurrentController ( doc ); XDrawView xDrawView = Lo . qi ( XDrawView . class , ctrl ); return xDrawView . getCurrentPage (); } // end of getViewedPage() 6.2. Adding a Dispatch Shape to the Visible Page \u00b6 If you try adding a smiley face to a slide inside Impress, it's a two-step process. It isn't enough only to click on the icon, it's also necessary to drag the cursor over the page in order for the shape to appear and be resized. These steps are necessary for all the Drawing toolbar and 3D-Objects shapes, and are emulated by my code. The programming equivalent of clicking on the icon is done by calling Lo.dispatchCmd(), while implementing a mouse drag utilizes JNA and Java's Robot class. Draw.addDispatchShape() uses createDispatchShape() to create the shape, and then positions and resizes it: // in Draw public static XShape addDispatchShape ( XDrawPage slide , String shapeDispatch , int x , int y , int width , int height ) { warnsPosition ( slide , x , y ); XShape shape = createDispatchShape ( slide , shapeDispatch ); if ( shape != null ) { setPosition ( shape , x , y ); setSize ( shape , width , height ); } return shape ; } // end of addDispatchShape() Draw.createDispatchShape() implements icon selection and click-and-drag: // in Draw public static XShape createDispatchShape ( XDrawPage slide , String shapeDispatch ) { int numShapes = slide . getCount (); Lo . dispatchCmd ( shapeDispatch ); // select the shape icon; Office must be visible Lo . wait ( 1000 ); // click and drag on the page to create the shape on the page; // the current page must be visible java . awt . Point p1 = JNAUtils . getClickPoint ( JNAUtils . getHandle () ); java . awt . Point p2 = JNAUtils . getOffsetPoint ( p1 , 100 , 100 ); // hardwired offset JNAUtils . doDrag ( p1 , p2 ); // drag the cursor between p1 and p2 Lo . wait ( 2000 ); /* get a reference to the shape by assuming it's the top one on the page */ int numShapes2 = slide . getCount (); if ( numShapes2 == numShapes + 1 ) { // there's a new shape System . out . println ( \"Shape \\\"\" + shapeDispatch + \"\\\" created\" ); return Draw . findTopShape ( slide ); } else { // no new shape System . out . println ( \"Shape \\\"\" + shapeDispatch + \"\\\" not created\" ); return null ; } } // end of createDispatchShape() The click-and-drag operation doesn't return a reference to the shape, so createDispatchShape() ends by calling Draw.findTopShape(). It returns a reference to the top-most shape on the page, which I'm assuming is the new shape. 6.3. Using JNA to Click and Drag \u00b6 JNAUtils.getHandle() returns Window's handle for Office, and getClickPoint() calculates the center of the Office window: // in JNAUtils public static Point getClickPoint ( HWND handle ) { Rectangle bounds = getBounds ( handle ); if ( bounds == null ) { System . out . println ( \"Bounding rectangle is null\" ); return null ; } int xCenter = bounds . x + bounds . width / 2 ; int yCenter = bounds . y + bounds . height / 2 ; return new Point ( xCenter , yCenter ); } // end of getClickPoint() I'm hoping that this point is somewhere on the slide. JNAUtils.getOffsetPoint() creates a second point offset some distance from the first: public static Point getOffsetPoint ( Point p1 , int xDist , int yDist ) { return new Point ( p1 . x + xDist , p1 . y + yDist ); } Again, I'm hoping this point is on the slide. JNAUtils.doDrag() employs Java's Robot class to send mouse actions to the active window. doDrag() moves the cursor to the first point, then sends press and move events to simulate a cursor drag to the second point. It finishes by sending a release event for the mouse button: // in JNAUtils public static void doDrag ( final Point clickPt , final Point releasePt ) // drag the cursor between the two points { if ( clickPt == null ) { System . out . println ( \"Click point is null\" ); return ; } if ( releasePt == null ) { System . out . println ( \"Release point is null\" ); return ; } EventQueue . invokeLater ( new Runnable () { public void run () { try { Point oldPos = MouseInfo . getPointerInfo (). getLocation (); Robot r = new Robot (); r . mouseMove ( clickPt . x , clickPt . y ); Lo . delay ( 300 ); r . mousePress ( InputEvent . BUTTON1_MASK ); Lo . delay ( 300 ); r . mouseMove ( releasePt . x , releasePt . y ); Lo . delay ( 300 ); r . mouseRelease ( InputEvent . BUTTON1_MASK ); r . mouseMove ( oldPos . x , oldPos . y ); } catch ( AWTException e ) { System . out . println ( \"Unable to carry out Drag: \" + e ); } } }); } // end of doDrag() The Robot events must be added to Java's event queue, so are wrapped up in a call to EventQueue.invokeLater(). The final call to Robot.mouseMove() moves the cursor back to its original position. 6.4. Things that Can Go Wrong \u00b6 createDispatchShape() assumes that the slide being edited by Office is the visible, active window. If these conditions aren't met then the dispatch and the dragging will go to the wrong window. Unfortunately, calling GUI.setVisible() and Draw.gotoPage() do not guarantee these conditions, since after their call the OS or the user may inadvertently change the desktop's focus. A different window could become active, and so receive those commands. There are also timing issues: the call to Lo.dispatchCmd() returns immediately, but the processing of the dispatch by Office may take hundreds of milliseconds. This is why calls to Lo.delay() are scattered through the code, to give the dispatches time to be processed. There's also a timing problem with EventQueue.invokeLater() which returns immediately after queuing up the Robot actions. The processing of its events may also take many hundreds of milliseconds, so createDispatchShape() must call Lo.delay() after returning from JNAUtils.doDrag(). Yet another problem is my assumption that the press and drag points are on the slide, and not some other part of the application window, such as the toolbar. 6.5. 3D Shapes Might be Different (but aren't) \u00b6 3D shapes are available both through the 3D-Objects toolbar (see Figure 11), and as undocumented Shape APIs. The classes don't match up exactly with the eight shapes in the toolbar, but are similar.The classes are Shape3DCubeObject, Shape3DSphereObject, , Shape3DPolygonObject, Shape3DLatheObject, Shape3DExtrudeObject, and Shape3DSceneObject, which all belong to the com.sun.star.drawing package. It should be possible to build a 3D cube by calling: XShape shape3D = Draw . addShape ( currSlide , \"Shape3DCubeObject\" , 120 , 120 , 60 , 60 ); I tried this, and it nearly worked. The resulting slide contains a Shape3DCubeObject object, which I deduced by listing all the shapes on the current slide with Draw.showShapesInfo(). Unfortunately, the shape is invisible because its width and height are 0. No amount of fiddling with its properties could change these zero dimensions. The conclusion of all this programming ugliness is that the API needs to be brought up to date so it can access all the shapes available through the GUI.","title":"Chapter 16. Making Slides"},{"location":"16-Making_Slides.html#chapter-16-making-slides","text":"Topics Creating Slides: title, subtitle, bullets, images, video, buttons; Shape Animations; Dispatch Shapes (special symbols, block arrows, 3D shapes, flowchart elements, callouts, and stars); Slide Viewing Example folders: \"Draw Tests\" and \"Utils\" The MakeSlides.java example creates a deck of five slides, illustrating different aspects of slide generation: Slide 1. A slide combining a title and subtitle (see Figure 3); Slide 2. A slide with a title, bullet points, and an image (see Figure 4); Slide 3. A slide with a title, and an embedded video which plays automatically when that slide appears during a slide show (see Figure 6); Slide 4. A slide with an ellipse and a rounded rectangle acting as buttons. During a slide show, clicking on the ellipse starts a video playing in an external viewer. Clicking on the rounded rectangle causes the slide show to jump to the first slide in the deck (see Figure 7); Slide 5. This slide contains eight shapes generated using dispatches, including special symbols, block arrows, 3D shapes, flowchart elements, callouts, and stars (see Figure 9). MakeSlides.java creates a slide deck, adds the five slides to it, and finishes by saving the presentation in \"makeslides.odp\": public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createImpressDoc ( loader ); // Impress doc if ( doc == null ) { System . out . println ( \"Impress doc creation failed\" ); Lo . closeOffice (); return ; } // first slide: title + subtitle XDrawPage currSlide = Draw . getSlide ( doc , 0 ); Draw . showShapesInfo ( currSlide ); Draw . titleSlide ( currSlide , \"Java-Generated Slides\" , \"Using LibreOffice\" ); Draw . showShapesInfo ( currSlide ); // second slide (bullets and image) currSlide = Draw . addSlide ( doc ); doBullets ( currSlide ); // third slide: title and video currSlide = Draw . addSlide ( doc ); Draw . titleOnlySlide ( currSlide , \"Clock Video\" ); Draw . drawMedia ( currSlide , \"clock.avi\" , 20 , 70 , 50 , 50 ); // fourth slide: buttons currSlide = Draw . addSlide ( doc ); buttonShapes ( currSlide ); // fifth slide: shapes created with dispatches dispatchShapes ( doc ); System . out . println ( \"Total no. of slides: \" + Draw . getSlidesCount ( doc )); Lo . saveDoc ( doc , \"makeslides.odp\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The five slides are explained in the following sections.","title":"Chapter 16. Making Slides"},{"location":"16-Making_Slides.html#1-the-first-slide-title-and-subtitle","text":"Draw.createImpressDoc() calls Lo.createDoc(), supplying it with the Impress document string type: // in the Draw class public static XComponent createImpressDoc ( XComponentLoader loader ) { return Lo . createDoc ( \"simpress\" , loader ); } This creates a new slide deck with one slide whose layout depends on Impress' default settings. Figure 1 shows the usual layout when a user starts Impress. Figure 1. The Default New Slide in Impress. The slide contains two empty presentation shapes \u2013 the text rectangle at the top is a TitleTextShape, and the larger rectangle below is a SubTitleShape. This first slide, which is at index position 0 in the deck, can be referred to by calling Draw.getSlide(): XDrawPage currSlide = Draw . getSlide ( doc , 0 ); This is the same method used to get the first page in a Draw document, so I won't go through it again. The XDrawPage object can be examined by calling Draw.showShapesInfo() which lists all the shapes (both draw and presentation ones) on the slide: // in Draw public static void showShapesInfo ( XDrawPage dp ) { System . out . println ( \"Draw Page shapes:\" ); ArrayList < XShape > shapes = getShapes ( dp ); if ( shapes != null ) { for ( XShape shape : shapes ) showShapeInfo ( shape ); } } // end of showShapesInfo() public static void showShapeInfo ( XShape xShape ) { System . out . println ( \" Shape service: \" + xShape . getShapeType () + \"; z-order: \" + getZOrder ( xShape )); } // end of showShapeInfo() public static int getZOrder ( XShape shape ) { return ( Integer ) Props . getProperty ( shape , \"ZOrder\" ); } Draw.showShapesInfo() output for the first slide is: Draw Page shapes: Shape service: com.sun.star.presentation.TitleTextShape; z-order: 0 Shape service: com.sun.star.presentation.SubtitleShape; z-order: 1 Obviously, the default layout sometimes isn't the one we want. One solution would be to delete the unnecessary shapes on the slide, then add the shapes that we do want. A better approach is the programming equivalent of selecting a different slide layout. This is implemented as several Draw methods, called titleSlide(), bulletsSlide(), titleOnlySlide(), and blankSlide(), which change the slide's layout to those shown in Figure 2. Figure 2. Slide Layout Methods. A title/subtitle layout is used for the first slide by calling: Draw . titleSlide ( currSlide , \"Java-Generated Slides\" , \"Using LibreOffice\" ); It generates the slide shown in Figure 3. Figure 3. The Title and Subtitle Slide. Having a Draw.titleSlide() method may seem a bit silly since we've seen that the first slide already uses this layout (e.g. in Figure 1). That's true for my Impress setup, but may not be the case for other installations with different configurations. The other layouts shown on the right of Figure 1 could also be implemented as Draw methods, but the four in Figure 2 seem most useful. They set the \"Layout\" property in the DrawPage service in the com.sun.star.presentation module (not the one in the drawing module). The documentation for DrawPage (use lodoc DrawPage presentation service ) only says that \"Layout\" stores a short; it doesn't list the possible values or how they correspond to layouts. However, there is a list at the excellent Japanese Office website, https://openoffice3.web.fc2.com/OOoBasic_Impress.html#OOoIPLy01a , which I used as the basis of the layout constants in my Draw class: // in Draw public static final int LAYOUT_TITLE_SUB = 0 ; // title, and subtitle below (the default, usually) public static final int LAYOUT_TITLE_BULLETS = 1 ; // the usual one you want public static final int LAYOUT_TITLE_CHART = 2 ; public static final int LAYOUT_TITLE_2CONTENT = 3 ; // 2 boxes: 1x2 (row x column), 1 row public static final int LAYOUT_TITLE_CONTENT_CHART = 4 ; public static final int LAYOUT_TITLE_CONTENT_CLIP = 6 ; public static final int LAYOUT_TITLE_CHART_CONTENT = 7 ; public static final int LAYOUT_TITLE_TABLE = 8 ; public static final int LAYOUT_TITLE_CLIP_CONTENT = 9 ; public static final int LAYOUT_TITLE_CONTENT_OBJECT = 10 ; public static final int LAYOUT_TITLE_OBJECT = 11 ; public static final int LAYOUT_TITLE_CONTENT_2CONTENT = 12 ; // 3 boxes in 2 columns: 1 in first col, 2 in second public static final int LAYOUT_TITLE_OBJECT_CONTENT = 13 ; public static final int LAYOUT_TITLE_CONTENT_OVER_CONTENT = 14 ; // 2 boxes: 2x1, 1 column public static final int LAYOUT_TITLE_2CONTENT_CONTENT = 15 ; // 3 boxes in 2 columns: 2 in first col, 1 in second public static final int LAYOUT_TITLE_2CONTENT_OVER_CONTENT = 16 ; // 3 boxes on 2 rows: 2 on first row, 1 on second public static final int LAYOUT_TITLE_CONTENT_OVER_OBJECT = 17 ; public static final int LAYOUT_TITLE_4OBJECT = 18 ; // 4 boxes: 2x2 public static final int LAYOUT_TITLE_ONLY = 19 ; // title only; no body shape public static final int LAYOUT_BLANK = 20 ; public static final int LAYOUT_VTITLE_VTEXT_CHART = 27 ; // vertical title, vertical text, and chart public static final int LAYOUT_VTITLE_VTEXT = 28 ; public static final int LAYOUT_TITLE_VTEXT = 29 ; public static final int LAYOUT_TITLE_VTEXT_CLIP = 30 ; public static final int LAYOUT_CENTERED_TEXT = 32 ; public static final int LAYOUT_TITLE_4CONTENT = 33 ; // 4 boxes: 2x2 public static final int LAYOUT_TITLE_6CONTENT = 34 ; // 6 boxes: 2x3 The four constants highlighted above are used by the Draw methods described next. Draw.titleSlide() starts by setting the slide's \"Layout\" property to LAYOUT_TITLE_SUB: // in Draw public static void titleSlide ( XDrawPage currSlide , String title , String subTitle ) { Props . setProperty ( currSlide , \"Layout\" , LAYOUT_TITLE_SUB ); // title and subtitle // add the title text to the title shape XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); XText textField = Lo . qi ( XText . class , xs ); textField . setString ( title ); // add the subtitle text to the subtitle shape xs = Draw . findShapeByType ( currSlide , Draw . SUBTITLE_TEXT ); textField = Lo . qi ( XText . class , xs ); textField . setString ( subTitle ); } // end of titleSlide() This changes the slide's layout to an empty TitleTextShape and SubtitleShape. The functions adds title and subtitle strings to these shapes, and returns. The tricky part is obtaining a reference to a particular shape so it can be modified. One (bad) solution is to use the index ordering of the shapes on the slide, which is displayed by Draw.showShapesInfo(). It turns out that TitleTextShape is first (i.e. at index 0), and SubtitleShape second. This can be used to write the following code: XShapes xShapes = Lo . qi ( XShapes . class , currSlide ); XShape titleShape = Lo . qi ( XShape . class , xShapes . getByIndex ( 0 )); XShape subTitleShape = Lo . qi ( XShape . class , xShapes . getByIndex ( 1 )); This is a bit hacky, so I coded Draw.findShapeByType() instead, which searches for a shape based on its type: // in Draw public static XShape findShapeByType ( XDrawPage slide , String shapeType ) { ArrayList < XShape > shapes = getShapes ( slide ); if ( shapes == null ) { System . out . println ( \"No shapes were found in the draw page\" ); return null ; } for ( XShape shape : shapes ) { if ( shapeType . equals ( shape . getShapeType ())) return shape ; } System . out . println ( \"No shape found of type \\\"\" + shapeType + \"\\\"\" ); return null ; } // end of findShapeByType() I added constants to the Draw class so the programmer wouldn't have to remember long shape type names: // in Draw public static final String TITLE_TEXT = \"com.sun.star.presentation.TitleTextShape\" ; public static final String SUBTITLE_TEXT = \"com.sun.star.presentation.SubtitleShape\" ; public static final String BULLETS_TEXT = \"com.sun.star.presentation.OutlinerShape\"; This allows me to find the title shape by calling: XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT );","title":"1.  The First Slide (Title and Subtitle)"},{"location":"16-Making_Slides.html#2-the-second-slide-title-bullets-and-image","text":"The second slide uses a title and bullet points layout, with an image added at the bottom right corner. The relevant lines in MakeSlides.java are: // in main() in MakeSlides.java... currSlide = Draw . addSlide ( doc ); doBullets ( currSlide ); The result is shown in Figure 4. Figure 4. A Slide with a Title, Bullet Points, and an Image. The slide is created by doBullets() in MakeSlides.java: // in MakeSlides.java private static void doBullets ( XDrawPage currSlide ) { XText body = Draw . bulletsSlide ( currSlide , \"What is an Algorithm?\" ); // bullet levels are 0, 1, 2,... Draw . addBullet ( body , 0 , \"An algorithm is a finite set of unambiguous instructions for solving a problem.\" ); Draw . addBullet ( body , 1 , \"An algorithm is correct if on all legitimate inputs, it outputs the right answer in a finite amount of time\" ); Draw . addBullet ( body , 0 , \"Can be expressed as\" ); Draw . addBullet ( body , 1 , \"pseudocode\" ); Draw . addBullet ( body , 1 , \"flow charts\" ); Draw . addBullet ( body , 1 , \"text in a natural language (e.g. English)\" ); Draw . addBullet ( body , 1 , \"computer code\" ); // add the image XShape im = Draw . drawImageOffset ( currSlide , \"skinner.png\" , 0.6 , 0.5 ); // in bottom right corner, and scaled if necessary Draw . moveToBottom ( currSlide , im ); //move pic below slide text } // end of doBullets() Draw.bulletsSlide() works in a similar way to Draw.titleSlide() \u2013 first the slide's layout is set, then the presentation shapes are found and modified: // in Draw public static XText bulletsSlide ( XDrawPage currSlide , String title ) { Props . setProperty ( currSlide , \"Layout\" , LAYOUT_TITLE_BULLETS ); // add the title text to the title shape XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); XText textField = Lo . qi ( XText . class , xs ); textField . setString ( title ); // return a reference to the bullet text area xs = Draw . findShapeByType ( currSlide , Draw . BULLETS_TEXT ); return Lo . qi ( XText . class , xs ); } // end of bulletsSlide() The Draw.LAYOUT_TITLE_BULLETS constant changes the slide's layout to contain two presentation shapes \u2013 a TitleTextShape at the top, and an OutlinerShape beneath it (as in the second picture in Figure 2). Draw.bulletsSlide() calls Draw.findShapeByType() twice to find these shapes, but it does nothing to the OutlinerShape itself, returning it as an XText reference. This allows text to be inserted into the shape by other code (i.e. by Draw.addBullet()).","title":"2.  The Second Slide (Title, Bullets, and Image)"},{"location":"16-Making_Slides.html#21-adding-bullets-to-a-text-area","text":"Draw.addBullet() converts the shape's XText reference into an XTextRange, which offers a setString() method: public static void addBullet ( XText bullsText , int level , String text ) { // access the end of the bullets text XTextRange tr = Lo . qi ( XTextRange . class , bullsText ). getEnd (); // set the bullet's level Props . setProperty ( tr , \"NumberingLevel\" ,( short ) level ); tr . setString ( text + \"\\n\" ); // add the text } // end of addBullet() As explained in Chapter 5, XTextRange is part of the TextRange service which inherits both paragraph and character property classes, as indicated by Figure 5. Figure 5. The TextRange Service. A look through the ParagraphProperties documentation reveals a \"NumberingLevel\" property which affects the displayed bullet level (use lodoc ParagraphProperties ). Another way of finding out about the properties associated with XTextRange is to use my Props.showObjProps() to list all of them: Props . showObjProps ( \"TextRange in OutlinerShape\" , tr ); The bullet text is added with XTextRange.setString(). A newline is added to the text before the set, to ensure that the string is treated as a complete paragraph. The drawback is that the newline causes an extra bullet symbol to be drawn after the real bullet points. This can be seen in Figure 4, at the bottom of the slide. (Principal Skinner is pointing at it.)","title":"2.1.  Adding Bullets to a Text Area"},{"location":"16-Making_Slides.html#22-offsetting-an-image","text":"The AnimBicycle.java example in Chapter 14 employed a version of Draw.drawImage() based around specifying an (x, y) position on the page and a width and height for the image frame. Draw.drawImageOffset() used here is a variant which specifies its position in terms of fractional offsets from the top-left corner of the slide. For example: XShape im = Draw . drawImageOffset ( currSlide , \"skinner.png\" , 0.6 , 0.5 ); The last two arguments mean that the image's top-left corner will be placed at a point that is 0.6 of the slide's width across and 0.5 of its height down. drawImageOffset() also scales the image so that it doesn't extend beyond the right and bottom edges of the slide. The scaling is the same along both dimensions so the picture isn't distorted. The code for Draw.drawImageOffset(): // in Draw public static XShape drawImageOffset ( XDrawPage slide , String imFnm , double xOffset , double yOffset ) { if (( xOffset < 0 ) || ( xOffset >= 1 )) { System . out . println ( \"xOffset should be between 0-1; using 0.5\" ); xOffset = 0.5 ; } if (( yOffset < 0 ) || ( yOffset >= 1 )) { System . out . println ( \"yOffset should be between 0-1; using 0.5\" ); yOffset = 0.5 ; } Size slideSize = Draw . getSlideSize ( slide ); // in mm units if ( slideSize == null ) { System . out . println ( \"Image drawing cannot proceed\" ); return null ; } int x = ( int ) Math . round ( slideSize . Width * xOffset ); //in mm units int y = ( int ) Math . round ( slideSize . Height * yOffset ); int maxWidth = slideSize . Width - x ; int maxHeight = slideSize . Height - y ; Size imSize = Images . calcScale ( imFnm , maxWidth , maxHeight ); return drawImage ( slide , imFnm , x , y , imSize . Width , imSize . Height ); } // end of drawImageOffset() drawImageOffset() uses the slide's size to determine an (x, y) position for the image, and its width and height. Images.calcScale() calculates the best width and height for the image frame such that the image will be drawn entirely on the slide: // in the Images class public static Size calcScale ( String fnm , int maxWidth , int maxHeight ) { Size imSize = Images . getSize100mm ( fnm ); // in 1/100 mm units if ( imSize == null ) return null ; // calculate the scale factors to obtain these maximums double widthScale = (( double ) maxWidth * 100 ) / imSize . Width ; double heightScale = (( double ) maxHeight * 100 ) / imSize . Height ; // use the smallest scale factor double scaleFactor = ( widthScale < heightScale ) ? widthScale : heightScale ; // calculate new dimensions for the image int w = ( int ) Math . round ( imSize . Width * scaleFactor / 100 ); int h = ( int ) Math . round ( imSize . Height * scaleFactor / 100 ); return new Size ( w , h ); } // end of calcScale() calcScale() uses Images.getSize100mm() to retrieve the size of the image in 1/100 mm units, and then a scale factor is calculated for both the width and height. This is used to set the image frame's dimensions when the graphic is loaded by drawImage().","title":"2.2.  Offsetting an Image"},{"location":"16-Making_Slides.html#3-the-third-slide-title-and-video","text":"The third slide consists of a title shape and a video frame, which looks like Figure 6. Figure 6. A Slide Containing a Video Frame. When this slide appears in a slide show, the video will automatically start playing. The code for generating this slide is: // main() of MakeSlides.java... currSlide = Draw . addSlide ( doc ); Draw . titleOnlySlide ( currSlide , \"Clock Video\" ); Draw . drawMedia ( currSlide , \"clock.avi\" , 20 , 70 , 50 , 50 ); Draw.titleOnlySlide() works in a similar way to titleSlide() and bulletsSlide(): // in Draw public static void titleOnlySlide ( XDrawPage currSlide , String header ) { Props . setProperty ( currSlide , \"Layout\" , LAYOUT_TITLE_ONLY ); // title only; no body shape // add the text to the title shape XShape xs = Draw . findShapeByType ( currSlide , Draw . TITLE_TEXT ); XText textField = Lo . qi ( XText . class , xs ); textField . setString ( header ); } // end of titleOnlySlide() The MediaShape service doesn't appear in the Office documentation. Perhaps one reason for its absence is that the shape behaves a little 'erratically'. In particular, although MakeSlides.java successfully builds a slide deck containing the video, Office crashes upon exiting. Also, when the deck is run as a slide show, the video frame is sometimes incorrectly placed, although the video plays correctly. Draw.drawMedia() is defined as: // in Draw public static XShape drawMedia ( XDrawPage slide , String fnm , int x , int y , int width , int height ) // causes Office to crash on exiting { XShape shape = addShape ( slide , \"MediaShape\" , x , y , width , height ); // Props.showObjProps(\"Shape\", shape); System . out . println ( \"Loading media: \\\"\" + fnm + \"\\\"\" ); Props . setProperty ( shape , \"MediaURL\" , FileIO . fnmToURL ( fnm )); Props . setProperty ( shape , \"Loop\" , true ); return shape ; } // end of drawMedia() In the absence of documentation, I used Props.showObjProps() to list the properties for the MediaShape: Props . showObjProps ( \"Shape\" , shape ); The \"MediaURL\" property requires a file in URL format, and \"Loop\" is a boolean for making the animation play repeatedly. Office supports the AVI and WMV video formats, but not MP4.","title":"3.  The Third Slide (Title and Video)"},{"location":"16-Making_Slides.html#4-the-fourth-slide-title-and-buttons","text":"The fourth slide has two 'buttons' \u2013 an ellipse which starts a video playing in an external application, and a rounded rectangle which makes the presentation jump to the first slide. These actions are both implemented using the \"OnClick\" property for presentation shapes. Figure 7 shows how the slide looks. Figure 7. A Slide with Two 'Buttons'. The relevant code in main() of MakeSlides.java is: currSlide = Draw . addSlide ( doc ); buttonShapes ( currSlide ); This button approach to playing a video doesn't suffer from the strange behavior when using MediaShape on the third slide. The buttonShapes() method in MakeSlides.java creates the slide: // in MakeSlides.java private static void buttonShapes ( XDrawPage currSlide ) { Draw . titleOnlySlide ( currSlide , \"Wildlife Video Via Button\" ); // button in the center of the slide com . sun . star . awt . Size sz = Draw . getSlideSize ( currSlide ); int width = 80 ; int height = 40 ; XShape ellipse = Draw . drawEllipse ( currSlide , ( sz . Width - width ) / 2 , ( sz . Height - height ) / 2 , width , height ); Draw . addText ( ellipse , \"Start Video\" , 30 ); Props . setProperty ( ellipse , \"OnClick\" , ClickAction . DOCUMENT ); Props . setProperty ( ellipse , \"Bookmark\" , FileIO . fnmToURL ( \"wildlife.wmv\" )); // draw a rounded rectangle with text XShape button = Draw . drawRectangle ( currSlide , sz . Width - width - 5 , sz . Height - height - 5 , width , height ); Draw . addText ( button , \"Click to go\\nto Slide 1\" ); Draw . setGradientColor ( button , \"Radial red/yellow\" ); Props . setProperty ( button , \"CornerRadius\" , 300 ); // 1/100 mm units Props . setProperty ( button , \"OnClick\" , ClickAction . FIRSTPAGE ); // clicking makes the presentation jump to first slide } // end of buttonShapes() A minor point of interest is that a rounded rectangle is a RectangleShape, but with its \"CornerRadius\" property set. The more important part of the method is the two uses of the \"OnClick\" property from the presentation Shape class. Clicking on the ellipse executes the video file \"wildlife.wmv\". This requires \"OnClick\" to be assigned the ClickAction.DOCUMENT constant, and \"Bookmark\" to refer to the file as an URL. Clicking on the rounded rectangle causes the slide show to jump back to the first page. This needs \"OnClick\" to be set to ClickAction.FIRSTPAGE. Several other forms of click action are listed in Table 1. ClickAction Name Effect NONE No action is performed on the click. Animation and fade effects are also switched off. PREVPAGE The presentation jumps to the previous page. NEXTPAGE The presentation jumps to the next page. FIRSTPAGE The presentation continues with the first page. LASTPAGE The presentation continues with the last page. BOOKMARK The presentation jumps to a bookmark. DOCUMENT The presentation jumps to another document. INVISIBLE The object renders itself invisible after a click. SOUND A sound is played after a click. VERB An OLE verb is performed on this object. VANISH The object vanishes with its effect. PROGRAM Another program is executed after a click. MACRO An Office macro is executed after the click. STOPPRESENTATION The presentation is stopped after the click. Table 1. ClickAction Effects. Table 1 shows that it's possible to jump to various places in a slide show, and also execute macros and external programs. In both cases, the \"Bookmark\" property is used to specify the URL of the macro or program. For example, the following will invoke Windows' calculator when the button is pressed: Props . setProperty ( button , \"OnClick\" , ClickAction . PROGRAM ); Props . setProperty ( button , \"Bookmark\" , FileIO . fnmToURL ( System . getenv ( \"SystemRoot\" ) + \"\\\\System32\\\\calc.exe\" ) ); \"Bookmark\" requires an absolute path to the application, converted to URL form. The ClickAction documentation can be reached using lodoc ClickAction , which loads the IDL webpage for the enumeration. Clicking on the \"ClickAction\" enum name takes you to a table very like the one in Table 1.","title":"4.  The Fourth Slide (Title and Buttons)"},{"location":"16-Making_Slides.html#5-shape-animation","text":"Shape animations are performed during a slide show, and are regulated through three presentation Shape properties: \"Effect\", \"Speed\" and \"TextEffect\". \"Effect\" can be assigned a large range of animation effects, which are defined as constants in the AnimationEffect enumeration. Use lodoc AnimationEffect to reach the presentation Shape service, then browse for its \"Effect\" property. Alternatively, you can find details in the com.sun.star.presentation module (use lodoc presentation module ). Another nice summary, in the form of a large table, is in the Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Drawings/Animations_and_Interactions/ (use loGuide \"Animations and Interactions\" ). Figure 8 shows part of that table. Figure 8. Part of the AnimationEffect Constants Table in the Developer's Guide. There are two broad groups of effects: those that move a shape onto the slide when the page appears, and fade effects that make a shape gradually appear in a given spot. The following code fragment makes the ellipse on the fourth slide fade into view, starting with the bottom of the shape: // in buttonShapes() in MakeSlides.java Props . setProperty ( ellipse , \"Effect\" , AnimationEffect . FADE_FROM_BOTTOM ); Props . setProperty ( ellipse , \"Speed\" , AnimationSpeed . SLOW ); The animation speed can be set to AnimationSpeed.SLOW, AnimationSpeed.MEDIUM, or AnimationSpeed.FAST. Unfortunately, there seems to be a problem saving these effects in the presentation file (\"makeSlides.odp\") created by MakeSlides.java. When that file is opened as a slide show, no animation effects occur \u2013 the ellipse is simply displayed. It seems that the shape animation properties are not saved to the ODP file, because when the ellipse is examined inside Impress, its \"Custom Animation\" task pane is empty.","title":"5.  Shape Animation"},{"location":"16-Making_Slides.html#more-complex-shape-animations","text":"If you browse chapter 9 of the Impress user's guide on slide shows, its animation capabilities extend well beyond the constants in AnimationEffect. These features are available through the XAnimationNode interface, which is obtained like so: XAnimationNodeSupplier nodeSupp = Lo . qi ( XAnimationNodeSupplier . class , slide ); XAnimationNode slideNode = nodeSupp . getAnimationNode (); XAnimationNode allows a programmer much finer control over animation timings and animation paths for shapes. XAnimationNode is part of the large com.sun.star.animations package (see lodoc animations module ). I won't be use XAnimationNode here.","title":"More Complex Shape Animations"},{"location":"16-Making_Slides.html#6-the-fifth-slide-various-dispatch-shapes","text":"The fifth slide is a hacky, slow solution for generating the numerous shapes in Impress' GUI which have no corresponding classes in the API. The approach uses dispatch commands, JNA, and Java's Robot class (first described back in Chapter 4). The resulting slide is shown in Figure 9. Figure 9. Shapes Created by Dispatch Commands. The shapes in Figure 9 are just a few of the many available via Impress' \"Drawing Toolbar\", shown in Figure 10. The relevant menus are labeled and their sub-menus are shown beneath the toolbar. Figure 10. The Shapes Available from the Drawing Toolbar. Each sub-menu shape has a name which appears in a tooltip when the cursor is placed over the shape's icon. This text turns out to be very useful when writing the dispatch commands. There's also a \"3D-Objects\" toolbar which offers the shapes in Figure 11. Figure 11. The 3D-Objects Toolbar. Some of these 3D shapes are available in the API as undocumented Shape subclasses, but I was unable to programmatically resize the shapes to make them visible. The only way I could get them to appear at a reasonable size was by creating them with dispatch commands. Although there's no mention of these custom and 3D shapes in the Developer's Guide, their dispatch commands do appear in the UICommands.ods spreadsheet (available from https://arielch.fedorapeople.org/devel/ooo/UICommands.ods ). They're also mentioned, in less detail, in the online documentation for Impress dispatches at https://wiki.documentfoundation.org/Development/DispatchCommands#Impress_slots_.28sdslots.29 . It's quite easy to match up the tooltip names in the GUI with the dispatch names. For example, the smiley face in the Symbol shapes menu is called \"Smiley Face\" in the GUI and \".uno:SymbolShapes.smiley\" in the UICommands spreadsheet. MakeSlides.java generates the eight shapes in Figure 9 by calling dispatchShapes(): // in MakeSlides.java private static void dispatchShapes ( XComponent doc ) { XDrawPage currSlide = Draw . addSlide ( doc ); Draw . titleOnlySlide ( currSlide , \"Dispatched Shapes\" ); GUI . setVisible ( doc , true ); Lo . wait ( 1000 ); Draw . gotoPage ( doc , currSlide ); System . out . println ( \"Viewing Slide number: \" + Draw . getSlideNumber ( Draw . getViewedPage ( doc ))); // first row XShape dShape = Draw . addDispatchShape ( currSlide , \"BasicShapes.diamond\" , 20 , 60 , 50 , 30 ); Draw . addDispatchShape ( currSlide , \"HalfSphere\" , 80 , 60 , 50 , 30 ); // 3D dShape = Draw . addDispatchShape ( currSlide , \"CalloutShapes.cloud-callout\" , 140 , 60 , 50 , 30 ); Draw . setBitmapColor ( dShape , \"Sky\" ); dShape = Draw . addDispatchShape ( currSlide , \"FlowChartShapes.flowchart-card\" , 200 , 60 , 50 , 30 ); Draw . setHatchingColor ( dShape , \"Black -45 degrees\" ); // second row dShape = Draw . addDispatchShape ( currSlide , \"StarShapes.star12\" , 20 , 140 , 40 , 40 ); Draw . setGradientColor ( dShape , \"Radial red/yellow\" ); Props . setProperty ( dShape , \"LineStyle\" , LineStyle . NONE ); // no outline dShape = Draw . addDispatchShape ( currSlide , \"SymbolShapes.heart\" , 80 , 140 , 40 , 40 ); Props . setProperty ( dShape , \"FillColor\" , 0xFF0000 ); Draw . addDispatchShape ( currSlide , \"ArrowShapes.left-right-arrow\" , 140 , 140 , 50 , 30 ); // Block Arrow sub-menu dShape = Draw . addDispatchShape ( currSlide , \"Cyramid\" , 200 , 120 , 50 , 50 ); // 3D pyramid, misspelt Draw . setBitmapColor ( dShape , \"Stone\" ); Draw . showShapesInfo ( currSlide ); } // end of dispatchShapes() A title-only slide is created, followed by eight calls to Draw.addDispatchShape() to create two rows of four shapes in Figure 9.","title":"6.  The Fifth Slide (Various Dispatch Shapes)"},{"location":"16-Making_Slides.html#61-viewing-the-fifth-slide","text":"Draw.addDispatchShape() requires the fifth slide to be the active, visible window on- screen. This necessitates a call to GUI.setVisible() to make the document visible, but that isn't quite enough. Making the document visible causes the first slide to be displayed, not the fifth one. Impress offers many ways of viewing slides, which are implemented in the API as view classes that inherit the Controller service. The inheritance structure is shown in Figure 12. Figure 12. Impress View Classes. When a Draw or Impress document is being edited, the view is DrawingDocumentDrawView, which supports a number of useful properties, such as \"ZoomType\" and \"VisibleArea\". Its XDrawView interface is employed for getting and setting the current page displayed in this view. Draw.gotoPage() gets the XController interface for the document, and converts it to XDrawView so the visible page can be set: // in Draw public static void gotoPage ( XComponent doc , XDrawPage page ) { XController ctrl = GUI . getCurrentController ( doc ); gotoPage ( ctrl , page ); } // end of jumpToPage() public static void gotoPage ( XController ctrl , XDrawPage page ) { XDrawView xDrawView = Lo . qi ( XDrawView . class , ctrl ); xDrawView . setCurrentPage ( page ); } // end of gotoPage() After the call to Draw.gotoPage(), the specified draw page will be visible on-screen, and so receive any dispatch commands. Draw.getViewedPage() returns a reference to the currently viewed page by calling XDrawView.getCurrentPage(): // in Draw public static XDrawPage getViewedPage ( XComponent doc ) { XController ctrl = GUI . getCurrentController ( doc ); XDrawView xDrawView = Lo . qi ( XDrawView . class , ctrl ); return xDrawView . getCurrentPage (); } // end of getViewedPage()","title":"6.1.  Viewing the Fifth Slide"},{"location":"16-Making_Slides.html#62-adding-a-dispatch-shape-to-the-visible-page","text":"If you try adding a smiley face to a slide inside Impress, it's a two-step process. It isn't enough only to click on the icon, it's also necessary to drag the cursor over the page in order for the shape to appear and be resized. These steps are necessary for all the Drawing toolbar and 3D-Objects shapes, and are emulated by my code. The programming equivalent of clicking on the icon is done by calling Lo.dispatchCmd(), while implementing a mouse drag utilizes JNA and Java's Robot class. Draw.addDispatchShape() uses createDispatchShape() to create the shape, and then positions and resizes it: // in Draw public static XShape addDispatchShape ( XDrawPage slide , String shapeDispatch , int x , int y , int width , int height ) { warnsPosition ( slide , x , y ); XShape shape = createDispatchShape ( slide , shapeDispatch ); if ( shape != null ) { setPosition ( shape , x , y ); setSize ( shape , width , height ); } return shape ; } // end of addDispatchShape() Draw.createDispatchShape() implements icon selection and click-and-drag: // in Draw public static XShape createDispatchShape ( XDrawPage slide , String shapeDispatch ) { int numShapes = slide . getCount (); Lo . dispatchCmd ( shapeDispatch ); // select the shape icon; Office must be visible Lo . wait ( 1000 ); // click and drag on the page to create the shape on the page; // the current page must be visible java . awt . Point p1 = JNAUtils . getClickPoint ( JNAUtils . getHandle () ); java . awt . Point p2 = JNAUtils . getOffsetPoint ( p1 , 100 , 100 ); // hardwired offset JNAUtils . doDrag ( p1 , p2 ); // drag the cursor between p1 and p2 Lo . wait ( 2000 ); /* get a reference to the shape by assuming it's the top one on the page */ int numShapes2 = slide . getCount (); if ( numShapes2 == numShapes + 1 ) { // there's a new shape System . out . println ( \"Shape \\\"\" + shapeDispatch + \"\\\" created\" ); return Draw . findTopShape ( slide ); } else { // no new shape System . out . println ( \"Shape \\\"\" + shapeDispatch + \"\\\" not created\" ); return null ; } } // end of createDispatchShape() The click-and-drag operation doesn't return a reference to the shape, so createDispatchShape() ends by calling Draw.findTopShape(). It returns a reference to the top-most shape on the page, which I'm assuming is the new shape.","title":"6.2.  Adding a Dispatch Shape to the Visible Page"},{"location":"16-Making_Slides.html#63-using-jna-to-click-and-drag","text":"JNAUtils.getHandle() returns Window's handle for Office, and getClickPoint() calculates the center of the Office window: // in JNAUtils public static Point getClickPoint ( HWND handle ) { Rectangle bounds = getBounds ( handle ); if ( bounds == null ) { System . out . println ( \"Bounding rectangle is null\" ); return null ; } int xCenter = bounds . x + bounds . width / 2 ; int yCenter = bounds . y + bounds . height / 2 ; return new Point ( xCenter , yCenter ); } // end of getClickPoint() I'm hoping that this point is somewhere on the slide. JNAUtils.getOffsetPoint() creates a second point offset some distance from the first: public static Point getOffsetPoint ( Point p1 , int xDist , int yDist ) { return new Point ( p1 . x + xDist , p1 . y + yDist ); } Again, I'm hoping this point is on the slide. JNAUtils.doDrag() employs Java's Robot class to send mouse actions to the active window. doDrag() moves the cursor to the first point, then sends press and move events to simulate a cursor drag to the second point. It finishes by sending a release event for the mouse button: // in JNAUtils public static void doDrag ( final Point clickPt , final Point releasePt ) // drag the cursor between the two points { if ( clickPt == null ) { System . out . println ( \"Click point is null\" ); return ; } if ( releasePt == null ) { System . out . println ( \"Release point is null\" ); return ; } EventQueue . invokeLater ( new Runnable () { public void run () { try { Point oldPos = MouseInfo . getPointerInfo (). getLocation (); Robot r = new Robot (); r . mouseMove ( clickPt . x , clickPt . y ); Lo . delay ( 300 ); r . mousePress ( InputEvent . BUTTON1_MASK ); Lo . delay ( 300 ); r . mouseMove ( releasePt . x , releasePt . y ); Lo . delay ( 300 ); r . mouseRelease ( InputEvent . BUTTON1_MASK ); r . mouseMove ( oldPos . x , oldPos . y ); } catch ( AWTException e ) { System . out . println ( \"Unable to carry out Drag: \" + e ); } } }); } // end of doDrag() The Robot events must be added to Java's event queue, so are wrapped up in a call to EventQueue.invokeLater(). The final call to Robot.mouseMove() moves the cursor back to its original position.","title":"6.3.  Using JNA to Click and Drag"},{"location":"16-Making_Slides.html#64-things-that-can-go-wrong","text":"createDispatchShape() assumes that the slide being edited by Office is the visible, active window. If these conditions aren't met then the dispatch and the dragging will go to the wrong window. Unfortunately, calling GUI.setVisible() and Draw.gotoPage() do not guarantee these conditions, since after their call the OS or the user may inadvertently change the desktop's focus. A different window could become active, and so receive those commands. There are also timing issues: the call to Lo.dispatchCmd() returns immediately, but the processing of the dispatch by Office may take hundreds of milliseconds. This is why calls to Lo.delay() are scattered through the code, to give the dispatches time to be processed. There's also a timing problem with EventQueue.invokeLater() which returns immediately after queuing up the Robot actions. The processing of its events may also take many hundreds of milliseconds, so createDispatchShape() must call Lo.delay() after returning from JNAUtils.doDrag(). Yet another problem is my assumption that the press and drag points are on the slide, and not some other part of the application window, such as the toolbar.","title":"6.4.  Things that Can Go Wrong"},{"location":"16-Making_Slides.html#65-3d-shapes-might-be-different-but-arent","text":"3D shapes are available both through the 3D-Objects toolbar (see Figure 11), and as undocumented Shape APIs. The classes don't match up exactly with the eight shapes in the toolbar, but are similar.The classes are Shape3DCubeObject, Shape3DSphereObject, , Shape3DPolygonObject, Shape3DLatheObject, Shape3DExtrudeObject, and Shape3DSceneObject, which all belong to the com.sun.star.drawing package. It should be possible to build a 3D cube by calling: XShape shape3D = Draw . addShape ( currSlide , \"Shape3DCubeObject\" , 120 , 120 , 60 , 60 ); I tried this, and it nearly worked. The resulting slide contains a Shape3DCubeObject object, which I deduced by listing all the shapes on the current slide with Draw.showShapesInfo(). Unfortunately, the shape is invisible because its width and height are 0. No amount of fiddling with its properties could change these zero dimensions. The conclusion of all this programming ugliness is that the API needs to be brought up to date so it can access all the shapes available through the GUI.","title":"6.5.  3D Shapes Might be Different (but aren't)"},{"location":"17-Slide_Deck_Manipulation.html","text":"Chapter 17. Slide Deck Manipulation \u00b6 Topics Deck Building; Master Pages; Adding a Slide to a Deck; Rearranging a Deck; Appending Two Decks; Exporting a Slide as an Image; Extracting the Text from a Deck Example folders: \"Draw Tests\" and \"Utils\" This chapter looks at a number of common tasks performed with slide decks: building a slide deck based on a file of text notes; using, changing, and creating master pages for slide decks; adding a slide to an existing deck; rearranging the slides in a deck; appending two (or more) decks; exporting a slide from a deck as an image; extracting all the text from a slide deck. 1. Building a Deck from Notes \u00b6 With Draw methods such as titleSlide() and bulletsSlide() it's quite easy to write a program that converts a set of notes in a text file into a slides deck. The PointsBuilder.java example does just that, using textual input formatted as shown below: What is a Algorithm? > An algorithm is a finite set of unambiguous instructions for solving a problem. >> An algorithm is correct if on all legitimate inputs, it outputs the right answer in a finite amount of time > Can be expressed as >>pseudocode >>flow charts >>text in a natural language (e.g. English) >>computer code Algorithm Design > The theoretical study of how to solve computational problems >>sorting a list of numbers >> finding a shortest route on a map >> scheduling when to work on homework >> answering web search queries >> and so on... When PointsBuilder reads this text, it generates three slides, and saves them to \"points.odp\" which is shown in Figure 1. Figure 1. Slides Generated by PointsBuilder.java The title slide in Figure 1 is generated automatically, but the other slides are created from the input text by calling Draw.bulletsSlide() and Draw.addBullet(). The reason the output looks so good is that PointsBuilder.java uses one of Impress' templates, \"Inspiration.otp\". These files are listed in Impress when you open the \"Master Pages\" section of the Tasks pane, part of which is shown in Figure 2. Figure 2. The List of Master Pages in Impress. If you move the cursor over the thumbnail images, the name of the template file is displayed as a tooltip. The main() function of PointsBuilder.java starts by printing the names of all the available templates, before using \"Inspiration.otp\" to create a new presentation document: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: PointsBuilder <points fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); reportTemplates (); String templateFnm = Draw . getSlideTemplatePath () + \"Inspiration.otp\" ; XComponent doc = Lo . createDocFromTemplate ( templateFnm , loader ); if ( doc == null ) { System . out . println ( \"Impress doc creation failed\" ); Lo . closeOffice (); return ; } readPoints ( args [ 0 ] , doc ); System . out . println ( \"Total no. of slides: \" + Draw . getSlidesCount ( doc )); Lo . saveDoc ( doc , \"points.odp\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() reportTemplates() uses Info.getDirs(\"Template\") to retrieve a list of all the directories examined by Office when looking for templates. It also calls Draw.getSlideTemplatePath() to retrieve the default slide template directory, and prints the names of the files in that folder: // in PointsBuilder.java private static void reportTemplates () { String [] templateDirs = Info . getDirs ( \"Template\" ); System . out . println ( \"Templates dirs:\" ); for ( String dir : templateDirs ) System . out . println ( \" \" + dir ); String templateDir = Draw . getSlideTemplatePath (); System . out . println ( \"\\nTemplates files in \\\"\" + templateDir + \"\\\"\" ); String [] templatesFnms = FileIO . getFileNames ( templateDir ); for ( String fnm : templatesFnms ) System . out . println ( \" \" + fnm ); } // end of reportTemplates() reportTemplates()'s output: Templates dirs: C:\\Program Files\\LibreOffice 4\\share\\template\\en-US C:\\Program Files\\LibreOffice 4\\share\\template\\common C:\\Users\\Ad\\Desktop\\LibreOffice Tests\\ Draw Tests\\$BUNDLED_EXTENSIONS\\wiki-publisher\\templates C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user\\template Templates files in \"C:\\Program Files\\LibreOffice 4\\ share/template/common/layout/\" AbstractGreen.otp AbstractRed.otp AbstractYellow.otp BrightBlue.otp DNA.otp Inspiration.otp LushGreen.otp Metropolis.otp Sunset.otp Vintage.otp PointsBuilder employs the \"Inspiration.otp\" template, via the call: String templateFnm = Draw . getSlideTemplatePath () + \"Inspiration.otp\" ; XComponent doc = Lo . createDocFromTemplate ( templateFnm , loader ); Lo.createDocFromTemplate() is a variant of Lo.createDoc() which specifies a template for the new document. It calls XComponentLoader.loadComponentFromURL() with the template file as an argument, and sets the \"AsTemplate\" property: // in the Lo class // global private static XMultiServiceFactory msFactory = null ; public static XComponent createDocFromTemplate ( String templatePath , XComponentLoader loader ) // create a new document using the specified template { if ( ! FileIO . isOpenable ( templatePath )) return null ; System . out . println ( \"Opening template \" + templatePath ); String templateURL = FileIO . fnmToURL ( templatePath ); if ( templateURL == null ) return null ; PropertyValue [] props = Props . makeProps ( \"Hidden\" , true , \"AsTemplate\" , true ); XComponent doc = null ; try { doc = loader . loadComponentFromURL ( templateURL , \"_blank\" , 0 , props ); msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); } catch ( Exception e ) { System . out . println ( \"Could not create doc from template: \" + e ); } return doc ; } // end of createDocFromTemplate() The readPoints() method in PointsBuilder.java loads the text points file line-by-line. It ignores blank lines and lines starting with \"//\", and examines the first character on each line: // in PointsBuilder.java private static void readPoints ( String fnm , XComponent doc ) { XDrawPage currSlide = Draw . getSlide ( doc , 0 ); Draw . titleSlide ( currSlide , \"Java-Generated Slides\" , \"Using LibreOffice\" ); XText body = null ; try { BufferedReader br = new BufferedReader ( new FileReader ( fnm )); String line ; char ch ; while (( line = br . readLine ()) != null ) { if ( line . length () == 0 ) // blank line continue ; if ( line . startsWith ( \"//\" )) // comment continue ; ch = line . charAt ( 0 ); if ( ch == '>' ) // a bullet with some indentation processBullet ( line , body ); else { // a title for a new slide currSlide = Draw . addSlide ( doc ); body = Draw . bulletsSlide ( currSlide , line ); } } br . close (); System . out . println ( \"Read in points file: \" + fnm ); } catch ( IOException e ) { System . out . println ( \"Error reading points file: \" + fnm ); } } // end of readPoints() If the line starts with a '>', then processBullet() is called to determine how many '>'s start the line. Depending on the number, Draw.addBullet() is called with a different bullet indentation level value. If the line doesn't start with a '>', then it's assumed to be the title line of a new slide, and Draw.addSlide() and Draw.bulletsSlide() create a new bullets-based slide. 2. Master Pages \u00b6 When a new slide deck is created it always has a single slide and a default master page, and every slide created subsequently will use this master page to format its background. The easiest way to view the master page is through the Impress GUI \u2013 by clicking on the View, Master, Slide Master menu, which displays something like Figure 3. Figure 3. The Default Master Page. There are five presentation shapes in Figure 3. From top-to-bottom, left-to-right, they are TitleTextShape, OutlinerShape , DateTimeShape. FooterShape, and SlideNumberShape. Even though a new slide links to this master page, the date/time, footer, and slide number text are not automatically displayed on the slide; their rendering must be turned on. It's possible to create more master pages in addition to the default one in Figure 3, and link a slide to one of those. The MastersUse.java example illustrates a number of master page features: the default master page has text added to its footer section, and a shape and text are placed in its top-left corner. The slide deck holds four slides \u2013 three of them link to the default master page, and are set to display its footer and slide number. However, the third slide in the deck links to a second master page with a slightly different appearance. Figure 4 shows the all the slides in the deck. Figure 4. A Slide Deck with Two Master Pages. Slides 1, 2, and 4 use the default master page, while slide 3 uses the new master. The main() function for MastersUse.java is: public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createImpressDoc ( loader ); if ( doc == null ) { System . out . println ( \"Impress doc creation failed\" ); Lo . closeOffice (); return ; } // report the shapes on the default master page XDrawPage masterPage = Draw . getMasterPage ( doc , 0 ); System . out . println ( \"Default Master Page\" ); Draw . showShapesInfo ( masterPage ); // set the master page's footer text Draw . setMasterFooter ( masterPage , \"Master Use Slides\" ); // add a rectangle and text to the default master page // at the top-left of the slide Size sz = Draw . getSlideSize ( masterPage ); Draw . drawRectangle ( masterPage , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Draw . drawText ( masterPage , \"Default Master Page\" , 10 , 15 , 100 , 10 , 24 ); /* set slide 1 to use the master page's slide number but its own footer text */ XDrawPage slide1 = Draw . getSlide ( doc , 0 ); Draw . titleSlide ( slide1 , \"Slide 1\" , \"\" ); Props . setProperty ( slide1 , \"IsPageNumberVisible\" , true ); // use the master page's slide number Props . setProperty ( slide1 , \"IsFooterVisible\" , true ); Props . setProperty ( slide1 , \"FooterText\" , \"MU Slides\" ); // change master page's footer for first slide (does not work) /* add three more slides, which use the master page's slide number and footer */ for ( int i = 1 ; i < 4 ; i ++ ) { XDrawPage slide = Draw . insertSlide ( doc , i ); Draw . bulletsSlide ( slide , \"Slide \" + ( i + 1 )); Props . setProperty ( slide , \"IsPageNumberVisible\" , true ); Props . setProperty ( slide , \"IsFooterVisible\" , true ); } // create master page 2 XDrawPage masterPage2 = Draw . insertMasterPage ( doc , 1 ); Draw . addSlideNumber ( masterPage2 ); // add slide number System . out . println ( \"Master Page 2\" ); Draw . showShapesInfo ( masterPage2 ); // link third slide to master page 2 Draw . setMasterPage ( Draw . getSlide ( doc , 2 ), masterPage2 ); // put green ellipse and text on master page 2 XShape ellipse = Draw . drawEllipse ( masterPage2 , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Props . setProperty ( ellipse , \"FillColor\" , 0xCCFF33 ); //neon green Draw . drawText ( masterPage2 , \"Master Page 2\" , 10 , 15 , 100 , 10 , 24 ); Lo . saveDoc ( doc , \"muSlides.odp\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() 2.1. Accessing a Master Page \u00b6 A presentation (or drawing) document can access its master pages through the XMasterPagesSupplier interface in the GenericDrawingDocument service. XMasterPagesSupplier.getMasterPages() returns a single XDrawPages object: XMasterPagesSupplier mpSupp = Lo . qi ( XMasterPagesSupplier . class , doc ); XDrawPages pgs = mpSupp . getMasterPages (); The XDrawPages object is an indexed collection, with the default master page at position 0: XDrawPage masterPage = Lo . qi ( XDrawPage . class , pgs . getByIndex ( 0 )); Note that there's no \"XMasterPage\" interface \u2013 both slides and master pages are manipulated using XDrawPage. These preceding lines are packaged up as Draw.getMasterPage(): // in the Draw class public static XDrawPage getMasterPage ( XComponent doc , int idx ) // get master page by index { try { XMasterPagesSupplier mpSupp = Lo . qi ( XMasterPagesSupplier . class , doc ); XDrawPages pgs = mpSupp . getMasterPages (); return Lo . qi ( XDrawPage . class , pgs . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not find master slide \" + idx ); return null ; } } // end of getMasterPage() There's a second way of obtaining a master page, via the link between a slide and its master; the linked master is called a target. This is implemented by a second Draw.getMasterPage() method: // in the Draw class public static XDrawPage getMasterPage ( XDrawPage slide ) // return master page for the slide { XMasterPageTarget mpTarget = Lo . qi ( XMasterPageTarget . class , slide ); return mpTarget . getMasterPage (); } // end of getMasterPage() 2.2. What's on a Master Page? \u00b6 The default master page was shown in Figure 3, and its structure is confirmed in MastersUse.java when Draw.showShapesInfo() is called: // in main() of MastersUse.java XDrawPage masterPage = Draw . getMasterPage ( doc , 0 ); System . out . println ( \"Default Master Page\" ); Draw . showShapesInfo ( masterPage ); The output: Default Master Page Draw Page shapes: Shape service: com.sun.star.presentation.TitleTextShape; z-order: 0 Shape service: com.sun.star.presentation.OutlinerShape; z-order: 1 Shape service: com.sun.star.presentation.DateTimeShape; z-order: 2 Shape service: com.sun.star.presentation.FooterShape; z-order: 3 Shape service: com.sun.star.presentation.SlideNumberShape;z-order:4 A new master page is created by using XMasterPagesSupplier.getMasterPages() and XDrawPages.insertNewByIndex(), as shown in Draw.insertMasterPage(): // in the Draw class public static XDrawPage insertMasterPage ( XComponent doc , int idx ) // creates new master page at the given index position, { XMasterPagesSupplier mpSupp = Lo . qi ( XMasterPagesSupplier . class , doc ); XDrawPages pgs = mpSupp . getMasterPages (); return pgs . insertNewByIndex ( idx ); } // end of insertMasterPage() The new master page contains no presentation shapes (unlike the default one). They must be added separately. 2.3. Modifying a Master Page \u00b6 MastersUse.java changes the default master page in three ways: it adds text to the footer shape (which is empty by default), and places a blue rectangle and some text in the top-left corner of the master: // in main() of MastersUse.java // set the master page's footer text Draw . setMasterFooter ( masterPage , \"Master Use Slides\" ); // add a rectangle and text to the default master page // at the top-left of the slide Size sz = Draw . getSlideSize ( masterPage ); Draw . drawRectangle ( masterPage , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Draw . drawText ( masterPage , \"Default Master Page\" , 10 , 15 , 100 , 10 , 24 ); Draw.setMasterFooter() searches through the shapes on the page looking for a FooterShape. The shape is cast to a text interface, and a string added: // in Draw public static void setMasterFooter ( XDrawPage master , String text ) // set the master page's footer text { XShape footerShape = Draw . findShapeByType ( master , \"com.sun.star.presentation.FooterShape\" ); XText textField = Lo . qi ( XText . class , footerShape ); textField . setString ( text ); } // end of setMasterFooter() MastersUse's second master page contains no shapes initially. An ellipse and some text are added to it in the same way as for the default master page: // in main() of MastersUse.java XDrawPage masterPage2 = Draw . insertMasterPage ( doc , 1 ); : // put ellipse and text on master page 2 XShape ellipse = Draw . drawEllipse ( masterPage2 , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Props . setProperty ( ellipse , \"FillColor\" , 0xCCFF33 ); // neon green Draw . drawText ( masterPage2 , \"Master Page 2\" , 10 , 15 , 100 , 10 , 24 ); Unlike the default master page, a number shape must be explicitly added to the second master, by calling Draw.addSlideNumber(): Draw . addSlideNumber ( masterPage2 ); It is implemented as: // in the Draw class public static XShape addSlideNumber ( XDrawPage slide ) // add slide number at bottom right (like on the default master) { Size sz = Draw . getSlideSize ( slide ); int width = 60 ; int height = 15 ; return Draw . addPresShape ( slide , \"SlideNumberShape\" , sz . Width - width - 12 , sz . Height - height - 4 , width , height ); } // end of addSlideNumber() Draw.addPresShape() creates a shape from the \"com.sun.star.presentation\" package: // in the Draw class public static XShape addPresShape ( XDrawPage slide , String shapeType , int x , int y , int width , int height ) { warnsPosition ( slide , x , y ); XShape shape = Lo . createInstanceMSF ( XShape . class , \"com.sun.star.presentation.\" + shapeType ); if ( shape != null ) { slide . add ( shape ); setPosition ( shape , x , y ); setSize ( shape , width , height ); } return shape ; } // end of addPresShape() 2.4. Using a Master Page \u00b6 New slides are automatically linked to the default master page, but properties must be explicitly set in order for the master's date/time, footer, and page number to be visible on the slide. For example, the footer and page number are drawn on a slide like so: // in main() of MastersUse.java XDrawPage slide1 = Draw . getSlide ( doc , 0 ); : Props . setProperty ( slide1 , \"IsPageNumberVisible\" , true ); Props . setProperty ( slide1 , \"IsFooterVisible\" , true ); The relevant property for showing the date/time is \"IsDateTimeVisible\". All these properties are define in the com.sun.star.presentation.DrawPage service. A related property is \"FooterText\", which changes the footer text for a specific slide. For example: Props . setProperty ( slide1 , \"FooterText\" , \"MU Slides\" ); However, this only works if the linked master page doesn't have its own footer text. A slide can be linked to a different master by calling Draw.setMasterPage(): // in main() of MastersUse.java // link third slide to second master XDrawPage slide3 = Draw . getSlide ( doc , 2 ); Draw . setMasterPage ( slide3 , masterPage2 ); It uses the XMasterPageTarget interface to create the new link: // in the Draw class public static void setMasterPage ( XDrawPage slide , XDrawPage mPg ) { XMasterPageTarget mpTarget = Lo . qi ( XMasterPageTarget . class , slide ); mpTarget . setMasterPage ( mPg ); } 3. Adding a Slide to a Deck \u00b6 The last section used XDrawPages.insertNewByIndex() to add a master page to the deck The same method is more commonly employed to add an ordinary slide. An example is shown in ModifySlides.java: its main() function opens a file, adds a title-only slide at the end of the deck, and a title/subtitle slide at the beginning. It finishes by saving the modified deck to a new file: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: ModifySlides fnm\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( ! Info . isDocType ( doc , Lo . IMPRESS_SERVICE )) { System . out . println ( \"-- not a slides presentation\" ); Lo . closeOffice (); return ; } XDrawPages slides = Draw . getSlides ( doc ); // add a title-only slide with a graphic at the end XDrawPage lastPage = slides . insertNewByIndex ( numSlides ); Draw . titleOnlySlide ( lastPage , \"Any Questions?\" ); Draw . drawImage ( lastPage , \"questions.png\" ); // add a title/subtitle slide at the start XDrawPage firstPage = slides . insertNewByIndex ( 0 ); // this is added after first slide! Draw . titleSlide ( firstPage , \"Interesting Slides\" , \"Andrew\" ); Lo . saveDoc ( doc , Info . getName ( args [ 0 ] ) + \"_Mod.\" + Info . getExt ( args [ 0 ] )); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() But if you examine the new file, you'll see that the title/subtitle slide has become the second slide in the deck. This highlights a restriction on XDrawPages.insertNewByIndex(), which is that a new slide cannot be inserted at index position 0. Instead, it will be inserted at the next spot, position 1. 4. Rearranging a Slide Deck \u00b6 A surprising gap in the presentation API is the lack of a simple way to rearrange slides: for example, to move the second slide to the fifth position. The closest the API comes is the ability to duplicate a slide, but the copy is always inserted after the original, so isn't of much use. If you did want to do this, the code would be something like: XDrawPageDuplicator dup = Lo . qi ( XDrawPageDuplicator . class , doc ); XDrawPage dupSlide = dup . duplicate ( slide ); // dupSlide is located after original slide in the deck The only way to rearrange slides inside Office is with dispatch commands, in particular with the \"Copy\" and \"Paste\" commands. This is complicated by the fact that copying an entire slide is only possible when the deck is displayed in slide-sorter mode. The CopySlide.java example illustrates the technique but, as with most uses of dispatching, is quite fragile. The better answer is to utilize a third-part API, the ODF Toolkit, which is the topic of Chapter 51. CopySlide.java is called with three arguments \u2013 the filename and two slide indices. The first index is the source slide's position in the deck, and the second is the position after which the copied slide will appear. For instance: > run CopySlide points.odp 1 4 will copy the second slide of the deck to after the fifth slide. The main() function of CopySlide.java: public static void main ( String args [] ) { if ( args . length != 3 ) { System . out . println ( \"Usage: CopySlide fnm from-index to-index\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open the file: \" + args [ 0 ] ); Lo . closeOffice (); return ; } int fromIdx = Lo . parseInt ( args [ 1 ] ); int toIdx = Lo . parseInt ( args [ 2 ] ); int numSlides = Draw . getSlidesCount ( doc ); if (( fromIdx < 0 ) || ( toIdx < 0 ) || ( fromIdx >= numSlides ) || ( toIdx >= numSlides )) { System . out . println ( \"One or both indices are out of range\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); copyTo ( doc , fromIdx , toIdx ); // Draw.deleteSlide(doc, fromIdx); // a problem if the copying changes the indices Lo . save ( doc ); // overwrite Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() All the interesting stuff is performed by copyTo(). One minor thing to note is the call to Lo.save() which causes the changed slide deck to be saved back to its original file. It is defined as: // in the Lo class public static void save ( XComponent doc ) { XStorable store = Lo . qi ( XStorable . class , doc ); try { store . store (); System . out . println ( \"Saved the document by overwriting\" ); } catch ( IOException e ) { System . out . println ( \"Could not save the document\" ); } } // end of save() I usually avoid calling Lo.save() due to the fact that it overwrites the input file; I prefer to create a new file to hold changes. I've commented out the call to Draw.deleteSlide() in main() due to its potential to cause damage. The problem is that the new slide may cause the overall indexing of the slide deck to change. For example, consider what happens if the fourth slide is copied to after the second slide. This will create a new third slide, moving the old third slide, and all later slides, to the right. If the program now deletes the fourth slide, that's not the slide that's just been copied, but the repositioned third slide. The copyTo() function in CopySlide.java: // in CopySlide.java private static void copyTo ( XComponent doc , int fromIdx , int toIdx ) /* Copy fromIdx slide to the clipboard in slide-sorter mode, then paste it to after the toIdx slide. */ { XController ctrl = GUI . getCurrentController ( doc ); Lo . dispatchCmd ( \"DiaMode\" ); // Switch to slide-sorter view so that slides can be copied Lo . delay ( 5000 ); // give Office plenty of time to do it XDrawPage fromSlide = Draw . getSlide ( doc , fromIdx ); XDrawPage toSlide = Draw . getSlide ( doc , toIdx ); Draw . gotoPage ( ctrl , fromSlide ); // select this slide Lo . dispatchCmd ( \"Copy\" ); System . out . println ( \"Copied \" + fromIdx ); Draw . gotoPage ( ctrl , toSlide ); Lo . dispatchCmd ( \"Paste\" ); System . out . println ( \"Pasted to after \" + toIdx ); Lo . dispatchCmd ( \"DrawingMode\" ); } // end of copyTo() The method sends out four dispatches: the \"DiaMode\" command switches the application into slide-sorter mode, and is followed by \"Copy\", \"Paste\", and finally \"DrawingMode\" which switches the mode back to normal. There are a few complications. One is that Draw.gotoPage() must be called twice. The first call ensures that the source slide is the visible, active window before the \"Copy\" is processed. The second Draw.gotoPage() call makes sure the destination slide is now visible. This means that \"Paste\" will insert the copied slide after the destination slide, as required. I usually call Draw.gotoPage() with a document argument (e.g. Draw.gotoPage(doc, fromSlide)). This does not work correctly for the pasting of the slide, for reasons I'm unsure about. The solution is to use a reference to the document's controller, as shown in copyTo(): XController ctrl = GUI . getCurrentController ( doc ); : Draw . gotoPage ( ctrl , fromSlide ); : Draw . gotoPage ( ctrl , toSlide ); 5. Appending Slide Decks Together \u00b6 A common Office forum question is how to add the slides of one deck to the end of another. One solution is to use \"Copy\" and \"Paste\" dispatches as in section 4, but in a more complicated fashion. As you might guess, the ODF Toolkit library described in Chapter 51 is a better solution, but I'll focus on using Office here. This approach means that two application windows could be open at the same time: one containing the deck that is being copied, and another for the destination slide deck. This requires references to two different application views and frames, which can be a problem because of the design of my utility classes. Another problem is caused by the issue of master page copying. When a slide using a different master page is copied to a deck, Impress will query the user with an 'Adaption' dialog asking if the copied slide's format (i.e. its master page) should be copied over to the destination deck. The dialog looks like Figure 5. Figure 5. Adaption Dialog. If you want the format of the copied deck to be retained in its new location, then you have to click the \"Yes\" button. Carrying out this clicking action programmatically requires stepping outside the Office API, and using JNA to interact with the dialog box. The resulting code is in the AppendSlides.java example. The main() function mostly processes the program's command line arguments, a list of filenames. The first file is the destination deck for the slides copied from the other files: // globals: controller and frame for the destination deck private static XController toCtrl ; private static XFrame toFrame ; public static void main ( String args [] ) { if ( args . length < 2 ) { System . out . println ( \"Usage: AppendSlides fnm1 fnm2 ...\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open first file: \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // controller and frame refs for the destination deck toCtrl = GUI . getCurrentController ( doc ); toFrame = GUI . getFrame ( doc ); Lo . dispatchCmd ( toFrame , \"DiaMode\" , null ); // Switch to slide-sorter view so that slides can be pasted XDrawPages toSlides = Draw . getSlides ( doc ); // process the other files on the command line for ( int i = 1 ; i < args . length ; i ++ ) { // start at 1 XComponent appDoc = Lo . openDoc ( args [ i ] , loader ); if ( appDoc == null ) System . out . println ( \"Could not open the file: \" + args [ i ] ); else appendDoc ( toSlides , appDoc ); } Lo . saveDoc ( doc , Info . getName ( args [ 0 ] ) + \"_Append.\" + Info . getExt ( args [ 0 ] )); Lo . dispatchCmd ( toFrame , \"PageMode\" , null ); // back to normal mode (does not work) Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Note that the controller and frame reference for the destination deck are saved as globals. I've done this to reduce the number of arguments passed between the functions. The for-loop in the middle of main() processes each of the slide decks in turn, appending their slides to the destination deck. appendDoc() accesses a slide deck in a second Impress window, which means that a second controller and frame reference are needed; they're stored in fromCtrl and fromFrame: // in AppendSlides.java private static void appendDoc ( XDrawPages toSlides , XComponent doc ) /* Append doc to the end of toSlides. Access the slides in the document, and the document's controller and frame refs. Switch to slide-sorter view so that slides can be copied. */ { GUI . setVisible ( doc , true ); // get this document's controller and frame refs XController fromCtrl = GUI . getCurrentController ( doc ); XFrame fromFrame = GUI . getFrame ( doc ); Lo . dispatchCmd ( fromFrame , \"DiaMode\" , null ); // switch this document to slide-sorter mode XDrawPages fromSlides = Draw . getSlides ( doc ); if ( fromSlides == null ) System . out . println ( \"- No slides found\" ); else { System . out . println ( \"- Adding slides\" ); appendSlides ( toSlides , fromSlides , fromCtrl , fromFrame ); } Lo . dispatchCmd ( fromFrame , \"PageMode\" , null ); // change back to normal slide view (does not work) Lo . closeDoc ( doc ); System . out . println (); } // end of appendDoc() appendDoc() calls appendSlides() to cycle through the slides, copying each one to the destination deck: // in AppendSlides.java private static void appendSlides ( XDrawPages toSlides , XDrawPages fromSlides , XController fromCtrl , XFrame fromFrame ) /* Append fromSlides to the end of toSlides Loop through the fromSlides, copying each one. */ { for ( int i = 0 ; i < fromSlides . getCount (); i ++ ) { XDrawPage fromSlide = Draw . getSlide ( fromSlides , i ); XDrawPage toSlide = Draw . getSlide ( toSlides , toSlides . getCount () - 1 ); // the copy of fromSlide will be placed *after* toSlide copyTo ( fromSlide , fromCtrl , fromFrame , toSlide , toCtrl , toFrame ); } } // end of appendSlides() The for-loop in appendSlides() calls copyTo() which copies and pastes a slide using dispatch commands. In addition, it deals with the 'Adaption' dialog in Figure 5. // in AppendSlides.java private static void copyTo ( XDrawPage fromSlide , XController fromCtrl , XFrame fromFrame , XDrawPage toSlide , XController toCtrl , XFrame toFrame ) // copy fromSlide to *after* toSlide { Draw . gotoPage ( fromCtrl , fromSlide ); // select this slide System . out . print ( \"-- Copy --> \" ); Lo . dispatchCmd ( fromFrame , \"Copy\" , null ); Lo . delay ( 1000 ); Draw . gotoPage ( toCtrl , toSlide ); // select this slide System . out . println ( \"Paste\" ); // wait for \"Adaption\" dialog and click it Thread monitorThread = new Thread () { public void run () { Lo . delay ( 500 ); clickWindow ( \"LibreOffice\" ); } }; monitorThread . start (); Lo . dispatchCmd ( toFrame , \"Paste\" , null ); } // end of copyTo() The dialog is handled by starting a Java thread which executes clickWindow(). This waits for the dialog by suspending until a window with a title starting with \"LibreOffice\" appears. I chose this string since it's what appears at the start of the dialog's title bar in Figure 5: // in AppendSlides.java private static void clickWindow ( String windowTitle ) { HWND handle = JNAUtils . findTitledWin ( windowTitle ); if ( handle == null ) return ; Rectangle bounds = JNAUtils . getBounds ( handle ); int xCenter = bounds . x + 64 ; // hard-wired loc for \"Yes\" int yCenter = bounds . y + 91 ; JNAUtils . doClick ( new Point ( xCenter , yCenter )); } // end of clickWindow() JNAUtils.findTitledWin() returns a handle to the window it has detected. The bounds of the window are obtained, and a click event is sent to the (64, 91) coordinate inside that window. These 'magic' coordinates are the location of the \"Yes\" button in the dialog. This is both ugly and fragile since the position is almost certain to change across different platforms and versions of Office. Let's also not forget that if the title of the \"Adaption\" dialog changes in a future version of Office, then JNAUtils.findTitledWin() may end up looking forever for the window. The AppendSlides.java and CopySlide.java examples highlight important missing features in the presentation API. Copying and pasting a slide in a deck should be available as methods in XDrawPages. If you need a robust way of doing these tasks, I suggest looking at the ODF Toolkit library in Chapter 51. 6. Exporting a Slide as an Image \u00b6 A drawing or slide can be exported as an image by using the GraphicExportFilter service and its XGraphicExportFilter interface. The service is represented in Figure 6. Figure 6. The GraphicExportFilter Service, Interfaces, and Methods. In older documentation, such as the Developer's Guide, there's no mention of XGraphicExportFilter. The guide claims that GraphicExportFilter directly supports XExporter, XFilter, and XMimeTypeInfo. Use lodoc XGraphicExportFilter to access the online documentation for the interface. The Slides2Image.java example reads three arguments from the command line: the filename of the slide deck, the index number of the slide, and the format used for saving the slide's image. For example: > run Slide2Image algs.ppt 2 png The index number value may be a source of confusion since slides are numbered from 1 inside Impress' GUI, but from 0 in the API. In this case, '2' means the third slide in the deck. The main() function for Slide2Image.java: public static void main ( String args [] ) { if ( args . length != 3 ) { System . out . println ( \"Usage: Slide2Image fnm index imageFormat\" ); return ; } String fnm = args [ 0 ] ; int idx = Lo . parseInt ( args [ 1 ] ); String imFormat = args [ 2 ] ; XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } XDrawPage slide = Draw . getSlide ( doc , idx ); if ( slide == null ) { Lo . closeOffice (); return ; } String [] names = Images . getMimeTypes (); System . out . println ( \"Known GraphicExportFilter mime types:\" ); for ( int i = 0 ; i < names . length ; i ++ ) System . out . println ( \" \" + names [ i ] ); String outFnm = Info . getName ( fnm ) + idx + \".\" + imFormat ; System . out . println ( \"Saving page \" + idx + \" to \\\"\" + outFnm + \"\\\"\" ); String mime = Images . changeToMime ( imFormat ); Draw . savePage ( slide , outFnm , mime ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The example uses two mime functions: Images.getMimeTypes() and Images.changeToMime(). The first returns an array of all the mime types supported by GraphicExportFilter by calling XMimeTypeInfo.getSupportedMimeTypeNames(): // in the Images class public static String [] getMimeTypes () { XMimeTypeInfo mi = Lo . createInstanceMCF ( XMimeTypeInfo . class , \"com.sun.star.drawing.GraphicExportFilter\" ); return mi . getSupportedMimeTypeNames (); } The printed array is: Known GraphicExportFilter mime types: image/x-MS-bmp image/x-emf image/x-eps image/gif image/jpeg image/x-met image/x-portable-bitmap image/x-pict image/x-portable-graymap image/png image/x-portable-pixmap image/x-cmu-raster image/svg+xml image/x-svm image/tiff image/x-wmf image/x-xpixmap Images.changeToMime() looks through the mime array for a type that contains the supplied format as a substring: // in the Images class public static String changeToMime ( String imFormat ) { String [] names = getMimeTypes (); String imf = imFormat . toLowerCase (). trim (); for ( int i = 0 ; i < names . length ; i ++ ) { if ( names [ i ] . contains ( imf )) { System . out . println ( \"Using mime type: \" + names [ i ] ); return names [ i ] ; } } System . out . println ( \"No matching mime type, so using image/png\" ); return \"image/png\" ; } // end of changeToMime() Draw.savePage() creates an XGraphicExportFilter object, configuring it with the page to be exported and the mime type filter: // in the Draw class public static void savePage ( XDrawPage page , String fnm , String mimeType ) { String saveFileURL = FileIO . fnmToURL ( fnm ); if ( saveFileURL == null ) return ; System . out . println ( \"Saving page in \" + fnm ); // create graphics exporter XGraphicExportFilter gef = Lo . createInstanceMCF ( XGraphicExportFilter . class , \"com.sun.star.drawing.GraphicExportFilter\" ); // set the output 'document' to be specified page XComponent doc = Lo . qi ( XComponent . class , page ); gef . setSourceDocument ( doc ); // link exporter to the document // export the page by converting to the specified mime type PropertyValue props [] = Props . makeProps ( \"MediaType\" , mimeType , \"URL\" , saveFileURL ); gef . filter ( props ); System . out . println ( \"Export completed\" ); } // end of savePage() The name of the XExporter.setSourceDocument() method is a bit misleading since its input argument should either be an XDrawPage (a slide, as here), XShape (a shape on the slide), or an XShapes object (a collection of shapes on a slide). XFilter.filter() exports the slide (or shape), based on values supplied in a properties array. The array should contain the mime type and the URL of the output file. 7. Extracting the Text from a Slide Deck \u00b6 Draw.getShapesText() supports the fairly common task of extracting all the text from a presentation. It is used by the ExtractText.java example: // from ExtractText.java : if ( Draw . isShapesBased ( doc )) { String text = Draw . getShapesText ( doc ); System . out . println ( \"----- Text Content -----\" ); System . out . println ( text ); System . out . println ( \"------------------------\" ); } else System . out . println ( \"Extraction unsupported\" ); : Draw.getShapesText() calls getOrderedShapes() to collect all the shapes from all the slides in the document. It then iterates over the shapes list, converting each shape to text and adding it to a StringBuffer: // in the Draw class public static String getShapesText ( XComponent doc ) { StringBuilder sb = new StringBuilder (); ArrayList < XShape > xShapes = getOrderedShapes ( doc ); for ( XShape xShape : xShapes ) { String text = getShapeText ( xShape ); sb . append ( text + \"\\n\" ); } return sb . toString (); } // end of getShapeText() Draw.getShapeText() pulls the text from a shape by casting it to a text interface, then uses a cursor to select the text: public static String getShapeText ( XShape xShape ) // get text from inside a shape { XText xText = Lo . qi ( XText . class , xShape ); XTextCursor xTextCursor = xText . createTextCursor (); XTextRange xTextRange = Lo . qi ( XTextRange . class , xTextCursor ); return xTextRange . getString (); } // end of getShapeText() getOrderedShapes() iterates over each slide in the document calling another version of itself to extract the shapes from a slide: public static ArrayList < XShape > getOrderedShapes ( XComponent doc ) // get shapes from all pages of the doc { XDrawPage [] slides = getSlidesArr ( doc ); if ( slides == null ) return null ; ArrayList < XShape > shapes = new ArrayList < XShape > (); for ( XDrawPage slide : slides ) shapes . addAll ( getOrderedShapes ( slide )); return shapes ; } // end of getOrderedShapes() The ordering of the shapes in a slide may not match their reading order (i.e. top- down, left-to-right). For example, I read a slide by first looking at the text in the TitleShape, before reading the bullets below in the OutlinerShape. However, TitleShape may be stored at the end of the slide's container. getOrderedShapes() deals with the problem by extracting all the shapes from the slide into a list, and then sorting it based on each shape's z-order. A shape with z-order 0 will be moved before a shape with z-order 1. This almost always corresponds to the user's reading order of the shapes. For example, TitleShape usually has a z-order of 0. public static ArrayList < XShape > getOrderedShapes ( XDrawPage slide ) // get all the shapes on the slide in increasing z-order { ArrayList < XShape > shapes = getShapes ( slide ); Collections . sort ( shapes , new Comparator < XShape > () { public int compare ( XShape s1 , XShape s2 ) { return ( getZOrder ( s1 ) > getZOrder ( s2 )) ? - 1 : 1 ; } }); return shapes ; } // end of getOrderedShapes() public static int getZOrder ( XShape shape ) { return ( Integer ) Props . getProperty ( shape , \"ZOrder\" ); } getShapes() extracts all the shapes from a slide as a list: public static ArrayList < XShape > getShapes ( XDrawPage slide ) { if ( slide == null ) { System . out . println ( \"Slide is null\" ); return null ; } if ( slide . getCount () == 0 ) { System . out . println ( \"Slide does not contain any shapes\" ); return null ; } ArrayList < XShape > shapes = new ArrayList < XShape > (); try { for ( int j = 0 ; j < slide . getCount (); j ++ ) shapes . add ( Lo . qi ( XShape . class , slide . getByIndex ( j ))); } catch ( Exception e ) { System . out . println ( \"Shapes extraction error in slide\" ); } return shapes ; } // end of getShapes()","title":"Chapter 17. Slide Deck Manipulation"},{"location":"17-Slide_Deck_Manipulation.html#chapter-17-slide-deck-manipulation","text":"Topics Deck Building; Master Pages; Adding a Slide to a Deck; Rearranging a Deck; Appending Two Decks; Exporting a Slide as an Image; Extracting the Text from a Deck Example folders: \"Draw Tests\" and \"Utils\" This chapter looks at a number of common tasks performed with slide decks: building a slide deck based on a file of text notes; using, changing, and creating master pages for slide decks; adding a slide to an existing deck; rearranging the slides in a deck; appending two (or more) decks; exporting a slide from a deck as an image; extracting all the text from a slide deck.","title":"Chapter 17. Slide Deck Manipulation"},{"location":"17-Slide_Deck_Manipulation.html#1-building-a-deck-from-notes","text":"With Draw methods such as titleSlide() and bulletsSlide() it's quite easy to write a program that converts a set of notes in a text file into a slides deck. The PointsBuilder.java example does just that, using textual input formatted as shown below: What is a Algorithm? > An algorithm is a finite set of unambiguous instructions for solving a problem. >> An algorithm is correct if on all legitimate inputs, it outputs the right answer in a finite amount of time > Can be expressed as >>pseudocode >>flow charts >>text in a natural language (e.g. English) >>computer code Algorithm Design > The theoretical study of how to solve computational problems >>sorting a list of numbers >> finding a shortest route on a map >> scheduling when to work on homework >> answering web search queries >> and so on... When PointsBuilder reads this text, it generates three slides, and saves them to \"points.odp\" which is shown in Figure 1. Figure 1. Slides Generated by PointsBuilder.java The title slide in Figure 1 is generated automatically, but the other slides are created from the input text by calling Draw.bulletsSlide() and Draw.addBullet(). The reason the output looks so good is that PointsBuilder.java uses one of Impress' templates, \"Inspiration.otp\". These files are listed in Impress when you open the \"Master Pages\" section of the Tasks pane, part of which is shown in Figure 2. Figure 2. The List of Master Pages in Impress. If you move the cursor over the thumbnail images, the name of the template file is displayed as a tooltip. The main() function of PointsBuilder.java starts by printing the names of all the available templates, before using \"Inspiration.otp\" to create a new presentation document: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: PointsBuilder <points fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); reportTemplates (); String templateFnm = Draw . getSlideTemplatePath () + \"Inspiration.otp\" ; XComponent doc = Lo . createDocFromTemplate ( templateFnm , loader ); if ( doc == null ) { System . out . println ( \"Impress doc creation failed\" ); Lo . closeOffice (); return ; } readPoints ( args [ 0 ] , doc ); System . out . println ( \"Total no. of slides: \" + Draw . getSlidesCount ( doc )); Lo . saveDoc ( doc , \"points.odp\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() reportTemplates() uses Info.getDirs(\"Template\") to retrieve a list of all the directories examined by Office when looking for templates. It also calls Draw.getSlideTemplatePath() to retrieve the default slide template directory, and prints the names of the files in that folder: // in PointsBuilder.java private static void reportTemplates () { String [] templateDirs = Info . getDirs ( \"Template\" ); System . out . println ( \"Templates dirs:\" ); for ( String dir : templateDirs ) System . out . println ( \" \" + dir ); String templateDir = Draw . getSlideTemplatePath (); System . out . println ( \"\\nTemplates files in \\\"\" + templateDir + \"\\\"\" ); String [] templatesFnms = FileIO . getFileNames ( templateDir ); for ( String fnm : templatesFnms ) System . out . println ( \" \" + fnm ); } // end of reportTemplates() reportTemplates()'s output: Templates dirs: C:\\Program Files\\LibreOffice 4\\share\\template\\en-US C:\\Program Files\\LibreOffice 4\\share\\template\\common C:\\Users\\Ad\\Desktop\\LibreOffice Tests\\ Draw Tests\\$BUNDLED_EXTENSIONS\\wiki-publisher\\templates C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user\\template Templates files in \"C:\\Program Files\\LibreOffice 4\\ share/template/common/layout/\" AbstractGreen.otp AbstractRed.otp AbstractYellow.otp BrightBlue.otp DNA.otp Inspiration.otp LushGreen.otp Metropolis.otp Sunset.otp Vintage.otp PointsBuilder employs the \"Inspiration.otp\" template, via the call: String templateFnm = Draw . getSlideTemplatePath () + \"Inspiration.otp\" ; XComponent doc = Lo . createDocFromTemplate ( templateFnm , loader ); Lo.createDocFromTemplate() is a variant of Lo.createDoc() which specifies a template for the new document. It calls XComponentLoader.loadComponentFromURL() with the template file as an argument, and sets the \"AsTemplate\" property: // in the Lo class // global private static XMultiServiceFactory msFactory = null ; public static XComponent createDocFromTemplate ( String templatePath , XComponentLoader loader ) // create a new document using the specified template { if ( ! FileIO . isOpenable ( templatePath )) return null ; System . out . println ( \"Opening template \" + templatePath ); String templateURL = FileIO . fnmToURL ( templatePath ); if ( templateURL == null ) return null ; PropertyValue [] props = Props . makeProps ( \"Hidden\" , true , \"AsTemplate\" , true ); XComponent doc = null ; try { doc = loader . loadComponentFromURL ( templateURL , \"_blank\" , 0 , props ); msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); } catch ( Exception e ) { System . out . println ( \"Could not create doc from template: \" + e ); } return doc ; } // end of createDocFromTemplate() The readPoints() method in PointsBuilder.java loads the text points file line-by-line. It ignores blank lines and lines starting with \"//\", and examines the first character on each line: // in PointsBuilder.java private static void readPoints ( String fnm , XComponent doc ) { XDrawPage currSlide = Draw . getSlide ( doc , 0 ); Draw . titleSlide ( currSlide , \"Java-Generated Slides\" , \"Using LibreOffice\" ); XText body = null ; try { BufferedReader br = new BufferedReader ( new FileReader ( fnm )); String line ; char ch ; while (( line = br . readLine ()) != null ) { if ( line . length () == 0 ) // blank line continue ; if ( line . startsWith ( \"//\" )) // comment continue ; ch = line . charAt ( 0 ); if ( ch == '>' ) // a bullet with some indentation processBullet ( line , body ); else { // a title for a new slide currSlide = Draw . addSlide ( doc ); body = Draw . bulletsSlide ( currSlide , line ); } } br . close (); System . out . println ( \"Read in points file: \" + fnm ); } catch ( IOException e ) { System . out . println ( \"Error reading points file: \" + fnm ); } } // end of readPoints() If the line starts with a '>', then processBullet() is called to determine how many '>'s start the line. Depending on the number, Draw.addBullet() is called with a different bullet indentation level value. If the line doesn't start with a '>', then it's assumed to be the title line of a new slide, and Draw.addSlide() and Draw.bulletsSlide() create a new bullets-based slide.","title":"1.  Building a Deck from Notes"},{"location":"17-Slide_Deck_Manipulation.html#2-master-pages","text":"When a new slide deck is created it always has a single slide and a default master page, and every slide created subsequently will use this master page to format its background. The easiest way to view the master page is through the Impress GUI \u2013 by clicking on the View, Master, Slide Master menu, which displays something like Figure 3. Figure 3. The Default Master Page. There are five presentation shapes in Figure 3. From top-to-bottom, left-to-right, they are TitleTextShape, OutlinerShape , DateTimeShape. FooterShape, and SlideNumberShape. Even though a new slide links to this master page, the date/time, footer, and slide number text are not automatically displayed on the slide; their rendering must be turned on. It's possible to create more master pages in addition to the default one in Figure 3, and link a slide to one of those. The MastersUse.java example illustrates a number of master page features: the default master page has text added to its footer section, and a shape and text are placed in its top-left corner. The slide deck holds four slides \u2013 three of them link to the default master page, and are set to display its footer and slide number. However, the third slide in the deck links to a second master page with a slightly different appearance. Figure 4 shows the all the slides in the deck. Figure 4. A Slide Deck with Two Master Pages. Slides 1, 2, and 4 use the default master page, while slide 3 uses the new master. The main() function for MastersUse.java is: public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Draw . createImpressDoc ( loader ); if ( doc == null ) { System . out . println ( \"Impress doc creation failed\" ); Lo . closeOffice (); return ; } // report the shapes on the default master page XDrawPage masterPage = Draw . getMasterPage ( doc , 0 ); System . out . println ( \"Default Master Page\" ); Draw . showShapesInfo ( masterPage ); // set the master page's footer text Draw . setMasterFooter ( masterPage , \"Master Use Slides\" ); // add a rectangle and text to the default master page // at the top-left of the slide Size sz = Draw . getSlideSize ( masterPage ); Draw . drawRectangle ( masterPage , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Draw . drawText ( masterPage , \"Default Master Page\" , 10 , 15 , 100 , 10 , 24 ); /* set slide 1 to use the master page's slide number but its own footer text */ XDrawPage slide1 = Draw . getSlide ( doc , 0 ); Draw . titleSlide ( slide1 , \"Slide 1\" , \"\" ); Props . setProperty ( slide1 , \"IsPageNumberVisible\" , true ); // use the master page's slide number Props . setProperty ( slide1 , \"IsFooterVisible\" , true ); Props . setProperty ( slide1 , \"FooterText\" , \"MU Slides\" ); // change master page's footer for first slide (does not work) /* add three more slides, which use the master page's slide number and footer */ for ( int i = 1 ; i < 4 ; i ++ ) { XDrawPage slide = Draw . insertSlide ( doc , i ); Draw . bulletsSlide ( slide , \"Slide \" + ( i + 1 )); Props . setProperty ( slide , \"IsPageNumberVisible\" , true ); Props . setProperty ( slide , \"IsFooterVisible\" , true ); } // create master page 2 XDrawPage masterPage2 = Draw . insertMasterPage ( doc , 1 ); Draw . addSlideNumber ( masterPage2 ); // add slide number System . out . println ( \"Master Page 2\" ); Draw . showShapesInfo ( masterPage2 ); // link third slide to master page 2 Draw . setMasterPage ( Draw . getSlide ( doc , 2 ), masterPage2 ); // put green ellipse and text on master page 2 XShape ellipse = Draw . drawEllipse ( masterPage2 , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Props . setProperty ( ellipse , \"FillColor\" , 0xCCFF33 ); //neon green Draw . drawText ( masterPage2 , \"Master Page 2\" , 10 , 15 , 100 , 10 , 24 ); Lo . saveDoc ( doc , \"muSlides.odp\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main()","title":"2.  Master Pages"},{"location":"17-Slide_Deck_Manipulation.html#21-accessing-a-master-page","text":"A presentation (or drawing) document can access its master pages through the XMasterPagesSupplier interface in the GenericDrawingDocument service. XMasterPagesSupplier.getMasterPages() returns a single XDrawPages object: XMasterPagesSupplier mpSupp = Lo . qi ( XMasterPagesSupplier . class , doc ); XDrawPages pgs = mpSupp . getMasterPages (); The XDrawPages object is an indexed collection, with the default master page at position 0: XDrawPage masterPage = Lo . qi ( XDrawPage . class , pgs . getByIndex ( 0 )); Note that there's no \"XMasterPage\" interface \u2013 both slides and master pages are manipulated using XDrawPage. These preceding lines are packaged up as Draw.getMasterPage(): // in the Draw class public static XDrawPage getMasterPage ( XComponent doc , int idx ) // get master page by index { try { XMasterPagesSupplier mpSupp = Lo . qi ( XMasterPagesSupplier . class , doc ); XDrawPages pgs = mpSupp . getMasterPages (); return Lo . qi ( XDrawPage . class , pgs . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not find master slide \" + idx ); return null ; } } // end of getMasterPage() There's a second way of obtaining a master page, via the link between a slide and its master; the linked master is called a target. This is implemented by a second Draw.getMasterPage() method: // in the Draw class public static XDrawPage getMasterPage ( XDrawPage slide ) // return master page for the slide { XMasterPageTarget mpTarget = Lo . qi ( XMasterPageTarget . class , slide ); return mpTarget . getMasterPage (); } // end of getMasterPage()","title":"2.1.  Accessing a Master Page"},{"location":"17-Slide_Deck_Manipulation.html#22-whats-on-a-master-page","text":"The default master page was shown in Figure 3, and its structure is confirmed in MastersUse.java when Draw.showShapesInfo() is called: // in main() of MastersUse.java XDrawPage masterPage = Draw . getMasterPage ( doc , 0 ); System . out . println ( \"Default Master Page\" ); Draw . showShapesInfo ( masterPage ); The output: Default Master Page Draw Page shapes: Shape service: com.sun.star.presentation.TitleTextShape; z-order: 0 Shape service: com.sun.star.presentation.OutlinerShape; z-order: 1 Shape service: com.sun.star.presentation.DateTimeShape; z-order: 2 Shape service: com.sun.star.presentation.FooterShape; z-order: 3 Shape service: com.sun.star.presentation.SlideNumberShape;z-order:4 A new master page is created by using XMasterPagesSupplier.getMasterPages() and XDrawPages.insertNewByIndex(), as shown in Draw.insertMasterPage(): // in the Draw class public static XDrawPage insertMasterPage ( XComponent doc , int idx ) // creates new master page at the given index position, { XMasterPagesSupplier mpSupp = Lo . qi ( XMasterPagesSupplier . class , doc ); XDrawPages pgs = mpSupp . getMasterPages (); return pgs . insertNewByIndex ( idx ); } // end of insertMasterPage() The new master page contains no presentation shapes (unlike the default one). They must be added separately.","title":"2.2.  What's on a Master Page?"},{"location":"17-Slide_Deck_Manipulation.html#23-modifying-a-master-page","text":"MastersUse.java changes the default master page in three ways: it adds text to the footer shape (which is empty by default), and places a blue rectangle and some text in the top-left corner of the master: // in main() of MastersUse.java // set the master page's footer text Draw . setMasterFooter ( masterPage , \"Master Use Slides\" ); // add a rectangle and text to the default master page // at the top-left of the slide Size sz = Draw . getSlideSize ( masterPage ); Draw . drawRectangle ( masterPage , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Draw . drawText ( masterPage , \"Default Master Page\" , 10 , 15 , 100 , 10 , 24 ); Draw.setMasterFooter() searches through the shapes on the page looking for a FooterShape. The shape is cast to a text interface, and a string added: // in Draw public static void setMasterFooter ( XDrawPage master , String text ) // set the master page's footer text { XShape footerShape = Draw . findShapeByType ( master , \"com.sun.star.presentation.FooterShape\" ); XText textField = Lo . qi ( XText . class , footerShape ); textField . setString ( text ); } // end of setMasterFooter() MastersUse's second master page contains no shapes initially. An ellipse and some text are added to it in the same way as for the default master page: // in main() of MastersUse.java XDrawPage masterPage2 = Draw . insertMasterPage ( doc , 1 ); : // put ellipse and text on master page 2 XShape ellipse = Draw . drawEllipse ( masterPage2 , 5 , 7 , sz . Width / 6 , sz . Height / 6 ); Props . setProperty ( ellipse , \"FillColor\" , 0xCCFF33 ); // neon green Draw . drawText ( masterPage2 , \"Master Page 2\" , 10 , 15 , 100 , 10 , 24 ); Unlike the default master page, a number shape must be explicitly added to the second master, by calling Draw.addSlideNumber(): Draw . addSlideNumber ( masterPage2 ); It is implemented as: // in the Draw class public static XShape addSlideNumber ( XDrawPage slide ) // add slide number at bottom right (like on the default master) { Size sz = Draw . getSlideSize ( slide ); int width = 60 ; int height = 15 ; return Draw . addPresShape ( slide , \"SlideNumberShape\" , sz . Width - width - 12 , sz . Height - height - 4 , width , height ); } // end of addSlideNumber() Draw.addPresShape() creates a shape from the \"com.sun.star.presentation\" package: // in the Draw class public static XShape addPresShape ( XDrawPage slide , String shapeType , int x , int y , int width , int height ) { warnsPosition ( slide , x , y ); XShape shape = Lo . createInstanceMSF ( XShape . class , \"com.sun.star.presentation.\" + shapeType ); if ( shape != null ) { slide . add ( shape ); setPosition ( shape , x , y ); setSize ( shape , width , height ); } return shape ; } // end of addPresShape()","title":"2.3.  Modifying a Master Page"},{"location":"17-Slide_Deck_Manipulation.html#24-using-a-master-page","text":"New slides are automatically linked to the default master page, but properties must be explicitly set in order for the master's date/time, footer, and page number to be visible on the slide. For example, the footer and page number are drawn on a slide like so: // in main() of MastersUse.java XDrawPage slide1 = Draw . getSlide ( doc , 0 ); : Props . setProperty ( slide1 , \"IsPageNumberVisible\" , true ); Props . setProperty ( slide1 , \"IsFooterVisible\" , true ); The relevant property for showing the date/time is \"IsDateTimeVisible\". All these properties are define in the com.sun.star.presentation.DrawPage service. A related property is \"FooterText\", which changes the footer text for a specific slide. For example: Props . setProperty ( slide1 , \"FooterText\" , \"MU Slides\" ); However, this only works if the linked master page doesn't have its own footer text. A slide can be linked to a different master by calling Draw.setMasterPage(): // in main() of MastersUse.java // link third slide to second master XDrawPage slide3 = Draw . getSlide ( doc , 2 ); Draw . setMasterPage ( slide3 , masterPage2 ); It uses the XMasterPageTarget interface to create the new link: // in the Draw class public static void setMasterPage ( XDrawPage slide , XDrawPage mPg ) { XMasterPageTarget mpTarget = Lo . qi ( XMasterPageTarget . class , slide ); mpTarget . setMasterPage ( mPg ); }","title":"2.4.  Using a Master Page"},{"location":"17-Slide_Deck_Manipulation.html#3-adding-a-slide-to-a-deck","text":"The last section used XDrawPages.insertNewByIndex() to add a master page to the deck The same method is more commonly employed to add an ordinary slide. An example is shown in ModifySlides.java: its main() function opens a file, adds a title-only slide at the end of the deck, and a title/subtitle slide at the beginning. It finishes by saving the modified deck to a new file: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: ModifySlides fnm\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( ! Info . isDocType ( doc , Lo . IMPRESS_SERVICE )) { System . out . println ( \"-- not a slides presentation\" ); Lo . closeOffice (); return ; } XDrawPages slides = Draw . getSlides ( doc ); // add a title-only slide with a graphic at the end XDrawPage lastPage = slides . insertNewByIndex ( numSlides ); Draw . titleOnlySlide ( lastPage , \"Any Questions?\" ); Draw . drawImage ( lastPage , \"questions.png\" ); // add a title/subtitle slide at the start XDrawPage firstPage = slides . insertNewByIndex ( 0 ); // this is added after first slide! Draw . titleSlide ( firstPage , \"Interesting Slides\" , \"Andrew\" ); Lo . saveDoc ( doc , Info . getName ( args [ 0 ] ) + \"_Mod.\" + Info . getExt ( args [ 0 ] )); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() But if you examine the new file, you'll see that the title/subtitle slide has become the second slide in the deck. This highlights a restriction on XDrawPages.insertNewByIndex(), which is that a new slide cannot be inserted at index position 0. Instead, it will be inserted at the next spot, position 1.","title":"3.  Adding a Slide to a Deck"},{"location":"17-Slide_Deck_Manipulation.html#4-rearranging-a-slide-deck","text":"A surprising gap in the presentation API is the lack of a simple way to rearrange slides: for example, to move the second slide to the fifth position. The closest the API comes is the ability to duplicate a slide, but the copy is always inserted after the original, so isn't of much use. If you did want to do this, the code would be something like: XDrawPageDuplicator dup = Lo . qi ( XDrawPageDuplicator . class , doc ); XDrawPage dupSlide = dup . duplicate ( slide ); // dupSlide is located after original slide in the deck The only way to rearrange slides inside Office is with dispatch commands, in particular with the \"Copy\" and \"Paste\" commands. This is complicated by the fact that copying an entire slide is only possible when the deck is displayed in slide-sorter mode. The CopySlide.java example illustrates the technique but, as with most uses of dispatching, is quite fragile. The better answer is to utilize a third-part API, the ODF Toolkit, which is the topic of Chapter 51. CopySlide.java is called with three arguments \u2013 the filename and two slide indices. The first index is the source slide's position in the deck, and the second is the position after which the copied slide will appear. For instance: > run CopySlide points.odp 1 4 will copy the second slide of the deck to after the fifth slide. The main() function of CopySlide.java: public static void main ( String args [] ) { if ( args . length != 3 ) { System . out . println ( \"Usage: CopySlide fnm from-index to-index\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open the file: \" + args [ 0 ] ); Lo . closeOffice (); return ; } int fromIdx = Lo . parseInt ( args [ 1 ] ); int toIdx = Lo . parseInt ( args [ 2 ] ); int numSlides = Draw . getSlidesCount ( doc ); if (( fromIdx < 0 ) || ( toIdx < 0 ) || ( fromIdx >= numSlides ) || ( toIdx >= numSlides )) { System . out . println ( \"One or both indices are out of range\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); copyTo ( doc , fromIdx , toIdx ); // Draw.deleteSlide(doc, fromIdx); // a problem if the copying changes the indices Lo . save ( doc ); // overwrite Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() All the interesting stuff is performed by copyTo(). One minor thing to note is the call to Lo.save() which causes the changed slide deck to be saved back to its original file. It is defined as: // in the Lo class public static void save ( XComponent doc ) { XStorable store = Lo . qi ( XStorable . class , doc ); try { store . store (); System . out . println ( \"Saved the document by overwriting\" ); } catch ( IOException e ) { System . out . println ( \"Could not save the document\" ); } } // end of save() I usually avoid calling Lo.save() due to the fact that it overwrites the input file; I prefer to create a new file to hold changes. I've commented out the call to Draw.deleteSlide() in main() due to its potential to cause damage. The problem is that the new slide may cause the overall indexing of the slide deck to change. For example, consider what happens if the fourth slide is copied to after the second slide. This will create a new third slide, moving the old third slide, and all later slides, to the right. If the program now deletes the fourth slide, that's not the slide that's just been copied, but the repositioned third slide. The copyTo() function in CopySlide.java: // in CopySlide.java private static void copyTo ( XComponent doc , int fromIdx , int toIdx ) /* Copy fromIdx slide to the clipboard in slide-sorter mode, then paste it to after the toIdx slide. */ { XController ctrl = GUI . getCurrentController ( doc ); Lo . dispatchCmd ( \"DiaMode\" ); // Switch to slide-sorter view so that slides can be copied Lo . delay ( 5000 ); // give Office plenty of time to do it XDrawPage fromSlide = Draw . getSlide ( doc , fromIdx ); XDrawPage toSlide = Draw . getSlide ( doc , toIdx ); Draw . gotoPage ( ctrl , fromSlide ); // select this slide Lo . dispatchCmd ( \"Copy\" ); System . out . println ( \"Copied \" + fromIdx ); Draw . gotoPage ( ctrl , toSlide ); Lo . dispatchCmd ( \"Paste\" ); System . out . println ( \"Pasted to after \" + toIdx ); Lo . dispatchCmd ( \"DrawingMode\" ); } // end of copyTo() The method sends out four dispatches: the \"DiaMode\" command switches the application into slide-sorter mode, and is followed by \"Copy\", \"Paste\", and finally \"DrawingMode\" which switches the mode back to normal. There are a few complications. One is that Draw.gotoPage() must be called twice. The first call ensures that the source slide is the visible, active window before the \"Copy\" is processed. The second Draw.gotoPage() call makes sure the destination slide is now visible. This means that \"Paste\" will insert the copied slide after the destination slide, as required. I usually call Draw.gotoPage() with a document argument (e.g. Draw.gotoPage(doc, fromSlide)). This does not work correctly for the pasting of the slide, for reasons I'm unsure about. The solution is to use a reference to the document's controller, as shown in copyTo(): XController ctrl = GUI . getCurrentController ( doc ); : Draw . gotoPage ( ctrl , fromSlide ); : Draw . gotoPage ( ctrl , toSlide );","title":"4.  Rearranging a Slide Deck"},{"location":"17-Slide_Deck_Manipulation.html#5-appending-slide-decks-together","text":"A common Office forum question is how to add the slides of one deck to the end of another. One solution is to use \"Copy\" and \"Paste\" dispatches as in section 4, but in a more complicated fashion. As you might guess, the ODF Toolkit library described in Chapter 51 is a better solution, but I'll focus on using Office here. This approach means that two application windows could be open at the same time: one containing the deck that is being copied, and another for the destination slide deck. This requires references to two different application views and frames, which can be a problem because of the design of my utility classes. Another problem is caused by the issue of master page copying. When a slide using a different master page is copied to a deck, Impress will query the user with an 'Adaption' dialog asking if the copied slide's format (i.e. its master page) should be copied over to the destination deck. The dialog looks like Figure 5. Figure 5. Adaption Dialog. If you want the format of the copied deck to be retained in its new location, then you have to click the \"Yes\" button. Carrying out this clicking action programmatically requires stepping outside the Office API, and using JNA to interact with the dialog box. The resulting code is in the AppendSlides.java example. The main() function mostly processes the program's command line arguments, a list of filenames. The first file is the destination deck for the slides copied from the other files: // globals: controller and frame for the destination deck private static XController toCtrl ; private static XFrame toFrame ; public static void main ( String args [] ) { if ( args . length < 2 ) { System . out . println ( \"Usage: AppendSlides fnm1 fnm2 ...\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open first file: \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // controller and frame refs for the destination deck toCtrl = GUI . getCurrentController ( doc ); toFrame = GUI . getFrame ( doc ); Lo . dispatchCmd ( toFrame , \"DiaMode\" , null ); // Switch to slide-sorter view so that slides can be pasted XDrawPages toSlides = Draw . getSlides ( doc ); // process the other files on the command line for ( int i = 1 ; i < args . length ; i ++ ) { // start at 1 XComponent appDoc = Lo . openDoc ( args [ i ] , loader ); if ( appDoc == null ) System . out . println ( \"Could not open the file: \" + args [ i ] ); else appendDoc ( toSlides , appDoc ); } Lo . saveDoc ( doc , Info . getName ( args [ 0 ] ) + \"_Append.\" + Info . getExt ( args [ 0 ] )); Lo . dispatchCmd ( toFrame , \"PageMode\" , null ); // back to normal mode (does not work) Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Note that the controller and frame reference for the destination deck are saved as globals. I've done this to reduce the number of arguments passed between the functions. The for-loop in the middle of main() processes each of the slide decks in turn, appending their slides to the destination deck. appendDoc() accesses a slide deck in a second Impress window, which means that a second controller and frame reference are needed; they're stored in fromCtrl and fromFrame: // in AppendSlides.java private static void appendDoc ( XDrawPages toSlides , XComponent doc ) /* Append doc to the end of toSlides. Access the slides in the document, and the document's controller and frame refs. Switch to slide-sorter view so that slides can be copied. */ { GUI . setVisible ( doc , true ); // get this document's controller and frame refs XController fromCtrl = GUI . getCurrentController ( doc ); XFrame fromFrame = GUI . getFrame ( doc ); Lo . dispatchCmd ( fromFrame , \"DiaMode\" , null ); // switch this document to slide-sorter mode XDrawPages fromSlides = Draw . getSlides ( doc ); if ( fromSlides == null ) System . out . println ( \"- No slides found\" ); else { System . out . println ( \"- Adding slides\" ); appendSlides ( toSlides , fromSlides , fromCtrl , fromFrame ); } Lo . dispatchCmd ( fromFrame , \"PageMode\" , null ); // change back to normal slide view (does not work) Lo . closeDoc ( doc ); System . out . println (); } // end of appendDoc() appendDoc() calls appendSlides() to cycle through the slides, copying each one to the destination deck: // in AppendSlides.java private static void appendSlides ( XDrawPages toSlides , XDrawPages fromSlides , XController fromCtrl , XFrame fromFrame ) /* Append fromSlides to the end of toSlides Loop through the fromSlides, copying each one. */ { for ( int i = 0 ; i < fromSlides . getCount (); i ++ ) { XDrawPage fromSlide = Draw . getSlide ( fromSlides , i ); XDrawPage toSlide = Draw . getSlide ( toSlides , toSlides . getCount () - 1 ); // the copy of fromSlide will be placed *after* toSlide copyTo ( fromSlide , fromCtrl , fromFrame , toSlide , toCtrl , toFrame ); } } // end of appendSlides() The for-loop in appendSlides() calls copyTo() which copies and pastes a slide using dispatch commands. In addition, it deals with the 'Adaption' dialog in Figure 5. // in AppendSlides.java private static void copyTo ( XDrawPage fromSlide , XController fromCtrl , XFrame fromFrame , XDrawPage toSlide , XController toCtrl , XFrame toFrame ) // copy fromSlide to *after* toSlide { Draw . gotoPage ( fromCtrl , fromSlide ); // select this slide System . out . print ( \"-- Copy --> \" ); Lo . dispatchCmd ( fromFrame , \"Copy\" , null ); Lo . delay ( 1000 ); Draw . gotoPage ( toCtrl , toSlide ); // select this slide System . out . println ( \"Paste\" ); // wait for \"Adaption\" dialog and click it Thread monitorThread = new Thread () { public void run () { Lo . delay ( 500 ); clickWindow ( \"LibreOffice\" ); } }; monitorThread . start (); Lo . dispatchCmd ( toFrame , \"Paste\" , null ); } // end of copyTo() The dialog is handled by starting a Java thread which executes clickWindow(). This waits for the dialog by suspending until a window with a title starting with \"LibreOffice\" appears. I chose this string since it's what appears at the start of the dialog's title bar in Figure 5: // in AppendSlides.java private static void clickWindow ( String windowTitle ) { HWND handle = JNAUtils . findTitledWin ( windowTitle ); if ( handle == null ) return ; Rectangle bounds = JNAUtils . getBounds ( handle ); int xCenter = bounds . x + 64 ; // hard-wired loc for \"Yes\" int yCenter = bounds . y + 91 ; JNAUtils . doClick ( new Point ( xCenter , yCenter )); } // end of clickWindow() JNAUtils.findTitledWin() returns a handle to the window it has detected. The bounds of the window are obtained, and a click event is sent to the (64, 91) coordinate inside that window. These 'magic' coordinates are the location of the \"Yes\" button in the dialog. This is both ugly and fragile since the position is almost certain to change across different platforms and versions of Office. Let's also not forget that if the title of the \"Adaption\" dialog changes in a future version of Office, then JNAUtils.findTitledWin() may end up looking forever for the window. The AppendSlides.java and CopySlide.java examples highlight important missing features in the presentation API. Copying and pasting a slide in a deck should be available as methods in XDrawPages. If you need a robust way of doing these tasks, I suggest looking at the ODF Toolkit library in Chapter 51.","title":"5.  Appending Slide Decks Together"},{"location":"17-Slide_Deck_Manipulation.html#6-exporting-a-slide-as-an-image","text":"A drawing or slide can be exported as an image by using the GraphicExportFilter service and its XGraphicExportFilter interface. The service is represented in Figure 6. Figure 6. The GraphicExportFilter Service, Interfaces, and Methods. In older documentation, such as the Developer's Guide, there's no mention of XGraphicExportFilter. The guide claims that GraphicExportFilter directly supports XExporter, XFilter, and XMimeTypeInfo. Use lodoc XGraphicExportFilter to access the online documentation for the interface. The Slides2Image.java example reads three arguments from the command line: the filename of the slide deck, the index number of the slide, and the format used for saving the slide's image. For example: > run Slide2Image algs.ppt 2 png The index number value may be a source of confusion since slides are numbered from 1 inside Impress' GUI, but from 0 in the API. In this case, '2' means the third slide in the deck. The main() function for Slide2Image.java: public static void main ( String args [] ) { if ( args . length != 3 ) { System . out . println ( \"Usage: Slide2Image fnm index imageFormat\" ); return ; } String fnm = args [ 0 ] ; int idx = Lo . parseInt ( args [ 1 ] ); String imFormat = args [ 2 ] ; XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } XDrawPage slide = Draw . getSlide ( doc , idx ); if ( slide == null ) { Lo . closeOffice (); return ; } String [] names = Images . getMimeTypes (); System . out . println ( \"Known GraphicExportFilter mime types:\" ); for ( int i = 0 ; i < names . length ; i ++ ) System . out . println ( \" \" + names [ i ] ); String outFnm = Info . getName ( fnm ) + idx + \".\" + imFormat ; System . out . println ( \"Saving page \" + idx + \" to \\\"\" + outFnm + \"\\\"\" ); String mime = Images . changeToMime ( imFormat ); Draw . savePage ( slide , outFnm , mime ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The example uses two mime functions: Images.getMimeTypes() and Images.changeToMime(). The first returns an array of all the mime types supported by GraphicExportFilter by calling XMimeTypeInfo.getSupportedMimeTypeNames(): // in the Images class public static String [] getMimeTypes () { XMimeTypeInfo mi = Lo . createInstanceMCF ( XMimeTypeInfo . class , \"com.sun.star.drawing.GraphicExportFilter\" ); return mi . getSupportedMimeTypeNames (); } The printed array is: Known GraphicExportFilter mime types: image/x-MS-bmp image/x-emf image/x-eps image/gif image/jpeg image/x-met image/x-portable-bitmap image/x-pict image/x-portable-graymap image/png image/x-portable-pixmap image/x-cmu-raster image/svg+xml image/x-svm image/tiff image/x-wmf image/x-xpixmap Images.changeToMime() looks through the mime array for a type that contains the supplied format as a substring: // in the Images class public static String changeToMime ( String imFormat ) { String [] names = getMimeTypes (); String imf = imFormat . toLowerCase (). trim (); for ( int i = 0 ; i < names . length ; i ++ ) { if ( names [ i ] . contains ( imf )) { System . out . println ( \"Using mime type: \" + names [ i ] ); return names [ i ] ; } } System . out . println ( \"No matching mime type, so using image/png\" ); return \"image/png\" ; } // end of changeToMime() Draw.savePage() creates an XGraphicExportFilter object, configuring it with the page to be exported and the mime type filter: // in the Draw class public static void savePage ( XDrawPage page , String fnm , String mimeType ) { String saveFileURL = FileIO . fnmToURL ( fnm ); if ( saveFileURL == null ) return ; System . out . println ( \"Saving page in \" + fnm ); // create graphics exporter XGraphicExportFilter gef = Lo . createInstanceMCF ( XGraphicExportFilter . class , \"com.sun.star.drawing.GraphicExportFilter\" ); // set the output 'document' to be specified page XComponent doc = Lo . qi ( XComponent . class , page ); gef . setSourceDocument ( doc ); // link exporter to the document // export the page by converting to the specified mime type PropertyValue props [] = Props . makeProps ( \"MediaType\" , mimeType , \"URL\" , saveFileURL ); gef . filter ( props ); System . out . println ( \"Export completed\" ); } // end of savePage() The name of the XExporter.setSourceDocument() method is a bit misleading since its input argument should either be an XDrawPage (a slide, as here), XShape (a shape on the slide), or an XShapes object (a collection of shapes on a slide). XFilter.filter() exports the slide (or shape), based on values supplied in a properties array. The array should contain the mime type and the URL of the output file.","title":"6.  Exporting a Slide as an Image"},{"location":"17-Slide_Deck_Manipulation.html#7-extracting-the-text-from-a-slide-deck","text":"Draw.getShapesText() supports the fairly common task of extracting all the text from a presentation. It is used by the ExtractText.java example: // from ExtractText.java : if ( Draw . isShapesBased ( doc )) { String text = Draw . getShapesText ( doc ); System . out . println ( \"----- Text Content -----\" ); System . out . println ( text ); System . out . println ( \"------------------------\" ); } else System . out . println ( \"Extraction unsupported\" ); : Draw.getShapesText() calls getOrderedShapes() to collect all the shapes from all the slides in the document. It then iterates over the shapes list, converting each shape to text and adding it to a StringBuffer: // in the Draw class public static String getShapesText ( XComponent doc ) { StringBuilder sb = new StringBuilder (); ArrayList < XShape > xShapes = getOrderedShapes ( doc ); for ( XShape xShape : xShapes ) { String text = getShapeText ( xShape ); sb . append ( text + \"\\n\" ); } return sb . toString (); } // end of getShapeText() Draw.getShapeText() pulls the text from a shape by casting it to a text interface, then uses a cursor to select the text: public static String getShapeText ( XShape xShape ) // get text from inside a shape { XText xText = Lo . qi ( XText . class , xShape ); XTextCursor xTextCursor = xText . createTextCursor (); XTextRange xTextRange = Lo . qi ( XTextRange . class , xTextCursor ); return xTextRange . getString (); } // end of getShapeText() getOrderedShapes() iterates over each slide in the document calling another version of itself to extract the shapes from a slide: public static ArrayList < XShape > getOrderedShapes ( XComponent doc ) // get shapes from all pages of the doc { XDrawPage [] slides = getSlidesArr ( doc ); if ( slides == null ) return null ; ArrayList < XShape > shapes = new ArrayList < XShape > (); for ( XDrawPage slide : slides ) shapes . addAll ( getOrderedShapes ( slide )); return shapes ; } // end of getOrderedShapes() The ordering of the shapes in a slide may not match their reading order (i.e. top- down, left-to-right). For example, I read a slide by first looking at the text in the TitleShape, before reading the bullets below in the OutlinerShape. However, TitleShape may be stored at the end of the slide's container. getOrderedShapes() deals with the problem by extracting all the shapes from the slide into a list, and then sorting it based on each shape's z-order. A shape with z-order 0 will be moved before a shape with z-order 1. This almost always corresponds to the user's reading order of the shapes. For example, TitleShape usually has a z-order of 0. public static ArrayList < XShape > getOrderedShapes ( XDrawPage slide ) // get all the shapes on the slide in increasing z-order { ArrayList < XShape > shapes = getShapes ( slide ); Collections . sort ( shapes , new Comparator < XShape > () { public int compare ( XShape s1 , XShape s2 ) { return ( getZOrder ( s1 ) > getZOrder ( s2 )) ? - 1 : 1 ; } }); return shapes ; } // end of getOrderedShapes() public static int getZOrder ( XShape shape ) { return ( Integer ) Props . getProperty ( shape , \"ZOrder\" ); } getShapes() extracts all the shapes from a slide as a list: public static ArrayList < XShape > getShapes ( XDrawPage slide ) { if ( slide == null ) { System . out . println ( \"Slide is null\" ); return null ; } if ( slide . getCount () == 0 ) { System . out . println ( \"Slide does not contain any shapes\" ); return null ; } ArrayList < XShape > shapes = new ArrayList < XShape > (); try { for ( int j = 0 ; j < slide . getCount (); j ++ ) shapes . add ( Lo . qi ( XShape . class , slide . getByIndex ( j ))); } catch ( Exception e ) { System . out . println ( \"Shapes extraction error in slide\" ); } return shapes ; } // end of getShapes()","title":"7.  Extracting the Text from a Slide Deck"},{"location":"18-Slide_Shows.html","text":"Chapter 18. Slide Shows \u00b6 Topics Starting a Slide Show; Play and End a Slide Show Automatically; Play a Slide Show Repeatedly; Play a Custom Slide Show Example folders: \"Draw Tests\" and \"Utils\" This chapter focuses on ways to programmatically control slide shows. If you're unfamiliar with what Impress offers in this regard, then chapter 9 of the Impress user guide gives a good overview. Creating and controlling slide shows employs properties in the Presentation service, and methods in the XSlideShowController interface (see Figure 1). Figure 1. The Slide Show Presentation Services. Two elements of slide shows not shown in Figure 1 are slide transition effects (e.g. have the next slide fade into view, replacing the current one), and shape animation effects (e.g. have some text whoosh in from the bottom of the screen). These effects are mostly controlled by setting properties \u2013 transition properties are in the com.sun.star.presentation.DrawPage service, animations properties in com.sun.star.presentation.Shape. 1. Starting a Slide Show \u00b6 The BasicShow.java example shows how a program can start a slide show, and then let the user progress through the presentation by clicking on a slide, pressing the space bar, or using the arrow keys. While the slide show is running, BasicShow.java suspends, but wakes up when the user exits the show. This can occur when he presses the ESC key, or clicks on the slide show's \"click to exit\" screen. BasicShow then closes the document and shuts down Office. The main() function: // in BasicShow.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // slideshow start() crashes if the doc is not visible XPresentation2 show = Draw . getShow ( doc ); Props . showObjProps ( \"Slide show\" , show ); show . start (); XSlideShowController sc = Draw . getShowController ( show ); Draw . waitEnded ( sc ); // BasicShow waits for the user // to finish the slide show Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The document is opened in the normal way and a slide show object created by calling Draw.getShow(), which is defined as: // in the Draw class public static XPresentation2 getShow ( XComponent doc ) { XPresentationSupplier ps = Lo . qi ( XPresentationSupplier . class , doc ); return Lo . qi ( XPresentation2 . class , ps . getPresentation ()); } The call to Props.showObjProps() in main() prints the properties associated with the slide show, most of which are defined in the Presentation service (see Figure 1): Slide show Properties AllowAnimations == true CustomShow == Display == 0 FirstPage == IsAlwaysOnTop == false IsAutomatic == false IsEndless == false IsFullScreen == true IsMouseVisible == false IsShowAll == true IsShowLogo == false IsTransitionOnClick == true Pause == 10 StartWithNavigator == false UsePen == false The default values for these properties are sufficient for most presentations. The slide show is started by calling XPresentation.show() and, although the call returns immediately, it may be a few 100 milliseconds before the presentation appears on screen. If you have more than one monitor, one of them will be allocated a \"Presenter Console\" window. This short period while the slide show initializes can cause a problem if the XSlideShowController instance is requested too quickly \u2013 null will be returned if the slide show hasn't finished being created. Draw.getShowController() handles this issue by waiting: // in the Draw class public static XSlideShowController getShowController ( XPresentation2 show ) // keep trying to get the slide show controller { XSlideShowController sc = show . getController (); // may return null if executed too quickly after start of show int numTries = 1 ; if (( sc == null ) && ( numTries < 4 )) { // try 3 times Lo . delay ( 1000 ); // give the slide show time to start numTries ++ ; sc = show . getController (); } if ( sc == null ) System . out . println ( \"Could not obtain slide show controller\" ); return sc ; } // end of XSlideShowController getShowController() getShowController() tries to obtain the controller three times before giving up and returning null. The XSlideShowController interface gives the programmer much greater control over the slide show, including the ability to change the slide being displayed, and monitor and control the slide show state. Two topics I won't cover here are how XSlideShowController can assign listeners to the slide show (of type XSlideShowListener), and how to utilize the XSlideShow interface. Back in BasicShow.java, the main() function suspends by calling Draw.waitEnded(); the idea is that the program will sleep until the human presenter ends the slide show. waitEnded() is implemented using XSlideShowController: // in the Draw class public static void waitEnded ( XSlideShowController sc ) { while ( sc . getCurrentSlideIndex () != - 1 ) //presentation not ended Lo . delay ( 1000 ); System . out . println ( \"End of presentation detected\" ); } XSlideShowController.getCurrentSlideIndex() normally returns a slide index (i.e. 0 or greater), but when the slide show has finished it returns -1. waitEnded() keeps polling for this value, sleeping for a second between each test. 2. Play and End a Slide Show Automatically \u00b6 The AutoShow.java example removes the need for a presenter to click on a slide to progress to the next one, and terminates the show itself after the last slide had been displayed: // in AutoShow.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // fast automatic change between all the slides XDrawPage [] slides = Draw . getSlidesArr ( doc ); for ( XDrawPage slide : slides ) Draw . setTransition ( slide , FadeEffect . NONE , AnimationSpeed . FAST , Draw . AUTO_CHANGE , 1 ); XPresentation2 show = Draw . getShow ( doc ); show . start (); XSlideShowController sc = Draw . getShowController ( show ); Draw . waitLast ( sc , 3000 ); // terminate 3 seconds after the // last slide has been shown System . out . println ( \"Ending the slide show\" ); sc . deactivate (); show . end (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Automatic Slide Transitioning \u00b6 The automated transition between slides is configured by calling Draw.setTransition() on every slide in the deck: Draw . setTransition ( slide , FadeEffect . NONE , AnimationSpeed . FAST , Draw . AUTO_CHANGE , 1 ); setTransition() combines the setting of four slide properties: \"Effect\", \"Speed\", \"Change\", and \"Duration\": // in the Draw class public static void setTransition ( XDrawPage currSlide , FadeEffect fadeEffect , AnimationSpeed speed , int change , int duration ) { try { XPropertySet props = Lo . qi ( XPropertySet . class , currSlide ); props . setPropertyValue ( \"Effect\" , fadeEffect ); props . setPropertyValue ( \"Speed\" , speed ); props . setPropertyValue ( \"Change\" , change ); props . setPropertyValue ( \"Duration\" , duration ); // in seconds } catch ( Exception e ) { System . out . println ( \"Could not set slide transition\" ); } } // end of setTransition() Slide transition properties (such as \"Effect\", \"Speed\", \"Change\", and \"Duration\") are defined in the com.sun.star.presentation.DrawPage service. However, the possible values for \"Effect\" are stored in an enumeration listed at the end of the com.sun.star.presentation module (use lodoc presentation module , and scroll to the bottom of the page); Figure 2 shows the enum. Figure 2. The FadeEffect Enum. If you click on a word in the enum, then the browser follows a link to more information. The \"Speed\" property is used to set the speed of a slide transition, and its values are also stored in an enum in the com.sun.star.presentation package. There are three possible settings: AnimationSpeed.SLOW, AnimationSpeed.MEDIUM, and AnimationSpeed.FAST. The \"Change\" property specifies how a transition is triggered. The property can take one of three integer values, which aren't defined by an enum for some reason. Instead, the programmer can use constants defined in my Draw class: // in the Draw class // slide show change constants public static final int CLICK_ALL_CHANGE = 0 ; public static final int AUTO_CHANGE = 1 ; public static final int CLICK_PAGE_CHANGE = 2 ; The default behavior is represented by 0 ( Draw.CLICK_ALL_CHANGE ) which requires the presenter to click on a slide to change it, and a click is also need to trigger any shape animations on the page. A value of 2 ( Draw.CLICK_PAGE_CHANGE ) relieves the presenter from clicking to trigger shape animations, but he still needs to activate a slide transition manually. AutoShow.java passes Draw.AUTO_CHANG E to Draw.setTransition() which causes all the animations and transitions to execute automatically. The \"Duration\" property is specified in seconds and refers to how long the current slide stays on display before the transition effect begins. This is different from the \"Speed\" property which refers to how quickly a transition is performed. Finishing Automatically \u00b6 The other aspect of this automated slide show is making it stop when the last slide has been displayed. This is implemented by Draw.waitLast(): // in the Draw class public static void waitLast ( XSlideShowController sc , int delay ) { int numSlides = sc . getSlideCount (); while ( sc . getCurrentSlideIndex () < numSlides - 1 ) { // has not yet reached the last slide Lo . delay ( 500 ); } Lo . delay ( delay ); } // end of waitLast() waitLast() keeps checking the current slide index and sleeps until the last slide in the deck is reached. It then goes to sleep one last time, to give the final slide time to be seen by the user. 3. Play a Slide Show Repeatedly \u00b6 Another common kind of automated slide show is one that plays the show repeatedly, only terminating when the presenter steps in and presses the ESC key. This only requires four lines to be changed in AutoShow.java, shown in bold below: // in AutoShow.java : XPresentation2 show = Draw . getShow ( doc ); Props . showObjProps ( \"Slide show\" , show ); Props . setProperty ( show , \"IsEndless\" , true ); Props . setProperty ( show , \"Pause\" , 0 ); // no pause before repeating show . start (); XSlideShowController sc = Draw . getShowController ( show ); // Draw.waitLast(sc, 3000); // commented out; replaced by the next line Draw . waitEnded ( sc ); System . out . println ( \"Ending the slide show\" ); sc . deactivate (); show . end (); : The \"IsEndless\" property turns on slide show cycling, and \"Pause\" indicates how long the black \"Click to exit\" screen is displayed before the show restarts. Draw.waitEnded() is the same as before \u2013 it makes AutoShow.java suspend until the user clicks on the exit screen or presses the ESC key. 4. Play a Custom Slide Show \u00b6 A custom slide show is a display sequence other than the usual one that starts with the first slide and moves linearly through to the last. A named 'play list' of pages must be created, consisting of references to slides in the deck. The list can point to the slides in any order, and may reference a slide more than once. Draw.buildPlayList() creates the named play list using three arguments: the slide document, an array of slide indices which represents the intended playing sequence, and a name for the list. For example: int [] slideIdxs = new int [] { 5 , 6 , 7 , 8 }; XNameContainer playList = Draw . buildPlayList ( doc , slideIdxs , \"ShortPlay\" ); This creates a play list called \"ShortPlay\" which will show the slides with indices 5, 6, 7, and 8 (note: the first slide has index 0). Draw.buildPlayList is used in the CustomShow.java example: // in CustomShow.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( \"algs.odp\" , loader ); if ( doc == null ) { System . out . println ( \"Could not open algs.odp\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); int [] slideIdxs = new int [] { 5 , 6 , 7 , 8 }; XNameContainer playList = Draw . buildPlayList ( doc , slideIdxs , \"ShortPlay\" ); XPresentation2 show = Draw . getShow ( doc ); Props . setProperty ( show , \"CustomShow\" , \"ShortPlay\" ); show . start (); XSlideShowController sc = Draw . getShowController ( show ); Draw . waitEnded ( sc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The play list is installed by setting the \"CustomShow\" property in the slide show. The rest of the code in CustomShow.java is similar to the BasicShow.java example. Creating a Play List Using Containers \u00b6 The most confusing part of Draw.buildPlayList() is its use of two containers to hold the play list: // part of buildPlayList() in the Draw class : // get name container for the slide show XNameContainer playList = Draw . getPlayList ( doc ); // get factory from the container XSingleServiceFactory xFactory = Lo . qi ( XSingleServiceFactory . class , playList ); // use factory to make an index container XIndexContainer slidesCon = Lo . qi ( XIndexContainer . class , xFactory . createInstance ()); : An index container is created by XSingleServiceFactory.createInstance(), which requires a factory instance. This factory is most conveniently obtained from an existing container, namely the one for the slide show. That's obtained by Draw.getPlayList(): // in the Draw class public static XNameContainer getPlayList ( XComponent doc ) // get a name container for the play list { XCustomPresentationSupplier cpSupp = Lo . qi ( XCustomPresentationSupplier . class , doc ); return cpSupp . getCustomPresentations (); } Draw.buildPlayList() fills the index container with references to the slides, and then places it inside the name container: /* store the index container under the play list name in the name container */ playList . insertByName ( customName , slidesCon ); In other words, the play list is a name container holding a named index container. The rest of buildPlayList() is straightforward: // in the Draw class public static XNameContainer buildPlayList ( XComponent doc , int [] slideIdxs , String customName ) { // get a name container for the play list XNameContainer playList = Draw . getPlayList ( doc ); try { // create an index container for the play list XSingleServiceFactory xFactory = Lo . qi ( XSingleServiceFactory . class , playList ); XIndexContainer slidesCon = Lo . qi ( XIndexContainer . class , xFactory . createInstance ()); /* index container is assigned slide references whose indices come from slideIdxs */ System . out . println ( \"Building play list using: \" ); for ( int j = 0 ; j < slideIdxs . length ; j ++ ) { XDrawPage slide = Draw . getSlide ( doc , slideIdxs [ j ] ); if ( slide != null ) { slidesCon . insertByIndex ( j , slide ); System . out . println ( \" Slide \" + slideIdxs [ j ] ); } } /* store the index container under the play list name in the name container */ playList . insertByName ( customName , slidesCon ); System . out . println ( \"Playlist has name: \" + customName + \"\\n\" ); return playList ; } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to build play list: \" + e ); return null ; } } // end of buildPlayList() The for-loop employs the array of indices to get references to the slides via Draw.getSlide(). Each reference is added to the index container.","title":"Chapter 18. Slide Shows"},{"location":"18-Slide_Shows.html#chapter-18-slide-shows","text":"Topics Starting a Slide Show; Play and End a Slide Show Automatically; Play a Slide Show Repeatedly; Play a Custom Slide Show Example folders: \"Draw Tests\" and \"Utils\" This chapter focuses on ways to programmatically control slide shows. If you're unfamiliar with what Impress offers in this regard, then chapter 9 of the Impress user guide gives a good overview. Creating and controlling slide shows employs properties in the Presentation service, and methods in the XSlideShowController interface (see Figure 1). Figure 1. The Slide Show Presentation Services. Two elements of slide shows not shown in Figure 1 are slide transition effects (e.g. have the next slide fade into view, replacing the current one), and shape animation effects (e.g. have some text whoosh in from the bottom of the screen). These effects are mostly controlled by setting properties \u2013 transition properties are in the com.sun.star.presentation.DrawPage service, animations properties in com.sun.star.presentation.Shape.","title":"Chapter 18. Slide Shows"},{"location":"18-Slide_Shows.html#1-starting-a-slide-show","text":"The BasicShow.java example shows how a program can start a slide show, and then let the user progress through the presentation by clicking on a slide, pressing the space bar, or using the arrow keys. While the slide show is running, BasicShow.java suspends, but wakes up when the user exits the show. This can occur when he presses the ESC key, or clicks on the slide show's \"click to exit\" screen. BasicShow then closes the document and shuts down Office. The main() function: // in BasicShow.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // slideshow start() crashes if the doc is not visible XPresentation2 show = Draw . getShow ( doc ); Props . showObjProps ( \"Slide show\" , show ); show . start (); XSlideShowController sc = Draw . getShowController ( show ); Draw . waitEnded ( sc ); // BasicShow waits for the user // to finish the slide show Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The document is opened in the normal way and a slide show object created by calling Draw.getShow(), which is defined as: // in the Draw class public static XPresentation2 getShow ( XComponent doc ) { XPresentationSupplier ps = Lo . qi ( XPresentationSupplier . class , doc ); return Lo . qi ( XPresentation2 . class , ps . getPresentation ()); } The call to Props.showObjProps() in main() prints the properties associated with the slide show, most of which are defined in the Presentation service (see Figure 1): Slide show Properties AllowAnimations == true CustomShow == Display == 0 FirstPage == IsAlwaysOnTop == false IsAutomatic == false IsEndless == false IsFullScreen == true IsMouseVisible == false IsShowAll == true IsShowLogo == false IsTransitionOnClick == true Pause == 10 StartWithNavigator == false UsePen == false The default values for these properties are sufficient for most presentations. The slide show is started by calling XPresentation.show() and, although the call returns immediately, it may be a few 100 milliseconds before the presentation appears on screen. If you have more than one monitor, one of them will be allocated a \"Presenter Console\" window. This short period while the slide show initializes can cause a problem if the XSlideShowController instance is requested too quickly \u2013 null will be returned if the slide show hasn't finished being created. Draw.getShowController() handles this issue by waiting: // in the Draw class public static XSlideShowController getShowController ( XPresentation2 show ) // keep trying to get the slide show controller { XSlideShowController sc = show . getController (); // may return null if executed too quickly after start of show int numTries = 1 ; if (( sc == null ) && ( numTries < 4 )) { // try 3 times Lo . delay ( 1000 ); // give the slide show time to start numTries ++ ; sc = show . getController (); } if ( sc == null ) System . out . println ( \"Could not obtain slide show controller\" ); return sc ; } // end of XSlideShowController getShowController() getShowController() tries to obtain the controller three times before giving up and returning null. The XSlideShowController interface gives the programmer much greater control over the slide show, including the ability to change the slide being displayed, and monitor and control the slide show state. Two topics I won't cover here are how XSlideShowController can assign listeners to the slide show (of type XSlideShowListener), and how to utilize the XSlideShow interface. Back in BasicShow.java, the main() function suspends by calling Draw.waitEnded(); the idea is that the program will sleep until the human presenter ends the slide show. waitEnded() is implemented using XSlideShowController: // in the Draw class public static void waitEnded ( XSlideShowController sc ) { while ( sc . getCurrentSlideIndex () != - 1 ) //presentation not ended Lo . delay ( 1000 ); System . out . println ( \"End of presentation detected\" ); } XSlideShowController.getCurrentSlideIndex() normally returns a slide index (i.e. 0 or greater), but when the slide show has finished it returns -1. waitEnded() keeps polling for this value, sleeping for a second between each test.","title":"1.  Starting a Slide Show"},{"location":"18-Slide_Shows.html#2-play-and-end-a-slide-show-automatically","text":"The AutoShow.java example removes the need for a presenter to click on a slide to progress to the next one, and terminates the show itself after the last slide had been displayed: // in AutoShow.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // fast automatic change between all the slides XDrawPage [] slides = Draw . getSlidesArr ( doc ); for ( XDrawPage slide : slides ) Draw . setTransition ( slide , FadeEffect . NONE , AnimationSpeed . FAST , Draw . AUTO_CHANGE , 1 ); XPresentation2 show = Draw . getShow ( doc ); show . start (); XSlideShowController sc = Draw . getShowController ( show ); Draw . waitLast ( sc , 3000 ); // terminate 3 seconds after the // last slide has been shown System . out . println ( \"Ending the slide show\" ); sc . deactivate (); show . end (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main()","title":"2.  Play and End a Slide Show Automatically"},{"location":"18-Slide_Shows.html#automatic-slide-transitioning","text":"The automated transition between slides is configured by calling Draw.setTransition() on every slide in the deck: Draw . setTransition ( slide , FadeEffect . NONE , AnimationSpeed . FAST , Draw . AUTO_CHANGE , 1 ); setTransition() combines the setting of four slide properties: \"Effect\", \"Speed\", \"Change\", and \"Duration\": // in the Draw class public static void setTransition ( XDrawPage currSlide , FadeEffect fadeEffect , AnimationSpeed speed , int change , int duration ) { try { XPropertySet props = Lo . qi ( XPropertySet . class , currSlide ); props . setPropertyValue ( \"Effect\" , fadeEffect ); props . setPropertyValue ( \"Speed\" , speed ); props . setPropertyValue ( \"Change\" , change ); props . setPropertyValue ( \"Duration\" , duration ); // in seconds } catch ( Exception e ) { System . out . println ( \"Could not set slide transition\" ); } } // end of setTransition() Slide transition properties (such as \"Effect\", \"Speed\", \"Change\", and \"Duration\") are defined in the com.sun.star.presentation.DrawPage service. However, the possible values for \"Effect\" are stored in an enumeration listed at the end of the com.sun.star.presentation module (use lodoc presentation module , and scroll to the bottom of the page); Figure 2 shows the enum. Figure 2. The FadeEffect Enum. If you click on a word in the enum, then the browser follows a link to more information. The \"Speed\" property is used to set the speed of a slide transition, and its values are also stored in an enum in the com.sun.star.presentation package. There are three possible settings: AnimationSpeed.SLOW, AnimationSpeed.MEDIUM, and AnimationSpeed.FAST. The \"Change\" property specifies how a transition is triggered. The property can take one of three integer values, which aren't defined by an enum for some reason. Instead, the programmer can use constants defined in my Draw class: // in the Draw class // slide show change constants public static final int CLICK_ALL_CHANGE = 0 ; public static final int AUTO_CHANGE = 1 ; public static final int CLICK_PAGE_CHANGE = 2 ; The default behavior is represented by 0 ( Draw.CLICK_ALL_CHANGE ) which requires the presenter to click on a slide to change it, and a click is also need to trigger any shape animations on the page. A value of 2 ( Draw.CLICK_PAGE_CHANGE ) relieves the presenter from clicking to trigger shape animations, but he still needs to activate a slide transition manually. AutoShow.java passes Draw.AUTO_CHANG E to Draw.setTransition() which causes all the animations and transitions to execute automatically. The \"Duration\" property is specified in seconds and refers to how long the current slide stays on display before the transition effect begins. This is different from the \"Speed\" property which refers to how quickly a transition is performed.","title":"Automatic Slide Transitioning"},{"location":"18-Slide_Shows.html#finishing-automatically","text":"The other aspect of this automated slide show is making it stop when the last slide has been displayed. This is implemented by Draw.waitLast(): // in the Draw class public static void waitLast ( XSlideShowController sc , int delay ) { int numSlides = sc . getSlideCount (); while ( sc . getCurrentSlideIndex () < numSlides - 1 ) { // has not yet reached the last slide Lo . delay ( 500 ); } Lo . delay ( delay ); } // end of waitLast() waitLast() keeps checking the current slide index and sleeps until the last slide in the deck is reached. It then goes to sleep one last time, to give the final slide time to be seen by the user.","title":"Finishing Automatically"},{"location":"18-Slide_Shows.html#3-play-a-slide-show-repeatedly","text":"Another common kind of automated slide show is one that plays the show repeatedly, only terminating when the presenter steps in and presses the ESC key. This only requires four lines to be changed in AutoShow.java, shown in bold below: // in AutoShow.java : XPresentation2 show = Draw . getShow ( doc ); Props . showObjProps ( \"Slide show\" , show ); Props . setProperty ( show , \"IsEndless\" , true ); Props . setProperty ( show , \"Pause\" , 0 ); // no pause before repeating show . start (); XSlideShowController sc = Draw . getShowController ( show ); // Draw.waitLast(sc, 3000); // commented out; replaced by the next line Draw . waitEnded ( sc ); System . out . println ( \"Ending the slide show\" ); sc . deactivate (); show . end (); : The \"IsEndless\" property turns on slide show cycling, and \"Pause\" indicates how long the black \"Click to exit\" screen is displayed before the show restarts. Draw.waitEnded() is the same as before \u2013 it makes AutoShow.java suspend until the user clicks on the exit screen or presses the ESC key.","title":"3.  Play a Slide Show Repeatedly"},{"location":"18-Slide_Shows.html#4-play-a-custom-slide-show","text":"A custom slide show is a display sequence other than the usual one that starts with the first slide and moves linearly through to the last. A named 'play list' of pages must be created, consisting of references to slides in the deck. The list can point to the slides in any order, and may reference a slide more than once. Draw.buildPlayList() creates the named play list using three arguments: the slide document, an array of slide indices which represents the intended playing sequence, and a name for the list. For example: int [] slideIdxs = new int [] { 5 , 6 , 7 , 8 }; XNameContainer playList = Draw . buildPlayList ( doc , slideIdxs , \"ShortPlay\" ); This creates a play list called \"ShortPlay\" which will show the slides with indices 5, 6, 7, and 8 (note: the first slide has index 0). Draw.buildPlayList is used in the CustomShow.java example: // in CustomShow.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( \"algs.odp\" , loader ); if ( doc == null ) { System . out . println ( \"Could not open algs.odp\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); int [] slideIdxs = new int [] { 5 , 6 , 7 , 8 }; XNameContainer playList = Draw . buildPlayList ( doc , slideIdxs , \"ShortPlay\" ); XPresentation2 show = Draw . getShow ( doc ); Props . setProperty ( show , \"CustomShow\" , \"ShortPlay\" ); show . start (); XSlideShowController sc = Draw . getShowController ( show ); Draw . waitEnded ( sc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The play list is installed by setting the \"CustomShow\" property in the slide show. The rest of the code in CustomShow.java is similar to the BasicShow.java example.","title":"4.  Play a  Custom Slide Show"},{"location":"18-Slide_Shows.html#creating-a-play-list-using-containers","text":"The most confusing part of Draw.buildPlayList() is its use of two containers to hold the play list: // part of buildPlayList() in the Draw class : // get name container for the slide show XNameContainer playList = Draw . getPlayList ( doc ); // get factory from the container XSingleServiceFactory xFactory = Lo . qi ( XSingleServiceFactory . class , playList ); // use factory to make an index container XIndexContainer slidesCon = Lo . qi ( XIndexContainer . class , xFactory . createInstance ()); : An index container is created by XSingleServiceFactory.createInstance(), which requires a factory instance. This factory is most conveniently obtained from an existing container, namely the one for the slide show. That's obtained by Draw.getPlayList(): // in the Draw class public static XNameContainer getPlayList ( XComponent doc ) // get a name container for the play list { XCustomPresentationSupplier cpSupp = Lo . qi ( XCustomPresentationSupplier . class , doc ); return cpSupp . getCustomPresentations (); } Draw.buildPlayList() fills the index container with references to the slides, and then places it inside the name container: /* store the index container under the play list name in the name container */ playList . insertByName ( customName , slidesCon ); In other words, the play list is a name container holding a named index container. The rest of buildPlayList() is straightforward: // in the Draw class public static XNameContainer buildPlayList ( XComponent doc , int [] slideIdxs , String customName ) { // get a name container for the play list XNameContainer playList = Draw . getPlayList ( doc ); try { // create an index container for the play list XSingleServiceFactory xFactory = Lo . qi ( XSingleServiceFactory . class , playList ); XIndexContainer slidesCon = Lo . qi ( XIndexContainer . class , xFactory . createInstance ()); /* index container is assigned slide references whose indices come from slideIdxs */ System . out . println ( \"Building play list using: \" ); for ( int j = 0 ; j < slideIdxs . length ; j ++ ) { XDrawPage slide = Draw . getSlide ( doc , slideIdxs [ j ] ); if ( slide != null ) { slidesCon . insertByIndex ( j , slide ); System . out . println ( \" Slide \" + slideIdxs [ j ] ); } } /* store the index container under the play list name in the name container */ playList . insertByName ( customName , slidesCon ); System . out . println ( \"Playlist has name: \" + customName + \"\\n\" ); return playList ; } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to build play list: \" + e ); return null ; } } // end of buildPlayList() The for-loop employs the array of indices to get references to the slides via Draw.getSlide(). Each reference is added to the index container.","title":"Creating a Play List Using Containers"},{"location":"19%20Part%204%20Calc.html","text":"Part 4 Calc \u00b6","title":"Part 4 Calc"},{"location":"19%20Part%204%20Calc.html#part-4-calc","text":"","title":"Part 4 Calc"},{"location":"19-Calc_API_Overview.html","text":"Chapter 19. Calc API Overview \u00b6 Topics The Spreadsheet Document; Document Spreadsheets; Spreadsheet Data; The Spreadsheet Service; Cell Range Services; Cell Services; Sheet Cell Ranges Example folders: \"Calc Tests\" and \"Utils\" This chapter gives an overview of the main services and interfaces used in the Calc parts of the Office API, illustrated with small code fragments. I'll revisit these topics in greater details (and with larger examples) in subsequent chapters. If you're unfamiliar with Calc, then a good starting point is its user guide, available from https://libreoffice.org/get-help/documentation/ . Chapter 8 of the Developer's Guide looks at spreadsheet programming, and is available from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . Alternatively, you can access the chapter online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Spreadsheet_Documents/ (or use loguide calc ). The guide's examples can be found at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Spreadsheet . There's also a few examples in the \"Spreadsheet Document Examples\" section of https://api.libreoffice.org/examples/examples.html#Java_examples . 1. The Spreadsheet Document \u00b6 The Calc API is organized around the SpreadsheetDocument service which subclasses OfficeDocument. Figure 1 shows these services, including some of their interfaces. Figure 1. Some Spreadsheet Services and Interfaces. Calc's functionality is mostly divided between two Java packages (modules), sheet and table, which are documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1sheet.html and https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1table.html . Alternatively, you can try lodoc star sheet module and lodoc star table module , but these only get you 'close' to the right pages. The reason for this module division is Office's support for three types of 'table': text tables, database tables, and spreadsheets. A spreadsheet is a table with formulae added into the mix. 2. Document Spreadsheets \u00b6 A spreadsheet document (i.e. a Calc file) can consist of multiple spreadsheets (or sheets). This is implemented using two services \u2013 called Spreadsheets (note the 's') and Spreadsheet, as in Figure 2. Figure 2. A Spreadsheet Document Hierarchy. The sheets stored in a Spreadsheets object can be accessed by index or by name. A newly created document always contains a blank spreadsheet in index position 0. The following code fragment shows how the first sheet in the \"test.odt\" document is accessed: XComponentLoader loader = Lo . loadOffice (); XComponent compdoc = Lo . openDoc ( \"test.odt\" , loader ); XSpreadsheetDocument doc = Lo . qi ( XSpreadsheetDocument . class , compdoc ); XSpreadsheets sheets = doc . getSheets (); XIndexAccess sheetsIdx = Lo . qi ( XIndexAccess . class , sheets ); XSpreadsheet sheet = Lo . qi ( XSpreadsheet . class , sheetsIdx . getByIndex ( 0 )); These steps are hidden by methods in the Calc utility class, so the programmer can write: XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( \"test.odt\" , loader ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Some Casting Required \u00b6 Surprisingly, XSpreadsheetDocument doesn't subclass XComponent. This means that it's not possible to pass an XSpreadsheetDocument reference to a method expecting an XComponent argument, such as the original GUI.setVisible(), which had the signature: // in the GUI class (old version) public static void setVisible ( XComponent objDoc , boolean isVisible ); Text documents can be passed to GUI.setVisible() because XTextDocument does subclass XComponent. The same is possible for Draw and Impress documents. It's possible to manipulate a spreadsheet document as an XComponent, but it must be cast first: XComponent xc = Lo . qi ( XComponent . class , doc ); GUI . setVisible ( xc , true ); I decided to hide this casting issue by weakening the typing of methods using XComponent parameters. For example, the current version of GUI.setVisible() assumes that its first argument is of type Object: // in the GUI class public static void setVisible ( Object objDoc , boolean isVisible ) { XComponent doc = Lo . qi ( XComponent . class , objDoc ); XWindow xWindow = getFrame ( doc ). getContainerWindow (); xWindow . setVisible ( isVisible ); xWindow . setFocus (); } // end of setVisible() This GUI.setVisible() can be called with a XSpreadsheet reference: GUI.setVisible(doc, true); The document is cast to XComponent inside GUI.setVisible() and then progresses as before. 3. Spreadsheet Data \u00b6 The data in a spreadsheet can be accessed in many ways: for example, as individual cells, cell ranges, collections of cell ranges, rows, and columns. These ways of viewing data are supported by different services which are used as labels in Figure 3. Figure 3. Services used with Spreadsheet Data. The simplest spreadsheet unit is a cell, which can be located by its (column, row) coordinate/position or by its name, as in Figure 4. Figure 4. Addressing Cells. For instance, the cell named \"C5\" in Figure 4 is at coordinate (2,4). Note that row names start at '1' but row positions begin at 0. A cell range is defined by the position of the top-left and bottom-right cells in the range's rectangle, and can use the same dual naming scheme. For example, the cell range B2:D3 is the rectangle between the cells (1,1) and (3,2). A spreadsheet document may contain multiple sheets, so a cell address can include a sheet name. The first sheet is called \"Sheet1\", the second \"Sheet2\", and so on. For example, \"Sheet1.A3:Sheet3.D4\" refers to a cube of 24 cells consisting of 3 sheets of 8 cells between A3 and D4. Sheets can be assigned more informative names, if you wish. A collection of cell ranges is defined using \"~\" (the tilde) as the concatenation operator. For example, \"A1:C3~B2:D2\" is a group of two ranges, A1:C3 and B2:D2. The comma, \",\", can be used as an alternative concatenation symbol, at least in some Calc functions. There's also an intersection operator, \"!\", for calculating the intersection of two ranges. Cell references can be relative or absolute, which mainly affect how formulae are copied between cells. For example, a formula (=A1*3) in cell \"C3\" becomes (=B1*3) when copied one cell to the right into \"D3\". However, an absolute reference (which uses \" \\(\" as a prefix) is unaffected when moved. For instance (=\\) A$1*3) stops the \"A\" and \"1\" from being changed by a move. My Calc.java support class includes methods for converting between simple cell names and positions; they don't handle \"~\", \"!\", or absolute references using \"$\". 4. The Spreadsheet Service \u00b6 The Spreadsheet service is a subclass of SheetCellRange, as shown in Figure 5, which means that a sheet can be treated as a very big cell range. Figure 5. The Spreadsheet Service. A great deal of spreadsheet-related functionality is implemented as interfaces belonging to the Spreadsheet service. The most important is probably XSpreadsheet (see lodoc xspreadsheet reference ), which gives the programmer access to a sheet's cells and cell ranges via getCellByPosition(), getCellRangeByPosition(), and getCellRangeByName(). For example: : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCell cell = sheet . getCellByPosition ( 2 , 4 ); // (column,row) XCellRange cellRange1 = sheet . getCellRangeByPosition ( 1 , 1 , 3 , 2 ); // startColumn, startRow, endColumn, endRow XCellRange cellRange2 = sheet . getCellRangeByName ( \"B2:D3\" ); Oddly enough there's no getCellByName() method, but my Calc.java class adds one. 5. Cell Range Services \u00b6 The main service for cell ranges is SheetCellRange, which inherits the CellRange service from the table module and several property-based classes, as indicated in Figure 6. Figure 6. The Cell Range Services. SheetCellRange supports an XSheetCellRange interface, but that interface gets most of its functionality by inheriting XCellRange from the table module. Most programs that manipulate cell ranges tend to use XCellRange rather than XSheetCellRange. XCellRange is where the useful cell and cell range access methods are defined, as shown in the class diagram in Figure 7. Figure 7. The CellRange Class Diagram. You can access the documentation using lodoc XCellRange . What's missing from XCellRange is a way to set the values in a cell range. This is supported by the XCellRangeData interface (see Figure 6) which offers a setDataArray() method (and a getDataArray()). CellProperties in the table module is frequently accessed to adjust cell styling, such as color, borders, and the justification and orientation of data inside a cell. However, styling for a cell's text is handled by properties in the CharacterProperties or ParagraphProperties classes (see Figure 6). Rows and columns of cells can be accessed using the TableRows and TableColumns services (and their corresponding XTableRows and XTableColumns interfaces). They're accessed through the XColumnRowRange interface shown in Figure 6. Code for obtaining the first row of a sheet is: XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); // get the XColumnRowRange interface for the sheet XTableRows rows = crRange . getRows (); // get all the rows XIndexAccess con = Lo . qi ( XIndexAccess . class , rows ); // treat the rows as an indexed container XCellRange rowRange = Lo . qi ( XCellRange . class , con . getByIndex ( 0 )); // access the first row as a cell range XTableRows is an indexed container containing a sequence of XCellRange objects. The TableRow services and interfaces are shown in Figure 8: Figure 8. The TableRow Services and Interfaces. Similar coding is used to retrieve a column: XColumnRowRange.getColumns() gets all the columns. Figure 9 shows the TableColumn services and interfaces. Figure 9. The TableColumn Services and Interfaces. My Calc class includes methods that hide these details, so the accessing the first row of the sheet becomes: XCellRange rowRange = Calc . getRowRange ( sheet , 0 ); 6. Cell Services \u00b6 XCellRange.getCellByPosition() returns a single cell from a given cell range. However, this method can also be applied to a sheet because the API considers a sheet to be a very big cell range. For example: XCell cell = sheet . getCellByPosition ( 2 , 4 ) The SheetCell service manages properties related to cell formulae and cell input validation. However, most cell functionality comes from inheriting the Cell service in the table module, and its XCell interface. This arrangement is shown in Figure 10. Figure 10. The SheetCell Services and Interfaces. SheetCell doesn't support an XSheetCell interface; instead most programming is done using XCell. XCell contains useful methods for getting and setting the values in a cell (which may be numbers, text, or formulae). For example, the following stores the number 9 in the cell at coordinate (2, 4) (the \"C5\" cell): : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCell cell = sheet . getCellByPosition ( 2 , 4 ); // (column,row) cell . setValue ( 9 ); SheetCell inherits the same properties as SheetCellRange. For example, CellProperties stores cell formatting properties, while text styling properties are supported by CharacterProperties and ParagraphProperties (see Figure 10). The Cell service supports both the XCell and XText interfaces. Via the XText interface, it's possible to manipulate cell text in the same way that text is handled in a text document. However, for most purposes, it\u2019s enough to use XCell's setFormula() which, despite its name, can be used to assign plain text to a cell. For instance: cell . setFormula ( \"hello\" ); // put \"hello\" text in the cell Calc differentiates between ordinary text and formulae by expecting a formula to begin with \"=\". The XCell class diagram is shown in Figure 11. Figure 11. The XCell Class Diagram. The documentation for XCell can be found using lodoc xcell . 7. Sheet Cell Ranges \u00b6 A collection of cell ranges has its own service, SheetCellRanges, shown in Figure 12. Figure 12. The SheetCellRanges Services and Interfaces. SheetCellRanges doesn't turn up much when programming since it's easy to access multiple cell ranges by accessing them one at a time inside a loop. One major use for SheetCellRanges are in sheet searches which return the matching cell ranges in a XSheetCellRangeContainer object. I'll give examples in Chapter 26.","title":"Chapter 19. Calc API Overview"},{"location":"19-Calc_API_Overview.html#chapter-19-calc-api-overview","text":"Topics The Spreadsheet Document; Document Spreadsheets; Spreadsheet Data; The Spreadsheet Service; Cell Range Services; Cell Services; Sheet Cell Ranges Example folders: \"Calc Tests\" and \"Utils\" This chapter gives an overview of the main services and interfaces used in the Calc parts of the Office API, illustrated with small code fragments. I'll revisit these topics in greater details (and with larger examples) in subsequent chapters. If you're unfamiliar with Calc, then a good starting point is its user guide, available from https://libreoffice.org/get-help/documentation/ . Chapter 8 of the Developer's Guide looks at spreadsheet programming, and is available from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . Alternatively, you can access the chapter online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Spreadsheet_Documents/ (or use loguide calc ). The guide's examples can be found at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Spreadsheet . There's also a few examples in the \"Spreadsheet Document Examples\" section of https://api.libreoffice.org/examples/examples.html#Java_examples .","title":"Chapter 19. Calc API Overview"},{"location":"19-Calc_API_Overview.html#1-the-spreadsheet-document","text":"The Calc API is organized around the SpreadsheetDocument service which subclasses OfficeDocument. Figure 1 shows these services, including some of their interfaces. Figure 1. Some Spreadsheet Services and Interfaces. Calc's functionality is mostly divided between two Java packages (modules), sheet and table, which are documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1sheet.html and https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1table.html . Alternatively, you can try lodoc star sheet module and lodoc star table module , but these only get you 'close' to the right pages. The reason for this module division is Office's support for three types of 'table': text tables, database tables, and spreadsheets. A spreadsheet is a table with formulae added into the mix.","title":"1.  The Spreadsheet Document"},{"location":"19-Calc_API_Overview.html#2-document-spreadsheets","text":"A spreadsheet document (i.e. a Calc file) can consist of multiple spreadsheets (or sheets). This is implemented using two services \u2013 called Spreadsheets (note the 's') and Spreadsheet, as in Figure 2. Figure 2. A Spreadsheet Document Hierarchy. The sheets stored in a Spreadsheets object can be accessed by index or by name. A newly created document always contains a blank spreadsheet in index position 0. The following code fragment shows how the first sheet in the \"test.odt\" document is accessed: XComponentLoader loader = Lo . loadOffice (); XComponent compdoc = Lo . openDoc ( \"test.odt\" , loader ); XSpreadsheetDocument doc = Lo . qi ( XSpreadsheetDocument . class , compdoc ); XSpreadsheets sheets = doc . getSheets (); XIndexAccess sheetsIdx = Lo . qi ( XIndexAccess . class , sheets ); XSpreadsheet sheet = Lo . qi ( XSpreadsheet . class , sheetsIdx . getByIndex ( 0 )); These steps are hidden by methods in the Calc utility class, so the programmer can write: XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( \"test.odt\" , loader ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 );","title":"2.  Document Spreadsheets"},{"location":"19-Calc_API_Overview.html#some-casting-required","text":"Surprisingly, XSpreadsheetDocument doesn't subclass XComponent. This means that it's not possible to pass an XSpreadsheetDocument reference to a method expecting an XComponent argument, such as the original GUI.setVisible(), which had the signature: // in the GUI class (old version) public static void setVisible ( XComponent objDoc , boolean isVisible ); Text documents can be passed to GUI.setVisible() because XTextDocument does subclass XComponent. The same is possible for Draw and Impress documents. It's possible to manipulate a spreadsheet document as an XComponent, but it must be cast first: XComponent xc = Lo . qi ( XComponent . class , doc ); GUI . setVisible ( xc , true ); I decided to hide this casting issue by weakening the typing of methods using XComponent parameters. For example, the current version of GUI.setVisible() assumes that its first argument is of type Object: // in the GUI class public static void setVisible ( Object objDoc , boolean isVisible ) { XComponent doc = Lo . qi ( XComponent . class , objDoc ); XWindow xWindow = getFrame ( doc ). getContainerWindow (); xWindow . setVisible ( isVisible ); xWindow . setFocus (); } // end of setVisible() This GUI.setVisible() can be called with a XSpreadsheet reference: GUI.setVisible(doc, true); The document is cast to XComponent inside GUI.setVisible() and then progresses as before.","title":"Some Casting Required"},{"location":"19-Calc_API_Overview.html#3-spreadsheet-data","text":"The data in a spreadsheet can be accessed in many ways: for example, as individual cells, cell ranges, collections of cell ranges, rows, and columns. These ways of viewing data are supported by different services which are used as labels in Figure 3. Figure 3. Services used with Spreadsheet Data. The simplest spreadsheet unit is a cell, which can be located by its (column, row) coordinate/position or by its name, as in Figure 4. Figure 4. Addressing Cells. For instance, the cell named \"C5\" in Figure 4 is at coordinate (2,4). Note that row names start at '1' but row positions begin at 0. A cell range is defined by the position of the top-left and bottom-right cells in the range's rectangle, and can use the same dual naming scheme. For example, the cell range B2:D3 is the rectangle between the cells (1,1) and (3,2). A spreadsheet document may contain multiple sheets, so a cell address can include a sheet name. The first sheet is called \"Sheet1\", the second \"Sheet2\", and so on. For example, \"Sheet1.A3:Sheet3.D4\" refers to a cube of 24 cells consisting of 3 sheets of 8 cells between A3 and D4. Sheets can be assigned more informative names, if you wish. A collection of cell ranges is defined using \"~\" (the tilde) as the concatenation operator. For example, \"A1:C3~B2:D2\" is a group of two ranges, A1:C3 and B2:D2. The comma, \",\", can be used as an alternative concatenation symbol, at least in some Calc functions. There's also an intersection operator, \"!\", for calculating the intersection of two ranges. Cell references can be relative or absolute, which mainly affect how formulae are copied between cells. For example, a formula (=A1*3) in cell \"C3\" becomes (=B1*3) when copied one cell to the right into \"D3\". However, an absolute reference (which uses \" \\(\" as a prefix) is unaffected when moved. For instance (=\\) A$1*3) stops the \"A\" and \"1\" from being changed by a move. My Calc.java support class includes methods for converting between simple cell names and positions; they don't handle \"~\", \"!\", or absolute references using \"$\".","title":"3.  Spreadsheet Data"},{"location":"19-Calc_API_Overview.html#4-the-spreadsheet-service","text":"The Spreadsheet service is a subclass of SheetCellRange, as shown in Figure 5, which means that a sheet can be treated as a very big cell range. Figure 5. The Spreadsheet Service. A great deal of spreadsheet-related functionality is implemented as interfaces belonging to the Spreadsheet service. The most important is probably XSpreadsheet (see lodoc xspreadsheet reference ), which gives the programmer access to a sheet's cells and cell ranges via getCellByPosition(), getCellRangeByPosition(), and getCellRangeByName(). For example: : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCell cell = sheet . getCellByPosition ( 2 , 4 ); // (column,row) XCellRange cellRange1 = sheet . getCellRangeByPosition ( 1 , 1 , 3 , 2 ); // startColumn, startRow, endColumn, endRow XCellRange cellRange2 = sheet . getCellRangeByName ( \"B2:D3\" ); Oddly enough there's no getCellByName() method, but my Calc.java class adds one.","title":"4.  The Spreadsheet Service"},{"location":"19-Calc_API_Overview.html#5-cell-range-services","text":"The main service for cell ranges is SheetCellRange, which inherits the CellRange service from the table module and several property-based classes, as indicated in Figure 6. Figure 6. The Cell Range Services. SheetCellRange supports an XSheetCellRange interface, but that interface gets most of its functionality by inheriting XCellRange from the table module. Most programs that manipulate cell ranges tend to use XCellRange rather than XSheetCellRange. XCellRange is where the useful cell and cell range access methods are defined, as shown in the class diagram in Figure 7. Figure 7. The CellRange Class Diagram. You can access the documentation using lodoc XCellRange . What's missing from XCellRange is a way to set the values in a cell range. This is supported by the XCellRangeData interface (see Figure 6) which offers a setDataArray() method (and a getDataArray()). CellProperties in the table module is frequently accessed to adjust cell styling, such as color, borders, and the justification and orientation of data inside a cell. However, styling for a cell's text is handled by properties in the CharacterProperties or ParagraphProperties classes (see Figure 6). Rows and columns of cells can be accessed using the TableRows and TableColumns services (and their corresponding XTableRows and XTableColumns interfaces). They're accessed through the XColumnRowRange interface shown in Figure 6. Code for obtaining the first row of a sheet is: XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); // get the XColumnRowRange interface for the sheet XTableRows rows = crRange . getRows (); // get all the rows XIndexAccess con = Lo . qi ( XIndexAccess . class , rows ); // treat the rows as an indexed container XCellRange rowRange = Lo . qi ( XCellRange . class , con . getByIndex ( 0 )); // access the first row as a cell range XTableRows is an indexed container containing a sequence of XCellRange objects. The TableRow services and interfaces are shown in Figure 8: Figure 8. The TableRow Services and Interfaces. Similar coding is used to retrieve a column: XColumnRowRange.getColumns() gets all the columns. Figure 9 shows the TableColumn services and interfaces. Figure 9. The TableColumn Services and Interfaces. My Calc class includes methods that hide these details, so the accessing the first row of the sheet becomes: XCellRange rowRange = Calc . getRowRange ( sheet , 0 );","title":"5.  Cell Range Services"},{"location":"19-Calc_API_Overview.html#6-cell-services","text":"XCellRange.getCellByPosition() returns a single cell from a given cell range. However, this method can also be applied to a sheet because the API considers a sheet to be a very big cell range. For example: XCell cell = sheet . getCellByPosition ( 2 , 4 ) The SheetCell service manages properties related to cell formulae and cell input validation. However, most cell functionality comes from inheriting the Cell service in the table module, and its XCell interface. This arrangement is shown in Figure 10. Figure 10. The SheetCell Services and Interfaces. SheetCell doesn't support an XSheetCell interface; instead most programming is done using XCell. XCell contains useful methods for getting and setting the values in a cell (which may be numbers, text, or formulae). For example, the following stores the number 9 in the cell at coordinate (2, 4) (the \"C5\" cell): : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCell cell = sheet . getCellByPosition ( 2 , 4 ); // (column,row) cell . setValue ( 9 ); SheetCell inherits the same properties as SheetCellRange. For example, CellProperties stores cell formatting properties, while text styling properties are supported by CharacterProperties and ParagraphProperties (see Figure 10). The Cell service supports both the XCell and XText interfaces. Via the XText interface, it's possible to manipulate cell text in the same way that text is handled in a text document. However, for most purposes, it\u2019s enough to use XCell's setFormula() which, despite its name, can be used to assign plain text to a cell. For instance: cell . setFormula ( \"hello\" ); // put \"hello\" text in the cell Calc differentiates between ordinary text and formulae by expecting a formula to begin with \"=\". The XCell class diagram is shown in Figure 11. Figure 11. The XCell Class Diagram. The documentation for XCell can be found using lodoc xcell .","title":"6.  Cell Services"},{"location":"19-Calc_API_Overview.html#7-sheet-cell-ranges","text":"A collection of cell ranges has its own service, SheetCellRanges, shown in Figure 12. Figure 12. The SheetCellRanges Services and Interfaces. SheetCellRanges doesn't turn up much when programming since it's easy to access multiple cell ranges by accessing them one at a time inside a loop. One major use for SheetCellRanges are in sheet searches which return the matching cell ranges in a XSheetCellRangeContainer object. I'll give examples in Chapter 26.","title":"7.  Sheet Cell Ranges"},{"location":"20-Spreadsheet_Manipulation.html","text":"Chapter 20. Spreadsheet Displaying and Creation \u00b6 Topics Displaying a Document; Read-only and Protected Viewing; Active Sheets; Sheet Names; Zooming; Creating a Document; Cell Names and Ranges; Cell Values; Data Arrays; Rows and Columns of Data; Adding a Picture and a Chart Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at two main topics: the display of an existing spreadsheet document, and the creation of a new document, based around two examples, ShowSheet.java and BuildTable.java. As part of displaying a document, I'll also describe how to use read-only and protected viewing, change the active sheet, use sheet names, and adjust the window view size by zooming. Document creation illustrates the use of cell names and ranges, the setting of cell data using arrays, rows, and columns, and adding a picture and a chart to a sheet. 1. Displaying a Document \u00b6 The ShowSheet.java example shows how to open a spreadsheet document, and display its first sheet. If the program is called with a filename argument, then the document is saved to that file before the program closes. The extension of the output filename is used to determine the exported file type. For example: run ShowSheet totals . ods show . pdf displays the totals.ods spreadsheet, and saves it as a PDF file. Alternatively: run ShowSheet sorted . csv sorted . html opens the CSV file as a Calc document, and saves it as HTML. The main() function of ShowSheet.java: // in ShowSheet.java public static void main ( String args [] ) { String outFnm = null ; if (( args . length < 1 ) || ( args . length > 2 )) { System . out . println ( \"Usage: run ShowSheet fnm [out-fnm]\" ); return ; } if ( args . length == 2 ) outFnm = args [ 1 ] ; XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Calc . gotoCell ( doc , \"A1\" ); // move view to top of sheet // XSpreadsheet sheet = Calc.getSheet(doc, 0); // not needed here Lo . waitEnter (); // wait for user to press <ENTER> if ( outFnm != null ) Lo . saveDoc ( doc , outFnm ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Calc.openDoc() opens the document, returning an XSpreadsheetDocument reference: // in the Calc class public static XSpreadsheetDocument openDoc ( String fnm , XComponentLoader loader ) { XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Document is null\" ); return null ; } return getSSDoc ( doc ); } // end of openDoc() public static XSpreadsheetDocument getSSDoc ( XComponent doc ) { if ( ! Info . isDocType ( doc , Lo . CALC_SERVICE )) { System . out . println ( \"Not a spreadsheet doc; closing\" ); Lo . closeDoc ( doc ); return null ; } XSpreadsheetDocument ssDoc = Lo . qi ( XSpreadsheetDocument . class , doc ); if ( ssDoc == null ) { System . out . println ( \"Not a spreadsheet doc; closing\" ); Lo . closeDoc ( doc ); return null ; } return ssDoc ; } // end of getSSDoc() First Lo.openDoc() returns an XComponent reference, then getSSDoc() converts it to XSpreadsheetDocument. This conversion will fail if the input document isn't a spreadsheet. GUI.setVisible(true) causes Office to display the spreadsheet's active sheet, which is the one that was being worked on when the file was previously saved. In addition, the application will display the cell or cells selected in the sheet at that time. The selection can be changed by calling Calc.gotoCell(): // in the Calc class public static void gotoCell ( XSpreadsheetDocument doc , String cellName ) { XFrame frame = getController ( doc ). getFrame (); gotoCell ( frame , cellName ); } public static XController getController ( XSpreadsheetDocument doc ) { XModel model = Lo . qi ( XModel . class , doc ); return model . getCurrentController (); } public static void gotoCell ( XFrame frame , String cellName ) { Lo . dispatchCmd ( frame , \"GoToCell\" , Props . makeProps ( \"ToPoint\" , cellName )); } Any changes to the document's view requires a reference to its controller. The active cell is changed by sending a \"GoToCell\" dispatch to the controller's frame. \"GoToCell\" requires a cell name argument, which is encoded as a property array containing a single \"ToPoint\" property. Calc.getSheet() returns a reference to the currently active sheet. but that line is commented out in ShowSheet.java, since it's not needed. getSheet() is implemented using code similar to that described in the previous chapter: // in the Calc class public static XSpreadsheet getSheet ( XSpreadsheetDocument doc , int index ) { XSpreadsheets sheets = doc . getSheets (); XSpreadsheet sheet = null ; try { XIndexAccess xSheetsIdx = Lo . qi ( XIndexAccess . class , sheets ); sheet = Lo . qi ( XSpreadsheet . class , xSheetsIdx . getByIndex ( index )); } catch ( Exception e ) { System . out . println ( \"Could not access spreadsheet: \" + index ); } return sheet ; } // end of getSheet() If the user calls ShowSheet.java with a filename argument, then Lo.saveDoc() performs a save to that file. saveDoc() utilizes Lo.ext2Format() to map the filename's extension (e.g. \"pdf\", \"html\", \"xhtml\") and the document type (in this case, a spreadsheet) to a suitable output format. The function consists of a long switch statement which decides on the most suitable mapping, as illustrated by the code fragment: // in the Lo class public static String ext2Format ( int docType , String ext ) { switch ( ext ) { case \"doc\" : return \"MS Word 97\" ; case \"docx\" : return \"Office Open XML Text\" ; : : // many more cases case \"pdf\" : if ( docType == Lo . WRITER ) return \"writer_pdf_Export\" ; else if ( docType == Lo . IMPRESS ) return \"impress_pdf_Export\" ; else if ( docType == Lo . DRAW ) return \"draw_pdf_Export\" ; else if ( docType == Lo . CALC ) return \"calc_pdf_Export\" ; else if ( docType == Lo . MATH ) return \"math_pdf_Export\" ; else return \"writer_pdf_Export\" ; : // many more cases } // end of ext2Format() The \"pdf\" case is selected when the output file extension is \"pdf\", but the export format also depends on the Office document. For ShowSheet.java, the docType value will be Lo.CALC, which causes ext2Format() to return \"calc_pdf_Export\". Lo.ext2Format() is very far from comprehensive, but understands Office and MS spreadsheet formats, CSV, RTF, text, HTML, XHTML, and PDF. Other mappings can be added as required. 1.1. Read-only and Protected Viewing \u00b6 One variant of ShowSheet.java prevents a user from changing the spreadsheet. Unfortunately, implementing this by opening the document read-only isn't particularly robust because Office always displays a message asking if the user wants to override the read-only setting. Nevertheless, the code is short: // commented out in ShowSheet.java XComponent cDoc = Lo . openReadOnlyDoc ( args [ 0 ] , loader ); XSpreadsheetDocument doc = Calc . getSSDoc ( cDoc ); openReadOnlyDoc() calls Lo.openDoc() with the \"ReadOnly\" property set to true: // in the Calc class public static XComponent openReadOnlyDoc ( String fnm , XComponentLoader loader ) { return openDoc ( fnm , loader , Props . makeProps ( \"Hidden\" , true , \"ReadOnly\" , true ) ); } If you want to actually stop the user from changing the spreadsheet, then it must be protected, using the XProtectable interface: XProtectable pro = Lo . qi ( XProtectable . class , doc ); pro . protect ( \"foobar\" ); XProtectable.protect() assigns a password to the sheet (in this example, \"foobar\"), which the user must supply in order to change any data . Document-level protection isn't supported in the current version of Office. The best we can do is to apply protection to individual sheets. Namely: // commented out in ShowSheet.java XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // get sheet 1 XProtectable pro = Lo . qi ( XProtectable . class , sheet ); pro . protect ( \"foobar\" ); // query the user for the password String pwd = GUI . getPassword ( \"Sheet protection\" , \"Supply password:\" ); if (( pwd != null ) && pwd . equals ( \"foobar\" )) { // check input System . out . println ( \"Password correct\" ); pro . unprotect ( \"foobar\" ); } else { System . out . println ( \"Password incorrect\" ); GUI . showJMessageBox ( \"Password Status\" , \"Password incorrect\" ); } The code fragment above shows how to query the user for the password. GUI.getPassword() displays a dialog window which includes a Java JPasswordField component for hiding the entered data: // in the GUI class public static String getPassword ( String title , String inputMsg ) { JLabel jl = new JLabel ( inputMsg ); JPasswordField jpf = new JPasswordField ( 24 ); Object [] ob = { jl , jpf }; int result = JOptionPane . showConfirmDialog ( null , ob , title , JOptionPane . OK_CANCEL_OPTION ); if ( result == JOptionPane . OK_OPTION ) return new String ( jpf . getPassword ()); else return null ; } // end of getPassword() 1.2. Changing the Active Sheet \u00b6 Another variation of ShowSheet allows the user to specify which sheet to make active, and so be displayed in Office. It's not enough to execute Calc.getSheet() with a sheet index; Calc.setActiveSheet() must also be called to make that sheet active: // in the Calc class public static void setActiveSheet ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { XSpreadsheetView ssView = Lo . qi ( XSpreadsheetView . class , getController ( doc )); ssView . setActiveSheet ( sheet ); } // end of setActiveSheet() Calc.setActiveSheet() converts the controller interface for the document into an XSpreadsheetView, which is the main interface for the SpreadsheetView service (see Figure 1). Figure 1. The SpreadsheetView Services and Interfaces. SpreadsheetView implements a number of interfaces for affecting the user's view of a document. View-related properties are stored in the inherited SpreadsheetViewSettings class, which can be listed by calling Props.showObjProps(): // commented out in ShowSheet.java XSpreadsheetView ssView = Lo . qi ( XSpreadsheetView . class , getController ( doc )); Props . showObjProps ( \"Spreadsheet view\" , ssView ); 1.3. Sheet Names \u00b6 Default spreadsheet names use \"Sheet\" followed by a positive integer. For example, a new document will name its first sheet \"Sheet1\". Calc.getSheet() can accept a sheet name, as in the following code which makes \"Sheet1\" active: // in ShowSheet.java XSpreadsheet sheet = Calc . getSheet ( doc , \"Sheet1\" ); Calc . setActiveSheet ( doc , sheet ); All the sheet names in a document can be accessed via Calc.getSheetNames(), and a sheet's name can be changed by Calc.setSheetName(): // in the Calc class public static String [] getSheetNames ( XSpreadsheetDocument doc ) { XSpreadsheets sheets = doc . getSheets (); return sheets . getElementNames (); } public static void setSheetName ( XSpreadsheet sheet , String name ) { XNamed xNamed = Lo . qi ( XNamed . class , sheet ); if ( xNamed == null ) System . out . println ( \"Could not access spreadsheet\" ); else xNamed . setName ( name ); } // end of setSheetName() 1.4. Zooming \u00b6 Zooming the view of a document is done by adjusting properties in SpreadsheetViewSettings (see Figure 1 above). The \"ZoomType\" property specifies the kind of zooming, which may be a size percentage or a constant indicating a particular zooming amount. The constants are defined in Calc.java: // in the Calc class public static final short OPTIMAL = 0 ; public static final short PAGE_WIDTH = 1 ; public static final short ENTIRE_PAGE = 2 ; public static final short BY_VALUE = 3 ; public static final short PAGE_WIDTH_EXACT = 4 ; The constants are understood by Calc.zoom(): // in the Calc class public static void zoom ( XSpreadsheetDocument doc , short type ) { XController ctrl = getController ( doc ); Props . setProperty ( ctrl , \"ZoomType\" , type ); } For example, the entire sheet can be made visible by calling: Calc . zoom ( doc , Calc . ENTIRE_PAGE ); For percentage zooming, the value must be assigned to the \"ZoomValue\" property. This is handled by Calc.zoomValue(): // in the Calc class public static void zoomValue ( XSpreadsheetDocument doc , int value ) { XController ctrl = getController ( doc ); Props . setProperty ( ctrl , \"ZoomType\" , BY_VALUE ); Props . setProperty ( ctrl , \"ZoomValue\" , ( short ) value ); } 2. Creating a Document \u00b6 The BuildTable.java example shows how to create a new spreadsheet document, populate it with data, apply cell styling, and save it to a file. I'll look at styling in the next chapter, and will concentrate here on the different ways to add data to a sheet. The main() function of BuildTable.java is: // in BuildTable.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); convertAddresses ( sheet ); // uncomment one of these build methods // buildCells(sheet); // buildRows(sheet); // buildCols(sheet); buildArray ( sheet ); Lo . saveDoc ( doc , \"buildTable.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() main() can call one of four different build methods to demonstrate various Calc.java functions for filling cells and cell ranges. convertAddresses() illustrates the Calc.java methods for converting between cell names and positions, and between cell range names and position intervals. 2.1. Switching between Cell Names, Cell Ranges, and Positions \u00b6 Although the Calc.java get/set methods for cells, columns, rows, and cell ranges support both name and position based addressing (e.g. \"D5\" and (3, 4)), it's still sometimes necessary to convert between the different formats. convertAddresses() demonstrates those methods: // in BuildTable.java private static void convertAddresses ( XSpreadsheet sheet ) { // cell name <--> position java . awt . Point pos = Calc . getCellPosition ( \"AA2\" ); System . out . println ( \"Position of AA2: (\" + pos . x + \", \" + pos . y + \")\" ); XCell cell = Calc . getCell ( sheet , pos . x , pos . y ); Calc . printCellAddress ( cell ); System . out . println ( \"AA2: \" + Calc . getCellStr ( pos . x , pos . y )); System . out . println (); // cell range name <--> position java . awt . Point [] range = Calc . getCellRangePositions ( \"A1:D5\" ); System . out . println ( \"Range of A1:D5: (\" + range [ 0 ] . x + \", \" + range [ 0 ] . y + \") -- (\" + range [ 1 ] . x + \", \" + range [ 1 ] . y + \")\" ); XCellRange cellRange = Calc . getCellRange ( sheet , range [ 0 ] . x , range [ 0 ] . y , range [ 1 ] . x , range [ 1 ] . y ); Calc . printAddress ( cellRange ); System . out . println ( \"A1:D5: \" + Calc . getRangeStr ( range [ 0 ] . x , range [ 0 ] . y , range [ 1 ] . x , range [ 1 ] . y )); System . out . println (); } // end of convertAddresses() convertAddresses() prints the following: Position of AA2: (26, 1) Cell: Sheet1.AA2 AA2: AA2 Range of A1:D5: (0, 0) -- (3, 4) Range: Sheet1.A1:D5 A1:D5: A1:D5 Cell Name Manipulation \u00b6 Calc.getCellPosition() converts a cell name, such as \"AA2\", into a (column, row) position coordinate, which it returns as a Java Point object. For \"AA2\" the result is (26, 1), since the column labeled \"AA\" follows \"Z\" in a spreadsheet. The implementation uses regular expression parsing of the input string to separate out the alphabetic and numerical parts before processing them: // in the Calc class public static Point getCellPosition ( String cellName ) { Pattern p = Pattern . compile ( \"([a-zA-Z]+)([0-9]+)\" ); Matcher m = p . matcher ( cellName ); if ( m . matches ()) { int nColumn = columnStringToNumber ( m . group ( 1 ). toUpperCase () ); int nRow = rowStringToNumber ( m . group ( 2 )); return new Point ( nColumn , nRow ); } else { System . out . println ( \"No match found\" ); return null ; } } // end of getCellPosition() Calc.getCell() converts a position into an XCell reference to the cell: XCell cell = Calc . getCell ( sheet , 26 , 1 ); The function is a wrapper around XCellRange.getCellByPosition(): // first version of Calc.getCell() public static XCell getCell ( XSpreadsheet sheet , int column , int row ) { try { return sheet . getCellByPosition ( column , row ); } catch ( Exception e ) { System . out . println ( \"Could not access cell at: \" + column + \" - \" + row ); return null ; } } // end of getCell() A second version of getCell() refers to a cell by name: XCell cell = Calc . getCell ( sheet , \"AA2\" ); The code: // 2nd version of Calc.getCell() public static XCell getCell ( XSpreadsheet sheet , String cellName ) { XCellRange cellRange = sheet . getCellRangeByName ( cellName ); return getCell ( cellRange , 0 , 0 ); // calls 1st getCell() } The call to XCellRange.getCellRangeByName() with a single cell name returns a cell range made up of one cell. This XCellRange reference can be passed to Calc.getCell() since XCellRange is a superclass of XSpreadsheet. The first version of getCell() is called, and XCellRange.getCellByPosition() treats (0, 0) as a position relative to the cell range. There's only one cell in this range, so getCellByPosition() returns a reference to the \"AA2\" cell. Cell Range Manipulation \u00b6 The second half of convertAddresses() shows off some of the cell range addressing methods. Calc.getCellRangePositions() returns an array of two Java Point objects corresponding to the top-left and bottom-right cells of the range: // in convertAddresses() in BuildTable.java : java . awt . Point [] range = Calc . getCellRangePositions ( \"A1:D5\" ); System . out . println ( \"Range of A1:D5: (\" + range [ 0 ] . x + \", \" + range [ 0 ] . y + \") -- (\" + range [ 1 ] . x + \", \" + range [ 1 ] . y + \")\" ); Only simple cell range names of the form ':' are understood by my functions. Range operators, such as \"~\", \"!\", and absolute references using \"$\" aren't supported. Calc.getCellRange() converts a range address into an XCellRange reference: XCellRange cellRange = Calc . getCellRange ( sheet , \"A1:D5\" ); This method wraps a call to XCellRange.getCellRangeByName(): // in the Calc class public static XCellRange getCellRange ( XSpreadsheet sheet , String rangeName ) { XCellRange cellRange = sheet . getCellRangeByName ( rangeName ); if ( cellRange == null ) System . out . println ( \"Could not access: \\\"\" + rangeName + \"\\\"\" ); return cellRange ; } 2.2. Changing Cell Values \u00b6 Back in BuildTable.java, the buildCells() methods shows how individual cells can be assigned values. The code uses two versions of Calc.setVal(), one that accepts a cell position, the other a cell name. For example: // in buildCells() in BuildTable.java : Calc . setVal ( sheet , \"B2\" , 31.45 ); // name Calc . setVal ( sheet , 1 , 0 , \"JAN\" ); // (column, row) Both methods store a number or a string in a cell, by processing the input value as an Object: // in the Calc class public static void setVal ( XSpreadsheet sheet , String cellName , Object value ) // save value using cell name { Point pos = getCellPosition ( cellName ); setVal ( sheet , pos . x , pos . y , value ); // column, row } public static void setVal ( XSpreadsheet sheet , int column , int row , Object value ) // save value using cell position { XCell cell = getCell ( sheet , column , row ); setVal ( cell , value ); } public static void setVal ( XCell cell , Object value ) // decide how to save value based on its type { if ( value instanceof Number ) cell . setValue ( convertToDouble ( value )); else if ( value instanceof String ) cell . setFormula (( String ) value ); else System . out . println ( \"Value is not a number/string: \" + value ); } // end of setVal() The third setVal() function examines the type of the value to decide whether to call XCell.setValue() or XCell.setFormula(). 2.3. Storing 2D Arrays of Data \u00b6 The buildArray() method in BuildTables.java shows how a block of data can be stored by Calc.setArray(): // in BuildTable.java private static void buildArray ( XSpreadsheet sheet ) { Object [][] vals = { { \"\" , \"JAN\" , \"FEB\" , \"MAR\" , \"APR\" , \"MAY\" , \"JUN\" , \"JUL\" , \"AUG\" , \"SEP\" , \"OCT\" , \"NOV\" , \"DEC\" }, { \"Smith\" , 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 , - 67.3 , 30.5 , 23.2 , - 97.3 , 22.4 , 23.5 }, { \"Jones\" , 21 , 40.9 , - 57.5 , - 23.4 , 34.5 , 59.3 , 27.3 , - 38.5 , 43.2 , 57.3 , 25.4 , 28.5 }, { \"Brown\" , 31.45 , - 20.9 , - 117.5 , 23.4 , - 114.5 , 115.3 , - 171.3 , 89.5 , 41.2 , 71.3 , 25.4 , 38.5 } }; Calc . setArray ( sheet , \"A1:M4\" , vals ); Calc . setVal ( sheet , \"N1\" , \"SUM\" ); Calc . setVal ( sheet , \"N2\" , \"=SUM(B2:M2)\" ); Calc . setVal ( sheet , \"N3\" , \"=SUM(B3:M3)\" ); Calc . setVal ( sheet , \"N4\" , \"=SUM(A4:L4)\" ); } // end of buildArray() Calc.setArray() accepts a 2D array of Object values (which means it can contain a mix of strings and doubles) with the data arranged in row-order. For example, the data shown above is stored in the sheet as in Figure 2. Figure 2. A Block of Data Added to a Sheet. The second argument of Calc.setArray() can be a cell range or a single cell name representing the top-left corner of the range. In the latter case, the cell range is calculated from the size of the array. This means that the call used above could be rewritten as: Calc . setArray ( sheet , \"A1\" , vals ); // string was \"A1:M4\" Calc . setArray () is defined as : // in the Calc class public static void setArray ( XSpreadsheet sheet , String name , Object [][] values ) // decide how sheet area is referred to by name { if ( isCellRangeName ( name )) setArrayRange ( sheet , name , values ); else // is a cell name setArrayCell ( sheet , name , values ); } // end of setArray() public static void setArrayRange ( XSpreadsheet sheet , String rangeName , Object [][] values ) // store array using cell range name { XCellRange cellRange = getCellRange ( sheet , rangeName ); setCellRangeArray ( cellRange , values ); } // end of setArrayRange() public static void setArrayCell ( XSpreadsheet sheet , String cellName , Object [][] values ) // store array using cell name { // calculate cell range name using array size Point pos = getCellPosition ( cellName ); int colEnd = pos . x + values [ 0 ] . length - 1 ; int rowEnd = pos . y + values . length - 1 ; XCellRange cellRange = getCellRange ( sheet , pos . x , pos . y , colEnd , rowEnd ); setCellRangeArray ( cellRange , values ); } // end of setArrayCell() public static void setCellRangeArray ( XCellRange cellRange , Object [][] values ) // store the array as data in the cell range { XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); crData . setDataArray ( values ); } // end of setCellRangeArray() The storage of the array is performed by Calc.setCellRangeArray() which is passed an XCellRange object and a 2D array. XCellRange is converted into XCellRangeData which has a setDataArray() method. 2.4. Storing Rows of Data \u00b6 Calc.setRow() lets the programmer store a 1D array as a row of data: Calc . setRow ( sheet , \"B2\" , new Object [] { 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 , - 67.3 , 30.5 , 23.2 , - 97.3 , 22.4 , 23.5 }); Calc.setRow() employs XCellRangeData.setDataArray(), which requires an XCellRange object and a 2D array: // in the Calc class public static void setRow ( XSpreadsheet sheet , String cellName , Object [] values ) // store values in row using cell name { Point pos = getCellPosition ( cellName ); setRow ( sheet , pos . x , pos . y , values ); // column, row } public static void setRow ( XSpreadsheet sheet , int colStart , int rowStart , Object [] values ) // store values in row starting at (colstart, rowstart) { XCellRange cellRange = getCellRange ( sheet , colStart , rowStart , colStart + values . length - 1 , rowStart ); // calculate cell range based on array size XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); crData . setDataArray ( new Object [][] { values }); // store the row as a 2D array containing one row of data } // end of setRow() 2.5. Storing Columns of Data \u00b6 Calc.setCol() lets the programmer store a column of data, as shown in BuildTable.java in its buildCols() method: // in BuildTable.java private static void buildCols ( XSpreadsheet sheet ) { Calc . setCol ( sheet , \"A2\" , new Object [] { \"JAN\" , \"FEB\" , \"MAR\" , \"APR\" , \"MAY\" , \"JUN\" , \"JUL\" , \"AUG\" , \"SEP\" , \"OCT\" , \"NOV\" , \"DEC\" }); Calc . setVal ( sheet , \"A14\" , \"SUM\" ); Calc . setVal ( sheet , \"B1\" , \"Smith\" ); Calc . setCol ( sheet , \"B2\" , new Object [] { 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 , - 67.3 , 30.5 , 23.2 , - 97.3 , 22.4 , 23.5 }); Calc . setVal ( sheet , \"B14\" , \"=SUM(B2:M2)\" ); Calc . setVal ( sheet , 2 , 0 , \"Jones\" ); Calc . setCol ( sheet , 2 , 1 , new Object [] { 21 , 40.9 , - 57.5 , - 23.4 , 34.5 , 59.3 , 27.3 , - 38.5 , 43.2 , 57.3 , 25.4 , 28.5 }); Calc . setVal ( sheet , 2 , 13 , \"=SUM(B3:M3)\" ); Calc . setVal ( sheet , 3 , 0 , \"Brown\" ); Calc . setCol ( sheet , 3 , 1 , new Object [] { 31.45 , - 20.9 , - 117.5 , 23.4 , - 114.5 , 115.3 , - 171.3 , 89.5 , 41.2 , 71.3 , 25.4 , 38.5 }); Calc . setVal ( sheet , 3 , 13 , \"=SUM(A4:L4)\" ); } // end of buildCols() buildCols() creates the spreadsheet shown in Figure 3. Figure 3. Columns of Data in a Sheet. Column creation is a little harder than row building since it's not possible to use XCellRangeData.setDataArray() which assumes that data is row-ordered. Instead Calc.setCol() calls Calc.setVal() in a loop: // in the Calc class public static void setCol ( XSpreadsheet sheet , String cellName , Object [] values ) // store values in column using cell name { Point pos = getCellPosition ( cellName ); setCol ( sheet , pos . x , pos . y , values ); // column, row } public static void setCol ( XSpreadsheet sheet , int colStart , int rowStart , Object [] values ) // store values down a column starting at (colstart, rowstart) { XCellRange cellRange = getCellRange ( sheet , colStart , rowStart , colStart , rowStart + values . length - 1 ); // calculate cell range from data size XCell xCell = null ; for ( int i = 0 ; i < values . length ; i ++ ) { xCell = getCell ( cellRange , 0 , i ); // column -- row setVal ( xCell , values [ i ] ); } } // end of setCol() 2.6. Adding a Picture \u00b6 Adding an image to a spreadsheet is straightforward since every sheet is also a draw page. The Spreadsheet service has an XDrawPageSupplier interface, which has a getDrawPage() method. The returned XDrawPage reference points to a transparent drawing surface that lies over the top of the sheet. Adding a picture is done by calling Draw.drawImage(): // in addPic() in BuildTables.java XDrawPageSupplier dpSupp = Lo . qi ( XDrawPageSupplier . class , sheet ); XDrawPage page = dpSupp . getDrawPage (); Draw . drawImage ( page , \"skinner.png\" , 50 , 40 ); : The (50, 40) passed to Draw.drawImage() is the (x, y) offset from the top-left corner of the sheet, specified in millimeters. This method comes from my Draw.java support class, explained in Part 3. Warning when Drawing \u00b6 Many of the Draw.java methods take a document argument, such as Draw.getSlidesCount() which returns the number of draw pages in the document: System . out . println ( \"No of draw pages: \" + Draw . getSlidesCount ( doc )); These methods assume that the document argument can be cast to XComponent. For instance, the function prototype for getSlidesCount() is: int getSlidesCount ( XComponent doc ); Unfortunately, this casting will not work with spreadsheet documents because XSpreadsheetDocument doesn't inherit XComponent. Instead the XSpreadsheetDocument interface must be explicitly converted to XComponent first, as in: // in addPic() in BuildTables.java XComponent compDoc = Lo . qi ( XComponent . class , doc ); System . out . println ( \"No of draw pages: \" + Draw . getSlidesCount ( compDoc )); 2.7. Adding a Chart \u00b6 I'll be discussing charting at length in Part 5, but I'll give a taster of it here since a CellRangeAddress object is used to pass data to the charting methods. For example, the cell range for \"A1:N4\" is passed to Chart2.insertChart(): // commented out code in BuildTables.java CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A1:N4\" ); Chart2 . insertChart ( sheet , rangeAddr , \"D6\" , 21 , 11 , \"Column\" ); The other arguments used by Chart2.insertChart() are a cell name, the millimeter width and height of the generated chart, and a chart type string. The named cell acts as an anchor point for the top-left corner of the chart. Figure 4 shows what the resulting chart looks like. Figure 4. A Column Chart in a Spreadsheet.","title":"Chapter 20. Spreadsheet Displaying and Creation"},{"location":"20-Spreadsheet_Manipulation.html#chapter-20-spreadsheet-displaying-and-creation","text":"Topics Displaying a Document; Read-only and Protected Viewing; Active Sheets; Sheet Names; Zooming; Creating a Document; Cell Names and Ranges; Cell Values; Data Arrays; Rows and Columns of Data; Adding a Picture and a Chart Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at two main topics: the display of an existing spreadsheet document, and the creation of a new document, based around two examples, ShowSheet.java and BuildTable.java. As part of displaying a document, I'll also describe how to use read-only and protected viewing, change the active sheet, use sheet names, and adjust the window view size by zooming. Document creation illustrates the use of cell names and ranges, the setting of cell data using arrays, rows, and columns, and adding a picture and a chart to a sheet.","title":"Chapter 20. Spreadsheet Displaying and Creation"},{"location":"20-Spreadsheet_Manipulation.html#1-displaying-a-document","text":"The ShowSheet.java example shows how to open a spreadsheet document, and display its first sheet. If the program is called with a filename argument, then the document is saved to that file before the program closes. The extension of the output filename is used to determine the exported file type. For example: run ShowSheet totals . ods show . pdf displays the totals.ods spreadsheet, and saves it as a PDF file. Alternatively: run ShowSheet sorted . csv sorted . html opens the CSV file as a Calc document, and saves it as HTML. The main() function of ShowSheet.java: // in ShowSheet.java public static void main ( String args [] ) { String outFnm = null ; if (( args . length < 1 ) || ( args . length > 2 )) { System . out . println ( \"Usage: run ShowSheet fnm [out-fnm]\" ); return ; } if ( args . length == 2 ) outFnm = args [ 1 ] ; XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Calc . gotoCell ( doc , \"A1\" ); // move view to top of sheet // XSpreadsheet sheet = Calc.getSheet(doc, 0); // not needed here Lo . waitEnter (); // wait for user to press <ENTER> if ( outFnm != null ) Lo . saveDoc ( doc , outFnm ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Calc.openDoc() opens the document, returning an XSpreadsheetDocument reference: // in the Calc class public static XSpreadsheetDocument openDoc ( String fnm , XComponentLoader loader ) { XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Document is null\" ); return null ; } return getSSDoc ( doc ); } // end of openDoc() public static XSpreadsheetDocument getSSDoc ( XComponent doc ) { if ( ! Info . isDocType ( doc , Lo . CALC_SERVICE )) { System . out . println ( \"Not a spreadsheet doc; closing\" ); Lo . closeDoc ( doc ); return null ; } XSpreadsheetDocument ssDoc = Lo . qi ( XSpreadsheetDocument . class , doc ); if ( ssDoc == null ) { System . out . println ( \"Not a spreadsheet doc; closing\" ); Lo . closeDoc ( doc ); return null ; } return ssDoc ; } // end of getSSDoc() First Lo.openDoc() returns an XComponent reference, then getSSDoc() converts it to XSpreadsheetDocument. This conversion will fail if the input document isn't a spreadsheet. GUI.setVisible(true) causes Office to display the spreadsheet's active sheet, which is the one that was being worked on when the file was previously saved. In addition, the application will display the cell or cells selected in the sheet at that time. The selection can be changed by calling Calc.gotoCell(): // in the Calc class public static void gotoCell ( XSpreadsheetDocument doc , String cellName ) { XFrame frame = getController ( doc ). getFrame (); gotoCell ( frame , cellName ); } public static XController getController ( XSpreadsheetDocument doc ) { XModel model = Lo . qi ( XModel . class , doc ); return model . getCurrentController (); } public static void gotoCell ( XFrame frame , String cellName ) { Lo . dispatchCmd ( frame , \"GoToCell\" , Props . makeProps ( \"ToPoint\" , cellName )); } Any changes to the document's view requires a reference to its controller. The active cell is changed by sending a \"GoToCell\" dispatch to the controller's frame. \"GoToCell\" requires a cell name argument, which is encoded as a property array containing a single \"ToPoint\" property. Calc.getSheet() returns a reference to the currently active sheet. but that line is commented out in ShowSheet.java, since it's not needed. getSheet() is implemented using code similar to that described in the previous chapter: // in the Calc class public static XSpreadsheet getSheet ( XSpreadsheetDocument doc , int index ) { XSpreadsheets sheets = doc . getSheets (); XSpreadsheet sheet = null ; try { XIndexAccess xSheetsIdx = Lo . qi ( XIndexAccess . class , sheets ); sheet = Lo . qi ( XSpreadsheet . class , xSheetsIdx . getByIndex ( index )); } catch ( Exception e ) { System . out . println ( \"Could not access spreadsheet: \" + index ); } return sheet ; } // end of getSheet() If the user calls ShowSheet.java with a filename argument, then Lo.saveDoc() performs a save to that file. saveDoc() utilizes Lo.ext2Format() to map the filename's extension (e.g. \"pdf\", \"html\", \"xhtml\") and the document type (in this case, a spreadsheet) to a suitable output format. The function consists of a long switch statement which decides on the most suitable mapping, as illustrated by the code fragment: // in the Lo class public static String ext2Format ( int docType , String ext ) { switch ( ext ) { case \"doc\" : return \"MS Word 97\" ; case \"docx\" : return \"Office Open XML Text\" ; : : // many more cases case \"pdf\" : if ( docType == Lo . WRITER ) return \"writer_pdf_Export\" ; else if ( docType == Lo . IMPRESS ) return \"impress_pdf_Export\" ; else if ( docType == Lo . DRAW ) return \"draw_pdf_Export\" ; else if ( docType == Lo . CALC ) return \"calc_pdf_Export\" ; else if ( docType == Lo . MATH ) return \"math_pdf_Export\" ; else return \"writer_pdf_Export\" ; : // many more cases } // end of ext2Format() The \"pdf\" case is selected when the output file extension is \"pdf\", but the export format also depends on the Office document. For ShowSheet.java, the docType value will be Lo.CALC, which causes ext2Format() to return \"calc_pdf_Export\". Lo.ext2Format() is very far from comprehensive, but understands Office and MS spreadsheet formats, CSV, RTF, text, HTML, XHTML, and PDF. Other mappings can be added as required.","title":"1.  Displaying a Document"},{"location":"20-Spreadsheet_Manipulation.html#11-read-only-and-protected-viewing","text":"One variant of ShowSheet.java prevents a user from changing the spreadsheet. Unfortunately, implementing this by opening the document read-only isn't particularly robust because Office always displays a message asking if the user wants to override the read-only setting. Nevertheless, the code is short: // commented out in ShowSheet.java XComponent cDoc = Lo . openReadOnlyDoc ( args [ 0 ] , loader ); XSpreadsheetDocument doc = Calc . getSSDoc ( cDoc ); openReadOnlyDoc() calls Lo.openDoc() with the \"ReadOnly\" property set to true: // in the Calc class public static XComponent openReadOnlyDoc ( String fnm , XComponentLoader loader ) { return openDoc ( fnm , loader , Props . makeProps ( \"Hidden\" , true , \"ReadOnly\" , true ) ); } If you want to actually stop the user from changing the spreadsheet, then it must be protected, using the XProtectable interface: XProtectable pro = Lo . qi ( XProtectable . class , doc ); pro . protect ( \"foobar\" ); XProtectable.protect() assigns a password to the sheet (in this example, \"foobar\"), which the user must supply in order to change any data . Document-level protection isn't supported in the current version of Office. The best we can do is to apply protection to individual sheets. Namely: // commented out in ShowSheet.java XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // get sheet 1 XProtectable pro = Lo . qi ( XProtectable . class , sheet ); pro . protect ( \"foobar\" ); // query the user for the password String pwd = GUI . getPassword ( \"Sheet protection\" , \"Supply password:\" ); if (( pwd != null ) && pwd . equals ( \"foobar\" )) { // check input System . out . println ( \"Password correct\" ); pro . unprotect ( \"foobar\" ); } else { System . out . println ( \"Password incorrect\" ); GUI . showJMessageBox ( \"Password Status\" , \"Password incorrect\" ); } The code fragment above shows how to query the user for the password. GUI.getPassword() displays a dialog window which includes a Java JPasswordField component for hiding the entered data: // in the GUI class public static String getPassword ( String title , String inputMsg ) { JLabel jl = new JLabel ( inputMsg ); JPasswordField jpf = new JPasswordField ( 24 ); Object [] ob = { jl , jpf }; int result = JOptionPane . showConfirmDialog ( null , ob , title , JOptionPane . OK_CANCEL_OPTION ); if ( result == JOptionPane . OK_OPTION ) return new String ( jpf . getPassword ()); else return null ; } // end of getPassword()","title":"1.1.  Read-only and Protected Viewing"},{"location":"20-Spreadsheet_Manipulation.html#12-changing-the-active-sheet","text":"Another variation of ShowSheet allows the user to specify which sheet to make active, and so be displayed in Office. It's not enough to execute Calc.getSheet() with a sheet index; Calc.setActiveSheet() must also be called to make that sheet active: // in the Calc class public static void setActiveSheet ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { XSpreadsheetView ssView = Lo . qi ( XSpreadsheetView . class , getController ( doc )); ssView . setActiveSheet ( sheet ); } // end of setActiveSheet() Calc.setActiveSheet() converts the controller interface for the document into an XSpreadsheetView, which is the main interface for the SpreadsheetView service (see Figure 1). Figure 1. The SpreadsheetView Services and Interfaces. SpreadsheetView implements a number of interfaces for affecting the user's view of a document. View-related properties are stored in the inherited SpreadsheetViewSettings class, which can be listed by calling Props.showObjProps(): // commented out in ShowSheet.java XSpreadsheetView ssView = Lo . qi ( XSpreadsheetView . class , getController ( doc )); Props . showObjProps ( \"Spreadsheet view\" , ssView );","title":"1.2.  Changing the Active Sheet"},{"location":"20-Spreadsheet_Manipulation.html#13-sheet-names","text":"Default spreadsheet names use \"Sheet\" followed by a positive integer. For example, a new document will name its first sheet \"Sheet1\". Calc.getSheet() can accept a sheet name, as in the following code which makes \"Sheet1\" active: // in ShowSheet.java XSpreadsheet sheet = Calc . getSheet ( doc , \"Sheet1\" ); Calc . setActiveSheet ( doc , sheet ); All the sheet names in a document can be accessed via Calc.getSheetNames(), and a sheet's name can be changed by Calc.setSheetName(): // in the Calc class public static String [] getSheetNames ( XSpreadsheetDocument doc ) { XSpreadsheets sheets = doc . getSheets (); return sheets . getElementNames (); } public static void setSheetName ( XSpreadsheet sheet , String name ) { XNamed xNamed = Lo . qi ( XNamed . class , sheet ); if ( xNamed == null ) System . out . println ( \"Could not access spreadsheet\" ); else xNamed . setName ( name ); } // end of setSheetName()","title":"1.3.  Sheet Names"},{"location":"20-Spreadsheet_Manipulation.html#14-zooming","text":"Zooming the view of a document is done by adjusting properties in SpreadsheetViewSettings (see Figure 1 above). The \"ZoomType\" property specifies the kind of zooming, which may be a size percentage or a constant indicating a particular zooming amount. The constants are defined in Calc.java: // in the Calc class public static final short OPTIMAL = 0 ; public static final short PAGE_WIDTH = 1 ; public static final short ENTIRE_PAGE = 2 ; public static final short BY_VALUE = 3 ; public static final short PAGE_WIDTH_EXACT = 4 ; The constants are understood by Calc.zoom(): // in the Calc class public static void zoom ( XSpreadsheetDocument doc , short type ) { XController ctrl = getController ( doc ); Props . setProperty ( ctrl , \"ZoomType\" , type ); } For example, the entire sheet can be made visible by calling: Calc . zoom ( doc , Calc . ENTIRE_PAGE ); For percentage zooming, the value must be assigned to the \"ZoomValue\" property. This is handled by Calc.zoomValue(): // in the Calc class public static void zoomValue ( XSpreadsheetDocument doc , int value ) { XController ctrl = getController ( doc ); Props . setProperty ( ctrl , \"ZoomType\" , BY_VALUE ); Props . setProperty ( ctrl , \"ZoomValue\" , ( short ) value ); }","title":"1.4.  Zooming"},{"location":"20-Spreadsheet_Manipulation.html#2-creating-a-document","text":"The BuildTable.java example shows how to create a new spreadsheet document, populate it with data, apply cell styling, and save it to a file. I'll look at styling in the next chapter, and will concentrate here on the different ways to add data to a sheet. The main() function of BuildTable.java is: // in BuildTable.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); convertAddresses ( sheet ); // uncomment one of these build methods // buildCells(sheet); // buildRows(sheet); // buildCols(sheet); buildArray ( sheet ); Lo . saveDoc ( doc , \"buildTable.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() main() can call one of four different build methods to demonstrate various Calc.java functions for filling cells and cell ranges. convertAddresses() illustrates the Calc.java methods for converting between cell names and positions, and between cell range names and position intervals.","title":"2.  Creating a Document"},{"location":"20-Spreadsheet_Manipulation.html#21-switching-between-cell-names-cell-ranges-and-positions","text":"Although the Calc.java get/set methods for cells, columns, rows, and cell ranges support both name and position based addressing (e.g. \"D5\" and (3, 4)), it's still sometimes necessary to convert between the different formats. convertAddresses() demonstrates those methods: // in BuildTable.java private static void convertAddresses ( XSpreadsheet sheet ) { // cell name <--> position java . awt . Point pos = Calc . getCellPosition ( \"AA2\" ); System . out . println ( \"Position of AA2: (\" + pos . x + \", \" + pos . y + \")\" ); XCell cell = Calc . getCell ( sheet , pos . x , pos . y ); Calc . printCellAddress ( cell ); System . out . println ( \"AA2: \" + Calc . getCellStr ( pos . x , pos . y )); System . out . println (); // cell range name <--> position java . awt . Point [] range = Calc . getCellRangePositions ( \"A1:D5\" ); System . out . println ( \"Range of A1:D5: (\" + range [ 0 ] . x + \", \" + range [ 0 ] . y + \") -- (\" + range [ 1 ] . x + \", \" + range [ 1 ] . y + \")\" ); XCellRange cellRange = Calc . getCellRange ( sheet , range [ 0 ] . x , range [ 0 ] . y , range [ 1 ] . x , range [ 1 ] . y ); Calc . printAddress ( cellRange ); System . out . println ( \"A1:D5: \" + Calc . getRangeStr ( range [ 0 ] . x , range [ 0 ] . y , range [ 1 ] . x , range [ 1 ] . y )); System . out . println (); } // end of convertAddresses() convertAddresses() prints the following: Position of AA2: (26, 1) Cell: Sheet1.AA2 AA2: AA2 Range of A1:D5: (0, 0) -- (3, 4) Range: Sheet1.A1:D5 A1:D5: A1:D5","title":"2.1.  Switching between Cell Names, Cell Ranges, and Positions"},{"location":"20-Spreadsheet_Manipulation.html#cell-name-manipulation","text":"Calc.getCellPosition() converts a cell name, such as \"AA2\", into a (column, row) position coordinate, which it returns as a Java Point object. For \"AA2\" the result is (26, 1), since the column labeled \"AA\" follows \"Z\" in a spreadsheet. The implementation uses regular expression parsing of the input string to separate out the alphabetic and numerical parts before processing them: // in the Calc class public static Point getCellPosition ( String cellName ) { Pattern p = Pattern . compile ( \"([a-zA-Z]+)([0-9]+)\" ); Matcher m = p . matcher ( cellName ); if ( m . matches ()) { int nColumn = columnStringToNumber ( m . group ( 1 ). toUpperCase () ); int nRow = rowStringToNumber ( m . group ( 2 )); return new Point ( nColumn , nRow ); } else { System . out . println ( \"No match found\" ); return null ; } } // end of getCellPosition() Calc.getCell() converts a position into an XCell reference to the cell: XCell cell = Calc . getCell ( sheet , 26 , 1 ); The function is a wrapper around XCellRange.getCellByPosition(): // first version of Calc.getCell() public static XCell getCell ( XSpreadsheet sheet , int column , int row ) { try { return sheet . getCellByPosition ( column , row ); } catch ( Exception e ) { System . out . println ( \"Could not access cell at: \" + column + \" - \" + row ); return null ; } } // end of getCell() A second version of getCell() refers to a cell by name: XCell cell = Calc . getCell ( sheet , \"AA2\" ); The code: // 2nd version of Calc.getCell() public static XCell getCell ( XSpreadsheet sheet , String cellName ) { XCellRange cellRange = sheet . getCellRangeByName ( cellName ); return getCell ( cellRange , 0 , 0 ); // calls 1st getCell() } The call to XCellRange.getCellRangeByName() with a single cell name returns a cell range made up of one cell. This XCellRange reference can be passed to Calc.getCell() since XCellRange is a superclass of XSpreadsheet. The first version of getCell() is called, and XCellRange.getCellByPosition() treats (0, 0) as a position relative to the cell range. There's only one cell in this range, so getCellByPosition() returns a reference to the \"AA2\" cell.","title":"Cell Name Manipulation"},{"location":"20-Spreadsheet_Manipulation.html#cell-range-manipulation","text":"The second half of convertAddresses() shows off some of the cell range addressing methods. Calc.getCellRangePositions() returns an array of two Java Point objects corresponding to the top-left and bottom-right cells of the range: // in convertAddresses() in BuildTable.java : java . awt . Point [] range = Calc . getCellRangePositions ( \"A1:D5\" ); System . out . println ( \"Range of A1:D5: (\" + range [ 0 ] . x + \", \" + range [ 0 ] . y + \") -- (\" + range [ 1 ] . x + \", \" + range [ 1 ] . y + \")\" ); Only simple cell range names of the form ':' are understood by my functions. Range operators, such as \"~\", \"!\", and absolute references using \"$\" aren't supported. Calc.getCellRange() converts a range address into an XCellRange reference: XCellRange cellRange = Calc . getCellRange ( sheet , \"A1:D5\" ); This method wraps a call to XCellRange.getCellRangeByName(): // in the Calc class public static XCellRange getCellRange ( XSpreadsheet sheet , String rangeName ) { XCellRange cellRange = sheet . getCellRangeByName ( rangeName ); if ( cellRange == null ) System . out . println ( \"Could not access: \\\"\" + rangeName + \"\\\"\" ); return cellRange ; }","title":"Cell Range Manipulation"},{"location":"20-Spreadsheet_Manipulation.html#22-changing-cell-values","text":"Back in BuildTable.java, the buildCells() methods shows how individual cells can be assigned values. The code uses two versions of Calc.setVal(), one that accepts a cell position, the other a cell name. For example: // in buildCells() in BuildTable.java : Calc . setVal ( sheet , \"B2\" , 31.45 ); // name Calc . setVal ( sheet , 1 , 0 , \"JAN\" ); // (column, row) Both methods store a number or a string in a cell, by processing the input value as an Object: // in the Calc class public static void setVal ( XSpreadsheet sheet , String cellName , Object value ) // save value using cell name { Point pos = getCellPosition ( cellName ); setVal ( sheet , pos . x , pos . y , value ); // column, row } public static void setVal ( XSpreadsheet sheet , int column , int row , Object value ) // save value using cell position { XCell cell = getCell ( sheet , column , row ); setVal ( cell , value ); } public static void setVal ( XCell cell , Object value ) // decide how to save value based on its type { if ( value instanceof Number ) cell . setValue ( convertToDouble ( value )); else if ( value instanceof String ) cell . setFormula (( String ) value ); else System . out . println ( \"Value is not a number/string: \" + value ); } // end of setVal() The third setVal() function examines the type of the value to decide whether to call XCell.setValue() or XCell.setFormula().","title":"2.2.  Changing Cell Values"},{"location":"20-Spreadsheet_Manipulation.html#23-storing-2d-arrays-of-data","text":"The buildArray() method in BuildTables.java shows how a block of data can be stored by Calc.setArray(): // in BuildTable.java private static void buildArray ( XSpreadsheet sheet ) { Object [][] vals = { { \"\" , \"JAN\" , \"FEB\" , \"MAR\" , \"APR\" , \"MAY\" , \"JUN\" , \"JUL\" , \"AUG\" , \"SEP\" , \"OCT\" , \"NOV\" , \"DEC\" }, { \"Smith\" , 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 , - 67.3 , 30.5 , 23.2 , - 97.3 , 22.4 , 23.5 }, { \"Jones\" , 21 , 40.9 , - 57.5 , - 23.4 , 34.5 , 59.3 , 27.3 , - 38.5 , 43.2 , 57.3 , 25.4 , 28.5 }, { \"Brown\" , 31.45 , - 20.9 , - 117.5 , 23.4 , - 114.5 , 115.3 , - 171.3 , 89.5 , 41.2 , 71.3 , 25.4 , 38.5 } }; Calc . setArray ( sheet , \"A1:M4\" , vals ); Calc . setVal ( sheet , \"N1\" , \"SUM\" ); Calc . setVal ( sheet , \"N2\" , \"=SUM(B2:M2)\" ); Calc . setVal ( sheet , \"N3\" , \"=SUM(B3:M3)\" ); Calc . setVal ( sheet , \"N4\" , \"=SUM(A4:L4)\" ); } // end of buildArray() Calc.setArray() accepts a 2D array of Object values (which means it can contain a mix of strings and doubles) with the data arranged in row-order. For example, the data shown above is stored in the sheet as in Figure 2. Figure 2. A Block of Data Added to a Sheet. The second argument of Calc.setArray() can be a cell range or a single cell name representing the top-left corner of the range. In the latter case, the cell range is calculated from the size of the array. This means that the call used above could be rewritten as: Calc . setArray ( sheet , \"A1\" , vals ); // string was \"A1:M4\" Calc . setArray () is defined as : // in the Calc class public static void setArray ( XSpreadsheet sheet , String name , Object [][] values ) // decide how sheet area is referred to by name { if ( isCellRangeName ( name )) setArrayRange ( sheet , name , values ); else // is a cell name setArrayCell ( sheet , name , values ); } // end of setArray() public static void setArrayRange ( XSpreadsheet sheet , String rangeName , Object [][] values ) // store array using cell range name { XCellRange cellRange = getCellRange ( sheet , rangeName ); setCellRangeArray ( cellRange , values ); } // end of setArrayRange() public static void setArrayCell ( XSpreadsheet sheet , String cellName , Object [][] values ) // store array using cell name { // calculate cell range name using array size Point pos = getCellPosition ( cellName ); int colEnd = pos . x + values [ 0 ] . length - 1 ; int rowEnd = pos . y + values . length - 1 ; XCellRange cellRange = getCellRange ( sheet , pos . x , pos . y , colEnd , rowEnd ); setCellRangeArray ( cellRange , values ); } // end of setArrayCell() public static void setCellRangeArray ( XCellRange cellRange , Object [][] values ) // store the array as data in the cell range { XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); crData . setDataArray ( values ); } // end of setCellRangeArray() The storage of the array is performed by Calc.setCellRangeArray() which is passed an XCellRange object and a 2D array. XCellRange is converted into XCellRangeData which has a setDataArray() method.","title":"2.3.  Storing 2D Arrays of Data"},{"location":"20-Spreadsheet_Manipulation.html#24-storing-rows-of-data","text":"Calc.setRow() lets the programmer store a 1D array as a row of data: Calc . setRow ( sheet , \"B2\" , new Object [] { 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 , - 67.3 , 30.5 , 23.2 , - 97.3 , 22.4 , 23.5 }); Calc.setRow() employs XCellRangeData.setDataArray(), which requires an XCellRange object and a 2D array: // in the Calc class public static void setRow ( XSpreadsheet sheet , String cellName , Object [] values ) // store values in row using cell name { Point pos = getCellPosition ( cellName ); setRow ( sheet , pos . x , pos . y , values ); // column, row } public static void setRow ( XSpreadsheet sheet , int colStart , int rowStart , Object [] values ) // store values in row starting at (colstart, rowstart) { XCellRange cellRange = getCellRange ( sheet , colStart , rowStart , colStart + values . length - 1 , rowStart ); // calculate cell range based on array size XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); crData . setDataArray ( new Object [][] { values }); // store the row as a 2D array containing one row of data } // end of setRow()","title":"2.4.  Storing Rows of Data"},{"location":"20-Spreadsheet_Manipulation.html#25-storing-columns-of-data","text":"Calc.setCol() lets the programmer store a column of data, as shown in BuildTable.java in its buildCols() method: // in BuildTable.java private static void buildCols ( XSpreadsheet sheet ) { Calc . setCol ( sheet , \"A2\" , new Object [] { \"JAN\" , \"FEB\" , \"MAR\" , \"APR\" , \"MAY\" , \"JUN\" , \"JUL\" , \"AUG\" , \"SEP\" , \"OCT\" , \"NOV\" , \"DEC\" }); Calc . setVal ( sheet , \"A14\" , \"SUM\" ); Calc . setVal ( sheet , \"B1\" , \"Smith\" ); Calc . setCol ( sheet , \"B2\" , new Object [] { 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 , - 67.3 , 30.5 , 23.2 , - 97.3 , 22.4 , 23.5 }); Calc . setVal ( sheet , \"B14\" , \"=SUM(B2:M2)\" ); Calc . setVal ( sheet , 2 , 0 , \"Jones\" ); Calc . setCol ( sheet , 2 , 1 , new Object [] { 21 , 40.9 , - 57.5 , - 23.4 , 34.5 , 59.3 , 27.3 , - 38.5 , 43.2 , 57.3 , 25.4 , 28.5 }); Calc . setVal ( sheet , 2 , 13 , \"=SUM(B3:M3)\" ); Calc . setVal ( sheet , 3 , 0 , \"Brown\" ); Calc . setCol ( sheet , 3 , 1 , new Object [] { 31.45 , - 20.9 , - 117.5 , 23.4 , - 114.5 , 115.3 , - 171.3 , 89.5 , 41.2 , 71.3 , 25.4 , 38.5 }); Calc . setVal ( sheet , 3 , 13 , \"=SUM(A4:L4)\" ); } // end of buildCols() buildCols() creates the spreadsheet shown in Figure 3. Figure 3. Columns of Data in a Sheet. Column creation is a little harder than row building since it's not possible to use XCellRangeData.setDataArray() which assumes that data is row-ordered. Instead Calc.setCol() calls Calc.setVal() in a loop: // in the Calc class public static void setCol ( XSpreadsheet sheet , String cellName , Object [] values ) // store values in column using cell name { Point pos = getCellPosition ( cellName ); setCol ( sheet , pos . x , pos . y , values ); // column, row } public static void setCol ( XSpreadsheet sheet , int colStart , int rowStart , Object [] values ) // store values down a column starting at (colstart, rowstart) { XCellRange cellRange = getCellRange ( sheet , colStart , rowStart , colStart , rowStart + values . length - 1 ); // calculate cell range from data size XCell xCell = null ; for ( int i = 0 ; i < values . length ; i ++ ) { xCell = getCell ( cellRange , 0 , i ); // column -- row setVal ( xCell , values [ i ] ); } } // end of setCol()","title":"2.5.  Storing Columns of Data"},{"location":"20-Spreadsheet_Manipulation.html#26-adding-a-picture","text":"Adding an image to a spreadsheet is straightforward since every sheet is also a draw page. The Spreadsheet service has an XDrawPageSupplier interface, which has a getDrawPage() method. The returned XDrawPage reference points to a transparent drawing surface that lies over the top of the sheet. Adding a picture is done by calling Draw.drawImage(): // in addPic() in BuildTables.java XDrawPageSupplier dpSupp = Lo . qi ( XDrawPageSupplier . class , sheet ); XDrawPage page = dpSupp . getDrawPage (); Draw . drawImage ( page , \"skinner.png\" , 50 , 40 ); : The (50, 40) passed to Draw.drawImage() is the (x, y) offset from the top-left corner of the sheet, specified in millimeters. This method comes from my Draw.java support class, explained in Part 3.","title":"2.6.  Adding a Picture"},{"location":"20-Spreadsheet_Manipulation.html#warning-when-drawing","text":"Many of the Draw.java methods take a document argument, such as Draw.getSlidesCount() which returns the number of draw pages in the document: System . out . println ( \"No of draw pages: \" + Draw . getSlidesCount ( doc )); These methods assume that the document argument can be cast to XComponent. For instance, the function prototype for getSlidesCount() is: int getSlidesCount ( XComponent doc ); Unfortunately, this casting will not work with spreadsheet documents because XSpreadsheetDocument doesn't inherit XComponent. Instead the XSpreadsheetDocument interface must be explicitly converted to XComponent first, as in: // in addPic() in BuildTables.java XComponent compDoc = Lo . qi ( XComponent . class , doc ); System . out . println ( \"No of draw pages: \" + Draw . getSlidesCount ( compDoc ));","title":"Warning when Drawing"},{"location":"20-Spreadsheet_Manipulation.html#27-adding-a-chart","text":"I'll be discussing charting at length in Part 5, but I'll give a taster of it here since a CellRangeAddress object is used to pass data to the charting methods. For example, the cell range for \"A1:N4\" is passed to Chart2.insertChart(): // commented out code in BuildTables.java CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A1:N4\" ); Chart2 . insertChart ( sheet , rangeAddr , \"D6\" , 21 , 11 , \"Column\" ); The other arguments used by Chart2.insertChart() are a cell name, the millimeter width and height of the generated chart, and a chart type string. The named cell acts as an anchor point for the top-left corner of the chart. Figure 4 shows what the resulting chart looks like. Figure 4. A Column Chart in a Spreadsheet.","title":"2.7.  Adding a Chart"},{"location":"21-Extracting_Data.html","text":"Chapter 21. Extracting Data \u00b6 Topics Getting a Cell Value; Getting the Data from a Cell Range; Getting Rows and Columns of Data; Obtaining Cell Ranges by Using Queries; Finding the Used Area with Sheet Cursors Example folders: \"Calc Tests\" and \"Utils\" This chapter is about extracting data from a spreadsheet. Two types of extraction are described: methods which are supplied with a predetermined cell range in order to obtain data from cells, rows, columns, and 2D regions. The other type of extraction uses cell ranges generated at run time based on content queries applied to the entire used area of the sheet. This approach requires the use of sheet cursors. All the example code comes from ExtractNums.java, which examines the \"small totals.ods\" spreadsheet shown in Figure 1. Figure 1. The \"small totals.ods\" Spreadsheet. Numerical data is stored in the cell range A2:D7 and the rest of the values are calculated using formulae. ExtracNums.java starts by accessing cells and cell ranges by name: // in ExtractNums.java public static void main ( String args [] ) { String outFnm = null ; if ( args . length != 1 ) { System . out . println ( \"Usage: run ExtractNums fnm\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); System . out . println ( \"\\nA1 string: \" + Calc . getVal ( sheet , \"A1\" )); XCell cell = Calc . getCell ( sheet , \"A2\" ); System . out . println ( \"A2 type: \" + Calc . getTypeString ( cell )); System . out . println ( \"A2 value: \" + Calc . getNum ( sheet , \"A2\" )); cell = Calc . getCell ( sheet , \"E2\" ); System . out . println ( \"E2 type: \" + Calc . getTypeString ( cell )); System . out . println ( \"E2 formula: \" + Calc . getVal ( sheet , \"E2\" )); System . out . println (); Object [][] data = Calc . getArray ( sheet , \"A1:E10\" ); Calc . printArray ( data ); double [][] ids = Calc . getDoublesArray ( sheet , \"A2:A7\" ); Calc . printArray ( ids ); double [] projs = Calc . convertToDoubles ( Calc . getCol ( sheet , \"B2:B7\" )); System . out . println ( \"Project scores\" ); for ( double proj : projs ) System . out . println ( \" \" + proj ); double [] stud = Calc . convertToDoubles ( Calc . getRow ( sheet , \"A4:E4\" )); System . out . println ( \"\\nStudent scores\" ); for ( double v : stud ) System . out . println ( \" \" + v ); : // more complex extraction code, explained later Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The output is: A1 string: Stud. No. A2 type: VALUE A2 value: 22001.0 E2 type: FORMULA E2 formula: =SUM(B2:D2)/100 Row x Column size: 10 x 5 Stud. No. Proj/20 Mid/35 Fin/45 Total% 22001.0 16.4583333333333 30.9166666666667 37.0125 0.843875 22028.0 11.875 23.0416666666667 25.4625 0.6037916666666671 22048.0 13.9583333333333 19.25 25.9875 0.591958333333333 23715.0 12.0833333333333 18.6666666666667 20.475 0.51225 23723.0 17.2916666666667 27.7083333333333 36.225 0.81225 24277.0 0.0 16.0416666666667 19.6875 0.357291666666667 11.9444444444444 22.6041666666667 27.475 0.6202361111111111 0.5972222222222221 0.645833333333334 0.6105555555555561 Proj/20 Mid/35 Fin/45 Total% Row x Column size: 6 x 1 22001.0 22028.0 22048.0 23715.0 23723.0 24277.0 Project scores 16.4583333333333 11.875 13.9583333333333 12.0833333333333 17.2916666666667 0.0 Student scores 22048.0 13.9583333333333 19.25 25.9875 0.591958333333333 I'll explain the highlighted get methods in the following sections. 1. Getting a Cell Value \u00b6 There are three versions of Calc.getVal() which access a value by cell name or position: // in the Calc class public static Object getVal ( XSpreadsheet sheet , String cellName ) // get value by cell name { Point pos = getCellPosition ( cellName ); return getVal ( sheet , pos . x , pos . y ); // column, row } // end of getVal() public static Object getVal ( XSpreadsheet sheet , int column , int row ) // get value by cell position { XCell xCell = getCell ( sheet , column , row ); return getVal ( xCell , column , row ); } // end of getVal() public static Object getVal ( XCell cell , int column , int row ) // get value based on the type of the data in the cell { CellContentType type = cell . getType (); if ( type == CellContentType . EMPTY ) return null ; else if ( type == CellContentType . VALUE ) return new Double ( cell . getValue ()); else if (( type == CellContentType . TEXT ) || ( type == CellContentType . FORMULA )) return cell . getFormula (); else { System . out . println ( \"Unknown cell type; returning null\" ); return null ; } } // end of getVal() The third getVal() utilizes XCell.getType() to decide how to extract the value. A cell may contain four different data types: a number, text, a formula, or be empty. When the data is numerical, the double value is accessed by calling XCell.getValue(), while for text or a formula XCell.getFormula() is employed. getVal() returns these different types of data cast to Object. This return type may be inconvenient for a user, who might have to cast the result to something more specific, such as a double. The support functions include Calc.getNum() which does this task. There's also Calc.getTypeString() which returns cell type information as a string: // in the Calc class public static String getTypeString ( XCell cell ) { CellContentType type = cell . getType (); if ( type == CellContentType . EMPTY ) return \"EMPTY\" ; else if ( type == CellContentType . VALUE ) return \"VALUE\" ; else if ( type == CellContentType . TEXT ) return \"TEXT\" ; else if ( type == CellContentType . FORMULA ) return \"FORMULA\" ; else { System . out . println ( \"Unknown cell type\" ); return \"??\" ; } } // end of getTypeString() 2. Getting the Data from a Cell Range \u00b6 Calc.getArray() extracts the data from a cell range as a 2D array of Objects. It utilizes XCellRangeData.getDataArray(): // in the Calc class public static Object [][] getArray ( XSpreadsheet sheet , String rangeName ) { XCellRange cellRange = getCellRange ( sheet , rangeName ); XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); return crData . getDataArray (); } // end of getArray() XCellRangeData.getDataArray() evaluates any formulae it encounters. This can be seen in the output from: // part of ExtractNum.java Object [][] data = Calc . getArray ( sheet , \"A1:E10\" ); The cell range includes several formulae (e.g. in \"E8\" and \"E9\"), but the data array contains their numerical values. If you don't want formulae to be evaluated then you'll need to implement your own version of getArray() which uses XCellRangeFormula. Its getDataArray() method doesn't process formulae. The code would look something like: XCellRange cellRange = getCellRange ( sheet , rangeName ); XCellRangeFormula crForm = Lo . qi ( XCellRangeFormula . class , cellRange ); return crForm . getDataArray (); Calc.getArray() returns a 2D array of Objects. Calc.getDoublesArray() can be employed to cast them to an array of doubles. 3. Getting Rows and Columns of Data \u00b6 Calc.getRow() extracts a row of data by utilizing Calc.getArray() since the array is in row-major order: // in the Calc class public static Object [] getRow ( XSpreadsheet sheet , String rangeName ) { Object [][] vals = getArray ( sheet , rangeName ); return extractRow ( vals , 0 ); // assumes user wants 1st row } // end of getRow() public static Object [] extractRow ( Object [][] vals , int rowIdx ) // get specified row index from vals { int rowSize = vals . length ; if (( rowIdx < 0 ) || ( rowIdx > rowSize - 1 )) { System . out . println ( \"Row index out of range\" ); return null ; } else return vals [ rowIdx ] ; } // end of extractRow() Calc.getRow() defaults to extracting the first row in the 2D array returned by Calc.getArray(), but it's possible to obtain other rows by directly calling Calc.extractRow(). Extracting a column from a sheet is more tricky since Calc.extractCol() must navigate the row-ordered array returned by Calc.getArray(). The retrieved column is returned as a 1D array: // in the Calc class public static Object [] getCol ( XSpreadsheet sheet , String rangeName ) { Object [][] vals = getArray ( sheet , rangeName ); return extractCol ( vals , 0 ); // assumes user wants 1st column } // end of getCol() public static Object [] extractCol ( Object [][] vals , int colIdx ) // extract the specified column index from vals { int rowSize = vals . length ; int colSize = vals [ 0 ] . length ; // assumes all columns are this length if (( colIdx < 0 ) || ( colIdx > colSize - 1 )) { System . out . println ( \"Column index out of range\" ); return null ; } else { Object [] colVals = new Object [ rowSize ] ; for ( int row = 0 ; row < rowSize ; row ++ ) colVals [ row ] = vals [ row ][ colIdx ] ; return colVals ; } } // end of extractCol() 4. Obtaining Cell Ranges by Using Queries \u00b6 A drawback of extracting data from a spreadsheet with getVal(), getArray(), getRow(), and getCol() is that they require the programmer to supply cell names or ranges. In other words, the location of the data must be known beforehand. For example, the call: double [][] ids = Calc . getDoublesArray ( sheet , \"A2:A7\" ); assumes that the data is located in the \"A2:A7\" range. A more flexible approach is offered by the SheetRangesQuery service, which can search for a cell range (or ranges) satisfying a content query. For example, it can return a sequence of cell ranges that cover all the numerical data in the sheet, or cell ranges for all the formulae. The search area for these queries is usually the entire used part of a sheet, which are all the cells containing numbers, text, or formulae. Obtaining this area involves sheet cursors, but the details are hidden inside Calc.findUsedRange(). The following code fragment illustrates how Calc.findUsedRange() and the SheetRangesQuery service can be used together : // the second half of ExtractNums.java : // get the cell range which spans the used area of the sheet XCellRange usedCellRange = Calc . findUsedRange ( sheet ); // find cell ranges that cover all the numerical cells XCellRangesQuery crQuery = Lo . qi ( XCellRangesQuery . class , usedCellRange ); XSheetCellRanges cellRanges = crQuery . queryContentCells (( short ) CellFlags . VALUE ); The cell range returned by Calc.findUsedRange() is converted to XCellRangesQuery, which contains the SheetRangesQuery methods. XCellRangesQuery.queryContentCells() is passed the CellFlags.VALUE constant so that the search will returns ranges that cover all the numerical data. The SheetRangesQuery service is inherited by SheetCell, SheetCellRange, and SheetCellRanges, as summarized in Figure 2. Figure 2. The SheetRangesQuery Services and Interfaces. The XFormulaQuery interface is used to find cells that are used by a formula, or cells that utilize a formula's result. The CellFlags constants used in XCellRangesQuery.queryContentCells() are documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1sheet_1_1CellFlags.html#a0f9444c5a241b2cd5f34553b05a18ca8 , or use lodoc cellflags . The constants can be combined with bit operations, such as \"|\". For instance, the query: XSheetCellRanges cellRanges = crQuery . queryContentCells ( ( short ) ( CellFlags . VALUE | CellFlags . FORMULA )); finds all the cell ranges that contain numbers or formulae. The XSheetCellRanges object is most easily processed as an array of cell range addresses: CellRangeAddress [] addrs = cellRanges . getRangeAddresses (); The following code prints out each range address and the numerical data in the range: // part of ExtractNums.java : if ( cellRanges == null ) System . out . println ( \"No cell ranges found\" ); else { System . out . println ( \"Found cell ranges: \" + cellRanges . getRangeAddressesAsString () + \"\\n\" ); CellRangeAddress [] addrs = cellRanges . getRangeAddresses (); System . out . println ( \"Cell ranges (\" + addrs . length + \"):\" ); for ( CellRangeAddress addr : addrs ) { Calc . printAddress ( addr ); double [][] vals = Calc . getDoublesArray ( sheet , Calc . getRangeStr ( addr )); Calc . printArray ( vals ); } } For the \"small totals.ods\" spreadsheet shown in Figure 1, the output is: Found cell ranges: Marks.A2:D7 Cell ranges (1): Range: Sheet1.A2:D7 Row x Column size: 6 x 4 22001.0 16.4583333333333 30.9166666666667 37.0125 22028.0 11.875 23.0416666666667 25.4625 22048.0 13.9583333333333 19.25 25.9875 23715.0 12.0833333333333 18.6666666666667 20.475 23723.0 17.2916666666667 27.7083333333333 36.225 24277.0 0.0 16.0416666666667 19.6875 The query found the range A2:D7, which excludes the labels on the first row, and the formula down the \"E column and along rows \"8\" and \"9\" (see Figure 1). These formulae could be included by modifying the query: XSheetCellRanges cellRanges = crQuery . queryContentCells ( ( short ) ( CellFlags . VALUE | CellFlags . FORMULA )); The output changes to: Found cell ranges: Marks.A2:A7,Marks.B2:D9,Marks.E2:E8 Cell ranges (3): Range: Sheet1.A2:A7 Row x Column size: 6 x 1 22001.0 22028.0 22048.0 23715.0 23723.0 24277.0 Range: Sheet1.B2:D9 Row x Column size: 8 x 3 16.4583333333333 30.9166666666667 37.0125 11.875 23.0416666666667 25.4625 13.9583333333333 19.25 25.9875 12.0833333333333 18.6666666666667 20.475 17.2916666666667 27.7083333333333 36.225 0.0 16.0416666666667 19.6875 11.9444444444444 22.6041666666667 27.475 0.5972222222222221 0.645833333333334 0.6105555555555561 Range: Sheet1.E2:E8 Row x Column size: 7 x 1 0.8438749999999999 0.6037916666666671 0.591958333333333 0.5122500000000001 0.81225 0.357291666666667 0.6202361111111111 The query returned three cell ranges. I thought they would be the numerical region (as before) and two ranges covering the formulae down the \"E\" column and along rows \"8\" and \"9\". Instead, the regions are those highlighted in Figure 3. Figure 3. The Cell Ranges Returned by the Value+Formula Query. The shape of these ranges suggests that they're chosen to maximize column length. Also searching for two content types (e.g. numbers and formulae) means that a single cell range may contain both types of data. 5. Finding the Used Area with Sheet Cursors \u00b6 The previous section relied on Calc.findUsedRange() to retrieve the sheet's used area; this section explains how that method is implemented using sheet cursors. A sheet cursor is analogous to a text cursor but moves across cells in a spreadsheet. As the cursor is moved, its cell range can be expanded or collapsed in a variety of ways, which parallels the selection of text by a text cursor. Calc.findUsedRange() creates a cursor and then calls findUsedCursor() to expand its cell range over the used area: // in the Calc class public static XCellRange findUsedRange ( XSpreadsheet sheet ) { XSheetCellCursor cursor = sheet . createCursor (); return findUsedCursor ( cursor ); } public static XCellRange findUsedCursor ( XSheetCellCursor cursor ) { // use the cursor to select the used area XUsedAreaCursor uaCursor = Lo . qi ( XUsedAreaCursor . class , cursor ); uaCursor . gotoStartOfUsedArea ( false ); // find start of area uaCursor . gotoEndOfUsedArea ( true ); // select to end XCellRange usedRange = Lo . qi ( XCellRange . class , uaCursor ); return usedRange ; } // end of findUsedCursor() Figure 4 shows the services and interfaces related to sheet cursors. Calc.findUsedRange() employs the XSheetCellCursor interface. Figure 4. The SheetCellCursor Services and Interfaces. An XSheetCellCursor cursor is assigned to a sheet by calling XSpreadsheet.createCursor() or XSpreadsheet.createCursorByRange(). Calc.findUsedRange() needs the ability to find the sheet's used area, which is obtained by converting XSheetCellCursor into XUsedAreaCursor (see Figure 4): // in Calc.findUsedCursor() XUsedAreaCursor uaCursor = Lo . qi ( XUsedAreaCursor . class , cursor ); uaCursor . gotoStartOfUsedArea ( false ); uaCursor . gotoEndOfUsedArea ( true ); The goto methods move the cursor to the start and end of the used area, and by calling gotoEndOfUsedArea() with a true flag, the cursor's cell range is extended from the start of the used area to its end. The cell range is retrieved by converting the cursor into a XCellRange: java XCellRange usedRange = Lo.qi(XCellRange.class, uaCursor);","title":"Chapter 21. Extracting Data"},{"location":"21-Extracting_Data.html#chapter-21-extracting-data","text":"Topics Getting a Cell Value; Getting the Data from a Cell Range; Getting Rows and Columns of Data; Obtaining Cell Ranges by Using Queries; Finding the Used Area with Sheet Cursors Example folders: \"Calc Tests\" and \"Utils\" This chapter is about extracting data from a spreadsheet. Two types of extraction are described: methods which are supplied with a predetermined cell range in order to obtain data from cells, rows, columns, and 2D regions. The other type of extraction uses cell ranges generated at run time based on content queries applied to the entire used area of the sheet. This approach requires the use of sheet cursors. All the example code comes from ExtractNums.java, which examines the \"small totals.ods\" spreadsheet shown in Figure 1. Figure 1. The \"small totals.ods\" Spreadsheet. Numerical data is stored in the cell range A2:D7 and the rest of the values are calculated using formulae. ExtracNums.java starts by accessing cells and cell ranges by name: // in ExtractNums.java public static void main ( String args [] ) { String outFnm = null ; if ( args . length != 1 ) { System . out . println ( \"Usage: run ExtractNums fnm\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); System . out . println ( \"\\nA1 string: \" + Calc . getVal ( sheet , \"A1\" )); XCell cell = Calc . getCell ( sheet , \"A2\" ); System . out . println ( \"A2 type: \" + Calc . getTypeString ( cell )); System . out . println ( \"A2 value: \" + Calc . getNum ( sheet , \"A2\" )); cell = Calc . getCell ( sheet , \"E2\" ); System . out . println ( \"E2 type: \" + Calc . getTypeString ( cell )); System . out . println ( \"E2 formula: \" + Calc . getVal ( sheet , \"E2\" )); System . out . println (); Object [][] data = Calc . getArray ( sheet , \"A1:E10\" ); Calc . printArray ( data ); double [][] ids = Calc . getDoublesArray ( sheet , \"A2:A7\" ); Calc . printArray ( ids ); double [] projs = Calc . convertToDoubles ( Calc . getCol ( sheet , \"B2:B7\" )); System . out . println ( \"Project scores\" ); for ( double proj : projs ) System . out . println ( \" \" + proj ); double [] stud = Calc . convertToDoubles ( Calc . getRow ( sheet , \"A4:E4\" )); System . out . println ( \"\\nStudent scores\" ); for ( double v : stud ) System . out . println ( \" \" + v ); : // more complex extraction code, explained later Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The output is: A1 string: Stud. No. A2 type: VALUE A2 value: 22001.0 E2 type: FORMULA E2 formula: =SUM(B2:D2)/100 Row x Column size: 10 x 5 Stud. No. Proj/20 Mid/35 Fin/45 Total% 22001.0 16.4583333333333 30.9166666666667 37.0125 0.843875 22028.0 11.875 23.0416666666667 25.4625 0.6037916666666671 22048.0 13.9583333333333 19.25 25.9875 0.591958333333333 23715.0 12.0833333333333 18.6666666666667 20.475 0.51225 23723.0 17.2916666666667 27.7083333333333 36.225 0.81225 24277.0 0.0 16.0416666666667 19.6875 0.357291666666667 11.9444444444444 22.6041666666667 27.475 0.6202361111111111 0.5972222222222221 0.645833333333334 0.6105555555555561 Proj/20 Mid/35 Fin/45 Total% Row x Column size: 6 x 1 22001.0 22028.0 22048.0 23715.0 23723.0 24277.0 Project scores 16.4583333333333 11.875 13.9583333333333 12.0833333333333 17.2916666666667 0.0 Student scores 22048.0 13.9583333333333 19.25 25.9875 0.591958333333333 I'll explain the highlighted get methods in the following sections.","title":"Chapter 21. Extracting Data"},{"location":"21-Extracting_Data.html#1-getting-a-cell-value","text":"There are three versions of Calc.getVal() which access a value by cell name or position: // in the Calc class public static Object getVal ( XSpreadsheet sheet , String cellName ) // get value by cell name { Point pos = getCellPosition ( cellName ); return getVal ( sheet , pos . x , pos . y ); // column, row } // end of getVal() public static Object getVal ( XSpreadsheet sheet , int column , int row ) // get value by cell position { XCell xCell = getCell ( sheet , column , row ); return getVal ( xCell , column , row ); } // end of getVal() public static Object getVal ( XCell cell , int column , int row ) // get value based on the type of the data in the cell { CellContentType type = cell . getType (); if ( type == CellContentType . EMPTY ) return null ; else if ( type == CellContentType . VALUE ) return new Double ( cell . getValue ()); else if (( type == CellContentType . TEXT ) || ( type == CellContentType . FORMULA )) return cell . getFormula (); else { System . out . println ( \"Unknown cell type; returning null\" ); return null ; } } // end of getVal() The third getVal() utilizes XCell.getType() to decide how to extract the value. A cell may contain four different data types: a number, text, a formula, or be empty. When the data is numerical, the double value is accessed by calling XCell.getValue(), while for text or a formula XCell.getFormula() is employed. getVal() returns these different types of data cast to Object. This return type may be inconvenient for a user, who might have to cast the result to something more specific, such as a double. The support functions include Calc.getNum() which does this task. There's also Calc.getTypeString() which returns cell type information as a string: // in the Calc class public static String getTypeString ( XCell cell ) { CellContentType type = cell . getType (); if ( type == CellContentType . EMPTY ) return \"EMPTY\" ; else if ( type == CellContentType . VALUE ) return \"VALUE\" ; else if ( type == CellContentType . TEXT ) return \"TEXT\" ; else if ( type == CellContentType . FORMULA ) return \"FORMULA\" ; else { System . out . println ( \"Unknown cell type\" ); return \"??\" ; } } // end of getTypeString()","title":"1.  Getting a Cell Value"},{"location":"21-Extracting_Data.html#2-getting-the-data-from-a-cell-range","text":"Calc.getArray() extracts the data from a cell range as a 2D array of Objects. It utilizes XCellRangeData.getDataArray(): // in the Calc class public static Object [][] getArray ( XSpreadsheet sheet , String rangeName ) { XCellRange cellRange = getCellRange ( sheet , rangeName ); XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); return crData . getDataArray (); } // end of getArray() XCellRangeData.getDataArray() evaluates any formulae it encounters. This can be seen in the output from: // part of ExtractNum.java Object [][] data = Calc . getArray ( sheet , \"A1:E10\" ); The cell range includes several formulae (e.g. in \"E8\" and \"E9\"), but the data array contains their numerical values. If you don't want formulae to be evaluated then you'll need to implement your own version of getArray() which uses XCellRangeFormula. Its getDataArray() method doesn't process formulae. The code would look something like: XCellRange cellRange = getCellRange ( sheet , rangeName ); XCellRangeFormula crForm = Lo . qi ( XCellRangeFormula . class , cellRange ); return crForm . getDataArray (); Calc.getArray() returns a 2D array of Objects. Calc.getDoublesArray() can be employed to cast them to an array of doubles.","title":"2.  Getting the Data from a Cell Range"},{"location":"21-Extracting_Data.html#3-getting-rows-and-columns-of-data","text":"Calc.getRow() extracts a row of data by utilizing Calc.getArray() since the array is in row-major order: // in the Calc class public static Object [] getRow ( XSpreadsheet sheet , String rangeName ) { Object [][] vals = getArray ( sheet , rangeName ); return extractRow ( vals , 0 ); // assumes user wants 1st row } // end of getRow() public static Object [] extractRow ( Object [][] vals , int rowIdx ) // get specified row index from vals { int rowSize = vals . length ; if (( rowIdx < 0 ) || ( rowIdx > rowSize - 1 )) { System . out . println ( \"Row index out of range\" ); return null ; } else return vals [ rowIdx ] ; } // end of extractRow() Calc.getRow() defaults to extracting the first row in the 2D array returned by Calc.getArray(), but it's possible to obtain other rows by directly calling Calc.extractRow(). Extracting a column from a sheet is more tricky since Calc.extractCol() must navigate the row-ordered array returned by Calc.getArray(). The retrieved column is returned as a 1D array: // in the Calc class public static Object [] getCol ( XSpreadsheet sheet , String rangeName ) { Object [][] vals = getArray ( sheet , rangeName ); return extractCol ( vals , 0 ); // assumes user wants 1st column } // end of getCol() public static Object [] extractCol ( Object [][] vals , int colIdx ) // extract the specified column index from vals { int rowSize = vals . length ; int colSize = vals [ 0 ] . length ; // assumes all columns are this length if (( colIdx < 0 ) || ( colIdx > colSize - 1 )) { System . out . println ( \"Column index out of range\" ); return null ; } else { Object [] colVals = new Object [ rowSize ] ; for ( int row = 0 ; row < rowSize ; row ++ ) colVals [ row ] = vals [ row ][ colIdx ] ; return colVals ; } } // end of extractCol()","title":"3.  Getting Rows and Columns of Data"},{"location":"21-Extracting_Data.html#4-obtaining-cell-ranges-by-using-queries","text":"A drawback of extracting data from a spreadsheet with getVal(), getArray(), getRow(), and getCol() is that they require the programmer to supply cell names or ranges. In other words, the location of the data must be known beforehand. For example, the call: double [][] ids = Calc . getDoublesArray ( sheet , \"A2:A7\" ); assumes that the data is located in the \"A2:A7\" range. A more flexible approach is offered by the SheetRangesQuery service, which can search for a cell range (or ranges) satisfying a content query. For example, it can return a sequence of cell ranges that cover all the numerical data in the sheet, or cell ranges for all the formulae. The search area for these queries is usually the entire used part of a sheet, which are all the cells containing numbers, text, or formulae. Obtaining this area involves sheet cursors, but the details are hidden inside Calc.findUsedRange(). The following code fragment illustrates how Calc.findUsedRange() and the SheetRangesQuery service can be used together : // the second half of ExtractNums.java : // get the cell range which spans the used area of the sheet XCellRange usedCellRange = Calc . findUsedRange ( sheet ); // find cell ranges that cover all the numerical cells XCellRangesQuery crQuery = Lo . qi ( XCellRangesQuery . class , usedCellRange ); XSheetCellRanges cellRanges = crQuery . queryContentCells (( short ) CellFlags . VALUE ); The cell range returned by Calc.findUsedRange() is converted to XCellRangesQuery, which contains the SheetRangesQuery methods. XCellRangesQuery.queryContentCells() is passed the CellFlags.VALUE constant so that the search will returns ranges that cover all the numerical data. The SheetRangesQuery service is inherited by SheetCell, SheetCellRange, and SheetCellRanges, as summarized in Figure 2. Figure 2. The SheetRangesQuery Services and Interfaces. The XFormulaQuery interface is used to find cells that are used by a formula, or cells that utilize a formula's result. The CellFlags constants used in XCellRangesQuery.queryContentCells() are documented at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1sheet_1_1CellFlags.html#a0f9444c5a241b2cd5f34553b05a18ca8 , or use lodoc cellflags . The constants can be combined with bit operations, such as \"|\". For instance, the query: XSheetCellRanges cellRanges = crQuery . queryContentCells ( ( short ) ( CellFlags . VALUE | CellFlags . FORMULA )); finds all the cell ranges that contain numbers or formulae. The XSheetCellRanges object is most easily processed as an array of cell range addresses: CellRangeAddress [] addrs = cellRanges . getRangeAddresses (); The following code prints out each range address and the numerical data in the range: // part of ExtractNums.java : if ( cellRanges == null ) System . out . println ( \"No cell ranges found\" ); else { System . out . println ( \"Found cell ranges: \" + cellRanges . getRangeAddressesAsString () + \"\\n\" ); CellRangeAddress [] addrs = cellRanges . getRangeAddresses (); System . out . println ( \"Cell ranges (\" + addrs . length + \"):\" ); for ( CellRangeAddress addr : addrs ) { Calc . printAddress ( addr ); double [][] vals = Calc . getDoublesArray ( sheet , Calc . getRangeStr ( addr )); Calc . printArray ( vals ); } } For the \"small totals.ods\" spreadsheet shown in Figure 1, the output is: Found cell ranges: Marks.A2:D7 Cell ranges (1): Range: Sheet1.A2:D7 Row x Column size: 6 x 4 22001.0 16.4583333333333 30.9166666666667 37.0125 22028.0 11.875 23.0416666666667 25.4625 22048.0 13.9583333333333 19.25 25.9875 23715.0 12.0833333333333 18.6666666666667 20.475 23723.0 17.2916666666667 27.7083333333333 36.225 24277.0 0.0 16.0416666666667 19.6875 The query found the range A2:D7, which excludes the labels on the first row, and the formula down the \"E column and along rows \"8\" and \"9\" (see Figure 1). These formulae could be included by modifying the query: XSheetCellRanges cellRanges = crQuery . queryContentCells ( ( short ) ( CellFlags . VALUE | CellFlags . FORMULA )); The output changes to: Found cell ranges: Marks.A2:A7,Marks.B2:D9,Marks.E2:E8 Cell ranges (3): Range: Sheet1.A2:A7 Row x Column size: 6 x 1 22001.0 22028.0 22048.0 23715.0 23723.0 24277.0 Range: Sheet1.B2:D9 Row x Column size: 8 x 3 16.4583333333333 30.9166666666667 37.0125 11.875 23.0416666666667 25.4625 13.9583333333333 19.25 25.9875 12.0833333333333 18.6666666666667 20.475 17.2916666666667 27.7083333333333 36.225 0.0 16.0416666666667 19.6875 11.9444444444444 22.6041666666667 27.475 0.5972222222222221 0.645833333333334 0.6105555555555561 Range: Sheet1.E2:E8 Row x Column size: 7 x 1 0.8438749999999999 0.6037916666666671 0.591958333333333 0.5122500000000001 0.81225 0.357291666666667 0.6202361111111111 The query returned three cell ranges. I thought they would be the numerical region (as before) and two ranges covering the formulae down the \"E\" column and along rows \"8\" and \"9\". Instead, the regions are those highlighted in Figure 3. Figure 3. The Cell Ranges Returned by the Value+Formula Query. The shape of these ranges suggests that they're chosen to maximize column length. Also searching for two content types (e.g. numbers and formulae) means that a single cell range may contain both types of data.","title":"4.  Obtaining Cell Ranges by Using Queries"},{"location":"21-Extracting_Data.html#5-finding-the-used-area-with-sheet-cursors","text":"The previous section relied on Calc.findUsedRange() to retrieve the sheet's used area; this section explains how that method is implemented using sheet cursors. A sheet cursor is analogous to a text cursor but moves across cells in a spreadsheet. As the cursor is moved, its cell range can be expanded or collapsed in a variety of ways, which parallels the selection of text by a text cursor. Calc.findUsedRange() creates a cursor and then calls findUsedCursor() to expand its cell range over the used area: // in the Calc class public static XCellRange findUsedRange ( XSpreadsheet sheet ) { XSheetCellCursor cursor = sheet . createCursor (); return findUsedCursor ( cursor ); } public static XCellRange findUsedCursor ( XSheetCellCursor cursor ) { // use the cursor to select the used area XUsedAreaCursor uaCursor = Lo . qi ( XUsedAreaCursor . class , cursor ); uaCursor . gotoStartOfUsedArea ( false ); // find start of area uaCursor . gotoEndOfUsedArea ( true ); // select to end XCellRange usedRange = Lo . qi ( XCellRange . class , uaCursor ); return usedRange ; } // end of findUsedCursor() Figure 4 shows the services and interfaces related to sheet cursors. Calc.findUsedRange() employs the XSheetCellCursor interface. Figure 4. The SheetCellCursor Services and Interfaces. An XSheetCellCursor cursor is assigned to a sheet by calling XSpreadsheet.createCursor() or XSpreadsheet.createCursorByRange(). Calc.findUsedRange() needs the ability to find the sheet's used area, which is obtained by converting XSheetCellCursor into XUsedAreaCursor (see Figure 4): // in Calc.findUsedCursor() XUsedAreaCursor uaCursor = Lo . qi ( XUsedAreaCursor . class , cursor ); uaCursor . gotoStartOfUsedArea ( false ); uaCursor . gotoEndOfUsedArea ( true ); The goto methods move the cursor to the start and end of the used area, and by calling gotoEndOfUsedArea() with a true flag, the cursor's cell range is extended from the start of the used area to its end. The cell range is retrieved by converting the cursor into a XCellRange: java XCellRange usedRange = Lo.qi(XCellRange.class, uaCursor);","title":"5.  Finding the Used Area with Sheet Cursors"},{"location":"22-Styles.html","text":"Chapter 22. Styles \u00b6 Topics Obtaining Style Information: the TableCellStyle and TablePageStyle Services; Creating and Using a New Style; Adding Borders Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at how spreadsheet styles are stored, how they can be examined, and how new styles can be instantiated and used. 1. Obtaining Style Information \u00b6 Calc uses the same style API as Writer, Draw, and Impress documents. Figure 1 shows its structure. Figure 1. Calc Style Families and their Property Sets. The Calc API only has two style families, CellStyles and PageStyles. A cell style can be applied to a cell, a cell range, or a spreadsheet (which is a very big cell range). A page style can be applied only to a spreadsheet. Each style family consists of styles, which are collection of property sets. The default cell style is called \"Default\", as is the default page style. The StylesAllInfo.java example prints out the style family names and the style names associated with the input document: // in StylesAllInfo.java public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run StylesAllInfo <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // get all the style families for this document String [] styleFamilies = Info . getStyleFamilyNames ( doc ); System . out . println ( \"Style Family Names (\" + styleFamilies . length + \"): \" ); for ( String styleFamily : styleFamilies ) System . out . println ( \" \" + styleFamily ); System . out . println (); // list all the style names for each style family for ( int i = 0 ; i < styleFamilies . length ; i ++ ) { String styleFamily = styleFamilies [ i ] ; System . out . println (( i + 1 ) + \". \\\"\" + styleFamily + \"\\\" Family styles:\" ); String [] styleNames = Info . getStyleNames ( doc , styleFamily ); Lo . printNames ( styleNames ); } Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() This code uses the Info.getStyleFamilyNames() and Info.getStyleNames() functions which I utilized in earlier chapters, so I won't explain their implementation again. The output for a simple spreadsheet is: Style Family Names (2): CellStyles PageStyles 1. \"CellStyles\" Family styles: No. of names: 5 \"Default\" \"Heading\" \"Heading1\" \"Result\" \"Result2\" 2. \"PageStyles\" Family styles: No. of names: 2 \"Default\" \"Report\" Finding Style Information \u00b6 From a programming point of view, the main difficult with styles is finding documentation about their properties, so that a value can be correctly read or changed. One approach is to use my Info.getStyleProps() method to list the properties for a given style family and style name. For example, the following displays all the properties for the default cell and page styles: // commented out code in StylesAllInfo.java Props . showProps ( \"CellStyles Default\" , Info . getStyleProps ( doc , \"CellStyles\" , \"Default\" ) ); Props . showProps ( \"PageStyles Default\" , Info . getStyleProps ( doc , \"PageStyles\" , \"Default\" ) ); The problem is that the output is extremely long, and some property names are less descriptive/understandable than others. It's probably better to search the online documentation for properties. Cell styles are managed by the TableCellStyle service (see Figure 22) and page styles by the TablePageStyle service (Figure 23). Use lodoc TableCellStyle and lodoc TablePageStyle to access the online information. The properties managed by TableCellStyle are inherited from a number of places, as summarized by Figure 2. Figure 2. The TableCellStyle Service. By far the most important source of cell style properties is the CellProperties class in the table module (use lodoc cellproperties service ). However, if a property relates to the text in a cell then it's more likely to originate from the CharacterProperties or ParagraphProperties classes in the style module (e.g. use lodoc characterproperties service ). The properties managed by TablePageStyle are also inherited from a few places, as summarized by Figure 3. Figure 3. The TablePageStyle Service. The main place to look for page properties is the PageProperties class in the style module (e.g. use lodoc pageproperties service ). The properties relate to things such as page margins, headers, and footers, which become important when printing a sheet. 2. Creating and Using New Styles \u00b6 The steps required in creating and using a new style are illustrated by BuildTables.java, in createStyles() and applyStyles(): // in BuildTables.java // globals private static String HEADER_STYLE_NAME = \"My HeaderStyle\" ; private static String DATA_STYLE_NAME = \"My DataStyle\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); buildArray ( sheet ); createStyles ( doc ); applyStyles ( sheet ); Lo . saveDoc ( doc , \"buildTable.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() createStyles() creates two cell styles called \"My HeaderStyle\" and \"My DataStyle\", which are applied to the spreadsheet by applyStyles(). The result is shown in Figure 4. Figure 4. Styled Spreadsheet Cells. The \"My HeaderStyle\" style is applied to the top row and the first column: the cells are colored blue, and the text made white and centered. The \"My DataStyle\" is used for the numerical data and formulae cells: the background color is made a light blue, and the text is right-justified. applyStyles() also changes the border properties of the bottom edges of the cells in the last row to be thick and blue. The resulting spreadsheet is saved in \"buildTable.ods\". If this document is examined by the StylesAllInfo.java program, it lists the new styles in the \"CellStyles\" family: > run StylesAllInfo buildTable.ods Loading Office... Opening buildTable.ods Style Family Names (2): CellStyles PageStyles 1. \"CellStyles\" Family styles: No. of names: 7 \"Default\" \"Heading\" \"Heading1\" \"My DataStyle\" \"My HeaderStyle\" \"Result\" \"Result2\" 2. \"PageStyles\" Family styles: No. of names: 2 \"Default\" \"Report\" Closing the document Closing Office Office terminated 2.1. Creating a New Style \u00b6 BuildTables.java calls createStyles() to create two styles: // in BuildTables.java public static void createStyles ( XSpreadsheetDocument doc ) // create HEADER_STYLE_NAME and // DATA_STYLE_NAME cell styles { try { XStyle style1 = Calc . createCellStyle ( doc , HEADER_STYLE_NAME ); XPropertySet props1 = Lo . qi ( XPropertySet . class , style1 ); props1 . setPropertyValue ( \"IsCellBackgroundTransparent\" , false ); props1 . setPropertyValue ( \"CellBackColor\" , 0x6699FF ); //dark blue props1 . setPropertyValue ( \"CharColor\" , 0xFFFFFF ); // white // Center cell content horizontally and vertically in the cell props1 . setPropertyValue ( \"HoriJustify\" , CellHoriJustify . CENTER ); props1 . setPropertyValue ( \"VertJustify\" , CellVertJustify . CENTER ); XStyle style2 = Calc . createCellStyle ( doc , DATA_STYLE_NAME ); XPropertySet props2 = Lo . qi ( XPropertySet . class , style2 ); props2 . setPropertyValue ( \"IsCellBackgroundTransparent\" , false ); props2 . setPropertyValue ( \"CellBackColor\" , 0xC2EBFF ); //light blue props2 . setPropertyValue ( \"ParaRightMargin\" , 500 ); // move away from right edge } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of createStyles() The styles are created by two calls to Calc.createCellStyle(), which stores them in the \"CellStyles\" family: // in the Calc class public static XStyle createCellStyle ( XSpreadsheetDocument doc , String styleName ) { // access the \"CellStyles\" family XComponent compDoc = Lo . qi ( XComponent . class , doc ); XNameContainer styleFamilies = Info . getStyleContainer ( compDoc , \"CellStyles\" ); // create a new style XStyle style = Lo . createInstanceMSF ( XStyle . class , \"com.sun.star.style.CellStyle\" ); try { styleFamilies . insertByName ( styleName , style ); // add to family return style ; } catch ( Exception e ) { System . out . println ( \"Unable to create style: \" + styleName ); return null ; } } // end of createCellStyle() Calc.createCellStyle() calls Info.getStyleContainer() to return a reference to the \"CellStyles\" family as an XNameContainer. A new cell style is created by calling Lo.createInstanceMSF(), and referred to using the XStyle interface. This style is added to the family by calling XNameContainer.insertByName() with the name passed to the function. A new style is automatically derived from the \"Default\" style, so the rest of the createStyles() method involves the changing of properties. Five are adjusted in the \"My HeaderStyle\" style, and three in \"My DataStyle\". The header properties are \"IsCellBackgroundTransparent\", \"CellBackColor\", \"CharColor\", \"HoriJustify\", and \"VertJustify\", which are all defined in the CellProperties class (see Figure 2). The data properties are \"IsCellBackgroundTransparent\", \"CellBackColor\", and \"ParaRightMargin\". Although \"IsCellBackgroundTransparent\" and \"CellBackColor\" are from the CellProperties class, \"ParaRightMargin\" is inherited from the ParagraphProperties class in the style module (also in Figure 2). 2.2. Applying a New Style \u00b6 The new styles, \"My HeaderStyle\" and \"My DataStyle\", are applied to the spreadsheet by the BuildTable.java method applyStyles(): // in BuildTable.java private static void applyStyles ( XSpreadsheet sheet ) { // apply cell styles Calc . changeStyle ( sheet , \"B1:N1\" , HEADER_STYLE_NAME ); Calc . changeStyle ( sheet , \"A2:A4\" , HEADER_STYLE_NAME ); Calc . changeStyle ( sheet , \"B2:N4\" , DATA_STYLE_NAME ); // change borders for the cell ranges Calc . addBorder ( sheet , \"A4:N4\" , Calc . BOTTOM_BORDER , 0x6699FF ); //dark blue bottom edge Calc . addBorder ( sheet , \"N1:N4\" , Calc . LEFT_BORDER | Calc . RIGHT_BORDER , 0x6699FF ); // dark blue left and right edges } // end of applyStyles() The header style is applied to two cell ranges: B1:N1 is the top row containing the months (see Figure 4), and A2:A4 is the first column. The data style is applied to B2:N4 which spans the numerical data and formulae. Calc.changeStyle() is defined as: // in the Calc class public static void changeStyle ( XSpreadsheet sheet , String rangeName , String styleName ) { XCellRange cellRange = Calc . getCellRange ( sheet , rangeName ); Props . setProperty ( cellRange , \"CellStyle\" , styleName ); } Calc.changeStyles() manipulates the styles via the cell range. The cellRange variable refers to a SheetCellRange service which inherits many properties, including those from CellProperties. Its \"CellStyle\" property holds the style name used by that cell range. 2.3. Adding Borders \u00b6 The Calc.addBorder() method highlights borders for a given range of cells. The two calls in applyStyles() draw a blue line along the bottom edge of the A4:N4 cell range, and two lines on either side of the \"SUM\" column (the N1:N4 range), as shown in Figure 5. Figure 5. Borders around the Data. Four border constants are defined in Calc.java: // in the Calc class // for border decoration (bitwise composition is possible) public static final int TOP_BORDER = 0x01 ; public static final int BOTTOM_BORDER = 0x02 ; public static final int LEFT_BORDER = 0x04 ; public static final int RIGHT_BORDER = 0x08 ; Calc.addBorder() highlights a border or borders for a cell range in three steps. First it creates a border line style, by instantiating a BorderLine2 object. That line style is used to create a border style represented by a TableBorder2 object. Finally, the border style is applied to the cell range by setting its \"TableBorder2\" property. // in the Calc class public static void addBorder ( XSpreadsheet sheet , String rangeName , int borderVals , int color ) { // create a border line style BorderLine2 line = new BorderLine2 (); line . Color = color ; line . InnerLineWidth = line . LineDistance = 0 ; line . OuterLineWidth = 100 ; // use the line style to set border styles TableBorder2 border = new TableBorder2 (); if (( borderVals & Calc . TOP_BORDER ) == Calc . TOP_BORDER ) { border . TopLine = line ; border . IsTopLineValid = true ; } if (( borderVals & Calc . BOTTOM_BORDER ) == Calc . BOTTOM_BORDER ) { border . BottomLine = line ; border . IsBottomLineValid = true ; } if (( borderVals & Calc . LEFT_BORDER ) == Calc . LEFT_BORDER ) { border . LeftLine = line ; border . IsLeftLineValid = true ; } if (( borderVals & Calc . RIGHT_BORDER ) == Calc . RIGHT_BORDER ) { border . RightLine = line ; border . IsRightLineValid = true ; } // store the border style in the cell range XCellRange cellRange = sheet . getCellRangeByName ( rangeName ); Props . setProperty ( cellRange , \"TableBorder2\" , border ); } // end of addBorder()","title":"Chapter 22. Styles"},{"location":"22-Styles.html#chapter-22-styles","text":"Topics Obtaining Style Information: the TableCellStyle and TablePageStyle Services; Creating and Using a New Style; Adding Borders Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at how spreadsheet styles are stored, how they can be examined, and how new styles can be instantiated and used.","title":"Chapter 22. Styles"},{"location":"22-Styles.html#1-obtaining-style-information","text":"Calc uses the same style API as Writer, Draw, and Impress documents. Figure 1 shows its structure. Figure 1. Calc Style Families and their Property Sets. The Calc API only has two style families, CellStyles and PageStyles. A cell style can be applied to a cell, a cell range, or a spreadsheet (which is a very big cell range). A page style can be applied only to a spreadsheet. Each style family consists of styles, which are collection of property sets. The default cell style is called \"Default\", as is the default page style. The StylesAllInfo.java example prints out the style family names and the style names associated with the input document: // in StylesAllInfo.java public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run StylesAllInfo <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } // get all the style families for this document String [] styleFamilies = Info . getStyleFamilyNames ( doc ); System . out . println ( \"Style Family Names (\" + styleFamilies . length + \"): \" ); for ( String styleFamily : styleFamilies ) System . out . println ( \" \" + styleFamily ); System . out . println (); // list all the style names for each style family for ( int i = 0 ; i < styleFamilies . length ; i ++ ) { String styleFamily = styleFamilies [ i ] ; System . out . println (( i + 1 ) + \". \\\"\" + styleFamily + \"\\\" Family styles:\" ); String [] styleNames = Info . getStyleNames ( doc , styleFamily ); Lo . printNames ( styleNames ); } Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() This code uses the Info.getStyleFamilyNames() and Info.getStyleNames() functions which I utilized in earlier chapters, so I won't explain their implementation again. The output for a simple spreadsheet is: Style Family Names (2): CellStyles PageStyles 1. \"CellStyles\" Family styles: No. of names: 5 \"Default\" \"Heading\" \"Heading1\" \"Result\" \"Result2\" 2. \"PageStyles\" Family styles: No. of names: 2 \"Default\" \"Report\"","title":"1.  Obtaining Style Information"},{"location":"22-Styles.html#finding-style-information","text":"From a programming point of view, the main difficult with styles is finding documentation about their properties, so that a value can be correctly read or changed. One approach is to use my Info.getStyleProps() method to list the properties for a given style family and style name. For example, the following displays all the properties for the default cell and page styles: // commented out code in StylesAllInfo.java Props . showProps ( \"CellStyles Default\" , Info . getStyleProps ( doc , \"CellStyles\" , \"Default\" ) ); Props . showProps ( \"PageStyles Default\" , Info . getStyleProps ( doc , \"PageStyles\" , \"Default\" ) ); The problem is that the output is extremely long, and some property names are less descriptive/understandable than others. It's probably better to search the online documentation for properties. Cell styles are managed by the TableCellStyle service (see Figure 22) and page styles by the TablePageStyle service (Figure 23). Use lodoc TableCellStyle and lodoc TablePageStyle to access the online information. The properties managed by TableCellStyle are inherited from a number of places, as summarized by Figure 2. Figure 2. The TableCellStyle Service. By far the most important source of cell style properties is the CellProperties class in the table module (use lodoc cellproperties service ). However, if a property relates to the text in a cell then it's more likely to originate from the CharacterProperties or ParagraphProperties classes in the style module (e.g. use lodoc characterproperties service ). The properties managed by TablePageStyle are also inherited from a few places, as summarized by Figure 3. Figure 3. The TablePageStyle Service. The main place to look for page properties is the PageProperties class in the style module (e.g. use lodoc pageproperties service ). The properties relate to things such as page margins, headers, and footers, which become important when printing a sheet.","title":"Finding Style Information"},{"location":"22-Styles.html#2-creating-and-using-new-styles","text":"The steps required in creating and using a new style are illustrated by BuildTables.java, in createStyles() and applyStyles(): // in BuildTables.java // globals private static String HEADER_STYLE_NAME = \"My HeaderStyle\" ; private static String DATA_STYLE_NAME = \"My DataStyle\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); buildArray ( sheet ); createStyles ( doc ); applyStyles ( sheet ); Lo . saveDoc ( doc , \"buildTable.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() createStyles() creates two cell styles called \"My HeaderStyle\" and \"My DataStyle\", which are applied to the spreadsheet by applyStyles(). The result is shown in Figure 4. Figure 4. Styled Spreadsheet Cells. The \"My HeaderStyle\" style is applied to the top row and the first column: the cells are colored blue, and the text made white and centered. The \"My DataStyle\" is used for the numerical data and formulae cells: the background color is made a light blue, and the text is right-justified. applyStyles() also changes the border properties of the bottom edges of the cells in the last row to be thick and blue. The resulting spreadsheet is saved in \"buildTable.ods\". If this document is examined by the StylesAllInfo.java program, it lists the new styles in the \"CellStyles\" family: > run StylesAllInfo buildTable.ods Loading Office... Opening buildTable.ods Style Family Names (2): CellStyles PageStyles 1. \"CellStyles\" Family styles: No. of names: 7 \"Default\" \"Heading\" \"Heading1\" \"My DataStyle\" \"My HeaderStyle\" \"Result\" \"Result2\" 2. \"PageStyles\" Family styles: No. of names: 2 \"Default\" \"Report\" Closing the document Closing Office Office terminated","title":"2.  Creating and Using New Styles"},{"location":"22-Styles.html#21-creating-a-new-style","text":"BuildTables.java calls createStyles() to create two styles: // in BuildTables.java public static void createStyles ( XSpreadsheetDocument doc ) // create HEADER_STYLE_NAME and // DATA_STYLE_NAME cell styles { try { XStyle style1 = Calc . createCellStyle ( doc , HEADER_STYLE_NAME ); XPropertySet props1 = Lo . qi ( XPropertySet . class , style1 ); props1 . setPropertyValue ( \"IsCellBackgroundTransparent\" , false ); props1 . setPropertyValue ( \"CellBackColor\" , 0x6699FF ); //dark blue props1 . setPropertyValue ( \"CharColor\" , 0xFFFFFF ); // white // Center cell content horizontally and vertically in the cell props1 . setPropertyValue ( \"HoriJustify\" , CellHoriJustify . CENTER ); props1 . setPropertyValue ( \"VertJustify\" , CellVertJustify . CENTER ); XStyle style2 = Calc . createCellStyle ( doc , DATA_STYLE_NAME ); XPropertySet props2 = Lo . qi ( XPropertySet . class , style2 ); props2 . setPropertyValue ( \"IsCellBackgroundTransparent\" , false ); props2 . setPropertyValue ( \"CellBackColor\" , 0xC2EBFF ); //light blue props2 . setPropertyValue ( \"ParaRightMargin\" , 500 ); // move away from right edge } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of createStyles() The styles are created by two calls to Calc.createCellStyle(), which stores them in the \"CellStyles\" family: // in the Calc class public static XStyle createCellStyle ( XSpreadsheetDocument doc , String styleName ) { // access the \"CellStyles\" family XComponent compDoc = Lo . qi ( XComponent . class , doc ); XNameContainer styleFamilies = Info . getStyleContainer ( compDoc , \"CellStyles\" ); // create a new style XStyle style = Lo . createInstanceMSF ( XStyle . class , \"com.sun.star.style.CellStyle\" ); try { styleFamilies . insertByName ( styleName , style ); // add to family return style ; } catch ( Exception e ) { System . out . println ( \"Unable to create style: \" + styleName ); return null ; } } // end of createCellStyle() Calc.createCellStyle() calls Info.getStyleContainer() to return a reference to the \"CellStyles\" family as an XNameContainer. A new cell style is created by calling Lo.createInstanceMSF(), and referred to using the XStyle interface. This style is added to the family by calling XNameContainer.insertByName() with the name passed to the function. A new style is automatically derived from the \"Default\" style, so the rest of the createStyles() method involves the changing of properties. Five are adjusted in the \"My HeaderStyle\" style, and three in \"My DataStyle\". The header properties are \"IsCellBackgroundTransparent\", \"CellBackColor\", \"CharColor\", \"HoriJustify\", and \"VertJustify\", which are all defined in the CellProperties class (see Figure 2). The data properties are \"IsCellBackgroundTransparent\", \"CellBackColor\", and \"ParaRightMargin\". Although \"IsCellBackgroundTransparent\" and \"CellBackColor\" are from the CellProperties class, \"ParaRightMargin\" is inherited from the ParagraphProperties class in the style module (also in Figure 2).","title":"2.1.  Creating a New Style"},{"location":"22-Styles.html#22-applying-a-new-style","text":"The new styles, \"My HeaderStyle\" and \"My DataStyle\", are applied to the spreadsheet by the BuildTable.java method applyStyles(): // in BuildTable.java private static void applyStyles ( XSpreadsheet sheet ) { // apply cell styles Calc . changeStyle ( sheet , \"B1:N1\" , HEADER_STYLE_NAME ); Calc . changeStyle ( sheet , \"A2:A4\" , HEADER_STYLE_NAME ); Calc . changeStyle ( sheet , \"B2:N4\" , DATA_STYLE_NAME ); // change borders for the cell ranges Calc . addBorder ( sheet , \"A4:N4\" , Calc . BOTTOM_BORDER , 0x6699FF ); //dark blue bottom edge Calc . addBorder ( sheet , \"N1:N4\" , Calc . LEFT_BORDER | Calc . RIGHT_BORDER , 0x6699FF ); // dark blue left and right edges } // end of applyStyles() The header style is applied to two cell ranges: B1:N1 is the top row containing the months (see Figure 4), and A2:A4 is the first column. The data style is applied to B2:N4 which spans the numerical data and formulae. Calc.changeStyle() is defined as: // in the Calc class public static void changeStyle ( XSpreadsheet sheet , String rangeName , String styleName ) { XCellRange cellRange = Calc . getCellRange ( sheet , rangeName ); Props . setProperty ( cellRange , \"CellStyle\" , styleName ); } Calc.changeStyles() manipulates the styles via the cell range. The cellRange variable refers to a SheetCellRange service which inherits many properties, including those from CellProperties. Its \"CellStyle\" property holds the style name used by that cell range.","title":"2.2.  Applying a New Style"},{"location":"22-Styles.html#23-adding-borders","text":"The Calc.addBorder() method highlights borders for a given range of cells. The two calls in applyStyles() draw a blue line along the bottom edge of the A4:N4 cell range, and two lines on either side of the \"SUM\" column (the N1:N4 range), as shown in Figure 5. Figure 5. Borders around the Data. Four border constants are defined in Calc.java: // in the Calc class // for border decoration (bitwise composition is possible) public static final int TOP_BORDER = 0x01 ; public static final int BOTTOM_BORDER = 0x02 ; public static final int LEFT_BORDER = 0x04 ; public static final int RIGHT_BORDER = 0x08 ; Calc.addBorder() highlights a border or borders for a cell range in three steps. First it creates a border line style, by instantiating a BorderLine2 object. That line style is used to create a border style represented by a TableBorder2 object. Finally, the border style is applied to the cell range by setting its \"TableBorder2\" property. // in the Calc class public static void addBorder ( XSpreadsheet sheet , String rangeName , int borderVals , int color ) { // create a border line style BorderLine2 line = new BorderLine2 (); line . Color = color ; line . InnerLineWidth = line . LineDistance = 0 ; line . OuterLineWidth = 100 ; // use the line style to set border styles TableBorder2 border = new TableBorder2 (); if (( borderVals & Calc . TOP_BORDER ) == Calc . TOP_BORDER ) { border . TopLine = line ; border . IsTopLineValid = true ; } if (( borderVals & Calc . BOTTOM_BORDER ) == Calc . BOTTOM_BORDER ) { border . BottomLine = line ; border . IsBottomLineValid = true ; } if (( borderVals & Calc . LEFT_BORDER ) == Calc . LEFT_BORDER ) { border . LeftLine = line ; border . IsLeftLineValid = true ; } if (( borderVals & Calc . RIGHT_BORDER ) == Calc . RIGHT_BORDER ) { border . RightLine = line ; border . IsRightLineValid = true ; } // store the border style in the cell range XCellRange cellRange = sheet . getCellRangeByName ( rangeName ); Props . setProperty ( cellRange , \"TableBorder2\" , border ); } // end of addBorder()","title":"2.3.  Adding Borders"},{"location":"23-Garlic_Secrets.html","text":"Chapter 23. Garlic Secrets \u00b6 Topics Freezing Rows; GeneralFunctions; Sheet Searching; Sheet Range Queries; Hidden Cells; Cell Merging; Splitting Windows; View Panes; View State Data; Active Panes; Inserting Rows and Columns; Shifting Cells Example folders: \"Calc Tests\" and \"Utils\" This chapter's GarlicSecrets.java example illustrates how data can be extracted from an existing spreadsheet (\"produceSales.xlsx\") using 'general' functions, sheet searching, and sheet range queries. It also has more examples of cell styling, and demonstrates sheet freezing, view pane splitting, pane activation, and the insertion of new rows into a sheet. The idea for this chapter, and the data, comes from the Excel example in chapter 12 of \"Automate the Boring Stuff with Python\" by Al Sweigart. However, he utilized the Python library OpenPyXL to manipulate his file. The beginning of the spreadsheet is shown in Figure 1. Figure 1. Part of the \"produceSales.xlsx\" Spreadsheet. Each row holds information about the sale of fruit or vegetables. The columns are the type of produce sold (column A), the cost per pound of that produce (B), the number of pounds sold (C), and the total revenue from the sale (D). The TOTAL column is calculated using a formula which multiplies the cost per pound by the number of pounds sold, and rounds the result to the nearest cent. For example, cell \"D2\" contains \"=ROUND(B2*C2, 2)\". Most of the main() function for GarlicSecrets.java is shown below. I'll explain the commented out parts in later sections: // in GarlicSecrets.java private static final String FNM = \"produceSales.xlsx\" ; private static final String OUT_FNM = \"garlicSecrets.ods\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + FNM ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . gotoCell ( doc , \"A1\" ); // make sure top of sheet is visible // freeze first 3 rows of view // Calc.freezeRows(doc, 3); // report total for the \"Total\" column XCellRange totalRange = Calc . getColRange ( sheet , 3 ); double total = Calc . computeFunction ( GeneralFunction . SUM , totalRange ); System . out . printf ( \"Total before change: %.2f\\n\" , total ); increaseGarlicCost ( doc , sheet ); // recalculate total and print again total = Calc . computeFunction ( GeneralFunction . SUM , totalRange ); System . out . printf ( \"Total after change: %.2f\\n\" , total ); // add a label at the bottom of the data, and hide it... // split sheet into panes... // make top pane the active one in the first sheet... // add a new first row, and label that as at the bottom... Lo . saveDoc ( doc , OUT_FNM ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() 1. Freezing Rows \u00b6 Calc.freezeRows() specifies the number of rows that should be 'frozen' on-screen as Office's view of the spreadsheet changes (e.g. when the user scrolls downwards). The function's argument is the number of rows to freeze, not a row index, and the choice of which rows are frozen depends on which row is currently selected (active) in the application window when the function is called. The earlier call to Calc.gotoCell() in main() means that \"A1\" is the active cell in the spreadsheet, and so row \"1\" is the active row (and \"A\" the active column). For that reason, Calc.freezeRows(doc, 3) will freeze rows \"1\", \"2\", and \"3\" so they remain in view when the spreadsheet is scrolled up or down. Calc.freezeRows() and Calc.freezeCols() are implemented using Calc.freeze(): // in the Calc class public static void freezeRows ( XSpreadsheetDocument doc , int numRows ) { freeze ( doc , 0 , numRows ); } public static void freezeCols ( XSpreadsheetDocument doc , int numCols ) { freeze ( doc , numCols , 0 ); } public static void freeze ( XSpreadsheetDocument doc , int numCols , int numRows ) { XViewFreezable xFreeze = Lo . qi ( XViewFreezable . class , getController ( doc )); xFreeze . freezeAtPosition ( numCols , numRows ); } Calc.freeze() accesses the SpreadsheetView service (see Figure 2) via the document's controller, and utilizes its XViewFreezable interface to call freezeAtPosition(). Figure 2. The SpreadsheetView Services and Interfaces. 2. General Functions \u00b6 Office has a small set of functions (called GeneralFunctions) which can be applied to cell ranges without the need for formula strings (i.e. a string starting with \"=\"). They're listed in the enum section at the end of the sheet module at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1sheet.html , or use lodoc GeneralFunctions . The more important functions are shown in Table 1. GeneralFunction Name Calculation Applied to the Cell Values SUM Sum the numerical values. COUNT Count all the values, including the non-numerical ones. COUNTNUMS Count only the numerical values. AVERAGE Average all the numerical values. MAX Find the maximum of all the numerical values. MIN Find the minimum of all the numerical values. PRODUCT Return the product of all the numerical values. STDEV The standard deviation is calculated for the values based on using a sample size. STDEVP The standard deviation is calculated for the values based on using the entire population. VAR The variance is calculated for the values based on using a sample size. VARP The variance is calculated for the values based on using the entire population. Table 1. Some GeneralFunctions. GeneralFunction.SUM is used in main(), to sum the \"TOTALS\" column of the spreadsheet: // in GarlicSecrets.java XCellRange totalRange = Calc . getColRange ( sheet , 3 ); double total = Calc . computeFunction ( GeneralFunction . SUM , totalRange ); Cal.getColRange() utilizes the XColumnRowRange interface to access the sheet as a series of columns. The required column is extracted from the series via its index position: // in the Calc class public static XCellRange getColRange ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableColumns cols = crRange . getColumns (); // get all columns XIndexAccess con = Lo . qi ( XIndexAccess . class , cols ); try { // get column at idx position return Lo . qi ( XCellRange . class , con . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not access range for col pos \" + idx ); return null ; } } // end of getColRange() The sheet can also be treated as a series of rows by calling XColumnRowRange.getRows(), as in Calc.getRowRange(): // in the Calc class public static XCellRange getRowRange ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableRows rows = crRange . getRows (); // get all rows XIndexAccess con = Lo . qi ( XIndexAccess . class , rows ); try { // get row at idx position return Lo . qi ( XCellRange . class , con . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not access range for row pos \" + idx ); return null ; } } // end of getRowRange() The column returned by Calc.getColRange(sheet,3) includes the cell containing the word \"TOTALS\", but GeneralFunction.SUM only sums cells holding numerical data. Calc.computeFunction() obtains the XSheetOperation interface for the cell range, and calls XSheetOperation.computeFunction() to apply a GeneralFunction: // in the Calc class public static double computeFunction ( GeneralFunction fn , XCellRange cellRange ) { try { XSheetOperation sheetOp = Lo . qi ( XSheetOperation . class , cellRange ); return sheetOp . computeFunction ( fn ); } catch ( Exception e ) { System . out . println ( \"Compute function failed: \" + e ); return 0 ; } } // end of computeFunction() 3. Searching for the Cost of Garlic, and Increasing it \u00b6 GarlicSecrets.java increases the \"Code per Pound\" value for every garlic entry. The source document uses $1.19 (e.g. see row 6 of Figure 1). Due to a worldwide garlic shortage, this must be increased by 5% to $1.2495. increaseGarlicCost() in GarlicSecrets.java scans every used row in the sheet, examining the \"Produce\" cell to see if it contains the string \"Garlic\". When the string is found, the corresponding \"Cost per Pound\" entry on that row is changed. When the scanning reaches an empty cell, the end of the data has been reached, and the function returns. // in GarlicSecrets.java private static int increaseGarlicCost ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { int row = 0 ; XCell prodCell = Calc . getCell ( sheet , 0 , row ); // get produce cell in first row XCell costCell ; while ( prodCell . getType () != CellContentType . EMPTY ) { // iterate down produce column until an empty cell is reached if ( prodCell . getFormula (). equals ( \"Garlic\" )) { Calc . gotoCell ( doc , Calc . getCellStr ( 0 , row )); // show the cell on-screen costCell = Calc . getCell ( sheet , 1 , row ); // change cost/pound entry in the row costCell . setValue ( 1.05 * costCell . getValue ()); Props . setProperty ( costCell , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); Props . setProperty ( costCell , \"CharColor\" , 0xFF0000 ); // red } row ++ ; prodCell = Calc . getCell ( sheet , 0 , row ); // get produce cell in next row } return row ; } // end of increaseGarlicCost() To help the user see that changes have been made to the sheet, the text of each updated \"Cost per Pound\" cell is made bold and red. The cell properties being altered come from the CharacterProperties class. The progression of the function is also highlighted by calling Calc.gotoCell() inside the loop. This causes the spreadsheet to scroll down, to follow the changes. Back in main() after the updates, the \"Totals\" column is summed once again, and the new value reported: Total before change: 231353.57 Total after change: 231488.58 4. Adding a Secret, Hidden Message \u00b6 The change made by increaseGarlicCost() are of a top-secret nature, and so the code adds an invisible message to the end of the sheet: // in main() of GarlicSecrets.java : int emptyRowNum = findEmptyRow ( sheet ); addGarlicLabel ( doc , sheet , emptyRowNum ); // add msg to row Lo . delay ( 2000 ); // wait a bit before hiding row XCellRange rowRange = Calc . getRowRange ( sheet , emptyRowNum ); Props . setProperty ( rowRange , \"IsVisible\" , false ); : findEmptyRow() returns the index of the first empty row in the sheet, which happens to be the first row after the end of the data. It passes the index to addGarlicLabel() which inserts the large red text \"Top Secret Garlic Changes\" into the first cell on the row. The message is so big that several cells are merged together to make enough space; the row's height is also increased. The result is shown in Figure 3. Figure 3. The Message at the end of the Sheet. This message is visible for about 2 seconds before it's hidden by setting the height of the row to 0. This results in Figure 4. Figure 4. The Hidden Message at the end of the Sheet. findEmptyRow() utilizes a sheet ranges query to find all the empty cell ranges in the first column (XCellRangesQuery.queryEmptyCells()). Then it extracts the smallest row index from those ranges: // in GarlicSecrets.java public static int findEmptyRow ( XSpreadsheet sheet ) { // create a cell range spanning the first column of the sheet XCellRange colRange = Calc . getColRange ( sheet , 0 ); Calc . printAddress ( colRange ); // build query using the column cell range XCellRangesQuery crQuery = Lo . qi ( XCellRangesQuery . class , colRange ); // find all empty cell ranges in the column XSheetCellRanges scRanges = crQuery . queryEmptyCells (); CellRangeAddress [] addrs = scRanges . getRangeAddresses (); Calc . printAddresses ( addrs ); // find smallest row index in those ranges int row = - 1 ; if ( addrs != null ) { row = addrs [ 0 ] . StartRow ; for ( int i = 1 ; i < addrs . length ; i ++ ) { if ( row < addrs [ i ] . StartRow ) row = addrs [ i ] . StartRow ; } System . out . println ( \"First empty row is at position: \" + row ); } else System . out . println ( \"Could not find an empty row\" ); return row ; } // end of findEmptyRow() The XCellRangesQuery interface needs a cell range to search, which is obtained by calling Calc.getColRange() to get the first column. The cell range is printed by Calc.printAddress(): Range: Sheet1.A1:A1048576 The first column extends down to row 1048576. XCellRangesQuery.queryEmptyCells() returns an XSheetCellRanges object, and an array of cell range addresses are extracted from it. Calc.printAddresses() prints: Range : Sheet1 . A5001 : A1048576 There's only one empty cell range in the column, starting at row position 5001 and extending to the bottom of the sheet. This is correct because the produce data is made up of 5000 records. findEmptyRow() returns the smallest start row (i.e. 5001). 5. Adding the Label \u00b6 addGarlicLabel() adds the large text string \"Top Secret Garlic Changes\" to the first cell in the supplied row. The cell is made wider by merging a few cells together, made taller by adjusting the row height, and turned bright red. // in GarlicSecrets.java private static void addGarlicLabel ( XSpreadsheetDocument doc , XSpreadsheet sheet , int emptyRowNum ) { Calc . gotoCell ( doc , Calc . getCellStr ( 0 , emptyRowNum )); // goto first cell of the empty row // merge first few cells of the row XCellRange cellRange = Calc . getCellRange ( sheet , 0 , emptyRowNum , 3 , emptyRowNum ); XMergeable xMerge = Lo . qi ( XMergeable . class , cellRange ); xMerge . merge ( true ); Calc . setRowHeight ( sheet , emptyRowNum , 18 ); // make row taller // set text and properties in the cell XCell cell = Calc . getCell ( sheet , 0 , emptyRowNum ); cell . setFormula ( \"Top Secret Garlic Changes\" ); // add text // adjust cell text properties Props . setProperty ( cell , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); Props . setProperty ( cell , \"CharHeight\" , 24 ); Props . setProperty ( cell , \"CellBackColor\" , 0xFF0000 ); // red Props . setProperty ( cell , \"HoriJustify\" , CellHoriJustify . CENTER ); Props . setProperty ( cell , \"VertJustify\" , CellVertJustify . CENTER ); } // end of addGarlicLabel() Cell merging requires a cell range, which is obtained by calling the version of Calc.getCellRange that employs start and end cell positions in (column, row) order. The range spans the first four cells of the empty row, making it wide enough for the large text. The XMergeable interface is supported by the SheetCellRange service and uses merge() with a boolean argument to merge or unmerge a cell range. Changing the cell height affects the entire row, not just the merged cells, and so Calc.setRowHeight() manipulates a cell range representing the row: // in the Calc class public static void setRowHeight ( XSpreadsheet sheet , int idx , int height ) { XCellRange rowRange = getRowRange ( sheet , idx ); Props . setProperty ( rowRange , \"Height\" , height * 100 ); // in 1/100 mm units } setRowHeight() illustrates the difficulties of finding property documentation. The first line obtains an XCellRange interface for the row, and the second line changes a property in the cell range's service. Pretend for a moment, that we don't know the name of this height property (\"Height\"). How could we find it? That depends on finding the cell range's service. First turn to the online documentation for the XCellRange class, which includes the class diagram shown in Figure 5 (which can be reached with lodoc XCellRange). Figure 5. Classes that Inherit XCellRange. This diagram combines the service and interface inheritance hierarchies. Ignoring the interfaces that inherit XCellRange is easy because their names always begin with \"X\". The remaining names mean that XCellRange is implemented by almost every service in the Calc API: CellRange (twice), TableColumn, TableRow, and TextTable. CellRange appears twice because the blue triangle in the bottom-right corner of the first CellRange box means that there's more subclass hierarchy that's not shown; in this case, SheetCellRange, SheetCellCursor, and Spreadsheet. The height property must be in one of these services, or one of their superclasses. The correct choice is TableRow because the cell range is representing a spreadsheet row. TableRow contains four properties, one of which is \"Height\". Another approach for finding the service is to call Info.showServices(). For example, by adding the following line to Calc.setRowHeight(): Info . showServices ( \"Cell range for a row\" , cellRange ); The following is printed: Cell range for a row Supported Services (1) \"com.sun.star.table.TableRow\" Back in addGarlicLabel(), text is stored in the cell, and its properties set. Although XMergeable changes a cell range into a cell, it doesn't return a reference to that cell. It can be accessed by calling Calc.getCell(): XCell cell = Calc . getCell ( sheet , 0 , emptyRowNum ); The various cell properties changed in addGarlicLabel() are inherited from different classes shown in Figure 6. Figure 6. The SheetCell Services and Interfaces. \"CharWeight\" and \"CharHeight\" come from CharacterProperties, and \"CellBackColor\", \"HoriJustify\", and \"VertJustify\" from CellProperties. Back in main(), the newly created label is hidden after an interval of 2 seconds: // in main() of GarlicSecrets.java Lo . delay ( 2000 ); // wait a bit before hiding last row XCellRange rowRange = Calc . getRowRange ( sheet , emptyRowNum ); Props . setProperty ( rowRange , \"IsVisible\" , false ); : Row invisibility requires a property change to the row. The row's cell range is obtained by calling Calc.getRowRange(), and then the \"IsVisible\" property is switched off. Finding the name of this property involves the same investigative skills as the search for \"Height\" in Calc.setRowHeight(). As with \"Height\", \"IsVisible\" is defined in the TableRow service. 6. Splitting a Window into Two View Panes \u00b6 The produce sales data is quite lengthy, so it's useful to split the window into two view panes: one showing the modified rows at the end, and the other the first few rows at the top of the sheet. My first attempt at splitting the sheet is shown in Figure 7. The division occurs just above row 4999, drawn as a thick dark gray line. Figure 7. Two Views of the Sheet. The code in main() of GarlicSecrets.java for this: // in GarlicSecrets.java : // split window into 2 view panes String cellName = Calc . getCellStr ( 0 , emptyRowNum - 2 ); System . out . println ( \"Splitting at: \" + cellName ); Calc . splitWindow ( doc , cellName ); // doesn't work with Calc.freeze() : Calc.splitWindow() can utilize the SpreadsheetView service (see Figure 2), and its XViewSplitable interface: XController controller = Calc . getController ( doc ); XViewSplitable viewSplit = Lo . qi ( XViewSplitable . class , xController ); Unfortunately, XViewSplitable only offers a splitAtPosition() method which specifies the split location in terms of pixels. In addition, the interface is deprecated. A better alternative is to employ the \"splitWindow\" dispatch command, which has a \"ToPoint\" property argument for a cell name (e.g. \"A4999\") where the split will occur. Therefore, Calc.splitWindow() is coded as: // in the Calc class public static void splitWindow ( XSpreadsheetDocument doc , String cellName ) { XFrame frame = getController ( doc ). getFrame (); gotoCell ( frame , cellName ); Lo . dispatchCmd ( frame , \"SplitWindow\" , Props . makeProps ( \"ToPoint\" , cellName )); } // end of splitWindow() public static void gotoCell ( XFrame frame , String cellName ) { Lo . dispatchCmd ( frame , \"GoToCell\" , Props . makeProps ( \"ToPoint\" , cellName )); } The call to Calc.gotoCell() changes the on-screen active cell. If it's left out then the \"SplitWindow\" dispatch creates a split at the currently selected cell rather than the one stored in the \"ToPoint\" property. In other words, it appears that the \"SplitWindow\" dispatch ignores the property. Figure 7 shows another problem with the split \u2013 the top pane still shows the rows of data immediately above the split line. I want the top view to show the first rows at the start of the sheet. One way of changing the displayed rows is via the view's XViewPane interface (see Figure 2). Each view (or pane) created by a split is represented by an XViewPane object, and a collection of all the current panes can be accessed through the SpreadsheetView service. This approach is implemented in Calc.getViewPanes(), which returns the collection as an array: // in the Calc class public static XViewPane [] getViewPanes ( XSpreadsheetDocument doc ) { XIndexAccess con = Lo . qi ( XIndexAccess . class , getController ( doc )); if ( con == null ) { System . out . println ( \"Could not access the view pane container\" ); return null ; } if ( con . getCount () == 0 ) { System . out . println ( \"No view panes found\" ); return null ; } // put each XViewPane obj in container into an array XViewPane [] panes = new XViewPane [ con . getCount () ] ; for ( int i = 0 ; i < con . getCount (); i ++ ) { try { panes [ i ] = Lo . qi ( XViewPane . class , con . getByIndex ( i )); } catch ( Exception e ) { System . out . println ( \"Could not get view pane \" + i ); } } return panes ; } // end of getViewPanes() Calc . getViewPanes () is called like so : XViewPane [] panes = Calc . getViewPanes ( doc ); System . out . println ( \"No of panes: \" + panes . length ); The XViewPane interface has methods for setting and getting the visible row and column in the view. For example, the first pane can be made to show the first row, by calling: panes [ 0 ] . setFirstVisibleRow ( 0 ); 7. View States, and Making the Top Pane Active \u00b6 The previous section split the window into two panes, and changed the view in the top pane to show the first rows of the sheet. But there's still a problem which can be seen in Figure 7 \u2013 the active cell is still in the bottom pane, and I want it to be in the first row of the top pane. More coding is required. Hidden away in the XController interface are the methods getViewData() and restoreViewData() . They allow a programmer to access and change the view details of all the sheets in the document. For example, the following retrieval of the view data for a document: XController ctrl = getController(doc); System.out.println( ctrl.getViewData() ); prints: 100/60/0;0;tw:270;3/13/0/0/0/0/2/0/0/0/1;5/15/0/0/0/0/2/0/0/0/0;0/0/0 /0/0/0/2/0/0/0/0 This can be better understood by separating the data according to the \";'s, producing: 100/60/0 0 tw:270 3/13/0/0/0/0/2/0/0/0/1 5/15/0/0/0/0/2/0/0/0/0 0/0/0/0/0/0/2/0/0/0/0 The first three lines refer to the document's zoom settings, the active sheet index, and the position of the scrollbar. The fourth line and below give the view state information for each sheet. In the example document, there are three sheets, so three view state lines. Each view state consists of 11 values, separated by \"/\"s. Their meaning, based on their index positions: indices 0 and 1 contain the current cursor position in terms of column and row positions; index 2: this records if column split mode is being used (0 or 1); 3: is row split mode being used? (0 or 1); 4: the vertical split position (in pixels); 5: the horizontal split position (in pixels); 6: the active/focused pane number for this sheet; 7: the left column index of the left-hand panes; 8: the left column index of the right-hand panes; 9: the top row index of the upper panes; 10: the top row index of the lower panes. A sheet can be split horizontal and/or vertically, which can generate a maximum of four panes, which are numbered as in Figure 8. Figure 8. The Four Panes in a Split Window. If a window is split only horizontally, then numbers 0 and 1 are used. If the split is only vertical, then the numbers used are 0 and 2. Only one pane can be active (i.e. have keyboard focus) at a time. For example, in Figure 8, pane 1 is active. The active pane number is stored in view state index 6. The view state information at index positions 7 to 10 define the top-left corners of each pane. For example, since pane 1 is in the top-right of the sheet, its top-left corner is obtained by combining the values in view state index positions 8 and 9. Position 8 supplies the column index of the two right-hand panes, and position 9 the row index of the top two panes. If a sheet is not split at all, then its top-left corner is reconstructed by accessing index positions 7 and 10. Although it's possible for a programmer to extract all this information from the view data string by himself, I've implemented a support class called ViewState which stores the data in a more easily accessible form. Calc.getViewStates() parses the view data string, creating an array of ViewState objects, one object for each sheet in the document. For example, the following code is in GarlicSecrets.java: // in GarlicSecrets.java : ViewState [] states = Calc . getViewStates ( doc ); for ( ViewState s : states ) s . report (); When it's executed after the sheet has been split as shown in Figure 7, the following is printed: Sheet View State Cursor pos (column, row): (0, 4998) or \"A4999\" Sheet is split horizontally at 138 Number of focused pane: 2 Left column indices of left/right panes: 0 / 0 Top row indices of upper/lower panes: 4992 / 4998 One view state is reported since the document only contains one sheet. The output says that the sheet is split vertically, and the lower pane is active (in focus). Calc.getViewStates() is implemented as: // in the Calc class public static ViewState [] getViewStates ( XSpreadsheetDocument doc ) { // get view data from controller XController ctrl = getController ( doc ); String viewData = ( String ) ctrl . getViewData (); // split into parts based on \";\" delimiter String [] viewParts = viewData . split ( \";\" ); if ( viewParts . length < 4 ) { System . out . println ( \"No sheet view states found in view data\" ); return null ; } // build view states array from view data after first 3 entries ViewState [] states = new ViewState [ viewParts . length - 3 ] ; for ( int i = 3 ; i < viewParts . length ; i ++ ) states [ i - 3 ] = new ViewState ( viewParts [ i ] ); // construct view state object return states ; } // end of getViewStates() The first three entries in the view data (i.e. the document's zoom, active sheet, and scrollbar position) are discarded, so only the document's view states are stored. Paired with Calc.getViewStates() is Calc.setViewStates() which uses an array of ViewState objects to update the view states of a document. It is coded as: // in the Calc class public static void setViewStates ( XSpreadsheetDocument doc , ViewState [] states ) { // get view data from controller XController ctrl = getController ( doc ); String viewData = ( String ) ctrl . getViewData (); String [] viewParts = viewData . split ( \";\" ); if ( viewParts . length < 4 ) { System . out . println ( \"No sheet states found in view data\" ); return ; } // start building a string holding the modified view data StringBuilder vdNew = new StringBuilder (); for ( int i = 0 ; i < 3 ; i ++ ) // copy first 3 parts unchanged vdNew . append ( viewParts [ i ] ). append ( \";\" ); // build rest of string using supplied view states array for ( int i = 0 ; i < states . length ; i ++ ) { vdNew . append ( states [ i ] . toString ()); //add new state as string if ( i != states . length - 1 ) vdNew . append ( \";\" ); } // use string to update controller's view data ctrl . restoreViewData ( vdNew . toString ()); } // end of setViewStates() A new view data string is constructed, and loaded into the document by calling XController.restoreViewData(). The string is composed from view state strings obtained by calling ViewState.toString() for each ViewState object. Also, the existing values for the document's zoom, active sheet, and scrollbar position are copied over unchanged by extracting their current values from a call to XController.getViewData(). I'm finally able to change the active pane to be the top view. While I'm at it, I'll also move the view in that newly activated pane to the top of the sheet: // in main() in GarlicSecrets.java : ViewState [] states = Calc . getViewStates ( doc ); // move focus to top pane in the first sheet states [ 0 ] . movePaneFocus ( ViewState . MOVE_UP ); Calc . setViewStates ( doc , states ); Calc . gotoCell ( doc , \"A1\" ); // move selection to top cell // print revised view states states = Calc . getViewStates ( doc ); for ( ViewState s : states ) s . report (); : The view states are obtained by calling Calc.getViewStates(). The states[] array will hold one ViewState object for each sheet in the document, so by using states[0] the panes in the first sheet will be affected. ViewState.movePaneFocus(), which I'll describe shortly, changes the focus to the top pane. Finally, the modified view states are written back to the document by Calc.setViewStates(). Figure 9 shows the outcome of this code: the active cell is now in the top pane, at cell \"A1\". Figure 9. A Changed Active Cell and Pane. The code fragment above also prints out the revised view state, which is: Sheet View State Cursor pos (column, row): (0, 0) or \"A1\" Sheet is split horizontally at 138 Number of focused pane: 0 Left column indices of left/right panes: 0 / 0 Top row indices of upper/lower panes: 0 / 4998 ViewState.movePaneFocus() changes one value in the view state \u2013 the focused pane number (index no. 6 in the list given earlier). I decided not to implement this by having the programmer supply a pane number (i.e., 0, 1, 2, or 3 as shown in Figure 8) since these numbers may not all be used in a given split. Instead the focus change is specified in terms of a direction, as shown in the code: // in the ViewState class // globals for moving the pane focus public static final int MOVE_UP = 0 ; public static final int MOVE_DOWN = 1 ; public static final int MOVE_LEFT = 2 ; public static final int MOVE_RIGHT = 3 ; private int focusNum ; public void movePaneFocus ( int dir ) { if ( dir == MOVE_UP ) { if ( focusNum == 3 ) focusNum = 1 ; else if ( focusNum == 2 ) focusNum = 0 ; else System . out . println ( \"cannot move up\" ); } else if ( dir == MOVE_DOWN ) { if ( focusNum == 1 ) focusNum = 3 ; else if ( focusNum == 0 ) focusNum = 2 ; else System . out . println ( \"cannot move down\" ); } else if ( dir == MOVE_LEFT ) { if ( focusNum == 1 ) focusNum = 0 ; else if ( focusNum == 3 ) focusNum = 2 ; else System . out . println ( \"cannot move left\" ); } else if ( dir == MOVE_RIGHT ) { if ( focusNum == 0 ) focusNum = 1 ; else if ( focusNum == 2 ) focusNum = 3 ; else System . out . println ( \"cannot move right\" ); } else System . out . println ( \"Unknown move direction\" ); } // end of movePaneFocus() 8. Adding a New First Row and Shifting Cells \u00b6 The final task in GarlicSecrets.java is to add the \"Top Secret Garlic Changes\" text to the sheet again, this time as a visible title for the spreadsheet. The only new API feature used is the insertion of a row. This is done with: // in GarlicSecrets.java // add a new first row, and label it Calc . insertRow ( sheet , 0 ); addGarlicLabel ( doc , sheet , 0 ); The addGarlicLabel() method is unchanged from earlier, but is now passed row index 0 rather than the last row. The result is shown in Figure 10. Figure 10. The Sheet with a New Title Row. Calc.insertRow() manipulates a row as a cell range, so it's once again necessary to access the sheet's XColumnRowRange interface, to retrieve a TableRows object. The XTableRows interface supports the adding and removal of rows at specified index positions. This allows Calc.insertRow() to be coded as: // in the Calc class public static void insertRow ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableRows rows = crRange . getRows (); rows . insertByIndex ( idx , 1 ); // add 1 row at idx position } There's a similar Calc.insertCols() method that utilizes the XTableColumns interface: // in the Calc class public static void insertColumn ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableColumns cols = crRange . getColumns (); cols . insertByIndex ( idx , 1 ); // add 1 column at idx position } The insertion of an arbitrary number of blank cells into a sheet is a bit more complicated because existing cells must be 'moved' out of the way, and this can be done by moving them downwards or to the right. The shift-able cells are specified as a cell range, and the sheet's XCellRangeMovement interface moves them in a specific direction. XCellRangeMovement is supported by the Spreadsheet service. The Calc.insertCells() method implements this approach: // in the Calc class public static void insertCells ( XSpreadsheet sheet , XCellRange cellRange , boolean isShiftRight ) /* insert blank cells at cellRange, moving the existing ones to the right or down depending on the boolean argument */ { XCellRangeMovement mover = Lo . qi ( XCellRangeMovement . class , sheet ); CellRangeAddress addr = getAddress ( cellRange ); // cells to shift if ( isShiftRight ) // move right mover . insertCells ( addr , CellInsertMode . RIGHT ); else // or move down mover . insertCells ( addr , CellInsertMode . DOWN ); } // end of insertCells() An example call: XCellRange blanks = Calc . getCellRange ( sheet , \"A4999:B5001\" ); Calc . insertCells ( sheet , blanks , true ); // shift right This shifts the last three rows of the produce sheet (A4999:B5001) to the right by two cells, producing Figure 11. Figure 11. Shifted Cells at the end of the Produce Sheet.","title":"Chapter 23. Garlic Secrets"},{"location":"23-Garlic_Secrets.html#chapter-23-garlic-secrets","text":"Topics Freezing Rows; GeneralFunctions; Sheet Searching; Sheet Range Queries; Hidden Cells; Cell Merging; Splitting Windows; View Panes; View State Data; Active Panes; Inserting Rows and Columns; Shifting Cells Example folders: \"Calc Tests\" and \"Utils\" This chapter's GarlicSecrets.java example illustrates how data can be extracted from an existing spreadsheet (\"produceSales.xlsx\") using 'general' functions, sheet searching, and sheet range queries. It also has more examples of cell styling, and demonstrates sheet freezing, view pane splitting, pane activation, and the insertion of new rows into a sheet. The idea for this chapter, and the data, comes from the Excel example in chapter 12 of \"Automate the Boring Stuff with Python\" by Al Sweigart. However, he utilized the Python library OpenPyXL to manipulate his file. The beginning of the spreadsheet is shown in Figure 1. Figure 1. Part of the \"produceSales.xlsx\" Spreadsheet. Each row holds information about the sale of fruit or vegetables. The columns are the type of produce sold (column A), the cost per pound of that produce (B), the number of pounds sold (C), and the total revenue from the sale (D). The TOTAL column is calculated using a formula which multiplies the cost per pound by the number of pounds sold, and rounds the result to the nearest cent. For example, cell \"D2\" contains \"=ROUND(B2*C2, 2)\". Most of the main() function for GarlicSecrets.java is shown below. I'll explain the commented out parts in later sections: // in GarlicSecrets.java private static final String FNM = \"produceSales.xlsx\" ; private static final String OUT_FNM = \"garlicSecrets.ods\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + FNM ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . gotoCell ( doc , \"A1\" ); // make sure top of sheet is visible // freeze first 3 rows of view // Calc.freezeRows(doc, 3); // report total for the \"Total\" column XCellRange totalRange = Calc . getColRange ( sheet , 3 ); double total = Calc . computeFunction ( GeneralFunction . SUM , totalRange ); System . out . printf ( \"Total before change: %.2f\\n\" , total ); increaseGarlicCost ( doc , sheet ); // recalculate total and print again total = Calc . computeFunction ( GeneralFunction . SUM , totalRange ); System . out . printf ( \"Total after change: %.2f\\n\" , total ); // add a label at the bottom of the data, and hide it... // split sheet into panes... // make top pane the active one in the first sheet... // add a new first row, and label that as at the bottom... Lo . saveDoc ( doc , OUT_FNM ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main()","title":"Chapter 23. Garlic Secrets"},{"location":"23-Garlic_Secrets.html#1-freezing-rows","text":"Calc.freezeRows() specifies the number of rows that should be 'frozen' on-screen as Office's view of the spreadsheet changes (e.g. when the user scrolls downwards). The function's argument is the number of rows to freeze, not a row index, and the choice of which rows are frozen depends on which row is currently selected (active) in the application window when the function is called. The earlier call to Calc.gotoCell() in main() means that \"A1\" is the active cell in the spreadsheet, and so row \"1\" is the active row (and \"A\" the active column). For that reason, Calc.freezeRows(doc, 3) will freeze rows \"1\", \"2\", and \"3\" so they remain in view when the spreadsheet is scrolled up or down. Calc.freezeRows() and Calc.freezeCols() are implemented using Calc.freeze(): // in the Calc class public static void freezeRows ( XSpreadsheetDocument doc , int numRows ) { freeze ( doc , 0 , numRows ); } public static void freezeCols ( XSpreadsheetDocument doc , int numCols ) { freeze ( doc , numCols , 0 ); } public static void freeze ( XSpreadsheetDocument doc , int numCols , int numRows ) { XViewFreezable xFreeze = Lo . qi ( XViewFreezable . class , getController ( doc )); xFreeze . freezeAtPosition ( numCols , numRows ); } Calc.freeze() accesses the SpreadsheetView service (see Figure 2) via the document's controller, and utilizes its XViewFreezable interface to call freezeAtPosition(). Figure 2. The SpreadsheetView Services and Interfaces.","title":"1.  Freezing Rows"},{"location":"23-Garlic_Secrets.html#2-general-functions","text":"Office has a small set of functions (called GeneralFunctions) which can be applied to cell ranges without the need for formula strings (i.e. a string starting with \"=\"). They're listed in the enum section at the end of the sheet module at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1sheet.html , or use lodoc GeneralFunctions . The more important functions are shown in Table 1. GeneralFunction Name Calculation Applied to the Cell Values SUM Sum the numerical values. COUNT Count all the values, including the non-numerical ones. COUNTNUMS Count only the numerical values. AVERAGE Average all the numerical values. MAX Find the maximum of all the numerical values. MIN Find the minimum of all the numerical values. PRODUCT Return the product of all the numerical values. STDEV The standard deviation is calculated for the values based on using a sample size. STDEVP The standard deviation is calculated for the values based on using the entire population. VAR The variance is calculated for the values based on using a sample size. VARP The variance is calculated for the values based on using the entire population. Table 1. Some GeneralFunctions. GeneralFunction.SUM is used in main(), to sum the \"TOTALS\" column of the spreadsheet: // in GarlicSecrets.java XCellRange totalRange = Calc . getColRange ( sheet , 3 ); double total = Calc . computeFunction ( GeneralFunction . SUM , totalRange ); Cal.getColRange() utilizes the XColumnRowRange interface to access the sheet as a series of columns. The required column is extracted from the series via its index position: // in the Calc class public static XCellRange getColRange ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableColumns cols = crRange . getColumns (); // get all columns XIndexAccess con = Lo . qi ( XIndexAccess . class , cols ); try { // get column at idx position return Lo . qi ( XCellRange . class , con . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not access range for col pos \" + idx ); return null ; } } // end of getColRange() The sheet can also be treated as a series of rows by calling XColumnRowRange.getRows(), as in Calc.getRowRange(): // in the Calc class public static XCellRange getRowRange ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableRows rows = crRange . getRows (); // get all rows XIndexAccess con = Lo . qi ( XIndexAccess . class , rows ); try { // get row at idx position return Lo . qi ( XCellRange . class , con . getByIndex ( idx )); } catch ( Exception e ) { System . out . println ( \"Could not access range for row pos \" + idx ); return null ; } } // end of getRowRange() The column returned by Calc.getColRange(sheet,3) includes the cell containing the word \"TOTALS\", but GeneralFunction.SUM only sums cells holding numerical data. Calc.computeFunction() obtains the XSheetOperation interface for the cell range, and calls XSheetOperation.computeFunction() to apply a GeneralFunction: // in the Calc class public static double computeFunction ( GeneralFunction fn , XCellRange cellRange ) { try { XSheetOperation sheetOp = Lo . qi ( XSheetOperation . class , cellRange ); return sheetOp . computeFunction ( fn ); } catch ( Exception e ) { System . out . println ( \"Compute function failed: \" + e ); return 0 ; } } // end of computeFunction()","title":"2.  General Functions"},{"location":"23-Garlic_Secrets.html#3-searching-for-the-cost-of-garlic-and-increasing-it","text":"GarlicSecrets.java increases the \"Code per Pound\" value for every garlic entry. The source document uses $1.19 (e.g. see row 6 of Figure 1). Due to a worldwide garlic shortage, this must be increased by 5% to $1.2495. increaseGarlicCost() in GarlicSecrets.java scans every used row in the sheet, examining the \"Produce\" cell to see if it contains the string \"Garlic\". When the string is found, the corresponding \"Cost per Pound\" entry on that row is changed. When the scanning reaches an empty cell, the end of the data has been reached, and the function returns. // in GarlicSecrets.java private static int increaseGarlicCost ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { int row = 0 ; XCell prodCell = Calc . getCell ( sheet , 0 , row ); // get produce cell in first row XCell costCell ; while ( prodCell . getType () != CellContentType . EMPTY ) { // iterate down produce column until an empty cell is reached if ( prodCell . getFormula (). equals ( \"Garlic\" )) { Calc . gotoCell ( doc , Calc . getCellStr ( 0 , row )); // show the cell on-screen costCell = Calc . getCell ( sheet , 1 , row ); // change cost/pound entry in the row costCell . setValue ( 1.05 * costCell . getValue ()); Props . setProperty ( costCell , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); Props . setProperty ( costCell , \"CharColor\" , 0xFF0000 ); // red } row ++ ; prodCell = Calc . getCell ( sheet , 0 , row ); // get produce cell in next row } return row ; } // end of increaseGarlicCost() To help the user see that changes have been made to the sheet, the text of each updated \"Cost per Pound\" cell is made bold and red. The cell properties being altered come from the CharacterProperties class. The progression of the function is also highlighted by calling Calc.gotoCell() inside the loop. This causes the spreadsheet to scroll down, to follow the changes. Back in main() after the updates, the \"Totals\" column is summed once again, and the new value reported: Total before change: 231353.57 Total after change: 231488.58","title":"3.  Searching for the Cost of Garlic, and Increasing it"},{"location":"23-Garlic_Secrets.html#4-adding-a-secret-hidden-message","text":"The change made by increaseGarlicCost() are of a top-secret nature, and so the code adds an invisible message to the end of the sheet: // in main() of GarlicSecrets.java : int emptyRowNum = findEmptyRow ( sheet ); addGarlicLabel ( doc , sheet , emptyRowNum ); // add msg to row Lo . delay ( 2000 ); // wait a bit before hiding row XCellRange rowRange = Calc . getRowRange ( sheet , emptyRowNum ); Props . setProperty ( rowRange , \"IsVisible\" , false ); : findEmptyRow() returns the index of the first empty row in the sheet, which happens to be the first row after the end of the data. It passes the index to addGarlicLabel() which inserts the large red text \"Top Secret Garlic Changes\" into the first cell on the row. The message is so big that several cells are merged together to make enough space; the row's height is also increased. The result is shown in Figure 3. Figure 3. The Message at the end of the Sheet. This message is visible for about 2 seconds before it's hidden by setting the height of the row to 0. This results in Figure 4. Figure 4. The Hidden Message at the end of the Sheet. findEmptyRow() utilizes a sheet ranges query to find all the empty cell ranges in the first column (XCellRangesQuery.queryEmptyCells()). Then it extracts the smallest row index from those ranges: // in GarlicSecrets.java public static int findEmptyRow ( XSpreadsheet sheet ) { // create a cell range spanning the first column of the sheet XCellRange colRange = Calc . getColRange ( sheet , 0 ); Calc . printAddress ( colRange ); // build query using the column cell range XCellRangesQuery crQuery = Lo . qi ( XCellRangesQuery . class , colRange ); // find all empty cell ranges in the column XSheetCellRanges scRanges = crQuery . queryEmptyCells (); CellRangeAddress [] addrs = scRanges . getRangeAddresses (); Calc . printAddresses ( addrs ); // find smallest row index in those ranges int row = - 1 ; if ( addrs != null ) { row = addrs [ 0 ] . StartRow ; for ( int i = 1 ; i < addrs . length ; i ++ ) { if ( row < addrs [ i ] . StartRow ) row = addrs [ i ] . StartRow ; } System . out . println ( \"First empty row is at position: \" + row ); } else System . out . println ( \"Could not find an empty row\" ); return row ; } // end of findEmptyRow() The XCellRangesQuery interface needs a cell range to search, which is obtained by calling Calc.getColRange() to get the first column. The cell range is printed by Calc.printAddress(): Range: Sheet1.A1:A1048576 The first column extends down to row 1048576. XCellRangesQuery.queryEmptyCells() returns an XSheetCellRanges object, and an array of cell range addresses are extracted from it. Calc.printAddresses() prints: Range : Sheet1 . A5001 : A1048576 There's only one empty cell range in the column, starting at row position 5001 and extending to the bottom of the sheet. This is correct because the produce data is made up of 5000 records. findEmptyRow() returns the smallest start row (i.e. 5001).","title":"4.  Adding a Secret, Hidden Message"},{"location":"23-Garlic_Secrets.html#5-adding-the-label","text":"addGarlicLabel() adds the large text string \"Top Secret Garlic Changes\" to the first cell in the supplied row. The cell is made wider by merging a few cells together, made taller by adjusting the row height, and turned bright red. // in GarlicSecrets.java private static void addGarlicLabel ( XSpreadsheetDocument doc , XSpreadsheet sheet , int emptyRowNum ) { Calc . gotoCell ( doc , Calc . getCellStr ( 0 , emptyRowNum )); // goto first cell of the empty row // merge first few cells of the row XCellRange cellRange = Calc . getCellRange ( sheet , 0 , emptyRowNum , 3 , emptyRowNum ); XMergeable xMerge = Lo . qi ( XMergeable . class , cellRange ); xMerge . merge ( true ); Calc . setRowHeight ( sheet , emptyRowNum , 18 ); // make row taller // set text and properties in the cell XCell cell = Calc . getCell ( sheet , 0 , emptyRowNum ); cell . setFormula ( \"Top Secret Garlic Changes\" ); // add text // adjust cell text properties Props . setProperty ( cell , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); Props . setProperty ( cell , \"CharHeight\" , 24 ); Props . setProperty ( cell , \"CellBackColor\" , 0xFF0000 ); // red Props . setProperty ( cell , \"HoriJustify\" , CellHoriJustify . CENTER ); Props . setProperty ( cell , \"VertJustify\" , CellVertJustify . CENTER ); } // end of addGarlicLabel() Cell merging requires a cell range, which is obtained by calling the version of Calc.getCellRange that employs start and end cell positions in (column, row) order. The range spans the first four cells of the empty row, making it wide enough for the large text. The XMergeable interface is supported by the SheetCellRange service and uses merge() with a boolean argument to merge or unmerge a cell range. Changing the cell height affects the entire row, not just the merged cells, and so Calc.setRowHeight() manipulates a cell range representing the row: // in the Calc class public static void setRowHeight ( XSpreadsheet sheet , int idx , int height ) { XCellRange rowRange = getRowRange ( sheet , idx ); Props . setProperty ( rowRange , \"Height\" , height * 100 ); // in 1/100 mm units } setRowHeight() illustrates the difficulties of finding property documentation. The first line obtains an XCellRange interface for the row, and the second line changes a property in the cell range's service. Pretend for a moment, that we don't know the name of this height property (\"Height\"). How could we find it? That depends on finding the cell range's service. First turn to the online documentation for the XCellRange class, which includes the class diagram shown in Figure 5 (which can be reached with lodoc XCellRange). Figure 5. Classes that Inherit XCellRange. This diagram combines the service and interface inheritance hierarchies. Ignoring the interfaces that inherit XCellRange is easy because their names always begin with \"X\". The remaining names mean that XCellRange is implemented by almost every service in the Calc API: CellRange (twice), TableColumn, TableRow, and TextTable. CellRange appears twice because the blue triangle in the bottom-right corner of the first CellRange box means that there's more subclass hierarchy that's not shown; in this case, SheetCellRange, SheetCellCursor, and Spreadsheet. The height property must be in one of these services, or one of their superclasses. The correct choice is TableRow because the cell range is representing a spreadsheet row. TableRow contains four properties, one of which is \"Height\". Another approach for finding the service is to call Info.showServices(). For example, by adding the following line to Calc.setRowHeight(): Info . showServices ( \"Cell range for a row\" , cellRange ); The following is printed: Cell range for a row Supported Services (1) \"com.sun.star.table.TableRow\" Back in addGarlicLabel(), text is stored in the cell, and its properties set. Although XMergeable changes a cell range into a cell, it doesn't return a reference to that cell. It can be accessed by calling Calc.getCell(): XCell cell = Calc . getCell ( sheet , 0 , emptyRowNum ); The various cell properties changed in addGarlicLabel() are inherited from different classes shown in Figure 6. Figure 6. The SheetCell Services and Interfaces. \"CharWeight\" and \"CharHeight\" come from CharacterProperties, and \"CellBackColor\", \"HoriJustify\", and \"VertJustify\" from CellProperties. Back in main(), the newly created label is hidden after an interval of 2 seconds: // in main() of GarlicSecrets.java Lo . delay ( 2000 ); // wait a bit before hiding last row XCellRange rowRange = Calc . getRowRange ( sheet , emptyRowNum ); Props . setProperty ( rowRange , \"IsVisible\" , false ); : Row invisibility requires a property change to the row. The row's cell range is obtained by calling Calc.getRowRange(), and then the \"IsVisible\" property is switched off. Finding the name of this property involves the same investigative skills as the search for \"Height\" in Calc.setRowHeight(). As with \"Height\", \"IsVisible\" is defined in the TableRow service.","title":"5.  Adding the Label"},{"location":"23-Garlic_Secrets.html#6-splitting-a-window-into-two-view-panes","text":"The produce sales data is quite lengthy, so it's useful to split the window into two view panes: one showing the modified rows at the end, and the other the first few rows at the top of the sheet. My first attempt at splitting the sheet is shown in Figure 7. The division occurs just above row 4999, drawn as a thick dark gray line. Figure 7. Two Views of the Sheet. The code in main() of GarlicSecrets.java for this: // in GarlicSecrets.java : // split window into 2 view panes String cellName = Calc . getCellStr ( 0 , emptyRowNum - 2 ); System . out . println ( \"Splitting at: \" + cellName ); Calc . splitWindow ( doc , cellName ); // doesn't work with Calc.freeze() : Calc.splitWindow() can utilize the SpreadsheetView service (see Figure 2), and its XViewSplitable interface: XController controller = Calc . getController ( doc ); XViewSplitable viewSplit = Lo . qi ( XViewSplitable . class , xController ); Unfortunately, XViewSplitable only offers a splitAtPosition() method which specifies the split location in terms of pixels. In addition, the interface is deprecated. A better alternative is to employ the \"splitWindow\" dispatch command, which has a \"ToPoint\" property argument for a cell name (e.g. \"A4999\") where the split will occur. Therefore, Calc.splitWindow() is coded as: // in the Calc class public static void splitWindow ( XSpreadsheetDocument doc , String cellName ) { XFrame frame = getController ( doc ). getFrame (); gotoCell ( frame , cellName ); Lo . dispatchCmd ( frame , \"SplitWindow\" , Props . makeProps ( \"ToPoint\" , cellName )); } // end of splitWindow() public static void gotoCell ( XFrame frame , String cellName ) { Lo . dispatchCmd ( frame , \"GoToCell\" , Props . makeProps ( \"ToPoint\" , cellName )); } The call to Calc.gotoCell() changes the on-screen active cell. If it's left out then the \"SplitWindow\" dispatch creates a split at the currently selected cell rather than the one stored in the \"ToPoint\" property. In other words, it appears that the \"SplitWindow\" dispatch ignores the property. Figure 7 shows another problem with the split \u2013 the top pane still shows the rows of data immediately above the split line. I want the top view to show the first rows at the start of the sheet. One way of changing the displayed rows is via the view's XViewPane interface (see Figure 2). Each view (or pane) created by a split is represented by an XViewPane object, and a collection of all the current panes can be accessed through the SpreadsheetView service. This approach is implemented in Calc.getViewPanes(), which returns the collection as an array: // in the Calc class public static XViewPane [] getViewPanes ( XSpreadsheetDocument doc ) { XIndexAccess con = Lo . qi ( XIndexAccess . class , getController ( doc )); if ( con == null ) { System . out . println ( \"Could not access the view pane container\" ); return null ; } if ( con . getCount () == 0 ) { System . out . println ( \"No view panes found\" ); return null ; } // put each XViewPane obj in container into an array XViewPane [] panes = new XViewPane [ con . getCount () ] ; for ( int i = 0 ; i < con . getCount (); i ++ ) { try { panes [ i ] = Lo . qi ( XViewPane . class , con . getByIndex ( i )); } catch ( Exception e ) { System . out . println ( \"Could not get view pane \" + i ); } } return panes ; } // end of getViewPanes() Calc . getViewPanes () is called like so : XViewPane [] panes = Calc . getViewPanes ( doc ); System . out . println ( \"No of panes: \" + panes . length ); The XViewPane interface has methods for setting and getting the visible row and column in the view. For example, the first pane can be made to show the first row, by calling: panes [ 0 ] . setFirstVisibleRow ( 0 );","title":"6.  Splitting a Window into Two View Panes"},{"location":"23-Garlic_Secrets.html#7-view-states-and-making-the-top-pane-active","text":"The previous section split the window into two panes, and changed the view in the top pane to show the first rows of the sheet. But there's still a problem which can be seen in Figure 7 \u2013 the active cell is still in the bottom pane, and I want it to be in the first row of the top pane. More coding is required. Hidden away in the XController interface are the methods getViewData() and restoreViewData() . They allow a programmer to access and change the view details of all the sheets in the document. For example, the following retrieval of the view data for a document: XController ctrl = getController(doc); System.out.println( ctrl.getViewData() ); prints: 100/60/0;0;tw:270;3/13/0/0/0/0/2/0/0/0/1;5/15/0/0/0/0/2/0/0/0/0;0/0/0 /0/0/0/2/0/0/0/0 This can be better understood by separating the data according to the \";'s, producing: 100/60/0 0 tw:270 3/13/0/0/0/0/2/0/0/0/1 5/15/0/0/0/0/2/0/0/0/0 0/0/0/0/0/0/2/0/0/0/0 The first three lines refer to the document's zoom settings, the active sheet index, and the position of the scrollbar. The fourth line and below give the view state information for each sheet. In the example document, there are three sheets, so three view state lines. Each view state consists of 11 values, separated by \"/\"s. Their meaning, based on their index positions: indices 0 and 1 contain the current cursor position in terms of column and row positions; index 2: this records if column split mode is being used (0 or 1); 3: is row split mode being used? (0 or 1); 4: the vertical split position (in pixels); 5: the horizontal split position (in pixels); 6: the active/focused pane number for this sheet; 7: the left column index of the left-hand panes; 8: the left column index of the right-hand panes; 9: the top row index of the upper panes; 10: the top row index of the lower panes. A sheet can be split horizontal and/or vertically, which can generate a maximum of four panes, which are numbered as in Figure 8. Figure 8. The Four Panes in a Split Window. If a window is split only horizontally, then numbers 0 and 1 are used. If the split is only vertical, then the numbers used are 0 and 2. Only one pane can be active (i.e. have keyboard focus) at a time. For example, in Figure 8, pane 1 is active. The active pane number is stored in view state index 6. The view state information at index positions 7 to 10 define the top-left corners of each pane. For example, since pane 1 is in the top-right of the sheet, its top-left corner is obtained by combining the values in view state index positions 8 and 9. Position 8 supplies the column index of the two right-hand panes, and position 9 the row index of the top two panes. If a sheet is not split at all, then its top-left corner is reconstructed by accessing index positions 7 and 10. Although it's possible for a programmer to extract all this information from the view data string by himself, I've implemented a support class called ViewState which stores the data in a more easily accessible form. Calc.getViewStates() parses the view data string, creating an array of ViewState objects, one object for each sheet in the document. For example, the following code is in GarlicSecrets.java: // in GarlicSecrets.java : ViewState [] states = Calc . getViewStates ( doc ); for ( ViewState s : states ) s . report (); When it's executed after the sheet has been split as shown in Figure 7, the following is printed: Sheet View State Cursor pos (column, row): (0, 4998) or \"A4999\" Sheet is split horizontally at 138 Number of focused pane: 2 Left column indices of left/right panes: 0 / 0 Top row indices of upper/lower panes: 4992 / 4998 One view state is reported since the document only contains one sheet. The output says that the sheet is split vertically, and the lower pane is active (in focus). Calc.getViewStates() is implemented as: // in the Calc class public static ViewState [] getViewStates ( XSpreadsheetDocument doc ) { // get view data from controller XController ctrl = getController ( doc ); String viewData = ( String ) ctrl . getViewData (); // split into parts based on \";\" delimiter String [] viewParts = viewData . split ( \";\" ); if ( viewParts . length < 4 ) { System . out . println ( \"No sheet view states found in view data\" ); return null ; } // build view states array from view data after first 3 entries ViewState [] states = new ViewState [ viewParts . length - 3 ] ; for ( int i = 3 ; i < viewParts . length ; i ++ ) states [ i - 3 ] = new ViewState ( viewParts [ i ] ); // construct view state object return states ; } // end of getViewStates() The first three entries in the view data (i.e. the document's zoom, active sheet, and scrollbar position) are discarded, so only the document's view states are stored. Paired with Calc.getViewStates() is Calc.setViewStates() which uses an array of ViewState objects to update the view states of a document. It is coded as: // in the Calc class public static void setViewStates ( XSpreadsheetDocument doc , ViewState [] states ) { // get view data from controller XController ctrl = getController ( doc ); String viewData = ( String ) ctrl . getViewData (); String [] viewParts = viewData . split ( \";\" ); if ( viewParts . length < 4 ) { System . out . println ( \"No sheet states found in view data\" ); return ; } // start building a string holding the modified view data StringBuilder vdNew = new StringBuilder (); for ( int i = 0 ; i < 3 ; i ++ ) // copy first 3 parts unchanged vdNew . append ( viewParts [ i ] ). append ( \";\" ); // build rest of string using supplied view states array for ( int i = 0 ; i < states . length ; i ++ ) { vdNew . append ( states [ i ] . toString ()); //add new state as string if ( i != states . length - 1 ) vdNew . append ( \";\" ); } // use string to update controller's view data ctrl . restoreViewData ( vdNew . toString ()); } // end of setViewStates() A new view data string is constructed, and loaded into the document by calling XController.restoreViewData(). The string is composed from view state strings obtained by calling ViewState.toString() for each ViewState object. Also, the existing values for the document's zoom, active sheet, and scrollbar position are copied over unchanged by extracting their current values from a call to XController.getViewData(). I'm finally able to change the active pane to be the top view. While I'm at it, I'll also move the view in that newly activated pane to the top of the sheet: // in main() in GarlicSecrets.java : ViewState [] states = Calc . getViewStates ( doc ); // move focus to top pane in the first sheet states [ 0 ] . movePaneFocus ( ViewState . MOVE_UP ); Calc . setViewStates ( doc , states ); Calc . gotoCell ( doc , \"A1\" ); // move selection to top cell // print revised view states states = Calc . getViewStates ( doc ); for ( ViewState s : states ) s . report (); : The view states are obtained by calling Calc.getViewStates(). The states[] array will hold one ViewState object for each sheet in the document, so by using states[0] the panes in the first sheet will be affected. ViewState.movePaneFocus(), which I'll describe shortly, changes the focus to the top pane. Finally, the modified view states are written back to the document by Calc.setViewStates(). Figure 9 shows the outcome of this code: the active cell is now in the top pane, at cell \"A1\". Figure 9. A Changed Active Cell and Pane. The code fragment above also prints out the revised view state, which is: Sheet View State Cursor pos (column, row): (0, 0) or \"A1\" Sheet is split horizontally at 138 Number of focused pane: 0 Left column indices of left/right panes: 0 / 0 Top row indices of upper/lower panes: 0 / 4998 ViewState.movePaneFocus() changes one value in the view state \u2013 the focused pane number (index no. 6 in the list given earlier). I decided not to implement this by having the programmer supply a pane number (i.e., 0, 1, 2, or 3 as shown in Figure 8) since these numbers may not all be used in a given split. Instead the focus change is specified in terms of a direction, as shown in the code: // in the ViewState class // globals for moving the pane focus public static final int MOVE_UP = 0 ; public static final int MOVE_DOWN = 1 ; public static final int MOVE_LEFT = 2 ; public static final int MOVE_RIGHT = 3 ; private int focusNum ; public void movePaneFocus ( int dir ) { if ( dir == MOVE_UP ) { if ( focusNum == 3 ) focusNum = 1 ; else if ( focusNum == 2 ) focusNum = 0 ; else System . out . println ( \"cannot move up\" ); } else if ( dir == MOVE_DOWN ) { if ( focusNum == 1 ) focusNum = 3 ; else if ( focusNum == 0 ) focusNum = 2 ; else System . out . println ( \"cannot move down\" ); } else if ( dir == MOVE_LEFT ) { if ( focusNum == 1 ) focusNum = 0 ; else if ( focusNum == 3 ) focusNum = 2 ; else System . out . println ( \"cannot move left\" ); } else if ( dir == MOVE_RIGHT ) { if ( focusNum == 0 ) focusNum = 1 ; else if ( focusNum == 2 ) focusNum = 3 ; else System . out . println ( \"cannot move right\" ); } else System . out . println ( \"Unknown move direction\" ); } // end of movePaneFocus()","title":"7.  View States, and Making the Top Pane Active"},{"location":"23-Garlic_Secrets.html#8-adding-a-new-first-row-and-shifting-cells","text":"The final task in GarlicSecrets.java is to add the \"Top Secret Garlic Changes\" text to the sheet again, this time as a visible title for the spreadsheet. The only new API feature used is the insertion of a row. This is done with: // in GarlicSecrets.java // add a new first row, and label it Calc . insertRow ( sheet , 0 ); addGarlicLabel ( doc , sheet , 0 ); The addGarlicLabel() method is unchanged from earlier, but is now passed row index 0 rather than the last row. The result is shown in Figure 10. Figure 10. The Sheet with a New Title Row. Calc.insertRow() manipulates a row as a cell range, so it's once again necessary to access the sheet's XColumnRowRange interface, to retrieve a TableRows object. The XTableRows interface supports the adding and removal of rows at specified index positions. This allows Calc.insertRow() to be coded as: // in the Calc class public static void insertRow ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableRows rows = crRange . getRows (); rows . insertByIndex ( idx , 1 ); // add 1 row at idx position } There's a similar Calc.insertCols() method that utilizes the XTableColumns interface: // in the Calc class public static void insertColumn ( XSpreadsheet sheet , int idx ) { XColumnRowRange crRange = Lo . qi ( XColumnRowRange . class , sheet ); XTableColumns cols = crRange . getColumns (); cols . insertByIndex ( idx , 1 ); // add 1 column at idx position } The insertion of an arbitrary number of blank cells into a sheet is a bit more complicated because existing cells must be 'moved' out of the way, and this can be done by moving them downwards or to the right. The shift-able cells are specified as a cell range, and the sheet's XCellRangeMovement interface moves them in a specific direction. XCellRangeMovement is supported by the Spreadsheet service. The Calc.insertCells() method implements this approach: // in the Calc class public static void insertCells ( XSpreadsheet sheet , XCellRange cellRange , boolean isShiftRight ) /* insert blank cells at cellRange, moving the existing ones to the right or down depending on the boolean argument */ { XCellRangeMovement mover = Lo . qi ( XCellRangeMovement . class , sheet ); CellRangeAddress addr = getAddress ( cellRange ); // cells to shift if ( isShiftRight ) // move right mover . insertCells ( addr , CellInsertMode . RIGHT ); else // or move down mover . insertCells ( addr , CellInsertMode . DOWN ); } // end of insertCells() An example call: XCellRange blanks = Calc . getCellRange ( sheet , \"A4999:B5001\" ); Calc . insertCells ( sheet , blanks , true ); // shift right This shifts the last three rows of the produce sheet (A4999:B5001) to the right by two cells, producing Figure 11. Figure 11. Shifted Cells at the end of the Produce Sheet.","title":"8.  Adding a New First Row and Shifting Cells"},{"location":"24-Complex_Data_Manipulation.html","text":"Chapter 24. Complex Data Manipulation \u00b6 Topics Sorting Data; Generating Data: Automatic, LINEAR Mode, DATE Mode, GROWTH Mode; Fancy Text: borders, headlines, hyperlinks, annotations Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at a variety of less common text manipulation techniques, including the sorting of data, generating data based on examples, and the use of borders, headlines, hyperlinks, and annotations in cells. 1. Sorting Data \u00b6 Sorting is available through SheetCellRange's XSortable interface. There are four basic steps required for sorting a block of cells: Obtain an XSortable interface for the cell range; Specify the sorting criteria as a TableSortField array; Create a sort descriptor; Execute the sort. These steps are illustrated by the DataSort.java example, which begins by building a small table: // in DataSort.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // create a table that needs sorting Object [][] vals = { { \"Level\" , \"Code\" , \"No.\" , \"Team\" , \"Name\" }, { \"BS\" , 20 , 4 , \"B\" , \"Elle\" }, { \"BS\" , 20 , 6 , \"C\" , \"Sweet\" }, { \"BS\" , 20 , 2 , \"A\" , \"Chcomic\" }, { \"CS\" , 30 , 5 , \"A\" , \"Ally\" }, { \"MS\" , 10 , 1 , \"A\" , \"Joker\" }, { \"MS\" , 10 , 3 , \"B\" , \"Kevin\" }, { \"CS\" , 30 , 7 , \"C\" , \"Tom\" } }; Calc . setArray ( sheet , \"A1:E8\" , vals ); // or just \"A1\" : // sorting code; explained below Lo . saveDoc ( doc , \"dataSort.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The unsorted table is shown in Figure 1. Figure 1. An Unsorted Table. The table is sorted so that its rows are in ascending order depending on their \"Code\" column values. When two rows have the same code number then the sort uses the \"No.\" column. Figure 2 shows the result of applying these two sorting criteria: Figure 2. The Sorted Table, Using Two Sort Criteria. The four sorting steps mentioned above are implemented like so: // in DataSort.java : // 1. obtain an XSortable interface for the cell range XCellRange sourceRange = Calc . getCellRange ( sheet , \"A1:E8\" ); XSortable xSort = Lo . qi ( XSortable . class , sourceRange ); // 2. specify the two sorting criteria as a TableSortField array TableSortField [] sortFields = new TableSortField [ 2 ] ; sortFields [ 0 ] = makeSortAsc ( 1 , true ); // sort by \"B\" col sortFields [ 1 ] = makeSortAsc ( 2 , true ); // then sort by \"C\" col // 3. define a sort descriptor PropertyValue [] props = Props . makeProps ( \"SortFields\" , sortFields , \"ContainsHeader\" , true ); Lo . wait ( 2000 ); //wait a bit so user can see original table before it's sorted System . out . println ( \"Sorting...\" ); xSort . sort ( props ); // 4. do the sort : The \"A1:E8\" cell range referenced using the XCellRange interface is converted to XSortable. This interface is defined in Office's util module, not in sheet or table, probably because it's also used in text documents for sorting tables. You can find its documentation by calling lodoc xsortable . The two sorting criteria are represented by two TableSortField objects in an array. The makeSortAsc() function is defined in DataSort.java as: // in DataSort.java private static TableSortField makeSortAsc ( int index , boolean isAscending ) // make a TableSortField object { TableSortField sf = new TableSortField (); sf . Field = index ; sf . IsAscending = isAscending ; // ascending or descending sf . IsCaseSensitive = false ; return sf ; } // end of makeSortAsc() A sort descriptor is an array of PropertyValue objects which affect how XSortable.sort() executes. The most commonly used properties are \"SortFields\" and \"ContainsHeader\". \"SortFields\" is assigned the sorting criteria (i.e. the TableSortField array), and the \"ContainsHeader\" boolean specifies whether the sort should exclude the first row because it contains header text. The sort descriptor properties are defined in a number of classes (SortDescriptor2, TableSortDescriptor2, and TextSortDescriptor2), which are most easily accessed from the XSortable documentation page. 2. Generating Data \u00b6 Cell data is generated by supplying numbers to a function which treats them as the initial values in a arithmetic (or geometric) series. The function employs the series to churn out as many more numbers as are needed to fill a given cell range. A series is created by the XCellSeries interface, which is part of the SheetCellRange service (see Figure 3). Figure 3. The Cell Range Services. Several examples of how to use XCellSeries' two methods, fillAuto() and fillSeries(), are contained in the Filler.java example described next. Filler.java starts by filling a blank sheet with an assortment of data, which will be used by the XCellSeries methods to initialize several series. The original sheet is shown in Figure 4. Figure 4. The Filler.java Sheet before Data Generation. The simpler of the two XCellSeries methods, XCellSeries.fillAuto(), requires a cell range, fill direction, and how many cells should be examined as 'seeds'. For example, rows 7, 8, and 9 of Figure 4 are filled using: // in fillSeries() in Filler.java : // store two values in three rows... // ascending integers: 1, 2 Calc . setVal ( sheet , \"A7\" , 1 ); Calc . setVal ( sheet , \"B7\" , 2 ); // dates, decreasing by month Calc . setDate ( sheet , \"A8\" , 28 , 2 , 2015 ); Calc . setDate ( sheet , \"B8\" , 28 , 1 , 2015 ); // descending integers: 6, 4 Calc . setVal ( sheet , \"A9\" , 6 ); Calc . setVal ( sheet , \"B9\" , 4 ); // get cell range series XCellSeries series = Calc . getCellSeries ( sheet , \"A7:G9\" ); // use first 2 cells for series, and fill to the right series . fillAuto ( FillDirection . TO_RIGHT , 2 ); The supplied cell range (A7:G9) includes the seed values, and the cells to be filled. It's converted into an XCellSeries interface by Calc.getCellSeries(), which is defined as: // in the Calc class public static XCellSeries getCellSeries ( XSpreadsheet sheet , String rangeName ) { XCellRange cellRange = sheet . getCellRangeByName ( rangeName ); return Lo . qi ( XCellSeries . class , cellRange ); } XCellSeries.fillAuto() can be supplied with four possible fill directions (TO_BOTTOM, TO_RIGHT, TO_TOP, and TO_LEFT) which also dictate which cells are examined for seeds. By setting the direction to be TO_RIGHT, seed cells in the left-hand parts of the rows are examined. The numerical argument (2) in the call to fillAuto() shown above specifies how many of those cells will be considered in order to automatically determine the series used for the generated cell values. Figure 5 shows the result of filling rows 7, 8, and 9. Figure 5. Row Filling Using XCellSeries.fillAuto(). If XCellSeries.fillAuto() doesn't guess the correct series for the data generation, then XCellSeries.fillSeries() offers finer control over the process. It supports five modes: SIMPLE, LINEAR , GROWTH, DATE, and AUTO. SIMPLE switches off the series generator, and the seed data is copied unchanged to the other blank cells. AUTO makes Office generate its data series automatically, so performs in the same way as fillAuto(). LINEAR , GROWTH, and DATE give more control to the programmer. 2.1. Using the LINEAR Mode \u00b6 Rows 2 and 3 of the spreadsheet contain the numbers 1 and 4 (see Figure 4). By using the LINEAR mode, a step, and a stopping value, it's possible to specify an arithmetic series. For example: // in fillSeries() in Filler.java : Calc . setVal ( sheet , \"A2\" , 1 ); Calc . setVal ( sheet , \"A3\" , 4 ); /* Fill 2 rows; the 2nd row is not filled completely since the end value is reached */ series = Calc . getCellSeries ( sheet , \"A2:E3\" ); series . fillSeries ( FillDirection . TO_RIGHT , FillMode . LINEAR , Calc . NO_DATE , 2 , 9 ); // ignore date mode; step == 2; end at 9 The Calc.NO_DATE argument means that dates are not being generated. The '2' value is the step, and '9' is the maximum. The resulting rows 2 and 3 are shown in Figure 6. Figure 6. Data Generation Using the LINEAR Mode. Note that the second row is incomplete since the generated values for those cells (10 and 12) exceeded the stopping value. If no stopping value is required, then the last argument can be replaced with Calc.MAX_VALUE. 2.2. Using the DATE Mode \u00b6 If XCellSeries.fillSeries() is called using the DATE mode then it's possible to specify whether the day, weekday, month, or year parts of the seed date are changed by the series. For example, the seed date at the start of row 4 (20 th Nov. 2015) can be incremented one month at a time with the code: // in fillSeries() in Filler.java : Calc . setDate ( sheet , \"A4\" , 20 , 11 , 2015 ); // day, month, year // fill by adding one month to date series = Calc . getCellSeries ( sheet , \"A4:E4\" ); series . fillSeries ( FillDirection . TO_RIGHT , FillMode . DATE , FillDateMode . FILL_DATE_MONTH , 1 , Calc . MAX_VALUE ); The result is shown in Figure 7. Figure 7. Data Generation Using the DATE Mode. When the month is incremented past 12, it resets to 1, and the year is incremented. 2.3. Using the GROWTH Mode \u00b6 Whereas the LINEAR mode is for creating arithmetic series (i.e. ones incrementing or decrementing in steps), GROWTH mode is for geometric progressions where the 'step' value is repeatedly multiplied to the seed. In the following example, the seed in \"G6\" (10; see Figure 7) is used in a geometric progression using multiples of 2. The series is placed in cells going up the sheet starting from \"G6\". The code: // in fillSeries() in Filler.java : Calc . setVal ( sheet , \"G6\" , 10 ); // Fill from bottom to top with a geometric series (*2) series = Calc . getCellSeries ( sheet , \"G2:G6\" ); series . fillSeries ( FillDirection . TO_TOP , FillMode . GROWTH , Calc . NO_DATE , 2 , Calc . MAX_VALUE ); The resulting sheet is shown in Figure 8. Figure 8. Data Generation Using the GROWTH Mode. 3. Cells with Fancy Text \u00b6 The CellsText.java example brings together a few techniques for manipulating text in cells, namely the addition of borders, headlines, hyperlinks, and annotations. The sheet ends up looking like Figure 9. Figure 9. Text manipulation in a Sheet. 3.1. Creating a Border and Headline \u00b6 CellTexts.java draws a decorative border and headline by calling: // in CellTexts.java Calc . highlightRange ( sheet , \"A2:C7\" , \"Cells and Cell Ranges\" ); Calc.highlightRange() adds a light blue border around the specified cell range (A2:C7), and the string argument is added to the top-left cell of the range. It's intended to be a headline, so is drawn in dark blue, and the entire top row is made light blue to match the border. The method is implemented as: // in the Calc class // some hex values for commonly used colors public static final int DARK_BLUE = 0x003399 ; public static final int LIGHT_BLUE = 0x99CCFF ; public static void highlightRange ( XSpreadsheet sheet , String rangeName , String headline ) { Calc . addBorder ( sheet , rangeName , LIGHT_BLUE ); // color the headline row CellRangeAddress addr = Calc . getAddress ( sheet , rangeName ); XCellRange headerRange = getCellRange ( sheet , addr . StartColumn , addr . StartRow , addr . EndColumn , addr . StartRow ); Props . setProperty ( headerRange , \"CellBackColor\" , LIGHT_BLUE ); // add headline text to the first cell of the row XCell firstCell = getCell ( headerRange , 0 , 0 ); // location is relative to range setVal ( firstCell , headline ); // make text dark blue and bold Props . setProperty ( firstCell , \"CharColor\" , DARK_BLUE ); Props . setProperty ( firstCell , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); } // end of highlightRange() The three-argument addBorder() method calls the four-argument version which was described back in Chapter 22, section 2.3. It passes it a bitwise composition of all the border constants: // in the Calc class public static void addBorder ( XSpreadsheet sheet , String rangeName , int color ) { addBorder ( sheet , rangeName , Calc . LEFT_BORDER | Calc . RIGHT_BORDER | Calc . TOP_BORDER | Calc . BOTTOM_BORDER , color ); } The cell range for the top row is extracted from the larger range supplied to Calc.highlightRange(). The easiest way of doing this is to get the address of the larger range as a CellRangeAddress object, and use its row and column positions. The header cell range uses the same row index for its starting and finishing rows: // part of Calc.highlightRange() : CellRangeAddress addr = Calc . getAddress ( sheet , rangeName ); XCellRange headerRange = getCellRange ( sheet , addr . StartColumn , addr . StartRow , addr . EndColumn , addr . StartRow ); // header row uses same start and end row from addr Perhaps the most confusing part of Calc.highlightRange() is how the first cell of the header range is referenced: XCell firstCell = getCell ( headerRange , 0 , 0 ); This is a somewhat different use of getCell() than previous examples, which have always found a cell within a sheet. For instance: XCell cell = Calc . getCell ( sheet , 0 , 0 ); The definition for this version of getCell() is: // in the Calc class public static XCell getCell ( XCellRange cellRange , int column , int row ) { try { return cellRange . getCellByPosition ( column , row ); } catch ( Exception e ) { System . out . println ( \"Could not access cell in at: \" + column + \" - \" + row ); return null ; } } // end of getCell() A position in a cell range (e.g. a (column, row) coordinate) is defined relative to the cell range. This means that the call: XCell firstCell = getCell(headerRange, 0, 0); is requesting the top-left cell in headerRange. Since the headerRange covers A2:C2, (0, 0) means the \"A2\" cell. 3.2. Adding Hyperlink Text \u00b6 Figure 9 shows that the \"B4\" cell contains two paragraphs. The second ends with a hyperlink, which means that if the user control-clicks on the \"hypertext\" text, then the URL \" https://fivedots.coe.psu.ac.th/~ad/jlop/ \" is opened in the OSes default web browser. The SheetCell service inherits the Cell service which allows a cell to be manipulated with the XCell or the XText interfaces (see Figure 10). Figure 10. The SheetCell Services and Interfaces. Once the cell is converted into XText, many of my Writer support methods can be utilized. For example: // in CellTexts.java : // Insert two text paragraphs and a hyperlink into the cell XText xText = Lo . qi ( XText . class , xCell ); // cell \uf0e0 text XTextCursor cursor = xText . createTextCursor (); Write . appendPara ( cursor , \"Text in first line.\" ); Write . append ( cursor , \"And a \" ); Write . addHyperlink ( cursor , \"hyperlink\" , \"https://fivedots.coe.psu.ac.th/~ad/jlop/\" ); A text cursor is created for the cell, and used to add the two paragraphs and the hyperlink. Cell formatting is done through its properties. As Figure 10 shows, the SheetCell service inherits the CharacterProperties and ParagraphProperties classes, which contain the properties related to cell text: // in CellTexts.java : // beautify the cell with big, blue, indented text // properties from CharacterProperties Props . setProperty ( xCell , \"CharHeight\" , 20.0 ); Props . setProperty ( xCell , \"CharColor\" , Calc . DARK_BLUE ); // property from ParagraphProperties Props . setProperty ( xCell , \"ParaLeftMargin\" , 500 ); 3.3. Printing the Cell's Text \u00b6 The cell's text is accessed via its XText interface: // in CellTexts.java private static void printCellText ( XCell xCell ) { XText xText = Lo . qi ( XText . class , xCell ); System . out . println ( \"Cell Text: \\\"\" + xText . getString () + \"\\\"\" ); : // more code, explained below } The call to XText.getString() returns all the text, which is printed as: Cell Text: \"Text in first line. And a hypertext\" The text can also be examined by moving a text cursor through it: XTextCursor cursor = xText . createTextCursor (); However, I was surprised to discover that this text cursor can not be converted into a sentence or paragraph cursor. Both the following calls return null: XSentenceCursor sentCursor = Lo . qi ( XSentenceCursor . class , cursor ); XParagraphCursor paraCursor = Lo . qi ( XParagraphCursor . class , cursor ); 3.4. Adding an Annotation \u00b6 Cells can be annotated, which causes a little yellow text box to appear near the cell, linked to the cell by an arrow (as in Figure 9). Creating a new annotation is a two-step process: the XSheetAnnotationsSupplier interface is used to access the collection of existing annotations, and a new one is added by supplying the annotation text and the address of the cell where its arrow will point. These steps are performed by the first half of Calc.addAnnotation(): // in the Calc class public static void addAnnotation ( XSpreadsheet sheet , String cellName , String msg ) { // get the existing annotations CellAddress addr = getCellAddress ( sheet , cellName ); XSheetAnnotationsSupplier annsSupp = Lo . qi ( XSheetAnnotationsSupplier . class , sheet ); XSheetAnnotations anns = annsSupp . getAnnotations (); anns . insertNew ( addr , msg ); // add the new annotation // get a reference to the new annotation XCell xCell = getCell ( sheet , cellName ); XSheetAnnotationAnchor annAnchor = Lo . qi ( XSheetAnnotationAnchor . class , xCell ); XSheetAnnotation ann = annAnchor . getAnnotation (); ann . setIsVisible ( true ); // make annotation visible } // end of addAnnotation() Annotation creation doesn't return a reference to the new annotation object. For that it's necessary to examine the cell pointed to by the annotation. XCell is converted into a XSheetAnnotationAnchor, which has a getAnnotation() method for returning the annotation (if one exists). XSheetAnnotation has several methods for obtaining information about the position, author, and modification date of the annotation. setIsVisible() allows its visibility to be switched on and off.","title":"Chapter 24. Complex Data Manipulation"},{"location":"24-Complex_Data_Manipulation.html#chapter-24-complex-data-manipulation","text":"Topics Sorting Data; Generating Data: Automatic, LINEAR Mode, DATE Mode, GROWTH Mode; Fancy Text: borders, headlines, hyperlinks, annotations Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at a variety of less common text manipulation techniques, including the sorting of data, generating data based on examples, and the use of borders, headlines, hyperlinks, and annotations in cells.","title":"Chapter 24. Complex Data Manipulation"},{"location":"24-Complex_Data_Manipulation.html#1-sorting-data","text":"Sorting is available through SheetCellRange's XSortable interface. There are four basic steps required for sorting a block of cells: Obtain an XSortable interface for the cell range; Specify the sorting criteria as a TableSortField array; Create a sort descriptor; Execute the sort. These steps are illustrated by the DataSort.java example, which begins by building a small table: // in DataSort.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // create a table that needs sorting Object [][] vals = { { \"Level\" , \"Code\" , \"No.\" , \"Team\" , \"Name\" }, { \"BS\" , 20 , 4 , \"B\" , \"Elle\" }, { \"BS\" , 20 , 6 , \"C\" , \"Sweet\" }, { \"BS\" , 20 , 2 , \"A\" , \"Chcomic\" }, { \"CS\" , 30 , 5 , \"A\" , \"Ally\" }, { \"MS\" , 10 , 1 , \"A\" , \"Joker\" }, { \"MS\" , 10 , 3 , \"B\" , \"Kevin\" }, { \"CS\" , 30 , 7 , \"C\" , \"Tom\" } }; Calc . setArray ( sheet , \"A1:E8\" , vals ); // or just \"A1\" : // sorting code; explained below Lo . saveDoc ( doc , \"dataSort.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The unsorted table is shown in Figure 1. Figure 1. An Unsorted Table. The table is sorted so that its rows are in ascending order depending on their \"Code\" column values. When two rows have the same code number then the sort uses the \"No.\" column. Figure 2 shows the result of applying these two sorting criteria: Figure 2. The Sorted Table, Using Two Sort Criteria. The four sorting steps mentioned above are implemented like so: // in DataSort.java : // 1. obtain an XSortable interface for the cell range XCellRange sourceRange = Calc . getCellRange ( sheet , \"A1:E8\" ); XSortable xSort = Lo . qi ( XSortable . class , sourceRange ); // 2. specify the two sorting criteria as a TableSortField array TableSortField [] sortFields = new TableSortField [ 2 ] ; sortFields [ 0 ] = makeSortAsc ( 1 , true ); // sort by \"B\" col sortFields [ 1 ] = makeSortAsc ( 2 , true ); // then sort by \"C\" col // 3. define a sort descriptor PropertyValue [] props = Props . makeProps ( \"SortFields\" , sortFields , \"ContainsHeader\" , true ); Lo . wait ( 2000 ); //wait a bit so user can see original table before it's sorted System . out . println ( \"Sorting...\" ); xSort . sort ( props ); // 4. do the sort : The \"A1:E8\" cell range referenced using the XCellRange interface is converted to XSortable. This interface is defined in Office's util module, not in sheet or table, probably because it's also used in text documents for sorting tables. You can find its documentation by calling lodoc xsortable . The two sorting criteria are represented by two TableSortField objects in an array. The makeSortAsc() function is defined in DataSort.java as: // in DataSort.java private static TableSortField makeSortAsc ( int index , boolean isAscending ) // make a TableSortField object { TableSortField sf = new TableSortField (); sf . Field = index ; sf . IsAscending = isAscending ; // ascending or descending sf . IsCaseSensitive = false ; return sf ; } // end of makeSortAsc() A sort descriptor is an array of PropertyValue objects which affect how XSortable.sort() executes. The most commonly used properties are \"SortFields\" and \"ContainsHeader\". \"SortFields\" is assigned the sorting criteria (i.e. the TableSortField array), and the \"ContainsHeader\" boolean specifies whether the sort should exclude the first row because it contains header text. The sort descriptor properties are defined in a number of classes (SortDescriptor2, TableSortDescriptor2, and TextSortDescriptor2), which are most easily accessed from the XSortable documentation page.","title":"1.  Sorting Data"},{"location":"24-Complex_Data_Manipulation.html#2-generating-data","text":"Cell data is generated by supplying numbers to a function which treats them as the initial values in a arithmetic (or geometric) series. The function employs the series to churn out as many more numbers as are needed to fill a given cell range. A series is created by the XCellSeries interface, which is part of the SheetCellRange service (see Figure 3). Figure 3. The Cell Range Services. Several examples of how to use XCellSeries' two methods, fillAuto() and fillSeries(), are contained in the Filler.java example described next. Filler.java starts by filling a blank sheet with an assortment of data, which will be used by the XCellSeries methods to initialize several series. The original sheet is shown in Figure 4. Figure 4. The Filler.java Sheet before Data Generation. The simpler of the two XCellSeries methods, XCellSeries.fillAuto(), requires a cell range, fill direction, and how many cells should be examined as 'seeds'. For example, rows 7, 8, and 9 of Figure 4 are filled using: // in fillSeries() in Filler.java : // store two values in three rows... // ascending integers: 1, 2 Calc . setVal ( sheet , \"A7\" , 1 ); Calc . setVal ( sheet , \"B7\" , 2 ); // dates, decreasing by month Calc . setDate ( sheet , \"A8\" , 28 , 2 , 2015 ); Calc . setDate ( sheet , \"B8\" , 28 , 1 , 2015 ); // descending integers: 6, 4 Calc . setVal ( sheet , \"A9\" , 6 ); Calc . setVal ( sheet , \"B9\" , 4 ); // get cell range series XCellSeries series = Calc . getCellSeries ( sheet , \"A7:G9\" ); // use first 2 cells for series, and fill to the right series . fillAuto ( FillDirection . TO_RIGHT , 2 ); The supplied cell range (A7:G9) includes the seed values, and the cells to be filled. It's converted into an XCellSeries interface by Calc.getCellSeries(), which is defined as: // in the Calc class public static XCellSeries getCellSeries ( XSpreadsheet sheet , String rangeName ) { XCellRange cellRange = sheet . getCellRangeByName ( rangeName ); return Lo . qi ( XCellSeries . class , cellRange ); } XCellSeries.fillAuto() can be supplied with four possible fill directions (TO_BOTTOM, TO_RIGHT, TO_TOP, and TO_LEFT) which also dictate which cells are examined for seeds. By setting the direction to be TO_RIGHT, seed cells in the left-hand parts of the rows are examined. The numerical argument (2) in the call to fillAuto() shown above specifies how many of those cells will be considered in order to automatically determine the series used for the generated cell values. Figure 5 shows the result of filling rows 7, 8, and 9. Figure 5. Row Filling Using XCellSeries.fillAuto(). If XCellSeries.fillAuto() doesn't guess the correct series for the data generation, then XCellSeries.fillSeries() offers finer control over the process. It supports five modes: SIMPLE, LINEAR , GROWTH, DATE, and AUTO. SIMPLE switches off the series generator, and the seed data is copied unchanged to the other blank cells. AUTO makes Office generate its data series automatically, so performs in the same way as fillAuto(). LINEAR , GROWTH, and DATE give more control to the programmer.","title":"2.  Generating Data"},{"location":"24-Complex_Data_Manipulation.html#21-using-the-linear-mode","text":"Rows 2 and 3 of the spreadsheet contain the numbers 1 and 4 (see Figure 4). By using the LINEAR mode, a step, and a stopping value, it's possible to specify an arithmetic series. For example: // in fillSeries() in Filler.java : Calc . setVal ( sheet , \"A2\" , 1 ); Calc . setVal ( sheet , \"A3\" , 4 ); /* Fill 2 rows; the 2nd row is not filled completely since the end value is reached */ series = Calc . getCellSeries ( sheet , \"A2:E3\" ); series . fillSeries ( FillDirection . TO_RIGHT , FillMode . LINEAR , Calc . NO_DATE , 2 , 9 ); // ignore date mode; step == 2; end at 9 The Calc.NO_DATE argument means that dates are not being generated. The '2' value is the step, and '9' is the maximum. The resulting rows 2 and 3 are shown in Figure 6. Figure 6. Data Generation Using the LINEAR Mode. Note that the second row is incomplete since the generated values for those cells (10 and 12) exceeded the stopping value. If no stopping value is required, then the last argument can be replaced with Calc.MAX_VALUE.","title":"2.1.  Using the LINEAR Mode"},{"location":"24-Complex_Data_Manipulation.html#22-using-the-date-mode","text":"If XCellSeries.fillSeries() is called using the DATE mode then it's possible to specify whether the day, weekday, month, or year parts of the seed date are changed by the series. For example, the seed date at the start of row 4 (20 th Nov. 2015) can be incremented one month at a time with the code: // in fillSeries() in Filler.java : Calc . setDate ( sheet , \"A4\" , 20 , 11 , 2015 ); // day, month, year // fill by adding one month to date series = Calc . getCellSeries ( sheet , \"A4:E4\" ); series . fillSeries ( FillDirection . TO_RIGHT , FillMode . DATE , FillDateMode . FILL_DATE_MONTH , 1 , Calc . MAX_VALUE ); The result is shown in Figure 7. Figure 7. Data Generation Using the DATE Mode. When the month is incremented past 12, it resets to 1, and the year is incremented.","title":"2.2.  Using the DATE Mode"},{"location":"24-Complex_Data_Manipulation.html#23-using-the-growth-mode","text":"Whereas the LINEAR mode is for creating arithmetic series (i.e. ones incrementing or decrementing in steps), GROWTH mode is for geometric progressions where the 'step' value is repeatedly multiplied to the seed. In the following example, the seed in \"G6\" (10; see Figure 7) is used in a geometric progression using multiples of 2. The series is placed in cells going up the sheet starting from \"G6\". The code: // in fillSeries() in Filler.java : Calc . setVal ( sheet , \"G6\" , 10 ); // Fill from bottom to top with a geometric series (*2) series = Calc . getCellSeries ( sheet , \"G2:G6\" ); series . fillSeries ( FillDirection . TO_TOP , FillMode . GROWTH , Calc . NO_DATE , 2 , Calc . MAX_VALUE ); The resulting sheet is shown in Figure 8. Figure 8. Data Generation Using the GROWTH Mode.","title":"2.3.  Using the GROWTH Mode"},{"location":"24-Complex_Data_Manipulation.html#3-cells-with-fancy-text","text":"The CellsText.java example brings together a few techniques for manipulating text in cells, namely the addition of borders, headlines, hyperlinks, and annotations. The sheet ends up looking like Figure 9. Figure 9. Text manipulation in a Sheet.","title":"3.  Cells with Fancy Text"},{"location":"24-Complex_Data_Manipulation.html#31-creating-a-border-and-headline","text":"CellTexts.java draws a decorative border and headline by calling: // in CellTexts.java Calc . highlightRange ( sheet , \"A2:C7\" , \"Cells and Cell Ranges\" ); Calc.highlightRange() adds a light blue border around the specified cell range (A2:C7), and the string argument is added to the top-left cell of the range. It's intended to be a headline, so is drawn in dark blue, and the entire top row is made light blue to match the border. The method is implemented as: // in the Calc class // some hex values for commonly used colors public static final int DARK_BLUE = 0x003399 ; public static final int LIGHT_BLUE = 0x99CCFF ; public static void highlightRange ( XSpreadsheet sheet , String rangeName , String headline ) { Calc . addBorder ( sheet , rangeName , LIGHT_BLUE ); // color the headline row CellRangeAddress addr = Calc . getAddress ( sheet , rangeName ); XCellRange headerRange = getCellRange ( sheet , addr . StartColumn , addr . StartRow , addr . EndColumn , addr . StartRow ); Props . setProperty ( headerRange , \"CellBackColor\" , LIGHT_BLUE ); // add headline text to the first cell of the row XCell firstCell = getCell ( headerRange , 0 , 0 ); // location is relative to range setVal ( firstCell , headline ); // make text dark blue and bold Props . setProperty ( firstCell , \"CharColor\" , DARK_BLUE ); Props . setProperty ( firstCell , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); } // end of highlightRange() The three-argument addBorder() method calls the four-argument version which was described back in Chapter 22, section 2.3. It passes it a bitwise composition of all the border constants: // in the Calc class public static void addBorder ( XSpreadsheet sheet , String rangeName , int color ) { addBorder ( sheet , rangeName , Calc . LEFT_BORDER | Calc . RIGHT_BORDER | Calc . TOP_BORDER | Calc . BOTTOM_BORDER , color ); } The cell range for the top row is extracted from the larger range supplied to Calc.highlightRange(). The easiest way of doing this is to get the address of the larger range as a CellRangeAddress object, and use its row and column positions. The header cell range uses the same row index for its starting and finishing rows: // part of Calc.highlightRange() : CellRangeAddress addr = Calc . getAddress ( sheet , rangeName ); XCellRange headerRange = getCellRange ( sheet , addr . StartColumn , addr . StartRow , addr . EndColumn , addr . StartRow ); // header row uses same start and end row from addr Perhaps the most confusing part of Calc.highlightRange() is how the first cell of the header range is referenced: XCell firstCell = getCell ( headerRange , 0 , 0 ); This is a somewhat different use of getCell() than previous examples, which have always found a cell within a sheet. For instance: XCell cell = Calc . getCell ( sheet , 0 , 0 ); The definition for this version of getCell() is: // in the Calc class public static XCell getCell ( XCellRange cellRange , int column , int row ) { try { return cellRange . getCellByPosition ( column , row ); } catch ( Exception e ) { System . out . println ( \"Could not access cell in at: \" + column + \" - \" + row ); return null ; } } // end of getCell() A position in a cell range (e.g. a (column, row) coordinate) is defined relative to the cell range. This means that the call: XCell firstCell = getCell(headerRange, 0, 0); is requesting the top-left cell in headerRange. Since the headerRange covers A2:C2, (0, 0) means the \"A2\" cell.","title":"3.1.  Creating a Border and Headline"},{"location":"24-Complex_Data_Manipulation.html#32-adding-hyperlink-text","text":"Figure 9 shows that the \"B4\" cell contains two paragraphs. The second ends with a hyperlink, which means that if the user control-clicks on the \"hypertext\" text, then the URL \" https://fivedots.coe.psu.ac.th/~ad/jlop/ \" is opened in the OSes default web browser. The SheetCell service inherits the Cell service which allows a cell to be manipulated with the XCell or the XText interfaces (see Figure 10). Figure 10. The SheetCell Services and Interfaces. Once the cell is converted into XText, many of my Writer support methods can be utilized. For example: // in CellTexts.java : // Insert two text paragraphs and a hyperlink into the cell XText xText = Lo . qi ( XText . class , xCell ); // cell \uf0e0 text XTextCursor cursor = xText . createTextCursor (); Write . appendPara ( cursor , \"Text in first line.\" ); Write . append ( cursor , \"And a \" ); Write . addHyperlink ( cursor , \"hyperlink\" , \"https://fivedots.coe.psu.ac.th/~ad/jlop/\" ); A text cursor is created for the cell, and used to add the two paragraphs and the hyperlink. Cell formatting is done through its properties. As Figure 10 shows, the SheetCell service inherits the CharacterProperties and ParagraphProperties classes, which contain the properties related to cell text: // in CellTexts.java : // beautify the cell with big, blue, indented text // properties from CharacterProperties Props . setProperty ( xCell , \"CharHeight\" , 20.0 ); Props . setProperty ( xCell , \"CharColor\" , Calc . DARK_BLUE ); // property from ParagraphProperties Props . setProperty ( xCell , \"ParaLeftMargin\" , 500 );","title":"3.2.  Adding Hyperlink Text"},{"location":"24-Complex_Data_Manipulation.html#33-printing-the-cells-text","text":"The cell's text is accessed via its XText interface: // in CellTexts.java private static void printCellText ( XCell xCell ) { XText xText = Lo . qi ( XText . class , xCell ); System . out . println ( \"Cell Text: \\\"\" + xText . getString () + \"\\\"\" ); : // more code, explained below } The call to XText.getString() returns all the text, which is printed as: Cell Text: \"Text in first line. And a hypertext\" The text can also be examined by moving a text cursor through it: XTextCursor cursor = xText . createTextCursor (); However, I was surprised to discover that this text cursor can not be converted into a sentence or paragraph cursor. Both the following calls return null: XSentenceCursor sentCursor = Lo . qi ( XSentenceCursor . class , cursor ); XParagraphCursor paraCursor = Lo . qi ( XParagraphCursor . class , cursor );","title":"3.3.  Printing the Cell's Text"},{"location":"24-Complex_Data_Manipulation.html#34-adding-an-annotation","text":"Cells can be annotated, which causes a little yellow text box to appear near the cell, linked to the cell by an arrow (as in Figure 9). Creating a new annotation is a two-step process: the XSheetAnnotationsSupplier interface is used to access the collection of existing annotations, and a new one is added by supplying the annotation text and the address of the cell where its arrow will point. These steps are performed by the first half of Calc.addAnnotation(): // in the Calc class public static void addAnnotation ( XSpreadsheet sheet , String cellName , String msg ) { // get the existing annotations CellAddress addr = getCellAddress ( sheet , cellName ); XSheetAnnotationsSupplier annsSupp = Lo . qi ( XSheetAnnotationsSupplier . class , sheet ); XSheetAnnotations anns = annsSupp . getAnnotations (); anns . insertNew ( addr , msg ); // add the new annotation // get a reference to the new annotation XCell xCell = getCell ( sheet , cellName ); XSheetAnnotationAnchor annAnchor = Lo . qi ( XSheetAnnotationAnchor . class , xCell ); XSheetAnnotation ann = annAnchor . getAnnotation (); ann . setIsVisible ( true ); // make annotation visible } // end of addAnnotation() Annotation creation doesn't return a reference to the new annotation object. For that it's necessary to examine the cell pointed to by the annotation. XCell is converted into a XSheetAnnotationAnchor, which has a getAnnotation() method for returning the annotation (if one exists). XSheetAnnotation has several methods for obtaining information about the position, author, and modification date of the annotation. setIsVisible() allows its visibility to be switched on and off.","title":"3.4.  Adding an Annotation"},{"location":"25-Monitoring_Sheets.html","text":"Chapter 25. Monitoring Sheets \u00b6 Topics Listening for Document Modifications (XModifyListener); Listening for Application Closing (XTopWindowListener); Listening for Cell Selection (XSelectionChangeListe ner) Example folders: \"Calc Tests\" and \"Utils\" The chapter looks at three kinds of listeners for spreadsheets: document modification, application closing, and cell selection listeners. Office's support for listeners was first described back in Chapter 4. 1. Listening for the User's Modifications \u00b6 A common requirement for spreadsheet programming is controlling how the user interacts with the sheet's data. In the extreme case, this might mean preventing the user from changing anything, which is possible through the XProtectable interface discussed in Chapter 20, section 1.1. But often we want to let the user edit the sheet, but monitor what is being changed. One way of doing this is to attach a XModifyListener interface to the open document so that its modified() method will be triggered whenever a cell is changed. ModifyListener.java illustrates this approach: // in ModifyListener.java public class ModifyListener implements XModifyListener { private XSpreadsheetDocument doc ; private XSpreadsheet sheet ; public ModifyListener () { XComponentLoader loader = Lo . loadOffice (); doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); sheet = Calc . getSheet ( doc , 0 ); // insert some data Calc . setCol ( sheet , \"A1\" , new Object [] { \"Smith\" , 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 }); // listen for cell modifications XModifyBroadcaster mb = Lo . qi ( XModifyBroadcaster . class , doc ); mb . addModifyListener ( this ); // close down when window close box is clicked XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { System . out . println ( \"Closing\" ); Lo . saveDoc ( doc , \"modify.ods\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } }); } // end of ModifyListener() // ----- XModifyListener methods ------ public void disposing ( EventObject event ) { System . out . println ( \"Disposing\" ); } public void modified ( EventObject event ) { // called whenever a cell is modified; // the code in this method is explained below } // ------------------------------------ public static void main ( String args [] ) { new ModifyListener (); } } // end of ModifyListener class 1.1. Listening to the Close Box \u00b6 main() creates a ModifyListener object and then terminates, which means that the object must deal with the closing of the spreadsheet and the termination of Office. This is done by employing another listener: an adapter for XTopWindowListener, called XTopWindowAdapter, attached to the Calc application's close box: // in ModifyListener.java : XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { /* called whenever the appl. is closed */ } } XTopWindowListener was described in Chapter 4, section 1, but XTopWindowAdapter is one of my support classes. XTopWindowListener defines eight methods, called when the application window is in different states: opened, activated, deactivated, minimized, normalized, closing, closed, and disposed. XTopWindowAdapter supplies empty implementations for those methods: // in Utils/XTopWindowAdapter.java public class XTopWindowAdapter implements XTopWindowListener { public XTopWindowAdapter (){} public void windowOpened ( EventObject event ){} public void windowActivated ( EventObject event ){} public void windowDeactivated ( EventObject event ){} public void windowMinimized ( EventObject event ) {} public void windowNormalized ( EventObject event ){} public void windowClosing ( EventObject event ){} public void windowClosed ( EventObject event ){} public void disposing ( EventObject event ){} } // end of XTopWindowAdapter class ModifyListener.java overides XTopWindowAdapter's windowClosing(), but leaves the other methods unchanged. windowClosing() is triggered when the application's close box is clicked, and it responds by saving the document, then closes it and Office: // in ModifyListener.java : tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { System . out . println ( \"Closing\" ); Lo . saveDoc ( doc , \"modify.ods\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } } 1.2. Listening for Modifications \u00b6 ModifyListener is notified of document changes by attaching itself to the document's XModifyBroadcaster: // in ModifyListener.java : // listen for cell modifications XModifyBroadcaster mb = Lo . qi ( XModifyBroadcaster . class , doc ); mb . addModifyListener ( this ); A look at the documentation for XModifyListener (use lodoc XModifyListener) shows that it defines a modified() method, and inherits disposing() from XEventListener. ModifyListener implements both of these, although disposing() only prints a message. ModifyListener.modified() does something useful: // in ModifyListener.java : // global variables private XSpreadsheetDocument doc ; private XSpreadsheet sheet ; public void modified ( EventObject event ) // called whenever a cell is modified { // System.out.println(\"Modified: \" + event.Source); // Info.showServices(\"Event source\", event.Source); // XSpreadsheetDocument doc = // Lo.qi(XSpreadsheetDocument.class, event.Source); CellAddress addr = Calc . getSelectedCellAddr ( doc ); System . out . println ( \" \" + Calc . getCellStr ( addr ) + \" = \" + Calc . getVal ( sheet , addr )); } // end of modified() An event object arriving at modified() contains a Source field of type XInterface. Every Office interface inherits XInterface so it's difficult to know what the source really is. The simplest solution is to print the names of the source's supported services, by calling Info.showServices(), as in the commented-out code above. In this case, the Source field is supported by the SpreadsheetDocument service, which means that it can be converted into an XSpreadsheetDocument interface. Lots of useful things can be accessed through this interface, but that's also commented-out because I can utilize the document via the global variable, doc. 1.3. Examining the Changed Cell (or Cells) \u00b6 While modified() is being executed, the modified cell in the document is still selected (or active), and so can be retrieved: // in modified() ... CellAddress addr = Calc . getSelectedCellAddr ( doc ); Calc.getSelectedCellAddr() needs the XModel interface for the document so that XModel.getCurrentSelection() can be called. It also has to handle the possibility that a cell range is currently selected rather than a single cell: // in the Calc class public static CellAddress getSelectedCellAddr ( XSpreadsheetDocument doc ) // return address of selected cell in document; // returns null if a cell range is selected { // get address of selected cell range CellRangeAddress crAddr = getSelectedAddr ( doc ); // if cell range is a single cell CellAddress addr = null ; if ( Calc . isSingleCellRange ( crAddr )) { XSpreadsheet sheet = getActiveSheet ( doc ); XCell cell = Calc . getCell ( sheet , crAddr . StartColumn , crAddr . StartRow ); // access the cell using the cell range position addr = Calc . getCellAddress ( cell ); // get address of selected cell } return addr ; } // end of getSelectedCellAddr() public static CellRangeAddress getSelectedAddr ( XSpreadsheetDocument doc ) { // look for selected address in document's model XModel model = Lo . qi ( XModel . class , doc ); return getSelectedAddr ( model ); } public static CellRangeAddress getSelectedAddr ( XModel model ) // return address of selected cell range in the model { if ( model == null ) { System . out . println ( \"No document model found\" ); return null ; } XCellRangeAddressable ra = Lo . qi ( XCellRangeAddressable . class , model . getCurrentSelection ()); if ( ra != null ) return ra . getRangeAddress (); else { System . out . println ( \"No range address found\" ); return null ; } } // end of getSelectedAddr() Calc.getSelectedCellAddr() utilizes Calc.getSelectedAddr(), which returns the address of the selected cell range. Calc.getSelectedCellAddr() examines this cell range to see if it's really just a single cell by calling Calc.isSingleCellRange(): // in the Calc class public static boolean isSingleCellRange ( CellRangeAddress addr ) { return (( addr . StartColumn == addr . EndColumn ) && ( addr . StartRow == addr . EndRow )); } If the cell range is referencing a cell then the cell range address position is used to directly access the cell in the sheet: // in Calc.getSelectedCellAddr() : XSpreadsheet sheet = getActiveSheet ( doc ); XCell cell = Calc . getCell ( sheet , crAddr . StartColumn , crAddr . StartRow ); This requires the current active sheet, which is obtained through Calc.getActiveSheet(). 1.4. Problems with the modified() Method \u00b6 After all this coding, the bad news is that modified() is still lacking in functionality. One minor problem is that modified() is called twice when the user finishes editing a cell. This occurs when the user presses enter, or tab, or an arrow key, and for reasons I don't understand. It could be fixed with some judicious hacking: e.g. by using a counter to control when the code is executed. A more important concern is that modified() only has access to the new value in the cell, but doesn't know what was overwritten, which would be very useful for implementing data validation. This led me to investigate another form of listening, based on cell selection, which is described next. 2. Listening for Cell Selections \u00b6 Listening to cell selections on the sheet has the drawback of generating a lot of events, but this abundance of data turns out to be useful; I can use it to report more about cell modifications. The SelectListener.java example is similar to ModifyListener.java except that it implements XSelectionChangeListener rather than XModifyListener: // in SelectListener.java public class SelectListener implements XSelectionChangeListener { private XSpreadsheetDocument doc ; private XSpreadsheet sheet ; // selected cell's current address and numeric value private CellAddress currAddr ; private Double currVal = null ; public SelectListener () { XComponentLoader loader = Lo . loadOffice (); doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); sheet = Calc . getSheet ( doc , 0 ); // initialize selected cell's current address and value currAddr = Calc . getSelectedCellAddr ( doc ); currVal = getCellDouble ( sheet , currAddr ); // may be null attachListener ( doc ); // listen for cell selections // insert some data Calc . setCol ( sheet , \"A1\" , new Object [] { \"Smith\" , 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 }); // close down when window close box is clicked XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { System . out . println ( \"Closing\" ); Lo . saveDoc ( doc , \"select.ods\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } }); } // end of SelectListener() SelectListener.java employs four globals instead of the two in ModifyListener: the document and sheet variables are joined by variables holding the address of the currently selected cell (currAddr) and its numerical value (currVal). If the cell doesn't contain a double then currVal is assigned null. currAddr and currVal are initialized after the document is first created, and are updated whenever the user changes a cell. attachListener() is called to attach the listener to the document: // in SelectListener.java private void attachListener ( XSpreadsheetDocument doc ) { // get selection supplier for document XController ctrl = Calc . getController ( doc ); XSelectionSupplier supp = Lo . qi ( XSelectionSupplier . class , ctrl ); if ( supp == null ) System . out . println ( \"Could not attach selection listener\" ); else // make \"this\" object a selection listener supp . addSelectionChangeListener ( this ); } // end of attachListener() The document's controller is changed to an XSelectionSupplier interface so its addSelectionChangeListener() method can be called. The XSelectionChangeListener interface defines disposing() and selectionChanged() (see lodoc XSelectionChangeListener for details). selectionChanged() listens for three kinds of changes in the sheet: it reports when the selected cell changes by printing the name of the previous cell and the newly selected one; it reports whether the cell that has just lost focus now has a value different from when it was selected; it reports if the newly selected cell contains a numerical value. For example, Figure 1 shows the initial sheet of data created by SelectListener: Figure 1. The Sheet of Data in SelectListener.java Note that the selected cell when the sheet is first created is \"A1\". If the user carries out the following operations: click in cell \"B2\" click in cell \"A4\" click in \"A5\" change \"A5 to 4 and press tab then the sheet will end up looking like Figure 2, with \"B5\" being the selected cell. Figure 2. The Modified Sheet in SelectListener.java During these changes, selectionChanged() will report: A1 --> B2 B2 --> A4 A4 value : - 66.5 A4 --> A5 A5 value : 43.4 A5 --> B5 A5 has changed from 43.4 to 4.0 The \"\u2192\" lines note cell selection changes. The \"value\" lines state the value of a cell when it's first selected, and the \"changed\" lines report whether the cell was left changed when the focus moved to another cell. The output from selectionChanged() shown above shows how the user moved around the spreadsheet, and changed the \"A5\" cell's contents from 43.4 to 4. selectionChanged() is defined as: // in SelectListener.java // globals private CellAddress currAddr ; private Double currVal = null ; public void selectionChanged ( EventObject event ) { XController ctrl = Lo . qi ( XController . class , event . Source ); if ( ctrl == null ){ System . out . println ( \"No ctrl for event source\" ); return ; } // get address of currently selected cell CellAddress addr = Calc . getSelectedCellAddr ( doc ); if ( addr == null ) return ; // is this different from the stored selected address? if ( ! Calc . isEqualAddresses ( addr , currAddr )) { System . out . println ( Calc . getCellStr ( currAddr ) + \" --> \" + Calc . getCellStr ( addr )); // check if currAddr value has changed Double d = getCellDouble ( sheet , currAddr ); // value right now if ( d != null ) { if ( currVal == null ) // so previously stored value was null System . out . println ( Calc . getCellStr ( currAddr ) + \" new value: \" + d ); else { // currVal has a value; is it different from d? if ( currVal . doubleValue () != d . doubleValue ()) System . out . println ( Calc . getCellStr ( currAddr ) + \" has changed from \" + currVal + \" to \" + d ); } } // update current address and value currAddr = addr ; currVal = getCellDouble ( sheet , addr ); if ( currVal != null ) // print numerical value System . out . println ( Calc . getCellStr ( currAddr ) + \" value: \" + currVal ); } } // end of selectionChanged() private Double getCellDouble ( XSpreadsheet sheet , CellAddress addr ) // return numerical value at cell address, or null { Object obj = Calc . getVal ( sheet , addr ); if ( obj instanceof Double ) return ( Double ) obj ; else // if not a double, return null return null ; } // end of getCellDouble() selectionChanged() is called whenever the user selects a new cell. The address of this new cell is obtained by Calc.getSelectedCellAddr(), which returns null if the user has selected a cell range. If the new selection is a cell then a series of comparisons are carried out between the previously selected cell address and value (stored in the globals currAddr and currVal) and the new address and its possible numerical value (stored in addr and d). At the end of the method the current address and value are updated with the new ones. XSelectionChangeListener shares a similar problem to XModifyListener in that a single user selection triggers multiple calls to selectionChanged(). Clicking once inside a cell causes four calls, and an arrow key press may trigger two calls depending on how it's entered from the keyboard.","title":"Chapter 25. Monitoring Sheets"},{"location":"25-Monitoring_Sheets.html#chapter-25-monitoring-sheets","text":"Topics Listening for Document Modifications (XModifyListener); Listening for Application Closing (XTopWindowListener); Listening for Cell Selection (XSelectionChangeListe ner) Example folders: \"Calc Tests\" and \"Utils\" The chapter looks at three kinds of listeners for spreadsheets: document modification, application closing, and cell selection listeners. Office's support for listeners was first described back in Chapter 4.","title":"Chapter 25. Monitoring Sheets"},{"location":"25-Monitoring_Sheets.html#1-listening-for-the-users-modifications","text":"A common requirement for spreadsheet programming is controlling how the user interacts with the sheet's data. In the extreme case, this might mean preventing the user from changing anything, which is possible through the XProtectable interface discussed in Chapter 20, section 1.1. But often we want to let the user edit the sheet, but monitor what is being changed. One way of doing this is to attach a XModifyListener interface to the open document so that its modified() method will be triggered whenever a cell is changed. ModifyListener.java illustrates this approach: // in ModifyListener.java public class ModifyListener implements XModifyListener { private XSpreadsheetDocument doc ; private XSpreadsheet sheet ; public ModifyListener () { XComponentLoader loader = Lo . loadOffice (); doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); sheet = Calc . getSheet ( doc , 0 ); // insert some data Calc . setCol ( sheet , \"A1\" , new Object [] { \"Smith\" , 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 }); // listen for cell modifications XModifyBroadcaster mb = Lo . qi ( XModifyBroadcaster . class , doc ); mb . addModifyListener ( this ); // close down when window close box is clicked XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { System . out . println ( \"Closing\" ); Lo . saveDoc ( doc , \"modify.ods\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } }); } // end of ModifyListener() // ----- XModifyListener methods ------ public void disposing ( EventObject event ) { System . out . println ( \"Disposing\" ); } public void modified ( EventObject event ) { // called whenever a cell is modified; // the code in this method is explained below } // ------------------------------------ public static void main ( String args [] ) { new ModifyListener (); } } // end of ModifyListener class","title":"1.  Listening for the User's Modifications"},{"location":"25-Monitoring_Sheets.html#11-listening-to-the-close-box","text":"main() creates a ModifyListener object and then terminates, which means that the object must deal with the closing of the spreadsheet and the termination of Office. This is done by employing another listener: an adapter for XTopWindowListener, called XTopWindowAdapter, attached to the Calc application's close box: // in ModifyListener.java : XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { /* called whenever the appl. is closed */ } } XTopWindowListener was described in Chapter 4, section 1, but XTopWindowAdapter is one of my support classes. XTopWindowListener defines eight methods, called when the application window is in different states: opened, activated, deactivated, minimized, normalized, closing, closed, and disposed. XTopWindowAdapter supplies empty implementations for those methods: // in Utils/XTopWindowAdapter.java public class XTopWindowAdapter implements XTopWindowListener { public XTopWindowAdapter (){} public void windowOpened ( EventObject event ){} public void windowActivated ( EventObject event ){} public void windowDeactivated ( EventObject event ){} public void windowMinimized ( EventObject event ) {} public void windowNormalized ( EventObject event ){} public void windowClosing ( EventObject event ){} public void windowClosed ( EventObject event ){} public void disposing ( EventObject event ){} } // end of XTopWindowAdapter class ModifyListener.java overides XTopWindowAdapter's windowClosing(), but leaves the other methods unchanged. windowClosing() is triggered when the application's close box is clicked, and it responds by saving the document, then closes it and Office: // in ModifyListener.java : tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { System . out . println ( \"Closing\" ); Lo . saveDoc ( doc , \"modify.ods\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } }","title":"1.1.  Listening to the Close Box"},{"location":"25-Monitoring_Sheets.html#12-listening-for-modifications","text":"ModifyListener is notified of document changes by attaching itself to the document's XModifyBroadcaster: // in ModifyListener.java : // listen for cell modifications XModifyBroadcaster mb = Lo . qi ( XModifyBroadcaster . class , doc ); mb . addModifyListener ( this ); A look at the documentation for XModifyListener (use lodoc XModifyListener) shows that it defines a modified() method, and inherits disposing() from XEventListener. ModifyListener implements both of these, although disposing() only prints a message. ModifyListener.modified() does something useful: // in ModifyListener.java : // global variables private XSpreadsheetDocument doc ; private XSpreadsheet sheet ; public void modified ( EventObject event ) // called whenever a cell is modified { // System.out.println(\"Modified: \" + event.Source); // Info.showServices(\"Event source\", event.Source); // XSpreadsheetDocument doc = // Lo.qi(XSpreadsheetDocument.class, event.Source); CellAddress addr = Calc . getSelectedCellAddr ( doc ); System . out . println ( \" \" + Calc . getCellStr ( addr ) + \" = \" + Calc . getVal ( sheet , addr )); } // end of modified() An event object arriving at modified() contains a Source field of type XInterface. Every Office interface inherits XInterface so it's difficult to know what the source really is. The simplest solution is to print the names of the source's supported services, by calling Info.showServices(), as in the commented-out code above. In this case, the Source field is supported by the SpreadsheetDocument service, which means that it can be converted into an XSpreadsheetDocument interface. Lots of useful things can be accessed through this interface, but that's also commented-out because I can utilize the document via the global variable, doc.","title":"1.2.  Listening for Modifications"},{"location":"25-Monitoring_Sheets.html#13-examining-the-changed-cell-or-cells","text":"While modified() is being executed, the modified cell in the document is still selected (or active), and so can be retrieved: // in modified() ... CellAddress addr = Calc . getSelectedCellAddr ( doc ); Calc.getSelectedCellAddr() needs the XModel interface for the document so that XModel.getCurrentSelection() can be called. It also has to handle the possibility that a cell range is currently selected rather than a single cell: // in the Calc class public static CellAddress getSelectedCellAddr ( XSpreadsheetDocument doc ) // return address of selected cell in document; // returns null if a cell range is selected { // get address of selected cell range CellRangeAddress crAddr = getSelectedAddr ( doc ); // if cell range is a single cell CellAddress addr = null ; if ( Calc . isSingleCellRange ( crAddr )) { XSpreadsheet sheet = getActiveSheet ( doc ); XCell cell = Calc . getCell ( sheet , crAddr . StartColumn , crAddr . StartRow ); // access the cell using the cell range position addr = Calc . getCellAddress ( cell ); // get address of selected cell } return addr ; } // end of getSelectedCellAddr() public static CellRangeAddress getSelectedAddr ( XSpreadsheetDocument doc ) { // look for selected address in document's model XModel model = Lo . qi ( XModel . class , doc ); return getSelectedAddr ( model ); } public static CellRangeAddress getSelectedAddr ( XModel model ) // return address of selected cell range in the model { if ( model == null ) { System . out . println ( \"No document model found\" ); return null ; } XCellRangeAddressable ra = Lo . qi ( XCellRangeAddressable . class , model . getCurrentSelection ()); if ( ra != null ) return ra . getRangeAddress (); else { System . out . println ( \"No range address found\" ); return null ; } } // end of getSelectedAddr() Calc.getSelectedCellAddr() utilizes Calc.getSelectedAddr(), which returns the address of the selected cell range. Calc.getSelectedCellAddr() examines this cell range to see if it's really just a single cell by calling Calc.isSingleCellRange(): // in the Calc class public static boolean isSingleCellRange ( CellRangeAddress addr ) { return (( addr . StartColumn == addr . EndColumn ) && ( addr . StartRow == addr . EndRow )); } If the cell range is referencing a cell then the cell range address position is used to directly access the cell in the sheet: // in Calc.getSelectedCellAddr() : XSpreadsheet sheet = getActiveSheet ( doc ); XCell cell = Calc . getCell ( sheet , crAddr . StartColumn , crAddr . StartRow ); This requires the current active sheet, which is obtained through Calc.getActiveSheet().","title":"1.3.  Examining the Changed Cell (or Cells)"},{"location":"25-Monitoring_Sheets.html#14-problems-with-the-modified-method","text":"After all this coding, the bad news is that modified() is still lacking in functionality. One minor problem is that modified() is called twice when the user finishes editing a cell. This occurs when the user presses enter, or tab, or an arrow key, and for reasons I don't understand. It could be fixed with some judicious hacking: e.g. by using a counter to control when the code is executed. A more important concern is that modified() only has access to the new value in the cell, but doesn't know what was overwritten, which would be very useful for implementing data validation. This led me to investigate another form of listening, based on cell selection, which is described next.","title":"1.4.  Problems with the modified() Method"},{"location":"25-Monitoring_Sheets.html#2-listening-for-cell-selections","text":"Listening to cell selections on the sheet has the drawback of generating a lot of events, but this abundance of data turns out to be useful; I can use it to report more about cell modifications. The SelectListener.java example is similar to ModifyListener.java except that it implements XSelectionChangeListener rather than XModifyListener: // in SelectListener.java public class SelectListener implements XSelectionChangeListener { private XSpreadsheetDocument doc ; private XSpreadsheet sheet ; // selected cell's current address and numeric value private CellAddress currAddr ; private Double currVal = null ; public SelectListener () { XComponentLoader loader = Lo . loadOffice (); doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); sheet = Calc . getSheet ( doc , 0 ); // initialize selected cell's current address and value currAddr = Calc . getSelectedCellAddr ( doc ); currVal = getCellDouble ( sheet , currAddr ); // may be null attachListener ( doc ); // listen for cell selections // insert some data Calc . setCol ( sheet , \"A1\" , new Object [] { \"Smith\" , 42 , 58.9 , - 66.5 , 43.4 , 44.5 , 45.3 }); // close down when window close box is clicked XExtendedToolkit tk = Lo . createInstanceMCF ( XExtendedToolkit . class , \"com.sun.star.awt.Toolkit\" ); if ( tk != null ) tk . addTopWindowListener ( new XTopWindowAdapter () { public void windowClosing ( EventObject eo ) { System . out . println ( \"Closing\" ); Lo . saveDoc ( doc , \"select.ods\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } }); } // end of SelectListener() SelectListener.java employs four globals instead of the two in ModifyListener: the document and sheet variables are joined by variables holding the address of the currently selected cell (currAddr) and its numerical value (currVal). If the cell doesn't contain a double then currVal is assigned null. currAddr and currVal are initialized after the document is first created, and are updated whenever the user changes a cell. attachListener() is called to attach the listener to the document: // in SelectListener.java private void attachListener ( XSpreadsheetDocument doc ) { // get selection supplier for document XController ctrl = Calc . getController ( doc ); XSelectionSupplier supp = Lo . qi ( XSelectionSupplier . class , ctrl ); if ( supp == null ) System . out . println ( \"Could not attach selection listener\" ); else // make \"this\" object a selection listener supp . addSelectionChangeListener ( this ); } // end of attachListener() The document's controller is changed to an XSelectionSupplier interface so its addSelectionChangeListener() method can be called. The XSelectionChangeListener interface defines disposing() and selectionChanged() (see lodoc XSelectionChangeListener for details). selectionChanged() listens for three kinds of changes in the sheet: it reports when the selected cell changes by printing the name of the previous cell and the newly selected one; it reports whether the cell that has just lost focus now has a value different from when it was selected; it reports if the newly selected cell contains a numerical value. For example, Figure 1 shows the initial sheet of data created by SelectListener: Figure 1. The Sheet of Data in SelectListener.java Note that the selected cell when the sheet is first created is \"A1\". If the user carries out the following operations: click in cell \"B2\" click in cell \"A4\" click in \"A5\" change \"A5 to 4 and press tab then the sheet will end up looking like Figure 2, with \"B5\" being the selected cell. Figure 2. The Modified Sheet in SelectListener.java During these changes, selectionChanged() will report: A1 --> B2 B2 --> A4 A4 value : - 66.5 A4 --> A5 A5 value : 43.4 A5 --> B5 A5 has changed from 43.4 to 4.0 The \"\u2192\" lines note cell selection changes. The \"value\" lines state the value of a cell when it's first selected, and the \"changed\" lines report whether the cell was left changed when the focus moved to another cell. The output from selectionChanged() shown above shows how the user moved around the spreadsheet, and changed the \"A5\" cell's contents from 43.4 to 4. selectionChanged() is defined as: // in SelectListener.java // globals private CellAddress currAddr ; private Double currVal = null ; public void selectionChanged ( EventObject event ) { XController ctrl = Lo . qi ( XController . class , event . Source ); if ( ctrl == null ){ System . out . println ( \"No ctrl for event source\" ); return ; } // get address of currently selected cell CellAddress addr = Calc . getSelectedCellAddr ( doc ); if ( addr == null ) return ; // is this different from the stored selected address? if ( ! Calc . isEqualAddresses ( addr , currAddr )) { System . out . println ( Calc . getCellStr ( currAddr ) + \" --> \" + Calc . getCellStr ( addr )); // check if currAddr value has changed Double d = getCellDouble ( sheet , currAddr ); // value right now if ( d != null ) { if ( currVal == null ) // so previously stored value was null System . out . println ( Calc . getCellStr ( currAddr ) + \" new value: \" + d ); else { // currVal has a value; is it different from d? if ( currVal . doubleValue () != d . doubleValue ()) System . out . println ( Calc . getCellStr ( currAddr ) + \" has changed from \" + currVal + \" to \" + d ); } } // update current address and value currAddr = addr ; currVal = getCellDouble ( sheet , addr ); if ( currVal != null ) // print numerical value System . out . println ( Calc . getCellStr ( currAddr ) + \" value: \" + currVal ); } } // end of selectionChanged() private Double getCellDouble ( XSpreadsheet sheet , CellAddress addr ) // return numerical value at cell address, or null { Object obj = Calc . getVal ( sheet , addr ); if ( obj instanceof Double ) return ( Double ) obj ; else // if not a double, return null return null ; } // end of getCellDouble() selectionChanged() is called whenever the user selects a new cell. The address of this new cell is obtained by Calc.getSelectedCellAddr(), which returns null if the user has selected a cell range. If the new selection is a cell then a series of comparisons are carried out between the previously selected cell address and value (stored in the globals currAddr and currVal) and the new address and its possible numerical value (stored in addr and d). At the end of the method the current address and value are updated with the new ones. XSelectionChangeListener shares a similar problem to XModifyListener in that a single user selection triggers multiple calls to selectionChanged(). Clicking once inside a cell causes four calls, and an arrow key press may trigger two calls depending on how it's entered from the keyboard.","title":"2.  Listening for Cell Selections"},{"location":"26-Search_Replace.html","text":"Chapter 26. Search and Replace \u00b6 Topics XSearchable; XReplaceable; SearchDescriptor; ReplaceDescriptor; Searching Iteratively; Searching For All Matches; Replacing All Matches Example folders: \"Calc Tests\" and \"Utils\" The increaseGarlicCost() method in GarlicSecrets.java (Chapter 23, section 3) illustrates how to use loops and if- tests to search for and replace data. Another approach is to employ the XSearchable and XReplaceable interfaces, as in the ReplaceAll.java example shown below: // global array private static final String [] animals = { \"ass\" , \"cat\" , \"cow\" , \"cub\" , \"doe\" , \"dog\" , \"elk\" , \"ewe\" , \"fox\" , \"gnu\" , \"hog\" , \"kid\" , \"kit\" , \"man\" , \"orc\" , \"pig\" , \"pup\" , \"ram\" , \"rat\" , \"roe\" , \"sow\" , \"yak\" }; public static void main ( String args [] ) { // read search animal from command line if ( args . length != 1 ) { System . out . println ( \"Usage: run ReplaceAll <animal>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // randomly fill a grid of 6 x 15 cells with animal names Random rand = new Random (); for ( int i = 0 ; i < 6 ; i ++ ) for ( int j = 0 ; j < 15 ; j ++ ) Calc . setVal ( sheet , i , j , animals [ rand . nextInt ( animals . length ) ] ); // create a cell range that covers the animals grid XCellRange cellRange = Calc . getCellRange ( sheet , 0 , 0 , 5 , 14 ); // colStart, rowStart, colEnd, rowEnd // two ways to search for an animal // searchIter(sheet, cellRange, args[0]); searchAll ( sheet , cellRange , args [ 0 ] ); /* replace all occurrences of the args[0] animal with a randonly chosen one */ replaceAll ( cellRange , args [ 0 ] , animals [ rand . nextInt ( animals . length ) ] ); Lo . saveDoc ( doc , \"replace.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() A blank sheet is filled with a 15 x 6 grid of randomly chosen animal names, such as the one shown in Figure 1. Figure 1. A Grid Of Animals for Searching and Replacing. The SheetCellRange supports the XReplaceable interface, which is a subclass of XSearchable, as in Figure 2. Figure 2. The XReplaceable and XSearchable Interfaces. A cell range's XSearchable interface is accessed through casting: XCellRange cellRange = //... XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); The XReplaceable interface for the range is obtained in the same way: XReplaceable repl = Lo . qi ( XReplaceable . class , cellRange ); XSearchable offers iterative searching using its findFirst() and findNext() methods, which I'll demonstrate shortly in the searchIter() method in ReplaceAll.java. XSearchable can also search for all matches at once with findAll(), which I employ in ReplaceAll.java's searchAll(). Only one of these methods is needed by the program, so the other is commented out in the main() function shown above. XReplaceable only offers replaceAll() which searches for and replaces all of its matches in a single call. It's utilized by ReplaceAll.java's replaceAll(). Before a search can begin, it's usually necessary to tweak the search properties, e.g. to employ regular expressions, be case sensitive, or use search similarity. Similarity allows a text match to be a certain number of characters different from the search text. These search properties are stored in the SearchDescriptor service, which is accessed by calling XSearchable.createSearchDescriptor(). For example: // in searchIter() in ReplaceAll.java : XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); XSearchDescriptor sd = srch . createSearchDescriptor (); sd . setPropertyValue ( \"SearchWords\" , true ); // only complete words will be found sd . setPropertyValue ( \"SearchRegularExpression\" , true ); // use regexs XSearchDescriptor is the interface for the SearchDescriptor service, as shown in Figure 3. Figure 3. The ReplaceDescriptor and SearchDescriptor Services. Aside from being used to set search properties, XSearchDescriptor is also where the search string is stored: sd . setSearchString ( \"dog\" ); // search for \"dog\" If regular expressions have been enabled, then the search string can utilize them: sd . setSearchString ( \"[a-z]+\" ); // search for a non-empty series of lower-case letters The regular expression syntax is standard, and documented online at https://help.libreoffice.org/Common/List_of_Regular_Expressions/ . 1. Searching Iteratively \u00b6 The searchIter() method in ReplaceAll.java is passed the cell range for the 15 x 6 grid of animals, and creates a search based on finding complete words. It uses XSearchable.findFirst() and XSearchable.findNext() to incrementally move through the grid: // in ReplaceAll.java private static void searchIter ( XSpreadsheet sheet , XCellRange cellRange , String srchStr ) { System . out . println ( \"Searching for \\\"\" + srchStr + \"\\\"\" ); try { XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); // set up search string and properties XSearchDescriptor sd = srch . createSearchDescriptor (); sd . setSearchString ( srchStr ); sd . setPropertyValue ( \"SearchWords\" , true ); // only complete words will be found // search iteratively XCellRange cr = Lo . qi ( XCellRange . class , srch . findFirst ( sd )); int count = 0 ; while ( cr != null ) { highlightMatch ( cr ); System . out . println ( \" Match \" + ( count + 1 ) + \": \" + Calc . getRangeStr ( cr )); cr = Lo . qi ( XCellRange . class , srch . findNext ( cr , sd )); count ++ ; } } catch ( Exception e ) { System . out . println ( e ); } } // end of searchIter() private static void highlightMatch ( XCellRange cr ) // highlight the matching of the cell range { Props . setProperty ( cr , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); Props . setProperty ( cr , \"CharColor\" , Calc . DARK_BLUE ); Props . setProperty ( cr , \"CellBackColor\" , Calc . LIGHT_BLUE ); } // end of highlightMatch() XSearchable.findNext() requires a reference to the previous match as its first input argument, so it can resume the search after that match. The Office documentation for XSearchable.findFirst() and XSearchable.findNext() specify that they return an XInterface reference, which seems to be incorrect (use lodoc XSearchable to look for yourself). In my code, the result had to be assigned to an Object variable or a runtime type exception occurs. Another surprise was when I listed the services supported by the references returned by XSearchable.findFirst() and XSearchable.findNext() by calling Info.showServices(): Object oFirst = srch . findFirst ( sd ); Info . showServices ( \"Find First\" , oFirst ); As I'd expected, the main service supported by the findFirst() result is SheetCell. This makes sense since the search is looking for a cell containing the search string. As a consequence, the oFirst reference can be converted to XCell: XCell cr = Lo . qi ( XCell . class , srch . findFirst ( sd )); However, checking out XSearchable.findNext() in the same way showed an occasional problem: Object oNext = srch . findNext ( oFirst , sd ); Info . showServices ( \"Find Next\" , oNext ); The reference returned by findNext() usually supports the SheetCell service, but sometimes represents SheetCellRange instead! When that occurs, code that attempts to convert oNext to XCell will return null: XCell cell = Lo . qi ( XCell . class , srch . findNext ( oFirst , sd )); My solution is shown in the searchIter() listing above \u2013 instead of converting the XSearchable.findFirst() and XSearchable.findNext() results to XCell, they're changed into XCellRange references, which always succeeds. searchIter() calls highlightMatch() on each match so the user can see the results more clearly, as in Figure 4. Figure 4. The Results of searchIter() when Looking for \"dog\". 2. Searching For All Matches \u00b6 The searchAll() method in ReplaceAll.java utilizes XSearchable.findAll() to return all the search matches at once, in the form of an indexed container. Calc.findAll() adds an extra conversion step, creating an array of XCellRange objects from the values in the container: // in the Calc class public static XCellRange [] findAll ( XSearchable srch , XSearchDescriptor sd ) { XIndexAccess con = srch . findAll ( sd ); if ( con == null ) { System . out . println ( \"Match result is null\" ); return null ; } if ( con . getCount () == 0 ) { System . out . println ( \"No matches found\" ); return null ; } // put container contents into an array XCellRange [] crs = new XCellRange [ con . getCount () ] ; for ( int i = 0 ; i < con . getCount (); i ++ ) { try { crs [ i ] = Lo . qi ( XCellRange . class , con . getByIndex ( i )); } catch ( Exception e ) { System . out . println ( \"Could not access match index \" + i ); } } return crs ; } // end of findAll() searchAll() iterates through the XCellRange array returned by Calc.findAll(), highlighting each match in the same way as the searchIter() function: // in ReplaceAll.java private static void searchAll ( XSpreadsheet sheet , XCellRange cellRange , String srchStr ) { System . out . println ( \"Searching for all of \\\"\" + srchStr + \"\\\"\" ); try { XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); // set up search string and properties XSearchDescriptor sd = srch . createSearchDescriptor (); sd . setSearchString ( srchStr ); sd . setPropertyValue ( \"SearchWords\" , true ); XCellRange [] matchCrs = Calc . findAll ( srch , sd ); if ( matchCrs == null ) return ; System . out . println ( \"Search text found \" + matchCrs . length + \" times\" ); // highlight each match in the array for ( int i = 0 ; i < matchCrs . length ; i ++ ) { highlightMatch ( matchCrs [ i ] ); System . out . println ( \" Index \" + i + \": \" + Calc . getRangeStr ( matchCrs [ i ] )); } } catch ( Exception e ) { System . out . println ( e ); } } // end of searchAll() 3. Replacing All Matches \u00b6 The XReplaceable interface only contains a replaceAll() method (see Figure 2), so there's no way to implement an iterative replace function. In addition, XReplaceable.replaceAll() returns a count of the number of changes, not a container of the matched cells like XSearchable.findAll(). This means that its not possible to code a replace-like version of my searchAll() method which highlights all the changed cells. The best that can be done is to execute two searches over the grid of animal names. The first looks only for the search string so it can highlight the matching cells. The second search calls XReplaceabl.replaceAll() to make the changes. My replaceAll() method is: // in ReplaceAll.java private static void replaceAll ( XCellRange cellRange , String srchStr , String replStr ) { System . out . println ( \"Replacing \\\"\" + srchStr + \"\\\" with \\\"\" + replStr + \"\\\"\" ); Lo . delay ( 2000 ); // wait a bit before search & replace try { XReplaceable repl = Lo . qi ( XReplaceable . class , cellRange ); // set up search and replace strings and properties XReplaceDescriptor rd = repl . createReplaceDescriptor (); rd . setSearchString ( srchStr ); rd . setReplaceString ( replStr ); rd . setPropertyValue ( \"SearchWords\" , true ); // rd.setPropertyValue(\"SearchRegularExpression\", true); int count = repl . replaceAll ( rd ); System . out . println ( \"Search text replaced \" + count + \" times\\n\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of replaceAll() The coding style is similar to my searchAll() method from above. One difference is that XReplaceDescriptor is used to setup the search and replacement strings. One way of calling replaceAll() is to use regular expressions in the function: replaceAll ( cellRange , \"[a-z]+\" , animals [ rand . nextInt ( animals . length ) ] ); The search string (\"[a-z]+\") will match every cell's text, and change all the animal names to one chosen at random. Typical output is shown in Figure 5. Figure 5. All Animals Become One.","title":"Chapter 26. Search and Replace"},{"location":"26-Search_Replace.html#chapter-26-search-and-replace","text":"Topics XSearchable; XReplaceable; SearchDescriptor; ReplaceDescriptor; Searching Iteratively; Searching For All Matches; Replacing All Matches Example folders: \"Calc Tests\" and \"Utils\" The increaseGarlicCost() method in GarlicSecrets.java (Chapter 23, section 3) illustrates how to use loops and if- tests to search for and replace data. Another approach is to employ the XSearchable and XReplaceable interfaces, as in the ReplaceAll.java example shown below: // global array private static final String [] animals = { \"ass\" , \"cat\" , \"cow\" , \"cub\" , \"doe\" , \"dog\" , \"elk\" , \"ewe\" , \"fox\" , \"gnu\" , \"hog\" , \"kid\" , \"kit\" , \"man\" , \"orc\" , \"pig\" , \"pup\" , \"ram\" , \"rat\" , \"roe\" , \"sow\" , \"yak\" }; public static void main ( String args [] ) { // read search animal from command line if ( args . length != 1 ) { System . out . println ( \"Usage: run ReplaceAll <animal>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // randomly fill a grid of 6 x 15 cells with animal names Random rand = new Random (); for ( int i = 0 ; i < 6 ; i ++ ) for ( int j = 0 ; j < 15 ; j ++ ) Calc . setVal ( sheet , i , j , animals [ rand . nextInt ( animals . length ) ] ); // create a cell range that covers the animals grid XCellRange cellRange = Calc . getCellRange ( sheet , 0 , 0 , 5 , 14 ); // colStart, rowStart, colEnd, rowEnd // two ways to search for an animal // searchIter(sheet, cellRange, args[0]); searchAll ( sheet , cellRange , args [ 0 ] ); /* replace all occurrences of the args[0] animal with a randonly chosen one */ replaceAll ( cellRange , args [ 0 ] , animals [ rand . nextInt ( animals . length ) ] ); Lo . saveDoc ( doc , \"replace.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() A blank sheet is filled with a 15 x 6 grid of randomly chosen animal names, such as the one shown in Figure 1. Figure 1. A Grid Of Animals for Searching and Replacing. The SheetCellRange supports the XReplaceable interface, which is a subclass of XSearchable, as in Figure 2. Figure 2. The XReplaceable and XSearchable Interfaces. A cell range's XSearchable interface is accessed through casting: XCellRange cellRange = //... XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); The XReplaceable interface for the range is obtained in the same way: XReplaceable repl = Lo . qi ( XReplaceable . class , cellRange ); XSearchable offers iterative searching using its findFirst() and findNext() methods, which I'll demonstrate shortly in the searchIter() method in ReplaceAll.java. XSearchable can also search for all matches at once with findAll(), which I employ in ReplaceAll.java's searchAll(). Only one of these methods is needed by the program, so the other is commented out in the main() function shown above. XReplaceable only offers replaceAll() which searches for and replaces all of its matches in a single call. It's utilized by ReplaceAll.java's replaceAll(). Before a search can begin, it's usually necessary to tweak the search properties, e.g. to employ regular expressions, be case sensitive, or use search similarity. Similarity allows a text match to be a certain number of characters different from the search text. These search properties are stored in the SearchDescriptor service, which is accessed by calling XSearchable.createSearchDescriptor(). For example: // in searchIter() in ReplaceAll.java : XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); XSearchDescriptor sd = srch . createSearchDescriptor (); sd . setPropertyValue ( \"SearchWords\" , true ); // only complete words will be found sd . setPropertyValue ( \"SearchRegularExpression\" , true ); // use regexs XSearchDescriptor is the interface for the SearchDescriptor service, as shown in Figure 3. Figure 3. The ReplaceDescriptor and SearchDescriptor Services. Aside from being used to set search properties, XSearchDescriptor is also where the search string is stored: sd . setSearchString ( \"dog\" ); // search for \"dog\" If regular expressions have been enabled, then the search string can utilize them: sd . setSearchString ( \"[a-z]+\" ); // search for a non-empty series of lower-case letters The regular expression syntax is standard, and documented online at https://help.libreoffice.org/Common/List_of_Regular_Expressions/ .","title":"Chapter 26. Search and Replace"},{"location":"26-Search_Replace.html#1-searching-iteratively","text":"The searchIter() method in ReplaceAll.java is passed the cell range for the 15 x 6 grid of animals, and creates a search based on finding complete words. It uses XSearchable.findFirst() and XSearchable.findNext() to incrementally move through the grid: // in ReplaceAll.java private static void searchIter ( XSpreadsheet sheet , XCellRange cellRange , String srchStr ) { System . out . println ( \"Searching for \\\"\" + srchStr + \"\\\"\" ); try { XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); // set up search string and properties XSearchDescriptor sd = srch . createSearchDescriptor (); sd . setSearchString ( srchStr ); sd . setPropertyValue ( \"SearchWords\" , true ); // only complete words will be found // search iteratively XCellRange cr = Lo . qi ( XCellRange . class , srch . findFirst ( sd )); int count = 0 ; while ( cr != null ) { highlightMatch ( cr ); System . out . println ( \" Match \" + ( count + 1 ) + \": \" + Calc . getRangeStr ( cr )); cr = Lo . qi ( XCellRange . class , srch . findNext ( cr , sd )); count ++ ; } } catch ( Exception e ) { System . out . println ( e ); } } // end of searchIter() private static void highlightMatch ( XCellRange cr ) // highlight the matching of the cell range { Props . setProperty ( cr , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); Props . setProperty ( cr , \"CharColor\" , Calc . DARK_BLUE ); Props . setProperty ( cr , \"CellBackColor\" , Calc . LIGHT_BLUE ); } // end of highlightMatch() XSearchable.findNext() requires a reference to the previous match as its first input argument, so it can resume the search after that match. The Office documentation for XSearchable.findFirst() and XSearchable.findNext() specify that they return an XInterface reference, which seems to be incorrect (use lodoc XSearchable to look for yourself). In my code, the result had to be assigned to an Object variable or a runtime type exception occurs. Another surprise was when I listed the services supported by the references returned by XSearchable.findFirst() and XSearchable.findNext() by calling Info.showServices(): Object oFirst = srch . findFirst ( sd ); Info . showServices ( \"Find First\" , oFirst ); As I'd expected, the main service supported by the findFirst() result is SheetCell. This makes sense since the search is looking for a cell containing the search string. As a consequence, the oFirst reference can be converted to XCell: XCell cr = Lo . qi ( XCell . class , srch . findFirst ( sd )); However, checking out XSearchable.findNext() in the same way showed an occasional problem: Object oNext = srch . findNext ( oFirst , sd ); Info . showServices ( \"Find Next\" , oNext ); The reference returned by findNext() usually supports the SheetCell service, but sometimes represents SheetCellRange instead! When that occurs, code that attempts to convert oNext to XCell will return null: XCell cell = Lo . qi ( XCell . class , srch . findNext ( oFirst , sd )); My solution is shown in the searchIter() listing above \u2013 instead of converting the XSearchable.findFirst() and XSearchable.findNext() results to XCell, they're changed into XCellRange references, which always succeeds. searchIter() calls highlightMatch() on each match so the user can see the results more clearly, as in Figure 4. Figure 4. The Results of searchIter() when Looking for \"dog\".","title":"1.  Searching Iteratively"},{"location":"26-Search_Replace.html#2-searching-for-all-matches","text":"The searchAll() method in ReplaceAll.java utilizes XSearchable.findAll() to return all the search matches at once, in the form of an indexed container. Calc.findAll() adds an extra conversion step, creating an array of XCellRange objects from the values in the container: // in the Calc class public static XCellRange [] findAll ( XSearchable srch , XSearchDescriptor sd ) { XIndexAccess con = srch . findAll ( sd ); if ( con == null ) { System . out . println ( \"Match result is null\" ); return null ; } if ( con . getCount () == 0 ) { System . out . println ( \"No matches found\" ); return null ; } // put container contents into an array XCellRange [] crs = new XCellRange [ con . getCount () ] ; for ( int i = 0 ; i < con . getCount (); i ++ ) { try { crs [ i ] = Lo . qi ( XCellRange . class , con . getByIndex ( i )); } catch ( Exception e ) { System . out . println ( \"Could not access match index \" + i ); } } return crs ; } // end of findAll() searchAll() iterates through the XCellRange array returned by Calc.findAll(), highlighting each match in the same way as the searchIter() function: // in ReplaceAll.java private static void searchAll ( XSpreadsheet sheet , XCellRange cellRange , String srchStr ) { System . out . println ( \"Searching for all of \\\"\" + srchStr + \"\\\"\" ); try { XSearchable srch = Lo . qi ( XSearchable . class , cellRange ); // set up search string and properties XSearchDescriptor sd = srch . createSearchDescriptor (); sd . setSearchString ( srchStr ); sd . setPropertyValue ( \"SearchWords\" , true ); XCellRange [] matchCrs = Calc . findAll ( srch , sd ); if ( matchCrs == null ) return ; System . out . println ( \"Search text found \" + matchCrs . length + \" times\" ); // highlight each match in the array for ( int i = 0 ; i < matchCrs . length ; i ++ ) { highlightMatch ( matchCrs [ i ] ); System . out . println ( \" Index \" + i + \": \" + Calc . getRangeStr ( matchCrs [ i ] )); } } catch ( Exception e ) { System . out . println ( e ); } } // end of searchAll()","title":"2.  Searching For All Matches"},{"location":"26-Search_Replace.html#3-replacing-all-matches","text":"The XReplaceable interface only contains a replaceAll() method (see Figure 2), so there's no way to implement an iterative replace function. In addition, XReplaceable.replaceAll() returns a count of the number of changes, not a container of the matched cells like XSearchable.findAll(). This means that its not possible to code a replace-like version of my searchAll() method which highlights all the changed cells. The best that can be done is to execute two searches over the grid of animal names. The first looks only for the search string so it can highlight the matching cells. The second search calls XReplaceabl.replaceAll() to make the changes. My replaceAll() method is: // in ReplaceAll.java private static void replaceAll ( XCellRange cellRange , String srchStr , String replStr ) { System . out . println ( \"Replacing \\\"\" + srchStr + \"\\\" with \\\"\" + replStr + \"\\\"\" ); Lo . delay ( 2000 ); // wait a bit before search & replace try { XReplaceable repl = Lo . qi ( XReplaceable . class , cellRange ); // set up search and replace strings and properties XReplaceDescriptor rd = repl . createReplaceDescriptor (); rd . setSearchString ( srchStr ); rd . setReplaceString ( replStr ); rd . setPropertyValue ( \"SearchWords\" , true ); // rd.setPropertyValue(\"SearchRegularExpression\", true); int count = repl . replaceAll ( rd ); System . out . println ( \"Search text replaced \" + count + \" times\\n\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of replaceAll() The coding style is similar to my searchAll() method from above. One difference is that XReplaceDescriptor is used to setup the search and replacement strings. One way of calling replaceAll() is to use regular expressions in the function: replaceAll ( cellRange , \"[a-z]+\" , animals [ rand . nextInt ( animals . length ) ] ); The search string (\"[a-z]+\") will match every cell's text, and change all the animal names to one chosen at random. Typical output is shown in Figure 5. Figure 5. All Animals Become One.","title":"3.  Replacing All Matches"},{"location":"27-Funcs_Analysis.html","text":"Chapter 27. Functions and Data Analysis \u00b6 Topics Calling Calc Functions from Code; Pivot Tables; Goal Seek; Linear and Nonlinear Solving (using SCO, DEPS) Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at how to utilize Calc's spreadsheet functions directly from Java, and then examines four of Calc's data analysis features: pivot tables, goal seeking, and linear and nonlinear solving. There are two nonlinear examples, one using the SCO solver, the using employing DEPS. 1. Calling Calc Functions from Code \u00b6 Calc comes with an extensive set of functions, which are described in Appendix B of the Calc User Guide, available from https://libreoffice.org/get-help/documentation/ . The information is also online at https://help.libreoffice.org/Calc/Functions_by_Category/ , organized into 11 categories: Database: for extracting information from Calc tables, where the data is organized into rows. The \"Database\" name is a little misleading, but the documentation makes the point that Calc database functions have nothing to do with Base databases. Chapter 13 of the Calc User Guide (\"Calc as a Simple Database\") explains the distinction in detail. Date and Time; e.g. see the EASTERSUNDAY function below Financial: for business calculations; Information: many of these return boolean information about cells, such as whether a cell contains text or a formula; Logical: functions for boolean logic; Mathematical: trigonometric, hyperbolic, logarithmic, and summation functions; e.g. see ROUND, SIN, and RADIANS below; Array: many of these operations treat cell ranges like 2D arrays; e.g. see TRANSPOSE below; Statistical: for statistical and probability calculations; e.g., see AVERAGE and SLOPE below; Spreadsheet: for finding values in tables, cell ranges, and cells; Text: string manipulation functions; Add-ins: a catch-all category that includes a lot of functions \u2013 extra data and time operations, conversion functions between number bases, more statistics, and complex numbers. See IMSUM and ROMAN below for examples. The \"Add-ins\" documentation starts at https://help.libreoffice.org/Calc/Add-in_Functions/ , and continues in https://help.libreoffice.org/Calc/Add-in_Functions,_List_of_Analysis_Functions_Part_One/ and https://help.libreoffice.org/Calc/Add-in_Functions,_List_of_Analysis_Functions_Part_Two/ . A different organization for the functions documentation is used at the OpenOffice site ( https://wiki.openoffice.org/wiki/Documentation/How_Tos/Calc:_Functions_listed_by_category/ ), and is probably easy to use when browsing/searching for a suitable function. If you know the name of the function, then a reasonably effective way of finding its documentation is to search for \"libreoffice calc function\" + the function name. The standard way of using these functions is, of course, inside cell formulae. But it's also possible to call them from code via the XFunctionAccess interface. XFunctionAccess only contains a single function, callFunction(), but it can be a bit hard to use due to data typing issues. Calc.callFun() creates an XFunctionAccess instance, and executes callFunction(): // in the Calc class public static Object callFun ( String funcName , Object [] args ) { try { XFunctionAccess fa = Lo . createInstanceMCF ( XFunctionAccess . class , \"com.sun.star.sheet.FunctionAccess\" ); return fa . callFunction ( funcName , args ); } catch ( Exception e ) { System . out . println ( \"Could not invoke \\\"\" + funcName + \"\\\"\" ); return null ; } } // end of callFun() public static Object callFun ( String funcName , Object arg ) { return callFun ( funcName , new Object [] { arg }); } Calc.callFun() is passed the Calc function name and an array of arguments; the function's result is returned as an Object instance. The second version of Calc.callFun() is for calling functions that accept a single argument. Several examples of how to use Calc.callFun() can be found in the FunctionsTest.java example: // in FunctionsTest.java public static void main ( String [] argus ) { XComponentLoader loader = Lo . loadOffice (); // round a double System . out . println ( \"ROUND result for 1.999 is: \" + Calc . callFun ( \"ROUND\" , 1.999 ) + \"\\n\" ); : // more examples, explained below Lo . closeOffice (); } // end of main() The value passed to Calc.callFun() in the code above is an ordinary double, but Java autoboxes it to become a Double object. This is passed to the second version of Calc.callFun() which handles a single Object input argument. The printed result is: ROUND result for 1.999 is: 2.0 Java can be used to convert the returned Object value. For example, the value returned by ROUND can be cast to a double: double res = ( Double ) Calc . callFun ( \"ROUND\" , 1.999 ); The Object is cast to Double, and then Java unboxes the object, converting it to a double. Function calls can be nested, as in: // in FunctionsTest.java System . out . printf ( \"SIN result for 30 degrees is: %.3f\\n\\n\" , Calc . callFun ( \"SIN\" , Calc . callFun ( \"RADIANS\" , 30 ))); The call to RADIANS converts 30 degrees to radians. The returned Object is accepted by the SIN function as input. The output is: SIN result for 30 degrees is: 0.500 Many functions require more than one argument. In that case, the sequence of arguments must be stored in an Object[] array before passing them to Calc.callFun(). For instance: // in FunctionsTest.java Object [] args = new Object [] { 1 , 2 , 3 , 4 , 5 }; // five args double avg = ( Double ) Calc . callFun ( \"AVERAGE\" , args ); System . out . println ( \"Average of the numbers is: \" + avg + \"\\n\" ); This reports the average to be 3.0. When the Calc function documentation talks about an \"array\" or \"matrix\" argument, then the data needs to be packaged as a 2D array. For example, the SLOPE function takes two arrays of x and y coordinates as input, and calculates the slope of the line through them. These two 1D arrays must be passed to Calc.callFun() as two 2D arrays: // in FunctionsTest.java double [][] xData = {{ 1.0 , 2.0 , 3.0 }}; // a 2D array/matrix holding one row of data double [][] yData = {{ 3.0 , 6.0 , 9.0 }}; args = new Object [] { yData , xData }; double slope = ( Double ) Calc . callFun ( \"SLOPE\" , args ); System . out . println ( \"SLOPE of the line: \" + slope + \"\\n\" ); The args array has to be built in stages so that the two arrays can be treated as two Objects. The slope result is 3.0, as expected. The functions in the \"Array\" category almost all use 2D arrays as arguments. For example, the TRANSPOSE function is called like so: // in FunctionsTest.java // transpose a matrix double [][] arr = {{ 1 , 2 , 3 },{ 4 , 5 , 6 }}; args = new Object [] { arr }; Object [][] transMat = ( Object [][] ) Calc . callFun ( \"TRANSPOSE\" , args ); Calc . printArray ( transMat ); The input array is in row-order, so the array arr created above has two rows and three columns. The printed transpose is: Row x Column size: 3 x 2 1.0 4.0 2.0 5.0 3.0 6.0 Note that the result of this call to Calc.callFun() was not a double but a transposed 2D array, which is why the Object result was cast to Object[][]. Unfortunately, Java's typing does not allow the result to be cast to double[][]. The casting can be done using Calc.convertToDoubles(): double [][] trans = Calc . convertToDoubles ( transMat ); The TRANSPOSE function only takes a single argument, so it's possible to use the second version of Calc.callFun() which takes a single Object input argument. A slight problem is caused by Java's type system; it's necessary to explicitly cast the double[][] array to Object in the call: // in FunctionsTest.java Object [][] transMat = ( Object [][] ) Calc . callFun ( \"TRANSPOSE\" , ( Object ) arr ); If arr is not cast then Java will issue a runtime error. There are several functions for manipulating imaginary numbers, which must be written in the form of strings. For example, IMSUM sums a series of complex numbers like so: // in FunctionsTest.java // sum two imaginary numbers: \"13+4j\" + \"5+3j\" returns 18+7j. String [][] nums = {{ \"13+4j\" },{ \"5+3j\" }}; args = new Object [] { nums }; String sum = ( String ) Calc . callFun ( \"IMSUM\" , args ); System . out . println ( \"13+4j + 5+3j: \" + sum + \"\\n\" ); Since IMSUM expects a series of complex numbers, Calc.callFun() must be passed a 2D array. Each row contains a single string argument representing a complex number. The summed complex number is returned as the string \"18+7j\". This means that the Calc.callFun() result is cast to String in this case. The IMSUM function is only processing a single argument, and so the single argument version of Calc.callFun() can be called. As with the TRANSPOSE function example, the String[][] array must be expicitly cast to an Object: String sum = ( String ) Calc . callFun ( \"IMSUM\" , ( Object ) nums ); Functions Help \u00b6 If you can't access the Calc documentation on functions, then Calc.java contains two help functions: Calc.getFunctionNames() and Calc.printFunctionInfo(). The former prints a very long list of function names: // in FunctionsTest.java System . out . println ( \"Function names\" ); Lo . printNames ( Calc . getFunctionNames (), 6 ); The output begins like so: Function names No. of names: 483 \"ABS\" \"ACCRINT\" \"ACCRINTM\" \"ACOS\" \"ACOSH\" \"ACOT\" \"ACOTH\" \"ADDRESS\" \"AGGREGATE\" \"AMORDEGRC\" \"AMORLINC\" \"AND\" \"ARABIC\" \"AREAS\" \"ASC\" \"ASIN\" \"ASINH\" \"ATAN\" \"ATAN2\" \"ATANH\" \"AVEDEV\" \"AVERAGE\" \"AVERAGEA\" \"AVERAGEIF\" \"AVERAGEIFS\" \"B\" \"BAHTTEXT\" \"BASE\" \"BESSELI\" \"BESSELJ\" \"BESSELK\" \"BESSELY\" \"BETA.DIST\" \"BETA.INV\" \"BETADIST\" \"BETAINV\" \"BIN2DEC\" \"BIN2HEX\" \"BIN2OCT\" \"BINOM.DIST\" \"BINOM.INV\" \"BINOMDIST\" : If you know a function name, then Calc.printFunctionInfo() will print details about it. For instance, information about the ROMAN function is obtained like so: Calc.printFunctionInfo(\"ROMAN\"); The output is: Properties for \"ROMAN\": Id: 383 Category: 10 Name: ROMAN Description: Converts a number to a Roman numeral. Arguments: [Lcom.sun.star.sheet.FunctionArgument;@b3fc9e No. of arguments: 2 1. Argument name: Number Description: \"The number to be converted to a Roman numeral must be in the 0 - 3999 range.\" Is optional?: false 2. Argument name: Mode Description: \"The more this value increases, the more the Roman numeral is simplified. The value must be in the 0 - 4 range.\" Is optional?: true This output states that ROMAN can be called with one or two arguments, the first being a decimal, and the second an optional argument for the amount of 'simplification' carried out on the Roman numeral. For example, here are two ways to convert 999 into Roman form: // in FunctionsTest.java String roman = ( String ) Calc . callFun ( \"ROMAN\" , 999 ); args = new Object [] { 999 , 4 }; // use max simplification String roman4 = ( String ) Calc . callFun ( \"ROMAN\" , args ); System . out . println ( \"999 in Roman numerals: \" + roman + \" or \" + roman4 + \"\\n\" ); The output is: 999 in Roman numerals: CMXCIX or IM Calc.getFunctionNames() and Calc.printFunctionInfo() utilize the XFunctionDescriptions interface for retrieving an indexed container of function descriptions. Each function description is an array of PropertyValue objects, which contain a \"Name\" property. Calc.findFunction() uses this organization to return the PropertyValue[] array for a given function name: // in the Calc class public static PropertyValue [] findFunction ( String funcNm ) // get the function description properties for funcNm { // get all the function descriptions XFunctionDescriptions funcsDesc = Lo . createInstanceMCF ( XFunctionDescriptions . class , \"com.sun.star.sheet.FunctionDescriptions\" ); if ( funcsDesc == null ) { System . out . println ( \"No function descriptions were found\" ); return null ; } // find the description whose fn name == funcNm int numFuncs = funcsDesc . getCount (); for ( int i = 0 ; i < numFuncs ; i ++ ) { try { PropertyValue [] props = ( PropertyValue [] ) funcsDesc . getByIndex ( i ); for ( int p = 0 ; p < props . length ; p ++ ) { if (( props [ p ] . Name . equals ( \"Name\" )) && ( props [ p ] . Value . equals ( funcNm ))) return props ; } } catch ( Exception e ) {} } System . out . println ( \"Function \\\"\" + funcNm + \"\\\" not found\" ); return null ; } // end of findFunction() The PropertyValue[] array contains five properties: \"Name\", \"Description\", \"Id\", \"Category\", and \"Arguments\". The \"Arguments\" property stores an array of FunctionArgument objects which contain information about each argument's name, description, and whether it is optional. This information is printed by Calc.printFunArguments(): // in the Calc class public static void printFunArguments ( PropertyValue [] propVals ) // print the function argument info in propVals { // get the FunctionArgument property FunctionArgument [] fargs = ( FunctionArgument [] ) Props . getValue ( \"Arguments\" , propVals ); if ( fargs == null ) { System . out . println ( \"No arguments found\" ); return ; } // print all the info System . out . println ( \"No. of arguments: \" + fargs . length ); for ( int i = 0 ; i < fargs . length ; i ++ ) printFunArgument ( i , fargs [ i ] ); } // end of printFunArguments() public static void printFunArgument ( int i , FunctionArgument fa ) { System . out . println (( i + 1 ) + \". Argument name: \" + fa . Name ); System . out . println ( \" Description: \\\"\" + fa . Description + \"\\\"\" ); System . out . println ( \" Is optional?: \" + fa . IsOptional + \"\\n\" ); } // end of printFunArgument() Calc . printFunctionInfo () calls Calc . findFunction () and Calc . printFunArguments () to report on a complete function : // in the Calc class public static void printFunctionInfo ( String funcName ) { PropertyValue [] propVals = findFunction ( funcName ); Props . showProps ( funcName , propVals ); printFunArguments ( propVals ); System . out . println (); } // end of printFunctionInfo() 2. Pivot Tables \u00b6 Pivot tables are explained in detail in chapter 8 of the Calc User's Guide. They allow a user to view a spreadsheet consisting of columns of data in a variety of table formats, thereby highlighting the relationships between the columns. For example, Figure 1 shows the small spreadsheet in my \"pivottable1.ods\". Figure 1. The \"pivottable1.ods\" Spreadsheet. The spreadsheet uses a database-like organization, with each row acting as a record, and each column is a different type/kind of information. This formatting style is described in chapter 13 \"Calc as a Simple Database\" in the User Guide. The drawback of this kind of data structuring is that it can be difficult to see the underlying relationships between the columns; this is where pivot tables can help. For example, a pivot table can be generated showing how the \"Category\" column affects \"Revenue (see Figure 2). Figure 2. \"Category\" Affecting \"Revenue\". Note that the pivot table shows the revenue sum in column B, since several revenue entries in the original sheet are covered by each category. Alternatively, it's possible to see how \"Period\" and \"Category\" interact to affect the revenue, as in Figure 3. Figure 3. Period and Category Affect on \"Revenue\". The ordering of the \"Period\" values can be changed by clicking on the arrow next to the \"Period\" text in cell \"A2\", then selecting a custom sort (e.g. Jan, Feb, Mar, etc.). The \"Total Result\" row and column are added automatically, and can be changed easily. It's also possible to change the way that the revenue data is grouped (e.g. it can be averaged instead of being summed). Pivot tables are straightforward to create and modify via Calc's GUI, starting from the Data, Pivot Table, Create menu item. Calc automatically selects all the cells used in the database-like table like the one in Figure 1, and displays the layout dialog shown in Figure 4. Figure 4. The Pivot Table Layout GUI. The right-most \"Available Fields\" list contains the names of the columns in the sheet, while the other four fields (Page, Column, Row, and Data) are empty. Figure 4 shows a bug in the current version of the Pivot Table GUI \u2013 the addition of a \"Data\" name in the \"Column\" fields list. This name cannot be removed from the layout dialog, but can be ignored since it doesn't appear in the rendered pivot table. The pivot table layout in Figure 5 is easily created by dragging the \"Period\" name to the Row fields list, \"Category to the Column fields list, and \"Revenue\" to the Data fields list, where it's converted into \"Sum \u2013 Revenue\". Figure 5. The Layout for the Pivot Table in Figure 3. Pivot Tables in the API \u00b6 The Calc API refers to pivot tables by their old Office name, DataPilot tables. The relationships between the DataPilotservices and interfaces are shown in Figure 6. Figure 6. The DataPilot Services and Interfaces. Figure 6 is best understood by reading downwards: a DataPilotTables service (note the \"s\") is a sequence of DataPilotTable services. Each table contains a DataPilotFields service (note the \"s\") which manages a sequence of DataPilotField objects. Each DataPilotField is a named property set, representing a column in the source sheet. For example, in the following code, four pilot fields will be created for the \"pivottable1.ods\" sheet shown in Figure 1, one each for the columns named Year, Period, Category, and Revenue. Figure 6 mentions one of the more important services \u2013 DataPilotDescriptor, which does the hard work of converting sheet columns into pilot fields. DataPilotDescriptor is also responsible for assigning each pilot field to one of the Page, Column, Row, or Data field lists. The PivotSheet1.java example illustrates how to create the pivot table shown in Figure 3. The program begins by opening the \"pivottable1.ods\" file (Figure 1): // in PivotSheet1.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( \"pivottable1.ods\" , loader ); if ( doc == null ) { System . out . println ( \"Could not open pivottable1.ods\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XSpreadsheet dpSheet = Calc . insertSheet ( doc , \"Pivot Table\" , ( short ) 1 ); createPivotTable ( sheet , dpSheet ); Calc . setActiveSheet ( doc , dpSheet ); Lo . saveDoc ( doc , \"pivotExample1.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() A second sheet (called dpSheet) is created to hold the generated pivot table, and createPivotTable() is called: // in PivotSheet1.java private static void createPivotTable ( XSpreadsheet sheet , XSpreadsheet dpSheet ) { XCellRange cellRange = Calc . findUsedRange ( sheet ); // find the table data on the sheet XDataPilotTables dpTables = Calc . getPilotTables ( sheet ); /* create a new pilot descriptor which will later be added as a new pilot table to the pilot tables */ XDataPilotDescriptor dpDesc = dpTables . createDataPilotDescriptor (); /* add the sheet's column data to the descriptor; this causes the creation of pilot fields */ dpDesc . setSourceRange ( Calc . getAddress ( cellRange ) ); /* assign \"Available\" (Hidden) pilot fields to the Page, Column, Row, and Data fields */ XIndexAccess fields = dpDesc . getHiddenFields (); XPropertySet props ; // set Page field; not used here //props = Lo.findContainerProps(fields, \"Year\"); //Props.setProperty(props, \"Orientation\", // DataPilotFieldOrientation.PAGE); // set Column field props = Lo . findContainerProps ( fields , \"Category\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . COLUMN ); // set Row field props = Lo . findContainerProps ( fields , \"Period\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . ROW ); // set Data field, calculating the sum props = Lo . findContainerProps ( fields , \"Revenue\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . DATA ); Props . setProperty ( props , \"Function\" , GeneralFunction . SUM ); // add new pivot table to other tables and to sheet at A1 CellAddress destAddr = Calc . getCellAddress ( dpSheet , \"A1\" ); dpTables . insertNewByName ( \"PivotTableExample\" , destAddr , dpDesc ); } // end of createPivotTable() All the sheet's data is selected by calling Calc.findUsedRange(). Then Calc.getPilotTables() obtains the DataPilotTables service: // in the Calc class public static XDataPilotTables getPilotTables ( XSpreadsheet sheet ) { XDataPilotTablesSupplier dpSupp = Lo . qi ( XDataPilotTablesSupplier . class , sheet ); XDataPilotTables dpTables = dpSupp . getDataPilotTables (); if ( dpTables == null ) System . out . println ( \"No data pilot tables found\" ); return dpTables ; } // end of getPilotTables() Calc.getPilotTables() utilizes the XDataPilotTablesSupplier interface of the Spreadsheet service to obtain the DataPilotTables service. PivotSheet1.java's task is to create a new pilot table, which it does indirectly by creating a new pilot description. After this pilot description has been initialized, it will be added to the DataPilotTables service as a new pilot table. An empty pilot description is created by calling XDataPilotTables.createDataPilotDescriptor(): // in createPivotTable in PivotTable.java XDataPilotTables dpTables = Calc . getPilotTables ( sheet ); XDataPilotDescriptor dpDesc = dpTables . createDataPilotDescriptor (); The new XDataPilotDescriptor reference (dpDesc) creates a pilot table by carrying out two tasks \u2013 loading the sheet data into the pilot table, and assigning the resulting pilot fields to the Page, Column, Row, and Data fields in the descriptor. This latter task is similar to what the Calc user does in the GUI's layout window in Figure 5. The descriptor is assigned a source range that spans all the data: dpDesc . setSourceRange ( Calc . getAddress ( cellRange ) ); It converts each detected column into a DataPilotField service, which is a named property set; the name is the column heading. These pilot fields are conceptually stored in the \"Available Fields\" list shown in the layout window in Figure 5, and are retrieved by calling XDataPilotDescriptor.getHiddenFields(): XIndexAccess fields = dpDesc . getHiddenFields (); It's useful to list the names of these pilot fields: // in createPivotTable() in PivotSheet1.java String [] fieldNames = Lo . getContainerNames ( fields ); System . out . println ( \"Field Names (\" + fieldNames . length + \"):\" ); for ( String name : fieldNames ) System . out . println ( \" \" + name ); The output for the spreadsheet in Figure 1 is: Field Names (5): Year Period Category Revenue Data This list includes the strange \"Data\" pilot field which you may remember also cropped up in the layout window in Figure 4. The second task is to assign selected pilot fields to the Page, Column, Row, and Data field lists. The standard way of doing this is illustrated below for the case of assigning the \"Category\" pilot field to the Column field list: // in createPivotTable() in PivotSheet1.java XPropertySet props = Lo . findContainerProps ( fields , \"Category\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . COLUMN ); The fields variable refers to all the pilot fields as an indexed container. Lo.findContainerProps() searches through that container looking for the specified field name. // in the Lo class public static XPropertySet findContainerProps ( XIndexAccess con , String nm ) { if ( con == null ) { System . out . println ( \"Container is null\" ); return null ; } for ( int i = 0 ; i < con . getCount (); i ++ ) { try { Object oElem = con . getByIndex ( i ); XNamed named = Lo . qi ( XNamed . class , oElem ); if ( named . getName (). equals ( nm )) { return ( XPropertySet ) Lo . qi ( XPropertySet . class , oElem ); } } catch ( Exception e ) { System . out . println ( \"Could not access element \" + i ); } } System . out . println ( \"Could not find a \\\"\" + nm + \"\\\" prop set\" ); return null ; } // end of findContainerProps() The returned property set is an instance of the DataPilotField service, so a complete list of all the properties can be found in its documentation (use lodoc datapilotfield ). The important property for our needs is \"Orientation\" which can be assigned a DataPilotFieldOrientation constant, whose values are HIDDEN, COLUMN, ROW, PAGE, and DATA, representing the field lists in the layout window. Once the required pilot fields have been assigned to field lists, the new pivot table is added to the other tables and to the sheet by calling XDataPilotTables.insertNewByName(). It takes three arguments: a unique name for the table, the cell address where the table will be drawn, and the completed pilot descriptor: // in createPivotTable() in PivotSheet1.java // add new pivot table to other tables and to sheet at A1 CellAddress destAddr = Calc . getCellAddress ( dpSheet , \"A1\" ); dpTables . insertNewByName ( \"PivotTableExample\" , destAddr , dpDesc ); This code should mark the end of the createPivotTable() method, but I found that more complex pivot tables would often not be correctly drawn. The cells in the Data field would be left containing the word \"#VALUE!\". This problem can be fixed by explicitly requesting a refresh of the pivot table, using: // in createPivotTable() in PivotSheet1.java // access pilot tables XDataPilotTables dpTables2 = Calc . getPilotTables ( dpSheet ); // find new table by name XDataPilotTable dpTable = Calc . getPilotTable ( dpTables2 , \"PivotTableExample\" ); if ( dpTable != null ) dpTable . refresh (); // update the table entries Calc.getPilotTable() searches XDataPilotTables, which is a named container of XDataPilotTable objects. Oddly enough, it's not enough to call Calc.getPilotTable() on the current XDataPilotTables reference (called dpTables in createPivotTable()), since the new pivot table isn't found. My \"Calc Tests\" folder contains two more pivot table examples, called PivotSheet2.java and PivotTable.java. PivotSheet2.java creates a more complex pivot table after reading in the spreadsheet stored in pivottable2.ods. PivotTable.java creates its own spreadsheet before generating a table. Both examples only use the methods in PivotSheet1.java, so won't be described here. 3. Seeking a Goal \u00b6 The Tools, Goal Seek menu item in Calc allows a formula to be executed 'backwards'. Instead of supplying the input to a formula, and obtaining the formula's result, the result is given and \"goal seek\" works backwards through the formula to calculate the value that produces the result. The GoalSeek.java example contains several uses of \"goal seeking\". It begins like so: // in GoalSeek.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XGoalSeek gs = Lo . qi ( XGoalSeek . class , doc ); Calc . setVal ( sheet , \"C1\" , 9 ); // x-variable and starting value Calc . setVal ( sheet , \"C2\" , \"=SQRT(C1)\" ); // formula double x = Calc . goalSeek ( gs , sheet , \"C1\" , \"C2\" , 4 ); // x-var, formula, result System . out . println ( \"x == \" + x + \" when sqrt(x) == 4\\n\" ); // x is 16 : // more goal seek examples Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Goal seek functionality is accessed via the XGoalSeek interface of the document. Also, a spreadsheet is needed to hold an initial guess for the input value being calculated (which I'll call the x-variable), and for the formula. In the example above, the x-variable is stored in cell \"C1\" with an initial value of 9, and its formula (sqrt(x)) in cell \"C2\". Calc.goalSeek() is passed the cell names of the x-variable and formula, and the formula's result, and returns the x-value that produces that result. In the example above, Calc.goalSeek() returns 16, because that's the input to sqrt() that results in 4. Calc.goalSeek() is defined as: // in the Calc class public static double goalSeek ( XGoalSeek gs , XSpreadsheet sheet , String xCellName , String formulaCellName , double result ) // find x input to formula which produces result; // use value in xCellName as a starting guess { CellAddress xPos = Calc . getCellAddress ( sheet , xCellName ); CellAddress formulaPos = Calc . getCellAddress ( sheet , formulaCellName ); GoalResult goalResult = gs . seekGoal ( formulaPos , xPos , \"\" + result ); if ( goalResult . Divergence >= 0.1 ) System . out . println ( \"NO result; divergence: \" + goalResult . Divergence ); return goalResult . Result ; } // end of goalSeek() The heart of Calc.goalSeek() is a call to XGoalSeek.seekGoal() which requires three arguments: the address of the x-variable cell, the address of the formula cell, and a string representing the formula's result. The call returns a GoalResult object that contains two fields: Result holds the calculated x-value, and Divergence measures the accuracy of the x-value. If the goal seek has succeeded, then the Divergence value should be very close to 0; if it failed to find an x-value then Divergence may be very large since it measures the amount the x-value changed in the last iteration of the \"goal seek\" algorithm. I wasn't able to find out what algorithm \"goal seek\" employs, but it's most likely a root-finding methods, such as Newton\u2013Raphson or the secant method. These may fail for a poor choice of starting x-value or if the formula function has a strange derivative (an odd curvature). This can be demonstrated by asking \"goal seek\" to look for an impossible x-value, such as the input that makes sqrt(x) == -4: // in GoalSeek.java x = Calc . goalSeek ( gs , sheet , \"C1\" , \"C2\" , - 4 ); System . out . println ( \"x == \" + x + \" when sqrt(x) == -4\\n\" ); There's no need to change the starting value in \"C1\" or the formula in \"C2\". The output is: NO result; divergence: 1.7976931348623157E308 x == 3.2462079627414548E-6 when sqrt(x) == -4 \"Goal seek\" can be useful when examining complex equations, such as: [*** missing formula ***] What's the x-value that produces y == 2? Actually, this equation is simple: is factorized into , and the common factor removed from the fraction; the equation becomes: So when y == 2, x will be 1. But let's do things the number-crunching way, and supply the original formula to \"goal seek\": // in GoalSeek.java Calc . setVal ( sheet , \"D1\" , 0.8 ); // x-variable and starting value Calc . setVal ( sheet , \"D2\" , \"=(D1^2 - 1)/(D1 - 1)\" ); // formula x = Calc . goalSeek ( gs , sheet , \"D1\" , \"D2\" , 2 ); System . out . println ( \"x == \" + x + \" when x+1 == 2\\n\" ); The printed x-value is: 1.0000000000000053. If a formula requires numerical values, they can be supplied as cell references, which allows them to be adjusted easily. The next \"goal seek\" example employs an annual interest formula, I = x*n*i, where I is the annual interest, x the capital, n the number of years, and i the interest rate. As usual, the x-variable has a starting value in a cell, but n and i are also represented by cells so that they can be changed. The code is: // in GoalSeek.java Calc . setVal ( sheet , \"B1\" , 100000 ); // x-variable; possible value Calc . setVal ( sheet , \"B2\" , 1 ); // n, no. of years Calc . setVal ( sheet , \"B3\" , 0.075 ); // i, interest rate (7.5%) Calc . setVal ( sheet , \"B4\" , \"=B1*B2*B3\" ); // formula x = Calc . goalSeek ( gs , sheet , \"B1\" , \"B4\" , 15000 ); System . out . println ( \"x == \" + x + \" when x*\" + Calc . getVal ( sheet , \"B2\" ) + \"*\" + Calc . getVal ( sheet , \"B3\" ) + \" == 15000\\n\" ); // x is 200,000 \"Goal seek\" is being asked to determine the x-value when the annual return from the formula is 20000. The values in the cells \"B2\" and \"B3\" are employed, and the printed answer is: x == 200000.0 when x*1.0*0.075 == 15000 4. Linear and Nonlinear Solving \u00b6 Calc supports both linear and nonlinear programming via its Tools \uf0e0 Solver menu item. The name \"linear programming\" dates from just after World War II, and doesn't mean programming in the modern sense; in fact, it's probably better to use its other common name, \"linear optimization\". Linear optimization starts with a series of linear equations involving inequalities, and finds the best numerical values that satisfy the equations according to a 'profit' equation that must be maximized (or minimized). Fortunately, this has a very nice graphical representation when the equations only involve two unknowns: the equations cam be drawn as lines crossing the x- and y- axes, and the best values will be one of the points where the lines intersect. As you might expect, nonlinear programming (optimization) is a generalization of the linear case where some of the equations are non-linear (e.g. perhaps they involve polynomials, logarithmic, or trigonometric functions). A gentle introduction to linear optimization and its graphing can be found at https://purplemath.com/modules/linprog.htm , or you can start at the Wikipedia page, https://en.wikipedia.org/wiki/Linear_programming/ . The Calc documentation on linear and nonlinear solving is rather minimal. There's no mention of it in the Calc Developer's Guide, and just a brief section on its GUI at the end of chapter 9 (\"Data Analysis\") of the Calc User guide. The current version of LibreOffice (v. 5) offers four optimization tools (called solvers) \u2013 two linear optimizers called \"LibreOffice Linear Solver\" and \"LibreOffice CoinMP Linear Solver\", and two nonlinear ones called \"DEPS Evolutionary Algorithm\" and \"SCO Evolutionary Algorithm\". The easiest way of checking the current solver situation in your version of Office is to look at Calc's Solver dialog window (by clicking on the Tools \uf0e0 Solver menu item), and click on the \"Options\" button. The options dialog window lists all the installed solvers, and their numerous parameters, as in Figure 8. Figure 8. The LibreOffice Solvers and their Parameters. Another way of getting a list of the installed solvers, is to call Calc.listSolvers(), which is demonstrated in the first example given below. The two linear solvers are implemented as DLLs, located in the \\program folder as lpsolve55.dll and CoinMP.dll. The source code for these libraries is online, at https://docs.libreoffice.org/sccomp/html/files.html , with the code (and graphs of the code) accessible via the \"Files\" tab. The file names are LpsolveSolver.cxx and CoinMPSolver.cxx. The lpsolve55.dll filename strongly suggests that Office's basic linear solver is lp_solve 5.5, which originates online at https://lpsolve.sourceforge.net/ . That site has extensive documentation, including a great introduction to linear optimization. The first programming example below comes from one of the examples in its documentation. One interesting possibility for the lpsolve library is that it can be called directly from Java without the need for Calc. The necessary steps are described on the \"Using lp_solve 5.5 in Java programs\" page for lp_solve 5.5 at https://lpsolve.sourceforge.net/ . The relevant download is lp_solve_5.5.2.0_java.zip from https://sourceforge.net/projects/lpsolve/files/lpsolve/5.5.2.0/ . Office's other linear optimizer, the CoinMP solver, comes from the COIN-OR (Computational Infrastructure for Operations Research) open-source project which started at IBM research ( https://coin-or.org/ ). According to https://coin-or.org/projects/CoinMP.xml , CoinMP implements most of the functionality of three other COIN-OR projects, called CLP (Coin LP), CBC (Coin Branch-and-Cut), and CGL (Cut Generation Library). The CLP and CBC solvers are documented at https://coin-or.org/projects/Clp.xml and https://coin-or.org/projects/Cbc.xml , and come with large user guides, at https://coin-or.org/Clp/userguide/ and https://www.coin-or.org/Cbc/ . The collection of cut generators in the CGL library is used to speed up the execution of CLP and CBC (see https://coin-or.org/projects/Cgl.xml ). A good overview of COIN-OR can be found in a series of slides by Matthew Saltzman at https://dimacs.rutgers.edu/Workshops/COIN/slides/saltzman.pdf . There's also a Wikipedia page about COIN-OR. The two nonlinear solvers are known as DEPS and SCO for short, and are explained in the OpenOffice wiki at https://wiki.openoffice.org/wiki/NLPSolver/ , along with descriptions of their extensive (and complicated) parameters. They're implemented as JAR files, located in \\share\\extensions\\nlpsolver as nlpsolver.jar and EvolutionarySolver.jar. Two of the examples below use these solvers. 4.1. A Linear Optimization Problem \u00b6 The LinearSolverTest.java example shows how to use the basic linear solver, and also CoinMP. It implements the following linear optimization problem, which comes from https://lpsolve.sourceforge.net/5.1/formulate.htm . There are three constraint inequalities: 120x + 210y \u2264 15000 110x + 30y \u2264 4000 x + y \u2264 75 The 'profit' expression to be maximized is: P = 143x + 60y The maximum P value is 6315.625, when x == 21.875 and y == 53.125. Perhaps the easiest way of calculating this outside of Office is via the linear optimization tool at https://zweigmedia.com/utilities/lpg/index.html?lang=en . Its solution is shown in Figure 9. Figure 9. Solved and Graphed Linear Optimization Problem. Aside from giving the answer, the equations are graphed, which shows how the maximum profit is one of the equation's intersection points. The main() function for LinearSolverTest.java: // in LinearSolverTest.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . listSolvers (); // specify the variable cells CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress [] vars = new CellAddress [] { xPos , yPos }; // specify profit equation Calc . setVal ( sheet , \"B3\" , \"=143*B1 + 60*B2\" ); // P = 143x + 60y, maximize CellAddress profitEqu = Calc . getCellAddress ( sheet , \"B3\" ); // set up equation formulae without inequalities Calc . setVal ( sheet , \"B4\" , \"=120*B1 + 210*B2\" ); Calc . setVal ( sheet , \"B5\" , \"=110*B1 + 30*B2\" ); Calc . setVal ( sheet , \"B6\" , \"=B1 + B2\" ); // create the constraints // constraints are equations and their inequalities SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 15000 ); // 120x + 210y <= 15000 // B4 is the cell address that is constrained SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B5\" , \"<=\" , 4000 ); // 110x + 30y <= 4000 SolverConstraint sc3 = Calc . makeConstraint ( sheet , \"B6\" , \"<=\" , 75 ); // x + y <= 75 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 , sc3 }; // initialize the linear solver (basic linear or CoinMP) XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.LpsolveSolver\" ); // \"com.sun.star.comp.Calc.CoinMPSolver\"); // System.out.println(\"Solver: \" + solver); solver . setDocument ( doc ); solver . setObjective ( profitEqu ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); Props . showObjProps ( \"Solver\" , solver ); Props . setProperty ( solver , \"NonNegative\" , true ); // restrict the search to the top-right quadrant of the graph // execute the solver; print the result solver . solve (); Calc . solverReport ( solver ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The call to Calc.listSolvers() isn't strictly necessary but it provides useful information about the names of the solver services: Services offered by the solver : com . sun . star . comp . Calc . CoinMPSolver com . sun . star . comp . Calc . LpsolveSolver com . sun . star . comp . Calc . NLPSolver . DEPSSolverImpl com . sun . star . comp . Calc . NLPSolver . SCOSolverImpl One of these names is needed when calling Lo.createInstanceMCF() to create a solver instance. Calc.listSolvers() is implemented as: // in the Calc class public static void listSolvers () { System . out . println ( \"Services offered by the solver:\" ); String [] nms = Info . getServiceNames ( \"com.sun.star.sheet.Solver\" ); if ( nms == null ) System . out . println ( \" none\" ); else { for ( String service : nms ) System . out . println ( \" \" + service ); System . out . println (); } } // end of listSolvers() The real work of listSolvers() is done by calling Info.getServiceNames() which finds all the implementations that support \"com.sun.star.sheet.Solver\". Back in LinearSolverTest.java, the inequality and profit equations are defined as formulae in a sheet, and the variables in the equations are also assigned to cells. The two variables in this problem (x and y) are assigned to the cells \"B1\" and \"B2\", and the cell addresses are stored in an array for later: // in LinearSolverTest.java CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress [] vars = new CellAddress [] { xPos , yPos }; Next the equations are defined. Their formulae are assigned to cells without their inequality parts: // in LinearSolverTest.java // specify profit equation Calc . setVal ( sheet , \"B3\" , \"=143*B1 + 60*B2\" ); // P = 143x + 60y, maximize CellAddress profitEqu = Calc . getCellAddress ( sheet , \"B3\" ); // set up equation formulae without inequalities Calc . setVal ( sheet , \"B4\" , \"=120*B1 + 210*B2\" ); Calc . setVal ( sheet , \"B5\" , \"=110*B1 + 30*B2\" ); Calc . setVal ( sheet , \"B6\" , \"=B1 + B2\" ); Now the three equation formulae are converted into SolverConstraint objects by calling Calc.makeConstraint(), and the constraints are stored in an array for later use: // in LinearSolverTest.java // create the constraints: // constraints are equations and their inequalities SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 15000 ); // 120x + 210y <= 15000 // B4 is the cell address that is constrained SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B5\" , \"<=\" , 4000 ); // 110x + 30y <= 4000 SolverConstraint sc3 = Calc . makeConstraint ( sheet , \"B6\" , \"<=\" , 75 ); // x + y <= 75 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 , sc3 }; A constraint is the cell name where an equation is stored and an inequality. Calc.makeConstraint() is defined as: // in the Calc class public static SolverConstraint makeConstraint ( XSpreadsheet sheet , String cellName , String op , double d ) { return makeConstraint ( Calc . getCellAddress ( sheet , cellName ), op , d ); } public static SolverConstraint makeConstraint ( CellAddress addr , String op , double d ) { return makeConstraint ( addr , toConstraintOp ( op ), d ); } public static SolverConstraint makeConstraint ( XSpreadsheet sheet , String cellName , SolverConstraintOperator op , double d ) { return makeConstraint ( Calc . getCellAddress ( sheet , cellName ), op , d );} public static SolverConstraint makeConstraint ( CellAddress addr , SolverConstraintOperator op , double d ) { SolverConstraint sc = new SolverConstraint (); sc . Left = addr ; sc . Operator = op ; sc . Right = d ; return sc ; } // end of makeConstraint() That's a lot of functions to create a SolverConstraint object with four arguments. Now the solver is created, and its parameters are set: // in LinearSolverTest.java XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.LpsolveSolver\" ); solver . setDocument ( doc ); solver . setObjective ( profitEqu ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); // maximize the profit equ The XSolver interface is utilized by all the solvers, but the name of service can vary. In the code above I'm using the basic linear solver. A CoinMP solver would be created by changing \"LpsolveSolver\" to \"CoinMPSolver\": XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.CoinMPSolver\" ); The various \"set\" methods are described in the XSolver documentation as public variables (call lodoc xsolver to see the page). They load the profit equation, constraints, and variables into the solver. It's also necessary to specify that the profit equation be maximized, and link the solver to the Calc document. These \"set\" methods are used in the same way no matter which of the four solvers is employed. Where the solvers differ is in their service properties. As mentioned above, there's a few sources of online information depending on which solver you're using, or you could look at the options dialog window shown in Figure 8. Another source is to call Props.showObjProps() on the solver, to list its property names and current values: Props.showObjProps(\"Solver\", solver); When the basic linear solver is being used, showObjProps()'s output is: EpsilonLevel == 0 Integer == false LimitBBDepth == true NonNegative == false Timeout == 100 This corresponds to the information shown for the basic linear solver in the options dialog in Figure 10. Figure 10. The Options Dialog for the Basic Linear Solver. As to what these parameters actually mean, you'll have to look through the \"lp_solve API reference\" section of the documentation at https://lpsolve.sourceforge.net/ . For example, the \"epsilon level\" is partly explained under the sub-heading \"set_epslevel\". The only property I've changed in the LinearSolverTest.java example is \"NonNegative\", which is set to true: // in LinearSolverTest.java ... Props . setProperty ( solver , \"NonNegative\" , true ); This restricts the search for intersection points to the top-right quadrant of the graph. Alternatively I could have implemented two more constraints: x \u2265 0 y \u2265 0 The solver's results are printed by Calc.solverReport(): // in LinearSolverTest.java solver . solve (); Calc . solverReport ( solver ); The output: Solver result: B3 == 6315.6250 Solver variables: B1 == 21.8750 B2 == 53.1250 Calc.solverReport() is implemented as: // in the Calc class public static void solverReport ( XSolver solver ) { boolean isSuccessful = solver . getSuccess (); if ( isSuccessful ) { String cellName = getCellStr ( solver . getObjective ()); System . out . println ( \"Solver result: \" ); System . out . printf ( \" %s == %.4f\\n\" , cellName , solver . getResultValue ()); CellAddress [] addrs = solver . getVariables (); double [] solns = solver . getSolution (); System . out . println ( \"Solver variables: \" ); for ( int i = 0 ; i < solns . length ; i ++ ) { cellName = getCellStr ( addrs [ i ] ); System . out . printf ( \" %s == %.4f\\n\" , cellName , solns [ i ] ); } System . out . println (); } else System . out . println ( \"Solver FAILED\" ); } // end of solverReport() XSolver.getObjective() and XSolver.getVariables() return the cell addresses holding the profit equation and the variables (x and y). In a corresponding fashion, XSolver.getResultValue() and XSolver.getSolution() return the calculated values for the profit equation and variables. A solver may fail, and so solverReport() first calls XSolver.getSuccess(). 4.2. Another Linear Problem (using SCO) \u00b6 I've coded two examples using the nonlinear optimizers \u2013 SolverTest.java utilizes the SCO solver, and SolverTest2.java employs DEPS. As I mentioned earlier, these two solvers are explained at https://wiki.openoffice.org/wiki/NLPSolver/ . The SolverTest.java example solves a linear problem, but one involving three unknowns. This means that graphically the equations define planes in a 3D space, and solving the profit equation involves examining the corners of the volume defined by how the planes intersect. Unfortunately, the https://zweigmedia.com/utilities/lpg/index.html?lang=en website cannot handle linear optimizations involving more than two variables, but no such restriction applies to Calc's solvers. There are three constraint inequalities: x \u2264 6 y \u2264 8 z \u2265 4 The 'profit' expression to be maximized is: P = x + y - z The maximum P value is 10, when x == 6, y == 8, and z == 4. Much of main() in SolverTest.java is very similar to LinearSolver.java: // part of main() in SolverTest.java : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // specify the variable cells CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress zPos = Calc . getCellAddress ( sheet , \"B3\" ); // z CellAddress [] vars = new CellAddress [] { xPos , yPos , zPos }; // only define the profit formula without inequality Calc . setVal ( sheet , \"B4\" , \"=B1+B2-B3\" ); CellAddress objective = Calc . getCellAddress ( sheet , \"B4\" ); // create three constraints (using the 3 variables) SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B1\" , \"<=\" , 6 ); // x <= 6 SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B2\" , \"<=\" , 8 ); // y <= 8 SolverConstraint sc3 = Calc . makeConstraint ( sheet , \"B3\" , \">=\" , 4 ); // z >= 4 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 , sc3 }; // initialize the SCO nonlinear solver XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.NLPSolver.SCOSolverImpl\" ); solver . setDocument ( doc ); solver . setObjective ( objective ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); Props . showObjProps ( \"Solver\" , solver ); Props . setProperty ( solver , \"EnhancedSolverStatus\" , false ); // switch off nonlinear dialog about current progress // execute the solver solver . solve (); Calc . solverReport ( solver ); Only the profit formula needs to be assigned to a cell due to the simplicity of the equation inequalities. Their constraints can use the cells containing the x, y, and z variables rather than be defined as separate formulae. The Solver is \"com.sun.star.comp.Calc.NLPSolver.SCOSolverImpl\", whose name I found by listing the solver names with Calc.listSolvers(). The properties associated with the SCO solver are more extensive than for the linear solvers. Props.showObjProps() reports: Solver Properties AssumeNonNegative == false EnhancedSolverStatus == true GuessVariableRange == true LearningCycles == 2000 LibrarySize == 210 StagnationLimit == 70 SwarmSize == 70 Tolerance == 1.0E-6 UseACRComparator == false UseRandomStartingPoint == false VariableRangeThreshold == 3.0 These can also be viewed via the Options dialog in the Calc GUI, as in Figure 11. Figure 11. The Options Dialog for the SCO Solver. These parameters, most of which apply to the DEPS solver as well, are explained at https://wiki.openoffice.org/wiki/NLPSolver#Options_and_Parameters . The correct solution reported by Calc.solverReport() is: Solver result: B4 == 10.0000 Solver variables: B1 == 6.0000 B2 == 8.0000 B3 == 4.0000 4.3. A Nonlinear Problem (using DEPS and SCO) \u00b6 SolverTest2.java defines a nonlinear optimization problem, so can only be solved by the DEPS or SCO solver; I'll start with DEPS. The problem comes from the Wikipedia page on nonlinear programming ( https://en.wikipedia.org/wiki/Nonlinear_programming/ ). There are four constraint inequalities: x \u2265 0 y \u2265 0 x 2 + y 2 \u2265 1 x 2 + y 2 \u2264 2 The 'profit' expression to be maximized is: P = x + y The maximum P value is 2, when x == 1 and y == 1, which can be represented graphically in Figure 12 since we're once again using only two unknowns. Figure 12. Solution for the Nonlinear Optimization Problem. The code in SolverTest2.java is only slightly different from the previous two examples: // part of main() in SolverTest2.java : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // specify the variable cells CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress [] vars = new CellAddress [] { xPos , yPos }; // specify profit equation Calc . setVal ( sheet , \"B3\" , \"=B1+B2\" ); // x + y CellAddress objective = Calc . getCellAddress ( sheet , \"B3\" ); // set up equation formula without inequality (only one needed) Calc . setVal ( sheet , \"B4\" , \"=B1*B1 + B2*B2\" ); // x^2 + y^2 // create two constraints from one equation SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \">=\" , 1 ); // x^2 + y^2 >= 1 SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 2 ); // x^2 + y^2 <= 2 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 }; // initialize DEPS nonlinear solver XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.sheet.Solver\" ); // uses \"com.sun.star.comp.Calc.NLPSolver.DEPSSolverImpl\" solver . setDocument ( doc ); solver . setObjective ( objective ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); Props . showObjProps ( \"Solver\" , solver ); Props . setProperty ( solver , \"EnhancedSolverStatus\" , false ); // switch off nonlinear dialog about current progress Props . setProperty ( solver , \"AssumeNonNegative\" , true ); // restrict search to the top-right quadrant of graph // execute the solver; print the results solver . solve (); Calc . solverReport ( solver ); Only one inequality equation is defined: Calc.setVal(sheet, \"B4\", \"=B1*B1 + B2*B2\"); // x^2 + y^2 because it can be used twice to define the nonlinear constraints: SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \">=\" , 1 ); // x^2 + y^2 >= 1 SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 2 ); // x^2 + y^2 <= 2 No constraints are defined for x >= 0 and y >= 0. Instead, the solver's \"AssumeNonNegative\" property is set to true, which achieves the same thing. The DEPS solver is used by default when a nonlinear optimization needs to be solved, so the solver is instantiated using the general Solver service name: XSolver solver = Lo.createInstanceMCF(XSolver.class, \"com.sun.star.sheet.Solver\"); Alternatively, it's possible to use the DEPS service name: \"com.sun.star.comp.Calc.NLPSolver.DEPSSolverImpl\" . The results printed by Calc.solverReport() are: Solver result: B3 == 2.0000 Solver variables: B1 == 1.0001 B2 == 0.9999 If DEPS is replaced by the SCO solver: XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.NLPSolver.SCOSolverImpl\" ); The printed result is slightly more accurate: Solver result: B3 == 2.0000 Solver variables: B1 == 1.0000 B2 == 1.0000 but it takes a little bit longer to return.","title":"Chapter 27. Functions and Data Analysis"},{"location":"27-Funcs_Analysis.html#chapter-27-functions-and-data-analysis","text":"Topics Calling Calc Functions from Code; Pivot Tables; Goal Seek; Linear and Nonlinear Solving (using SCO, DEPS) Example folders: \"Calc Tests\" and \"Utils\" This chapter looks at how to utilize Calc's spreadsheet functions directly from Java, and then examines four of Calc's data analysis features: pivot tables, goal seeking, and linear and nonlinear solving. There are two nonlinear examples, one using the SCO solver, the using employing DEPS.","title":"Chapter 27. Functions and Data Analysis"},{"location":"27-Funcs_Analysis.html#1-calling-calc-functions-from-code","text":"Calc comes with an extensive set of functions, which are described in Appendix B of the Calc User Guide, available from https://libreoffice.org/get-help/documentation/ . The information is also online at https://help.libreoffice.org/Calc/Functions_by_Category/ , organized into 11 categories: Database: for extracting information from Calc tables, where the data is organized into rows. The \"Database\" name is a little misleading, but the documentation makes the point that Calc database functions have nothing to do with Base databases. Chapter 13 of the Calc User Guide (\"Calc as a Simple Database\") explains the distinction in detail. Date and Time; e.g. see the EASTERSUNDAY function below Financial: for business calculations; Information: many of these return boolean information about cells, such as whether a cell contains text or a formula; Logical: functions for boolean logic; Mathematical: trigonometric, hyperbolic, logarithmic, and summation functions; e.g. see ROUND, SIN, and RADIANS below; Array: many of these operations treat cell ranges like 2D arrays; e.g. see TRANSPOSE below; Statistical: for statistical and probability calculations; e.g., see AVERAGE and SLOPE below; Spreadsheet: for finding values in tables, cell ranges, and cells; Text: string manipulation functions; Add-ins: a catch-all category that includes a lot of functions \u2013 extra data and time operations, conversion functions between number bases, more statistics, and complex numbers. See IMSUM and ROMAN below for examples. The \"Add-ins\" documentation starts at https://help.libreoffice.org/Calc/Add-in_Functions/ , and continues in https://help.libreoffice.org/Calc/Add-in_Functions,_List_of_Analysis_Functions_Part_One/ and https://help.libreoffice.org/Calc/Add-in_Functions,_List_of_Analysis_Functions_Part_Two/ . A different organization for the functions documentation is used at the OpenOffice site ( https://wiki.openoffice.org/wiki/Documentation/How_Tos/Calc:_Functions_listed_by_category/ ), and is probably easy to use when browsing/searching for a suitable function. If you know the name of the function, then a reasonably effective way of finding its documentation is to search for \"libreoffice calc function\" + the function name. The standard way of using these functions is, of course, inside cell formulae. But it's also possible to call them from code via the XFunctionAccess interface. XFunctionAccess only contains a single function, callFunction(), but it can be a bit hard to use due to data typing issues. Calc.callFun() creates an XFunctionAccess instance, and executes callFunction(): // in the Calc class public static Object callFun ( String funcName , Object [] args ) { try { XFunctionAccess fa = Lo . createInstanceMCF ( XFunctionAccess . class , \"com.sun.star.sheet.FunctionAccess\" ); return fa . callFunction ( funcName , args ); } catch ( Exception e ) { System . out . println ( \"Could not invoke \\\"\" + funcName + \"\\\"\" ); return null ; } } // end of callFun() public static Object callFun ( String funcName , Object arg ) { return callFun ( funcName , new Object [] { arg }); } Calc.callFun() is passed the Calc function name and an array of arguments; the function's result is returned as an Object instance. The second version of Calc.callFun() is for calling functions that accept a single argument. Several examples of how to use Calc.callFun() can be found in the FunctionsTest.java example: // in FunctionsTest.java public static void main ( String [] argus ) { XComponentLoader loader = Lo . loadOffice (); // round a double System . out . println ( \"ROUND result for 1.999 is: \" + Calc . callFun ( \"ROUND\" , 1.999 ) + \"\\n\" ); : // more examples, explained below Lo . closeOffice (); } // end of main() The value passed to Calc.callFun() in the code above is an ordinary double, but Java autoboxes it to become a Double object. This is passed to the second version of Calc.callFun() which handles a single Object input argument. The printed result is: ROUND result for 1.999 is: 2.0 Java can be used to convert the returned Object value. For example, the value returned by ROUND can be cast to a double: double res = ( Double ) Calc . callFun ( \"ROUND\" , 1.999 ); The Object is cast to Double, and then Java unboxes the object, converting it to a double. Function calls can be nested, as in: // in FunctionsTest.java System . out . printf ( \"SIN result for 30 degrees is: %.3f\\n\\n\" , Calc . callFun ( \"SIN\" , Calc . callFun ( \"RADIANS\" , 30 ))); The call to RADIANS converts 30 degrees to radians. The returned Object is accepted by the SIN function as input. The output is: SIN result for 30 degrees is: 0.500 Many functions require more than one argument. In that case, the sequence of arguments must be stored in an Object[] array before passing them to Calc.callFun(). For instance: // in FunctionsTest.java Object [] args = new Object [] { 1 , 2 , 3 , 4 , 5 }; // five args double avg = ( Double ) Calc . callFun ( \"AVERAGE\" , args ); System . out . println ( \"Average of the numbers is: \" + avg + \"\\n\" ); This reports the average to be 3.0. When the Calc function documentation talks about an \"array\" or \"matrix\" argument, then the data needs to be packaged as a 2D array. For example, the SLOPE function takes two arrays of x and y coordinates as input, and calculates the slope of the line through them. These two 1D arrays must be passed to Calc.callFun() as two 2D arrays: // in FunctionsTest.java double [][] xData = {{ 1.0 , 2.0 , 3.0 }}; // a 2D array/matrix holding one row of data double [][] yData = {{ 3.0 , 6.0 , 9.0 }}; args = new Object [] { yData , xData }; double slope = ( Double ) Calc . callFun ( \"SLOPE\" , args ); System . out . println ( \"SLOPE of the line: \" + slope + \"\\n\" ); The args array has to be built in stages so that the two arrays can be treated as two Objects. The slope result is 3.0, as expected. The functions in the \"Array\" category almost all use 2D arrays as arguments. For example, the TRANSPOSE function is called like so: // in FunctionsTest.java // transpose a matrix double [][] arr = {{ 1 , 2 , 3 },{ 4 , 5 , 6 }}; args = new Object [] { arr }; Object [][] transMat = ( Object [][] ) Calc . callFun ( \"TRANSPOSE\" , args ); Calc . printArray ( transMat ); The input array is in row-order, so the array arr created above has two rows and three columns. The printed transpose is: Row x Column size: 3 x 2 1.0 4.0 2.0 5.0 3.0 6.0 Note that the result of this call to Calc.callFun() was not a double but a transposed 2D array, which is why the Object result was cast to Object[][]. Unfortunately, Java's typing does not allow the result to be cast to double[][]. The casting can be done using Calc.convertToDoubles(): double [][] trans = Calc . convertToDoubles ( transMat ); The TRANSPOSE function only takes a single argument, so it's possible to use the second version of Calc.callFun() which takes a single Object input argument. A slight problem is caused by Java's type system; it's necessary to explicitly cast the double[][] array to Object in the call: // in FunctionsTest.java Object [][] transMat = ( Object [][] ) Calc . callFun ( \"TRANSPOSE\" , ( Object ) arr ); If arr is not cast then Java will issue a runtime error. There are several functions for manipulating imaginary numbers, which must be written in the form of strings. For example, IMSUM sums a series of complex numbers like so: // in FunctionsTest.java // sum two imaginary numbers: \"13+4j\" + \"5+3j\" returns 18+7j. String [][] nums = {{ \"13+4j\" },{ \"5+3j\" }}; args = new Object [] { nums }; String sum = ( String ) Calc . callFun ( \"IMSUM\" , args ); System . out . println ( \"13+4j + 5+3j: \" + sum + \"\\n\" ); Since IMSUM expects a series of complex numbers, Calc.callFun() must be passed a 2D array. Each row contains a single string argument representing a complex number. The summed complex number is returned as the string \"18+7j\". This means that the Calc.callFun() result is cast to String in this case. The IMSUM function is only processing a single argument, and so the single argument version of Calc.callFun() can be called. As with the TRANSPOSE function example, the String[][] array must be expicitly cast to an Object: String sum = ( String ) Calc . callFun ( \"IMSUM\" , ( Object ) nums );","title":"1.  Calling Calc Functions from Code"},{"location":"27-Funcs_Analysis.html#functions-help","text":"If you can't access the Calc documentation on functions, then Calc.java contains two help functions: Calc.getFunctionNames() and Calc.printFunctionInfo(). The former prints a very long list of function names: // in FunctionsTest.java System . out . println ( \"Function names\" ); Lo . printNames ( Calc . getFunctionNames (), 6 ); The output begins like so: Function names No. of names: 483 \"ABS\" \"ACCRINT\" \"ACCRINTM\" \"ACOS\" \"ACOSH\" \"ACOT\" \"ACOTH\" \"ADDRESS\" \"AGGREGATE\" \"AMORDEGRC\" \"AMORLINC\" \"AND\" \"ARABIC\" \"AREAS\" \"ASC\" \"ASIN\" \"ASINH\" \"ATAN\" \"ATAN2\" \"ATANH\" \"AVEDEV\" \"AVERAGE\" \"AVERAGEA\" \"AVERAGEIF\" \"AVERAGEIFS\" \"B\" \"BAHTTEXT\" \"BASE\" \"BESSELI\" \"BESSELJ\" \"BESSELK\" \"BESSELY\" \"BETA.DIST\" \"BETA.INV\" \"BETADIST\" \"BETAINV\" \"BIN2DEC\" \"BIN2HEX\" \"BIN2OCT\" \"BINOM.DIST\" \"BINOM.INV\" \"BINOMDIST\" : If you know a function name, then Calc.printFunctionInfo() will print details about it. For instance, information about the ROMAN function is obtained like so: Calc.printFunctionInfo(\"ROMAN\"); The output is: Properties for \"ROMAN\": Id: 383 Category: 10 Name: ROMAN Description: Converts a number to a Roman numeral. Arguments: [Lcom.sun.star.sheet.FunctionArgument;@b3fc9e No. of arguments: 2 1. Argument name: Number Description: \"The number to be converted to a Roman numeral must be in the 0 - 3999 range.\" Is optional?: false 2. Argument name: Mode Description: \"The more this value increases, the more the Roman numeral is simplified. The value must be in the 0 - 4 range.\" Is optional?: true This output states that ROMAN can be called with one or two arguments, the first being a decimal, and the second an optional argument for the amount of 'simplification' carried out on the Roman numeral. For example, here are two ways to convert 999 into Roman form: // in FunctionsTest.java String roman = ( String ) Calc . callFun ( \"ROMAN\" , 999 ); args = new Object [] { 999 , 4 }; // use max simplification String roman4 = ( String ) Calc . callFun ( \"ROMAN\" , args ); System . out . println ( \"999 in Roman numerals: \" + roman + \" or \" + roman4 + \"\\n\" ); The output is: 999 in Roman numerals: CMXCIX or IM Calc.getFunctionNames() and Calc.printFunctionInfo() utilize the XFunctionDescriptions interface for retrieving an indexed container of function descriptions. Each function description is an array of PropertyValue objects, which contain a \"Name\" property. Calc.findFunction() uses this organization to return the PropertyValue[] array for a given function name: // in the Calc class public static PropertyValue [] findFunction ( String funcNm ) // get the function description properties for funcNm { // get all the function descriptions XFunctionDescriptions funcsDesc = Lo . createInstanceMCF ( XFunctionDescriptions . class , \"com.sun.star.sheet.FunctionDescriptions\" ); if ( funcsDesc == null ) { System . out . println ( \"No function descriptions were found\" ); return null ; } // find the description whose fn name == funcNm int numFuncs = funcsDesc . getCount (); for ( int i = 0 ; i < numFuncs ; i ++ ) { try { PropertyValue [] props = ( PropertyValue [] ) funcsDesc . getByIndex ( i ); for ( int p = 0 ; p < props . length ; p ++ ) { if (( props [ p ] . Name . equals ( \"Name\" )) && ( props [ p ] . Value . equals ( funcNm ))) return props ; } } catch ( Exception e ) {} } System . out . println ( \"Function \\\"\" + funcNm + \"\\\" not found\" ); return null ; } // end of findFunction() The PropertyValue[] array contains five properties: \"Name\", \"Description\", \"Id\", \"Category\", and \"Arguments\". The \"Arguments\" property stores an array of FunctionArgument objects which contain information about each argument's name, description, and whether it is optional. This information is printed by Calc.printFunArguments(): // in the Calc class public static void printFunArguments ( PropertyValue [] propVals ) // print the function argument info in propVals { // get the FunctionArgument property FunctionArgument [] fargs = ( FunctionArgument [] ) Props . getValue ( \"Arguments\" , propVals ); if ( fargs == null ) { System . out . println ( \"No arguments found\" ); return ; } // print all the info System . out . println ( \"No. of arguments: \" + fargs . length ); for ( int i = 0 ; i < fargs . length ; i ++ ) printFunArgument ( i , fargs [ i ] ); } // end of printFunArguments() public static void printFunArgument ( int i , FunctionArgument fa ) { System . out . println (( i + 1 ) + \". Argument name: \" + fa . Name ); System . out . println ( \" Description: \\\"\" + fa . Description + \"\\\"\" ); System . out . println ( \" Is optional?: \" + fa . IsOptional + \"\\n\" ); } // end of printFunArgument() Calc . printFunctionInfo () calls Calc . findFunction () and Calc . printFunArguments () to report on a complete function : // in the Calc class public static void printFunctionInfo ( String funcName ) { PropertyValue [] propVals = findFunction ( funcName ); Props . showProps ( funcName , propVals ); printFunArguments ( propVals ); System . out . println (); } // end of printFunctionInfo()","title":"Functions Help"},{"location":"27-Funcs_Analysis.html#2-pivot-tables","text":"Pivot tables are explained in detail in chapter 8 of the Calc User's Guide. They allow a user to view a spreadsheet consisting of columns of data in a variety of table formats, thereby highlighting the relationships between the columns. For example, Figure 1 shows the small spreadsheet in my \"pivottable1.ods\". Figure 1. The \"pivottable1.ods\" Spreadsheet. The spreadsheet uses a database-like organization, with each row acting as a record, and each column is a different type/kind of information. This formatting style is described in chapter 13 \"Calc as a Simple Database\" in the User Guide. The drawback of this kind of data structuring is that it can be difficult to see the underlying relationships between the columns; this is where pivot tables can help. For example, a pivot table can be generated showing how the \"Category\" column affects \"Revenue (see Figure 2). Figure 2. \"Category\" Affecting \"Revenue\". Note that the pivot table shows the revenue sum in column B, since several revenue entries in the original sheet are covered by each category. Alternatively, it's possible to see how \"Period\" and \"Category\" interact to affect the revenue, as in Figure 3. Figure 3. Period and Category Affect on \"Revenue\". The ordering of the \"Period\" values can be changed by clicking on the arrow next to the \"Period\" text in cell \"A2\", then selecting a custom sort (e.g. Jan, Feb, Mar, etc.). The \"Total Result\" row and column are added automatically, and can be changed easily. It's also possible to change the way that the revenue data is grouped (e.g. it can be averaged instead of being summed). Pivot tables are straightforward to create and modify via Calc's GUI, starting from the Data, Pivot Table, Create menu item. Calc automatically selects all the cells used in the database-like table like the one in Figure 1, and displays the layout dialog shown in Figure 4. Figure 4. The Pivot Table Layout GUI. The right-most \"Available Fields\" list contains the names of the columns in the sheet, while the other four fields (Page, Column, Row, and Data) are empty. Figure 4 shows a bug in the current version of the Pivot Table GUI \u2013 the addition of a \"Data\" name in the \"Column\" fields list. This name cannot be removed from the layout dialog, but can be ignored since it doesn't appear in the rendered pivot table. The pivot table layout in Figure 5 is easily created by dragging the \"Period\" name to the Row fields list, \"Category to the Column fields list, and \"Revenue\" to the Data fields list, where it's converted into \"Sum \u2013 Revenue\". Figure 5. The Layout for the Pivot Table in Figure 3.","title":"2.  Pivot Tables"},{"location":"27-Funcs_Analysis.html#pivot-tables-in-the-api","text":"The Calc API refers to pivot tables by their old Office name, DataPilot tables. The relationships between the DataPilotservices and interfaces are shown in Figure 6. Figure 6. The DataPilot Services and Interfaces. Figure 6 is best understood by reading downwards: a DataPilotTables service (note the \"s\") is a sequence of DataPilotTable services. Each table contains a DataPilotFields service (note the \"s\") which manages a sequence of DataPilotField objects. Each DataPilotField is a named property set, representing a column in the source sheet. For example, in the following code, four pilot fields will be created for the \"pivottable1.ods\" sheet shown in Figure 1, one each for the columns named Year, Period, Category, and Revenue. Figure 6 mentions one of the more important services \u2013 DataPilotDescriptor, which does the hard work of converting sheet columns into pilot fields. DataPilotDescriptor is also responsible for assigning each pilot field to one of the Page, Column, Row, or Data field lists. The PivotSheet1.java example illustrates how to create the pivot table shown in Figure 3. The program begins by opening the \"pivottable1.ods\" file (Figure 1): // in PivotSheet1.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( \"pivottable1.ods\" , loader ); if ( doc == null ) { System . out . println ( \"Could not open pivottable1.ods\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XSpreadsheet dpSheet = Calc . insertSheet ( doc , \"Pivot Table\" , ( short ) 1 ); createPivotTable ( sheet , dpSheet ); Calc . setActiveSheet ( doc , dpSheet ); Lo . saveDoc ( doc , \"pivotExample1.ods\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() A second sheet (called dpSheet) is created to hold the generated pivot table, and createPivotTable() is called: // in PivotSheet1.java private static void createPivotTable ( XSpreadsheet sheet , XSpreadsheet dpSheet ) { XCellRange cellRange = Calc . findUsedRange ( sheet ); // find the table data on the sheet XDataPilotTables dpTables = Calc . getPilotTables ( sheet ); /* create a new pilot descriptor which will later be added as a new pilot table to the pilot tables */ XDataPilotDescriptor dpDesc = dpTables . createDataPilotDescriptor (); /* add the sheet's column data to the descriptor; this causes the creation of pilot fields */ dpDesc . setSourceRange ( Calc . getAddress ( cellRange ) ); /* assign \"Available\" (Hidden) pilot fields to the Page, Column, Row, and Data fields */ XIndexAccess fields = dpDesc . getHiddenFields (); XPropertySet props ; // set Page field; not used here //props = Lo.findContainerProps(fields, \"Year\"); //Props.setProperty(props, \"Orientation\", // DataPilotFieldOrientation.PAGE); // set Column field props = Lo . findContainerProps ( fields , \"Category\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . COLUMN ); // set Row field props = Lo . findContainerProps ( fields , \"Period\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . ROW ); // set Data field, calculating the sum props = Lo . findContainerProps ( fields , \"Revenue\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . DATA ); Props . setProperty ( props , \"Function\" , GeneralFunction . SUM ); // add new pivot table to other tables and to sheet at A1 CellAddress destAddr = Calc . getCellAddress ( dpSheet , \"A1\" ); dpTables . insertNewByName ( \"PivotTableExample\" , destAddr , dpDesc ); } // end of createPivotTable() All the sheet's data is selected by calling Calc.findUsedRange(). Then Calc.getPilotTables() obtains the DataPilotTables service: // in the Calc class public static XDataPilotTables getPilotTables ( XSpreadsheet sheet ) { XDataPilotTablesSupplier dpSupp = Lo . qi ( XDataPilotTablesSupplier . class , sheet ); XDataPilotTables dpTables = dpSupp . getDataPilotTables (); if ( dpTables == null ) System . out . println ( \"No data pilot tables found\" ); return dpTables ; } // end of getPilotTables() Calc.getPilotTables() utilizes the XDataPilotTablesSupplier interface of the Spreadsheet service to obtain the DataPilotTables service. PivotSheet1.java's task is to create a new pilot table, which it does indirectly by creating a new pilot description. After this pilot description has been initialized, it will be added to the DataPilotTables service as a new pilot table. An empty pilot description is created by calling XDataPilotTables.createDataPilotDescriptor(): // in createPivotTable in PivotTable.java XDataPilotTables dpTables = Calc . getPilotTables ( sheet ); XDataPilotDescriptor dpDesc = dpTables . createDataPilotDescriptor (); The new XDataPilotDescriptor reference (dpDesc) creates a pilot table by carrying out two tasks \u2013 loading the sheet data into the pilot table, and assigning the resulting pilot fields to the Page, Column, Row, and Data fields in the descriptor. This latter task is similar to what the Calc user does in the GUI's layout window in Figure 5. The descriptor is assigned a source range that spans all the data: dpDesc . setSourceRange ( Calc . getAddress ( cellRange ) ); It converts each detected column into a DataPilotField service, which is a named property set; the name is the column heading. These pilot fields are conceptually stored in the \"Available Fields\" list shown in the layout window in Figure 5, and are retrieved by calling XDataPilotDescriptor.getHiddenFields(): XIndexAccess fields = dpDesc . getHiddenFields (); It's useful to list the names of these pilot fields: // in createPivotTable() in PivotSheet1.java String [] fieldNames = Lo . getContainerNames ( fields ); System . out . println ( \"Field Names (\" + fieldNames . length + \"):\" ); for ( String name : fieldNames ) System . out . println ( \" \" + name ); The output for the spreadsheet in Figure 1 is: Field Names (5): Year Period Category Revenue Data This list includes the strange \"Data\" pilot field which you may remember also cropped up in the layout window in Figure 4. The second task is to assign selected pilot fields to the Page, Column, Row, and Data field lists. The standard way of doing this is illustrated below for the case of assigning the \"Category\" pilot field to the Column field list: // in createPivotTable() in PivotSheet1.java XPropertySet props = Lo . findContainerProps ( fields , \"Category\" ); Props . setProperty ( props , \"Orientation\" , DataPilotFieldOrientation . COLUMN ); The fields variable refers to all the pilot fields as an indexed container. Lo.findContainerProps() searches through that container looking for the specified field name. // in the Lo class public static XPropertySet findContainerProps ( XIndexAccess con , String nm ) { if ( con == null ) { System . out . println ( \"Container is null\" ); return null ; } for ( int i = 0 ; i < con . getCount (); i ++ ) { try { Object oElem = con . getByIndex ( i ); XNamed named = Lo . qi ( XNamed . class , oElem ); if ( named . getName (). equals ( nm )) { return ( XPropertySet ) Lo . qi ( XPropertySet . class , oElem ); } } catch ( Exception e ) { System . out . println ( \"Could not access element \" + i ); } } System . out . println ( \"Could not find a \\\"\" + nm + \"\\\" prop set\" ); return null ; } // end of findContainerProps() The returned property set is an instance of the DataPilotField service, so a complete list of all the properties can be found in its documentation (use lodoc datapilotfield ). The important property for our needs is \"Orientation\" which can be assigned a DataPilotFieldOrientation constant, whose values are HIDDEN, COLUMN, ROW, PAGE, and DATA, representing the field lists in the layout window. Once the required pilot fields have been assigned to field lists, the new pivot table is added to the other tables and to the sheet by calling XDataPilotTables.insertNewByName(). It takes three arguments: a unique name for the table, the cell address where the table will be drawn, and the completed pilot descriptor: // in createPivotTable() in PivotSheet1.java // add new pivot table to other tables and to sheet at A1 CellAddress destAddr = Calc . getCellAddress ( dpSheet , \"A1\" ); dpTables . insertNewByName ( \"PivotTableExample\" , destAddr , dpDesc ); This code should mark the end of the createPivotTable() method, but I found that more complex pivot tables would often not be correctly drawn. The cells in the Data field would be left containing the word \"#VALUE!\". This problem can be fixed by explicitly requesting a refresh of the pivot table, using: // in createPivotTable() in PivotSheet1.java // access pilot tables XDataPilotTables dpTables2 = Calc . getPilotTables ( dpSheet ); // find new table by name XDataPilotTable dpTable = Calc . getPilotTable ( dpTables2 , \"PivotTableExample\" ); if ( dpTable != null ) dpTable . refresh (); // update the table entries Calc.getPilotTable() searches XDataPilotTables, which is a named container of XDataPilotTable objects. Oddly enough, it's not enough to call Calc.getPilotTable() on the current XDataPilotTables reference (called dpTables in createPivotTable()), since the new pivot table isn't found. My \"Calc Tests\" folder contains two more pivot table examples, called PivotSheet2.java and PivotTable.java. PivotSheet2.java creates a more complex pivot table after reading in the spreadsheet stored in pivottable2.ods. PivotTable.java creates its own spreadsheet before generating a table. Both examples only use the methods in PivotSheet1.java, so won't be described here.","title":"Pivot Tables in the API"},{"location":"27-Funcs_Analysis.html#3-seeking-a-goal","text":"The Tools, Goal Seek menu item in Calc allows a formula to be executed 'backwards'. Instead of supplying the input to a formula, and obtaining the formula's result, the result is given and \"goal seek\" works backwards through the formula to calculate the value that produces the result. The GoalSeek.java example contains several uses of \"goal seeking\". It begins like so: // in GoalSeek.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XGoalSeek gs = Lo . qi ( XGoalSeek . class , doc ); Calc . setVal ( sheet , \"C1\" , 9 ); // x-variable and starting value Calc . setVal ( sheet , \"C2\" , \"=SQRT(C1)\" ); // formula double x = Calc . goalSeek ( gs , sheet , \"C1\" , \"C2\" , 4 ); // x-var, formula, result System . out . println ( \"x == \" + x + \" when sqrt(x) == 4\\n\" ); // x is 16 : // more goal seek examples Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Goal seek functionality is accessed via the XGoalSeek interface of the document. Also, a spreadsheet is needed to hold an initial guess for the input value being calculated (which I'll call the x-variable), and for the formula. In the example above, the x-variable is stored in cell \"C1\" with an initial value of 9, and its formula (sqrt(x)) in cell \"C2\". Calc.goalSeek() is passed the cell names of the x-variable and formula, and the formula's result, and returns the x-value that produces that result. In the example above, Calc.goalSeek() returns 16, because that's the input to sqrt() that results in 4. Calc.goalSeek() is defined as: // in the Calc class public static double goalSeek ( XGoalSeek gs , XSpreadsheet sheet , String xCellName , String formulaCellName , double result ) // find x input to formula which produces result; // use value in xCellName as a starting guess { CellAddress xPos = Calc . getCellAddress ( sheet , xCellName ); CellAddress formulaPos = Calc . getCellAddress ( sheet , formulaCellName ); GoalResult goalResult = gs . seekGoal ( formulaPos , xPos , \"\" + result ); if ( goalResult . Divergence >= 0.1 ) System . out . println ( \"NO result; divergence: \" + goalResult . Divergence ); return goalResult . Result ; } // end of goalSeek() The heart of Calc.goalSeek() is a call to XGoalSeek.seekGoal() which requires three arguments: the address of the x-variable cell, the address of the formula cell, and a string representing the formula's result. The call returns a GoalResult object that contains two fields: Result holds the calculated x-value, and Divergence measures the accuracy of the x-value. If the goal seek has succeeded, then the Divergence value should be very close to 0; if it failed to find an x-value then Divergence may be very large since it measures the amount the x-value changed in the last iteration of the \"goal seek\" algorithm. I wasn't able to find out what algorithm \"goal seek\" employs, but it's most likely a root-finding methods, such as Newton\u2013Raphson or the secant method. These may fail for a poor choice of starting x-value or if the formula function has a strange derivative (an odd curvature). This can be demonstrated by asking \"goal seek\" to look for an impossible x-value, such as the input that makes sqrt(x) == -4: // in GoalSeek.java x = Calc . goalSeek ( gs , sheet , \"C1\" , \"C2\" , - 4 ); System . out . println ( \"x == \" + x + \" when sqrt(x) == -4\\n\" ); There's no need to change the starting value in \"C1\" or the formula in \"C2\". The output is: NO result; divergence: 1.7976931348623157E308 x == 3.2462079627414548E-6 when sqrt(x) == -4 \"Goal seek\" can be useful when examining complex equations, such as: [*** missing formula ***] What's the x-value that produces y == 2? Actually, this equation is simple: is factorized into , and the common factor removed from the fraction; the equation becomes: So when y == 2, x will be 1. But let's do things the number-crunching way, and supply the original formula to \"goal seek\": // in GoalSeek.java Calc . setVal ( sheet , \"D1\" , 0.8 ); // x-variable and starting value Calc . setVal ( sheet , \"D2\" , \"=(D1^2 - 1)/(D1 - 1)\" ); // formula x = Calc . goalSeek ( gs , sheet , \"D1\" , \"D2\" , 2 ); System . out . println ( \"x == \" + x + \" when x+1 == 2\\n\" ); The printed x-value is: 1.0000000000000053. If a formula requires numerical values, they can be supplied as cell references, which allows them to be adjusted easily. The next \"goal seek\" example employs an annual interest formula, I = x*n*i, where I is the annual interest, x the capital, n the number of years, and i the interest rate. As usual, the x-variable has a starting value in a cell, but n and i are also represented by cells so that they can be changed. The code is: // in GoalSeek.java Calc . setVal ( sheet , \"B1\" , 100000 ); // x-variable; possible value Calc . setVal ( sheet , \"B2\" , 1 ); // n, no. of years Calc . setVal ( sheet , \"B3\" , 0.075 ); // i, interest rate (7.5%) Calc . setVal ( sheet , \"B4\" , \"=B1*B2*B3\" ); // formula x = Calc . goalSeek ( gs , sheet , \"B1\" , \"B4\" , 15000 ); System . out . println ( \"x == \" + x + \" when x*\" + Calc . getVal ( sheet , \"B2\" ) + \"*\" + Calc . getVal ( sheet , \"B3\" ) + \" == 15000\\n\" ); // x is 200,000 \"Goal seek\" is being asked to determine the x-value when the annual return from the formula is 20000. The values in the cells \"B2\" and \"B3\" are employed, and the printed answer is: x == 200000.0 when x*1.0*0.075 == 15000","title":"3.  Seeking a Goal"},{"location":"27-Funcs_Analysis.html#4-linear-and-nonlinear-solving","text":"Calc supports both linear and nonlinear programming via its Tools \uf0e0 Solver menu item. The name \"linear programming\" dates from just after World War II, and doesn't mean programming in the modern sense; in fact, it's probably better to use its other common name, \"linear optimization\". Linear optimization starts with a series of linear equations involving inequalities, and finds the best numerical values that satisfy the equations according to a 'profit' equation that must be maximized (or minimized). Fortunately, this has a very nice graphical representation when the equations only involve two unknowns: the equations cam be drawn as lines crossing the x- and y- axes, and the best values will be one of the points where the lines intersect. As you might expect, nonlinear programming (optimization) is a generalization of the linear case where some of the equations are non-linear (e.g. perhaps they involve polynomials, logarithmic, or trigonometric functions). A gentle introduction to linear optimization and its graphing can be found at https://purplemath.com/modules/linprog.htm , or you can start at the Wikipedia page, https://en.wikipedia.org/wiki/Linear_programming/ . The Calc documentation on linear and nonlinear solving is rather minimal. There's no mention of it in the Calc Developer's Guide, and just a brief section on its GUI at the end of chapter 9 (\"Data Analysis\") of the Calc User guide. The current version of LibreOffice (v. 5) offers four optimization tools (called solvers) \u2013 two linear optimizers called \"LibreOffice Linear Solver\" and \"LibreOffice CoinMP Linear Solver\", and two nonlinear ones called \"DEPS Evolutionary Algorithm\" and \"SCO Evolutionary Algorithm\". The easiest way of checking the current solver situation in your version of Office is to look at Calc's Solver dialog window (by clicking on the Tools \uf0e0 Solver menu item), and click on the \"Options\" button. The options dialog window lists all the installed solvers, and their numerous parameters, as in Figure 8. Figure 8. The LibreOffice Solvers and their Parameters. Another way of getting a list of the installed solvers, is to call Calc.listSolvers(), which is demonstrated in the first example given below. The two linear solvers are implemented as DLLs, located in the \\program folder as lpsolve55.dll and CoinMP.dll. The source code for these libraries is online, at https://docs.libreoffice.org/sccomp/html/files.html , with the code (and graphs of the code) accessible via the \"Files\" tab. The file names are LpsolveSolver.cxx and CoinMPSolver.cxx. The lpsolve55.dll filename strongly suggests that Office's basic linear solver is lp_solve 5.5, which originates online at https://lpsolve.sourceforge.net/ . That site has extensive documentation, including a great introduction to linear optimization. The first programming example below comes from one of the examples in its documentation. One interesting possibility for the lpsolve library is that it can be called directly from Java without the need for Calc. The necessary steps are described on the \"Using lp_solve 5.5 in Java programs\" page for lp_solve 5.5 at https://lpsolve.sourceforge.net/ . The relevant download is lp_solve_5.5.2.0_java.zip from https://sourceforge.net/projects/lpsolve/files/lpsolve/5.5.2.0/ . Office's other linear optimizer, the CoinMP solver, comes from the COIN-OR (Computational Infrastructure for Operations Research) open-source project which started at IBM research ( https://coin-or.org/ ). According to https://coin-or.org/projects/CoinMP.xml , CoinMP implements most of the functionality of three other COIN-OR projects, called CLP (Coin LP), CBC (Coin Branch-and-Cut), and CGL (Cut Generation Library). The CLP and CBC solvers are documented at https://coin-or.org/projects/Clp.xml and https://coin-or.org/projects/Cbc.xml , and come with large user guides, at https://coin-or.org/Clp/userguide/ and https://www.coin-or.org/Cbc/ . The collection of cut generators in the CGL library is used to speed up the execution of CLP and CBC (see https://coin-or.org/projects/Cgl.xml ). A good overview of COIN-OR can be found in a series of slides by Matthew Saltzman at https://dimacs.rutgers.edu/Workshops/COIN/slides/saltzman.pdf . There's also a Wikipedia page about COIN-OR. The two nonlinear solvers are known as DEPS and SCO for short, and are explained in the OpenOffice wiki at https://wiki.openoffice.org/wiki/NLPSolver/ , along with descriptions of their extensive (and complicated) parameters. They're implemented as JAR files, located in \\share\\extensions\\nlpsolver as nlpsolver.jar and EvolutionarySolver.jar. Two of the examples below use these solvers.","title":"4.  Linear and Nonlinear Solving"},{"location":"27-Funcs_Analysis.html#41-a-linear-optimization-problem","text":"The LinearSolverTest.java example shows how to use the basic linear solver, and also CoinMP. It implements the following linear optimization problem, which comes from https://lpsolve.sourceforge.net/5.1/formulate.htm . There are three constraint inequalities: 120x + 210y \u2264 15000 110x + 30y \u2264 4000 x + y \u2264 75 The 'profit' expression to be maximized is: P = 143x + 60y The maximum P value is 6315.625, when x == 21.875 and y == 53.125. Perhaps the easiest way of calculating this outside of Office is via the linear optimization tool at https://zweigmedia.com/utilities/lpg/index.html?lang=en . Its solution is shown in Figure 9. Figure 9. Solved and Graphed Linear Optimization Problem. Aside from giving the answer, the equations are graphed, which shows how the maximum profit is one of the equation's intersection points. The main() function for LinearSolverTest.java: // in LinearSolverTest.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . listSolvers (); // specify the variable cells CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress [] vars = new CellAddress [] { xPos , yPos }; // specify profit equation Calc . setVal ( sheet , \"B3\" , \"=143*B1 + 60*B2\" ); // P = 143x + 60y, maximize CellAddress profitEqu = Calc . getCellAddress ( sheet , \"B3\" ); // set up equation formulae without inequalities Calc . setVal ( sheet , \"B4\" , \"=120*B1 + 210*B2\" ); Calc . setVal ( sheet , \"B5\" , \"=110*B1 + 30*B2\" ); Calc . setVal ( sheet , \"B6\" , \"=B1 + B2\" ); // create the constraints // constraints are equations and their inequalities SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 15000 ); // 120x + 210y <= 15000 // B4 is the cell address that is constrained SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B5\" , \"<=\" , 4000 ); // 110x + 30y <= 4000 SolverConstraint sc3 = Calc . makeConstraint ( sheet , \"B6\" , \"<=\" , 75 ); // x + y <= 75 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 , sc3 }; // initialize the linear solver (basic linear or CoinMP) XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.LpsolveSolver\" ); // \"com.sun.star.comp.Calc.CoinMPSolver\"); // System.out.println(\"Solver: \" + solver); solver . setDocument ( doc ); solver . setObjective ( profitEqu ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); Props . showObjProps ( \"Solver\" , solver ); Props . setProperty ( solver , \"NonNegative\" , true ); // restrict the search to the top-right quadrant of the graph // execute the solver; print the result solver . solve (); Calc . solverReport ( solver ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The call to Calc.listSolvers() isn't strictly necessary but it provides useful information about the names of the solver services: Services offered by the solver : com . sun . star . comp . Calc . CoinMPSolver com . sun . star . comp . Calc . LpsolveSolver com . sun . star . comp . Calc . NLPSolver . DEPSSolverImpl com . sun . star . comp . Calc . NLPSolver . SCOSolverImpl One of these names is needed when calling Lo.createInstanceMCF() to create a solver instance. Calc.listSolvers() is implemented as: // in the Calc class public static void listSolvers () { System . out . println ( \"Services offered by the solver:\" ); String [] nms = Info . getServiceNames ( \"com.sun.star.sheet.Solver\" ); if ( nms == null ) System . out . println ( \" none\" ); else { for ( String service : nms ) System . out . println ( \" \" + service ); System . out . println (); } } // end of listSolvers() The real work of listSolvers() is done by calling Info.getServiceNames() which finds all the implementations that support \"com.sun.star.sheet.Solver\". Back in LinearSolverTest.java, the inequality and profit equations are defined as formulae in a sheet, and the variables in the equations are also assigned to cells. The two variables in this problem (x and y) are assigned to the cells \"B1\" and \"B2\", and the cell addresses are stored in an array for later: // in LinearSolverTest.java CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress [] vars = new CellAddress [] { xPos , yPos }; Next the equations are defined. Their formulae are assigned to cells without their inequality parts: // in LinearSolverTest.java // specify profit equation Calc . setVal ( sheet , \"B3\" , \"=143*B1 + 60*B2\" ); // P = 143x + 60y, maximize CellAddress profitEqu = Calc . getCellAddress ( sheet , \"B3\" ); // set up equation formulae without inequalities Calc . setVal ( sheet , \"B4\" , \"=120*B1 + 210*B2\" ); Calc . setVal ( sheet , \"B5\" , \"=110*B1 + 30*B2\" ); Calc . setVal ( sheet , \"B6\" , \"=B1 + B2\" ); Now the three equation formulae are converted into SolverConstraint objects by calling Calc.makeConstraint(), and the constraints are stored in an array for later use: // in LinearSolverTest.java // create the constraints: // constraints are equations and their inequalities SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 15000 ); // 120x + 210y <= 15000 // B4 is the cell address that is constrained SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B5\" , \"<=\" , 4000 ); // 110x + 30y <= 4000 SolverConstraint sc3 = Calc . makeConstraint ( sheet , \"B6\" , \"<=\" , 75 ); // x + y <= 75 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 , sc3 }; A constraint is the cell name where an equation is stored and an inequality. Calc.makeConstraint() is defined as: // in the Calc class public static SolverConstraint makeConstraint ( XSpreadsheet sheet , String cellName , String op , double d ) { return makeConstraint ( Calc . getCellAddress ( sheet , cellName ), op , d ); } public static SolverConstraint makeConstraint ( CellAddress addr , String op , double d ) { return makeConstraint ( addr , toConstraintOp ( op ), d ); } public static SolverConstraint makeConstraint ( XSpreadsheet sheet , String cellName , SolverConstraintOperator op , double d ) { return makeConstraint ( Calc . getCellAddress ( sheet , cellName ), op , d );} public static SolverConstraint makeConstraint ( CellAddress addr , SolverConstraintOperator op , double d ) { SolverConstraint sc = new SolverConstraint (); sc . Left = addr ; sc . Operator = op ; sc . Right = d ; return sc ; } // end of makeConstraint() That's a lot of functions to create a SolverConstraint object with four arguments. Now the solver is created, and its parameters are set: // in LinearSolverTest.java XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.LpsolveSolver\" ); solver . setDocument ( doc ); solver . setObjective ( profitEqu ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); // maximize the profit equ The XSolver interface is utilized by all the solvers, but the name of service can vary. In the code above I'm using the basic linear solver. A CoinMP solver would be created by changing \"LpsolveSolver\" to \"CoinMPSolver\": XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.CoinMPSolver\" ); The various \"set\" methods are described in the XSolver documentation as public variables (call lodoc xsolver to see the page). They load the profit equation, constraints, and variables into the solver. It's also necessary to specify that the profit equation be maximized, and link the solver to the Calc document. These \"set\" methods are used in the same way no matter which of the four solvers is employed. Where the solvers differ is in their service properties. As mentioned above, there's a few sources of online information depending on which solver you're using, or you could look at the options dialog window shown in Figure 8. Another source is to call Props.showObjProps() on the solver, to list its property names and current values: Props.showObjProps(\"Solver\", solver); When the basic linear solver is being used, showObjProps()'s output is: EpsilonLevel == 0 Integer == false LimitBBDepth == true NonNegative == false Timeout == 100 This corresponds to the information shown for the basic linear solver in the options dialog in Figure 10. Figure 10. The Options Dialog for the Basic Linear Solver. As to what these parameters actually mean, you'll have to look through the \"lp_solve API reference\" section of the documentation at https://lpsolve.sourceforge.net/ . For example, the \"epsilon level\" is partly explained under the sub-heading \"set_epslevel\". The only property I've changed in the LinearSolverTest.java example is \"NonNegative\", which is set to true: // in LinearSolverTest.java ... Props . setProperty ( solver , \"NonNegative\" , true ); This restricts the search for intersection points to the top-right quadrant of the graph. Alternatively I could have implemented two more constraints: x \u2265 0 y \u2265 0 The solver's results are printed by Calc.solverReport(): // in LinearSolverTest.java solver . solve (); Calc . solverReport ( solver ); The output: Solver result: B3 == 6315.6250 Solver variables: B1 == 21.8750 B2 == 53.1250 Calc.solverReport() is implemented as: // in the Calc class public static void solverReport ( XSolver solver ) { boolean isSuccessful = solver . getSuccess (); if ( isSuccessful ) { String cellName = getCellStr ( solver . getObjective ()); System . out . println ( \"Solver result: \" ); System . out . printf ( \" %s == %.4f\\n\" , cellName , solver . getResultValue ()); CellAddress [] addrs = solver . getVariables (); double [] solns = solver . getSolution (); System . out . println ( \"Solver variables: \" ); for ( int i = 0 ; i < solns . length ; i ++ ) { cellName = getCellStr ( addrs [ i ] ); System . out . printf ( \" %s == %.4f\\n\" , cellName , solns [ i ] ); } System . out . println (); } else System . out . println ( \"Solver FAILED\" ); } // end of solverReport() XSolver.getObjective() and XSolver.getVariables() return the cell addresses holding the profit equation and the variables (x and y). In a corresponding fashion, XSolver.getResultValue() and XSolver.getSolution() return the calculated values for the profit equation and variables. A solver may fail, and so solverReport() first calls XSolver.getSuccess().","title":"4.1.  A Linear Optimization Problem"},{"location":"27-Funcs_Analysis.html#42-another-linear-problem-using-sco","text":"I've coded two examples using the nonlinear optimizers \u2013 SolverTest.java utilizes the SCO solver, and SolverTest2.java employs DEPS. As I mentioned earlier, these two solvers are explained at https://wiki.openoffice.org/wiki/NLPSolver/ . The SolverTest.java example solves a linear problem, but one involving three unknowns. This means that graphically the equations define planes in a 3D space, and solving the profit equation involves examining the corners of the volume defined by how the planes intersect. Unfortunately, the https://zweigmedia.com/utilities/lpg/index.html?lang=en website cannot handle linear optimizations involving more than two variables, but no such restriction applies to Calc's solvers. There are three constraint inequalities: x \u2264 6 y \u2264 8 z \u2265 4 The 'profit' expression to be maximized is: P = x + y - z The maximum P value is 10, when x == 6, y == 8, and z == 4. Much of main() in SolverTest.java is very similar to LinearSolver.java: // part of main() in SolverTest.java : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // specify the variable cells CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress zPos = Calc . getCellAddress ( sheet , \"B3\" ); // z CellAddress [] vars = new CellAddress [] { xPos , yPos , zPos }; // only define the profit formula without inequality Calc . setVal ( sheet , \"B4\" , \"=B1+B2-B3\" ); CellAddress objective = Calc . getCellAddress ( sheet , \"B4\" ); // create three constraints (using the 3 variables) SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B1\" , \"<=\" , 6 ); // x <= 6 SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B2\" , \"<=\" , 8 ); // y <= 8 SolverConstraint sc3 = Calc . makeConstraint ( sheet , \"B3\" , \">=\" , 4 ); // z >= 4 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 , sc3 }; // initialize the SCO nonlinear solver XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.NLPSolver.SCOSolverImpl\" ); solver . setDocument ( doc ); solver . setObjective ( objective ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); Props . showObjProps ( \"Solver\" , solver ); Props . setProperty ( solver , \"EnhancedSolverStatus\" , false ); // switch off nonlinear dialog about current progress // execute the solver solver . solve (); Calc . solverReport ( solver ); Only the profit formula needs to be assigned to a cell due to the simplicity of the equation inequalities. Their constraints can use the cells containing the x, y, and z variables rather than be defined as separate formulae. The Solver is \"com.sun.star.comp.Calc.NLPSolver.SCOSolverImpl\", whose name I found by listing the solver names with Calc.listSolvers(). The properties associated with the SCO solver are more extensive than for the linear solvers. Props.showObjProps() reports: Solver Properties AssumeNonNegative == false EnhancedSolverStatus == true GuessVariableRange == true LearningCycles == 2000 LibrarySize == 210 StagnationLimit == 70 SwarmSize == 70 Tolerance == 1.0E-6 UseACRComparator == false UseRandomStartingPoint == false VariableRangeThreshold == 3.0 These can also be viewed via the Options dialog in the Calc GUI, as in Figure 11. Figure 11. The Options Dialog for the SCO Solver. These parameters, most of which apply to the DEPS solver as well, are explained at https://wiki.openoffice.org/wiki/NLPSolver#Options_and_Parameters . The correct solution reported by Calc.solverReport() is: Solver result: B4 == 10.0000 Solver variables: B1 == 6.0000 B2 == 8.0000 B3 == 4.0000","title":"4.2.  Another Linear Problem (using SCO)"},{"location":"27-Funcs_Analysis.html#43-a-nonlinear-problem-using-deps-and-sco","text":"SolverTest2.java defines a nonlinear optimization problem, so can only be solved by the DEPS or SCO solver; I'll start with DEPS. The problem comes from the Wikipedia page on nonlinear programming ( https://en.wikipedia.org/wiki/Nonlinear_programming/ ). There are four constraint inequalities: x \u2265 0 y \u2265 0 x 2 + y 2 \u2265 1 x 2 + y 2 \u2264 2 The 'profit' expression to be maximized is: P = x + y The maximum P value is 2, when x == 1 and y == 1, which can be represented graphically in Figure 12 since we're once again using only two unknowns. Figure 12. Solution for the Nonlinear Optimization Problem. The code in SolverTest2.java is only slightly different from the previous two examples: // part of main() in SolverTest2.java : XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // specify the variable cells CellAddress xPos = Calc . getCellAddress ( sheet , \"B1\" ); // x CellAddress yPos = Calc . getCellAddress ( sheet , \"B2\" ); // y CellAddress [] vars = new CellAddress [] { xPos , yPos }; // specify profit equation Calc . setVal ( sheet , \"B3\" , \"=B1+B2\" ); // x + y CellAddress objective = Calc . getCellAddress ( sheet , \"B3\" ); // set up equation formula without inequality (only one needed) Calc . setVal ( sheet , \"B4\" , \"=B1*B1 + B2*B2\" ); // x^2 + y^2 // create two constraints from one equation SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \">=\" , 1 ); // x^2 + y^2 >= 1 SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 2 ); // x^2 + y^2 <= 2 SolverConstraint [] constraints = new SolverConstraint [] { sc1 , sc2 }; // initialize DEPS nonlinear solver XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.sheet.Solver\" ); // uses \"com.sun.star.comp.Calc.NLPSolver.DEPSSolverImpl\" solver . setDocument ( doc ); solver . setObjective ( objective ); solver . setVariables ( vars ); solver . setConstraints ( constraints ); solver . setMaximize ( true ); Props . showObjProps ( \"Solver\" , solver ); Props . setProperty ( solver , \"EnhancedSolverStatus\" , false ); // switch off nonlinear dialog about current progress Props . setProperty ( solver , \"AssumeNonNegative\" , true ); // restrict search to the top-right quadrant of graph // execute the solver; print the results solver . solve (); Calc . solverReport ( solver ); Only one inequality equation is defined: Calc.setVal(sheet, \"B4\", \"=B1*B1 + B2*B2\"); // x^2 + y^2 because it can be used twice to define the nonlinear constraints: SolverConstraint sc1 = Calc . makeConstraint ( sheet , \"B4\" , \">=\" , 1 ); // x^2 + y^2 >= 1 SolverConstraint sc2 = Calc . makeConstraint ( sheet , \"B4\" , \"<=\" , 2 ); // x^2 + y^2 <= 2 No constraints are defined for x >= 0 and y >= 0. Instead, the solver's \"AssumeNonNegative\" property is set to true, which achieves the same thing. The DEPS solver is used by default when a nonlinear optimization needs to be solved, so the solver is instantiated using the general Solver service name: XSolver solver = Lo.createInstanceMCF(XSolver.class, \"com.sun.star.sheet.Solver\"); Alternatively, it's possible to use the DEPS service name: \"com.sun.star.comp.Calc.NLPSolver.DEPSSolverImpl\" . The results printed by Calc.solverReport() are: Solver result: B3 == 2.0000 Solver variables: B1 == 1.0001 B2 == 0.9999 If DEPS is replaced by the SCO solver: XSolver solver = Lo . createInstanceMCF ( XSolver . class , \"com.sun.star.comp.Calc.NLPSolver.SCOSolverImpl\" ); The printed result is slightly more accurate: Solver result: B3 == 2.0000 Solver variables: B1 == 1.0000 B2 == 1.0000 but it takes a little bit longer to return.","title":"4.3.  A Nonlinear Problem (using DEPS and SCO)"},{"location":"28%20Part%205%20Chart.html","text":"Part 5 Chart \u00b6","title":"Part 5 Chart"},{"location":"28%20Part%205%20Chart.html#part-5-chart","text":"","title":"Part 5 Chart"},{"location":"28-Chart2_API_Overview.html","text":"Chapter 28. Chart2 API Overview \u00b6 Topics Charting Elements; Chart Creation: TableChart, ChartDocument, linking template, diagram, and data source; Modifying Chart Elements: diagram, coordinate system, chart type, data series Example folders: \"Chart2 Tests\" and \"Utils\" At over 1,600 pages the OpenOffice Developer's Guide isn't a quick read, but you might expect it to cover all the major parts of the Office API. That's mostly true, except for one omission \u2013 there's no mention of the chart2 charting module. It's absent from the guide, the online examples, and only makes a brief appearance in the Wiki, at https://wiki.openoffice.org/wiki/Chart/ . That's not to say that chart creation isn't explained in the guide; chapter 10 is all about that topic, but using the older charting module, called chart (as you might guess). One source of confusion is that both modules have a similar top-level interface to Calc via XTableChart and XChartDocument, but they rapidly diverge as you progress further into the APIs. A sure way to make code crash is to mix services and interfaces from the two modules. Since newer is obviously better, the question arises as to why the Developer's Guide skips chart2 ? The reason seems to be historical \u2013 the guide was written for OpenOffice version 3.1, which dates from the middle of 2009. The chart2 module was released two years before, in September 2007, for version 2.3. That release came with dire warnings in the Wiki about the API being unstable and subject to change, comments that are still there. I'm sure those warnings were valid back in 2007, but chart2 underwent a lot of development over the next three years before LibreOffice was forked off in September 2010. After that the pace of change slowed, mainly because the module was stable. For example, Calc's charting wizard is implemented using chart2. Since the developer's guide hasn't been updated in six years, the chart2 module hasn't received much notice. I'll be rectifying that by concentrating solely on chart2 programming; I won't be using the old chart API. The primary source of online information about chart2 is its API documentation at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1chart2.html , or you can access it with lodoc chart2 . The only extensive programming resource I've found on chart2 is a Japanese site ( https://hermione.s41.xrea.com/pukiwiki/index.php?OOoBasic%2FCalc%2Fchart2 ) which uses the OOoBasic version of the API. It's a great site, but often offline; one partly remedy is to use Google's cached copies of some of its pages. One problem with searching the Web for examples is that programs using the chart2 and chart modules look similar. The crucial difference for Java is that most of the chart2 services and interfaces are inside the \"com.sun.star.chart2\" package whereas the older chart services and interfaces are inside \"com.sun.star.chart\" (no \"2\"). Another way to distinguish between examples, especially for programs written in Basic, is to look at the names of the chart services. The old chart names end with the word \"Diagram\" (e.g. BarDiagram, DonutDiagram, LineDiagram) whereas the chart2 names either end with the word \"ChartType\" (e.g. BarChartType, PieChartType, LineChartType), or with no special word (e.g. Bar, Donut, Line). A good way to get a feel for chart2's functionality is to look at chapter 3 of Calc's user guide, available from https://libreoffice.org/get-help/documentation/ . It describes the charting wizard, which acts as a very nice GUI for most of the chart2 API. The chapter also introduces a lot of charting terminology (e.g. chart types, data ranges, data series) used in the API. 1. Charting Elements \u00b6 Different chart types share many common elements, as illustrated in Figure 1. Figure 1. Typical Chart Elements. Most of the labeled components in Figure 1 are automatically included when a chart template is instantiated; the programmer typically only has to supply text and a few property settings, such as the wall color and font size. There are ten main chart types, which are listed when the \"Chart Wizard\" is started via Calc's Insert, Chart menu item. Figures 2 shows the possibilities. Figure 2. Ten Chart Types. Most of the types offer variants, which are displayed as icons to the right of the dialog window. When you position the mouse over an icon, the name of the variant appears briefly in a tooltip, as in Figure 3. Figure 3. A Column Chart Icon with its Tooltip Name. When the checkboxes, buttons, or combo boxes are selected in the dialog, the icons change to reflect changes in the variants. The three most common variants are \"3D\", \"Stacked\" and \"Percent\". \"Stacked\" is utilized when the chart displays multiple data sequences stacked on top of each other. \"Percent\" is combined with \"Stacked\" to stack the sequences in terms of their percentage contribution to the total. A lengthy discussion about chart variants can be found in chapter 3 of the Calc User Guide, in the section \"Gallery of Chart Types\". In the chart2 API, the variants are accessed via template names, which are listed in Table 1. Chart Types Template Names Column Stacked Column, StackedColumn, PercentStackedColumn, Percent ThreeDColumnDeep, ThreeDColumnFlat, 3D StackedThreeDColumnFlat, PercentStackedThreeDColumnFlat Bar Stacked Bar, StackedBar, PercentStackedBar, Percent ThreeDBarDeep, ThreeDBarFlat, 3D StackedThreeDBarFlat, PercentStackedThreeDBarFlat Pie Donut Pie, Donut, Explode PieAllExploded, DonutAllExploded, 3D ThreeDPie, ThreeDPieAllExploded, ThreeDDonut, ThreeDDonutAllExploded Area Stacked Area, StackedArea, PercentStackedArea, Percent ThreeDArea, StackedThreeDArea, 3D PercentStackedThreeDArea Line Symbol Line, Symbol, LineSymbol, Stacked StackedLine, StackedSymbol, StackedLineSymbol, Percent PercentStackedLine, PercentStackedSymbol, 3D PercentStackedLineSymbol, ThreeDLine, ThreeDLineDeep, StackedThreeDLine, PercentStackedThreeDLine XY Line ScatterSymbol, ScatterLine, ScatterLineSymbol, (Scatter) 3D ThreeDScatter Bubble Bubble Net Line Net, NetLine, NetSymbol, FilledNet, Symbol StackedNet, StackedNetLine, Filled StackedNetSymbol, StackedFilledNet, Stacked PercentStackedNet, PercentStackedNetLine, PercentStackedNetSymbol, Percent PercentStackedFilledNet Stock Open StockLowHighClose, Volume StockOpenLowHighClose, StockVolumeLowHighClose, StockVolumeOpenLowHighClose Column Stacked ColumnWithLine, StackedColumnWithLine and Line Table 1. Chart Types and Template Names. The templates I'll be using are highlighted in bold in Table 1. The template names are closely related to the tooltip names in Calc's chart wizard. For example, the tooltip name in Figure 3 corresponds to the \"PercentStackedColumn\" template. It's also possible to create a chart using a chart type name, which are listed in Table 2. Chart Chart Type Names Column ColumnChartType Bar BarChartType Pie PieChartType Area AreaChartType Line LineChartType XY (Scatter) ScatterChartType Bubble BubbleChartType Net NetChartType, FilledNetChartType Stock CandleStickChartType Table 2. Chart Type Names. Note that a stock chart graph is drawn using a CandleStickChartType, and that there's no type name for a column and line chart because it's implemented as a combination of ColumnChartType and BarChartType. Almost all my examples will use chart templates. I'll only use chart type names when I want to add extra data to an existing chart (e.g. add a line graph to a stock chart). The chart2 module is quite complex, so I've hidden a lot of details inside methods in my Chart2.java class. It simplifies four kinds of operation: The creation of a new chart in a spreadsheet document, based on a template name. The accessing and modification of elements inside a chart, such as the title, legend, axes, and colors. The addition of extra data to a chart, such as error bars or a second graph. The embedding of a chart in a document other than a spreadsheet, namely in a text document or slide presentation. Operations no. 1 (chart creation) and no. 2 (element modification) are used by all my examples, so the rest of this chapter will give an overview of how the corresponding Chart2.java methods work. Programming details specific to particular charts will be discussed in subsequent chapters: column: chapter 29; bar, pie, area, line: chapter 30; XY (scatter): chapter 31; bubble, net, stock: chapter 32. 2. Chart Creation \u00b6 Chart creation can be divided into three steps: A TableChart service is created inside the spreadsheet. The ChartDocument service is accessed inside the TableChart. The ChartDocument is initialized by linking together a chart template, diagram, and data source. The details are explained in the following sub-sections. 2.1. Creating a Table Chart \u00b6 XTableCharts.addNewByName() adds a new TableChart to the TableCharts collection in a spreadsheet. This is shown graphically in Figure 4, and is implemented by Chart2.addTableChart(). Figure 4. Creating a new TableChart Service. Chart2.addTableChart() is defined as: // in the Chart2 class public static void addTableChart ( XSpreadsheet sheet , String chartName , CellRangeAddress cellsRange , String cellName , int width , int height ) // create table chart at cell name and size width x height { XTableChartsSupplier chartsSupplier = Lo . qi ( XTableChartsSupplier . class , sheet ); XTableCharts tableCharts = chartsSupplier . getCharts (); com . sun . star . awt . Point pos = Calc . getCellPos ( sheet , cellName ); Rectangle rect = new Rectangle ( pos . X , pos . Y , width * 1000 , height * 1000 ); CellRangeAddress [] addrs = new CellRangeAddress [] { cellsRange }; tableCharts . addNewByName ( chartName , rect , addrs , true , true ); } // end of addTableChart() The arguments passed to Chart2.addTableChart() include the new chart's name, the cell range used as a data source, and the chart's position and dimensions when drawn in the Calc window. The position is a cell name (e.g. \"A1\"), which becomes the location of the top-left corner of the chart in the Calc window. The name is converted into a position by calling Calc.getCellPos(). The size of the chart is supplied as millimeter width and height arguments and converted into a Rectangle in 1/100mm units. My methods assume that the data range has a specific format, which is illustrated by Figure 5. Figure 5. Cell Range Data Format. The data is organized into columns, the first for the x-axis categories, and the others for the y-axis data displayed as graphs. The first row of the data range contains labels for the x-axis and the graphs. For example, the data range in Figure 5 is drawn as a Column chart in Figure 6. Figure 6. A Column Chart Using the Data in Figure 5. The assumption that the first data column are x-axis categories doesn't apply to scatter and bubble charts which use numerical x-axis values. I'll give examples of those in later chapters. The data format assumptions are used in the call to XTableCharts.addNewByName() in Chart2.addTableChart() by setting its last two arguments to true. This specifies that the top row and left column will be used as categories and/or labels. More specific format information will be supplied later. 2.2. Accessing the Chart Document \u00b6 Although Chart2.addTableChart() adds a table chart to the spreadsheet, it doesn't return a reference to the new chart document. That's obtained by calling Chart2.getChartDoc(): Chart2 . addTableChart ( sheet , chartName , cellsRange , cellName , width , height ); XChartDocument chartDoc = Chart2 . getChartDoc ( sheet , chartName ); Chart2.getChartDoc() accesses the spreadsheet's collection of TableCharts, searching for the one with the given name. The matching TableChart service is treated as an XEmbeddedObjectSupplier interface, which lets its embedded chart document be referenced. These steps are illustrated by Figure 7. Figure 7. Accessing a Chart Document. Chart2.getChartDoc() implements Figure 7, using Chart2.getTableChart() to access the named table chart: // in the Chart2 class public static XChartDocument getChartDoc ( XSpreadsheet sheet , String chartName ) // return the chart doc from the sheet { // get the named table chart XTableChart tableChart = getTableChart ( sheet , chartName ); if ( tableChart == null ) return null ; // chart doc is embedded inside table chart XEmbeddedObjectSupplier eos = Lo . qi ( XEmbeddedObjectSupplier . class , tableChart ); return Lo . qi ( XChartDocument . class , eos . getEmbeddedObject ()); } // end of getChartDoc() public static XTableChart getTableChart ( XSpreadsheet sheet , String chartName ) // return the named table chart from the sheet { // get the supplier for the table charts XTableChartsSupplier chartsSupplier = Lo . qi ( XTableChartsSupplier . class , sheet ); XTableCharts tableCharts = chartsSupplier . getCharts (); XNameAccess tcAccess = Lo . qi ( XNameAccess . class , tableCharts ); // try to access the chart with the specified name XTableChart tableChart = null ; try { tableChart = Lo . qi ( XTableChart . class , tcAccess . getByName ( chartName )); } catch ( Exception ex ) { System . out . println ( \"Could not access \" + chartName ); } return tableChart ; } // end of getTableChart() 2.3. Initializing the Chart Document \u00b6 The chart document is initialized by linking three components: the chart template, the chart's diagram, and a data source, as illustrated by Figure 8. Figure 8. Initializing a Chart Document. The initialization steps in Figure 8, and the earlier calls to Chart2.addTableChart() and Chart2.getChartDoc() are carried out by Chart2.insertChart(). A typical call to insertChart() would be: CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E15:G21\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A22\" , 20 , 11 , \"Column\" ); The first line converts \"E15:G21\" into a data range (this corresponds to the cells shown in Figure 5), which is passed to Chart2.insertChart(). The \"A22\" string and the 20x11 mm dimensions specify the position and size of the chart, and the last argument (\"Column\") is the desired chart template (see Table 1). The result is the column chart shown in Figure 6. Chart2.insertChart() is: // in the Chart2 class // globals private static final String CHART_NAME = \"chart$$_\" ; public static XChartDocument insertChart ( XSpreadsheet sheet , CellRangeAddress cellsRange , String cellName , int width , int height , String diagramName ) { String chartName = CHART_NAME + ( int )( Math . random () * 10000 ); // generate a random name addTableChart ( sheet , chartName , cellsRange , cellName , width , height ); // get newly created (empty) chart XChartDocument chartDoc = getChartDoc ( sheet , chartName ); // assign chart template to the chart's diagram System . out . println ( \"Using chart template: \" + diagramName ); XDiagram diagram = chartDoc . getFirstDiagram (); XChartTypeTemplate ctTemplate = setTemplate ( chartDoc , diagram , diagramName ); if ( ctTemplate == null ) return null ; boolean hasCats = hasCategories ( diagramName ); // initialize data source XDataProvider dp = chartDoc . getDataProvider (); PropertyValue [] aProps = Props . makeProps ( new String [] { \"CellRangeRepresentation\" , \"DataRowSource\" , \"FirstCellAsLabel\" , \"HasCategories\" }, new Object [] { Calc . getRangeStr ( cellsRange , sheet ), ChartDataRowSource . COLUMNS , true , hasCats }); XDataSource ds = dp . createDataSource ( aProps ); // add data source to chart template PropertyValue [] args = Props . makeProps ( \"HasCategories\" , hasCats ); ctTemplate . changeDiagramData ( diagram , ds , args ); // apply style settings to chart doc setBackgroundColors ( chartDoc , Calc . PALE_BLUE , Calc . LIGHT_BLUE ); // background and wall colors if ( hasCats ) // charts using x-axis categories setDataPointLabels ( chartDoc , Chart2 . DP_NUMBER ); // show y-axis values printChartTypes ( chartDoc ); return chartDoc ; } // end of insertChart() insertChart() creates a new chart document by calling addTableChart() and getChartDoc(), and then proceeds to link the chart template, diagram, and data source. Get the Diagram \u00b6 The chart diagram is the easiest to obtain, since it's directly accessible via the XChartDocument reference: // part of Chart2.insertChart()... XDiagram diagram = chartDoc . getFirstDiagram (); Creating a Template \u00b6 Creating a chart template is a few more steps. requiring the creation of a XChartTypeManager interface inside Chart2.setTemplate(): // in the Chart2 class public static XChartTypeTemplate setTemplate ( XChartDocument chartDoc , XDiagram diagram , String diagramName ) // set diagram to use the specified chart template { try { XChartTypeManager ctMan = chartDoc . getChartTypeManager (); XMultiServiceFactory msf = Lo . qi ( XMultiServiceFactory . class , ctMan ); String templateNm = \"com.sun.star.chart2.template.\" + diagramName ; XChartTypeTemplate ctTemplate = Lo . qi ( XChartTypeTemplate . class , msf . createInstance ( templateNm )); if ( ctTemplate == null ) { System . out . println ( \"Could not create chart template \\\"\" + diagramName + \"\\\"; using a column chart\" ); ctTemplate = Lo . qi ( XChartTypeTemplate . class , msf . createInstance ( \"com.sun.star.chart2.template.Column\" )); } ctTemplate . changeDiagram ( diagram ); return ctTemplate ; } catch ( Exception ex ) { System . out . println ( \"Could not set chart to \" + diagramName ); return null ; } } // end of setTemplate() The diagramName value is one of the template names shown in Table 1 (e.g. \"Column\"). The string \"com.sun.star.chart2.template.\" is added to the front to create a fully qualified service name, which is then instantiated. If the instance creation fails, then the function falls back to creating an instance of the \"Column\" template. setTemplate() ends by calling XChartTypeTemplate.changeDiagram() which links the template to the chart's diagram. Get the Data Source \u00b6 Back in Chart2.insertChart(), the right-most branch of Figure 8 involves the creation of an XDataProvider instance: // part of Chart2.insertChart()... XDataProvider dp = chartDoc . getDataProvider (); This data provider converts the chart's data range into an XDataSource: // part of Chart2.insertChart()... boolean hasCats = hasCategories ( diagramName ); PropertyValue [] aProps = Props . makeProps ( new String [] { \"CellRangeRepresentation\" , \"DataRowSource\" , \"FirstCellAsLabel\" , \"HasCategories\" }, new Object [] { Calc . getRangeStr ( cellsRange , sheet ), ChartDataRowSource . COLUMNS , true , hasCats }); XDataSource ds = dp . createDataSource ( aProps ); The properties passed to XDataProvider.createDataSource() specify more details about the format of the data in Figure 5 \u2013 the data for each graph is organized into columns with the first cell being the label for the graph. The \"HasCategories\" property is set to true when the first column of the data is to be used as x-axis categories. These properties passed to createDataSource() are described in the documentation for the TabularDataProviderArguments service, which you can access using lodoc TabularDataProviderArguments . The hasCats boolean is set by examining the diagram name: if it's an XY scatter chart or bubble chart then the first column of data will not be used as x-axis categories, so the boolean is set to false: // in the Chart2 class public static boolean hasCategories ( String diagramName ) { String name = diagramName . toLowerCase (); if ( name . contains ( \"scatter\" ) || name . contains ( \"bubble\" )) return false ; return true ; } // end of hasCategories() Linking the template, diagram, and data source \u00b6 Now the data source can populate the diagram using the specified chart template format: // part of Chart2.insertChart()... PropertyValue [] args = Props . makeProps ( \"HasCategories\" , hasCats ); ctTemplate . changeDiagramData ( diagram , ds , args ); At this point the chart will be drawn in the Calc application window, and Chart2.insertChart() could return. Instead my code modifies the appearance of the chart in two ways: // part of Chart2.insertChart()... // apply some style settings to chart doc setBackgroundColors ( chartDoc , Calc . PALE_BLUE , Calc . LIGHT_BLUE ); // color the background and wall colors if ( hasCats ) // charts using x-axis categories setDataPointLabels ( chartDoc , Chart2 . DP_NUMBER ); // show y-axis values on the data points Chart2.setBackgroundColors() changes the background and wall colors of the chart (see Figure 6). Chart2.setDataPointLabels() switches on the displaying of the y-axis data points as numbers which appear just above the top of each column in a column chart. I'll describe how these methods work in the next section. The call to Chart2.printChartTypes() at the end of Chart2.insertChart() could be commented out since it's a diagnostic check. It prints the names of the chart types used by the template. 3. Accessing and Modifying Chart Elements \u00b6 Almost every aspect of a chart can be adjusted, including such things as its color scheme, the fonts, the scaling of the axes, the positioning of the legend, axis labels, and titles. It's also possible to augment charts with regression line details, error bars, and additional graphs. These elements are located in a number of different places in the hierarchy of services accessible through the ChartDocument service. A simplified version of this hierarchy is shown in Figure 9. Figure 9. The Hierarchy of Services Below ChartDocument. I'll supply more information about the Diagram, CoordinateSystem, ChartType, and DataSeries services as this section progresses, but Figure 9 indicates that Diagram manages the legend, floor and chart wall, CoordinateSystem is in charge of the axes, and the data points are manipulated via DataSeries. The \"1\" and \"*\" in the figure indicate that a diagram may utilize multiple coordinate systems, that a single coordinate system may display multiple chart types, and a single chart type can employ many data series. Fortunately, this generality isn't often needed for the charts created by Chart2.insertChart(). In particular, the chart diagram only uses a single coordinate system and a single chart type (most of the time). 3.1. Accessing the Diagram \u00b6 A chart's Diagram service is easily reached by calling ChartDocument.getFirstDiagram(), which returns a reference to the diagram's XDiagram interface: XDiagram diagram = chartDoc . getFirstDiagram (); XDiagram contains several useful methods (e.g. getLegend(), getWall(), getFloor()), and its services hold many properties (e.g. \"StartingAngle\" used in pie charts and \"RotationVertical\" for 3D charts). This is summarized by Figure 10. Figure 10. The Diagram Service. The easiest way to access the documentation for Diagram and XDiagram is via loDoc: > loDoc chart2 diagram > loDoc xdiagram Chart2.setBackgroundColors() changes the background and wall colors of the chart through the ChartDocument and Diagram services: // in the Chart2 class public static void setBackgroundColors ( XChartDocument chartDoc , int bgColor , int wallColor ) { if ( bgColor > 0 ) { XPropertySet bgProps = chartDoc . getPageBackground (); // Props.showProps(\"Background\", bgProps); Props . setProperty ( bgProps , \"FillBackground\" , true ); Props . setProperty ( bgProps , \"FillStyle\" , FillStyle . SOLID ); Props . setProperty ( bgProps , \"FillColor\" , bgColor ); } if ( wallColor > 0 ) { XDiagram diagram = chartDoc . getFirstDiagram (); XPropertySet wallProps = diagram . getWall (); // Props.showProps(\"Wall\", wallProps); Props . setProperty ( wallProps , \"FillBackground\" , true ); Props . setProperty ( wallProps , \"FillStyle\" , FillStyle . SOLID ); Props . setProperty ( wallProps , \"FillColor\" , wallColor ); } } // end of setBackgroundColors() The chart background is manipulated with a property set accessible through XChartDocument.getPageBackground(), while the wall is reached with XDiagram.getWall(). The documentation for the getPageBackground() and getWall() methods doesn't list the contents of their property sets, so the easiest way of finding out what's available is by calling Props.showProps(). Two showProps() calls are commented out in the code above. Most chart services inherit a mix of four property classes: com.sun.star.style.CharacterProperties com.sun.star.style.ParagraphProperties com.sun.star.drawing.LineProperties com.sun.star.drawing.FillProperties Since getWall() and getPageBackground() both deal with areas in the chart, their properties come from the FillProperties class. 3.2. Accessing the Coordinate System \u00b6 Figure 10 shows that the diagram's coordinate systems are reached through XCoordinateSystemContainer.getCoordinateSystems(). Chart2.getCoordSystem() assumes that the programmer only wants the first coordinate system: // in the Chart2 class public static XCoordinateSystem getCoordSystem ( XChartDocument chartDoc ) { XDiagram diagram = chartDoc . getFirstDiagram (); XCoordinateSystemContainer coordSysCon = Lo . qi ( XCoordinateSystemContainer . class , diagram ); XCoordinateSystem [] coordSys = coordSysCon . getCoordinateSystems (); if ( coordSys . length > 1 ) System . out . println ( \"No of coord systems: \" + coordSys . length + \"; using first\" ); return coordSys [ 0 ] ; // return first } // end of getCoordSystem() The CoordinateSystem service is employed to access the chart's axes and its chart type (or types), as in Figure 11. Figure 11. The CoordinateSystem Service. I'll describe the Axis service when I look at methods for adjusting axis properties. It contains a lot of properties, which are documented online. The easiest way to access the page is with loDoc chart2 axis service . The extra lodoc arguments help to narrow the search since the word \"axis\" is used in multiple places in the chart2 and chart modules. 3.3. Accessing the Chart Type \u00b6 Figure 11 shows that the chart types in a coordinate system are reached through XChartTypeContainer.getChartTypes(). Chart2.getChartType() assumes the programmer only wants the first chart type in the array: // in the Chart2 class public static XChartType getChartType ( XChartDocument chartDoc ) { XChartType [] chartTypes = getChartTypes ( chartDoc ); return chartTypes [ 0 ] ; // get first } public static XChartType [] getChartTypes ( XChartDocument chartDoc ) { XCoordinateSystem coordSys = getCoordSystem ( chartDoc ); XChartTypeContainer ctCon = Lo . qi ( XChartTypeContainer . class , coordSys ); return ctCon . getChartTypes (); } // end of getChartTypes() Figure 12 shows the main components of the ChartType service. Figure 12. The ChartType Service. Somewhat surprisingly, the ChartType service isn't the home for chart type related properties; instead XChartType contains methods for examining chart type \"roles\", which I'll describe later. One useful features of XChartType is getChartType() which returns the type as a string. The CandleStickChartType service inherits ChartType, and contains properties related to stock charts. Use loDoc chart2 charttype to view the online documentation for ChartType. 3.4. Accessing the Data Series \u00b6 Figure 12 shows that the data series for a chart type is accessed via XDataSeriesContainer.getDataSeries(). This is implemented by Chart2.getDataSeries(): // in the Chart2 class public static XDataSeries [] getDataSeries ( XChartDocument chartDoc ) { XChartType xChartType = getChartType ( chartDoc ); XDataSeriesContainer dsCon = Lo . qi ( XDataSeriesContainer . class , xChartType ); return dsCon . getDataSeries (); } //end of getDataSeries() The DataSeries service is one of the more complex parts of the Chart2 module because of its support for several important interfaces. I won't explain all of them just yet; Figure 13 focuses on the XDataSeries interface. Figure 13. The DataSeries Service and XDataSeries Interface. A DataSeries represents a series of data points in the chart. Changes to the look of these data points (e.g. adding numbers next to the points, or changing their shape and color) can be done in two ways. A data series as a whole maintains a set of properties, most of which are inherited from the DataPointProperties class. Typical DataPointProperies values are \"Color\", \"Shape\", \"LineWidth\". The online documentation can be accessed by calling lodoc DataPointProperties . It's also possible to adjust point properties on an individual basis by accessing a particular data point by calling XDataSeries.getDataPointByIndex(). As the method name suggests, this requires an index value for the point, which can be a little tricky to determine. I can now explain the second of the two chart changing methods called at the end of Chart2.insertChart(): Chart2.setDataPointLabels(), which switches on the displaying of the y-axis data points as numbers. The call is: // part of Chart2.insertChart()... setDataPointLabels ( chartDoc , Chart2 . DP_NUMBER ); Chart2.setDataPointLabels() uses Chart2.getDataSeries() described above, which returns an array of all the data series used in the chart. setDataPointLabels() iterates through the array and manipulates the \"Label\" property for each series. In other words, it modifies each data series property without accessing each point. The code for Chart2.setDataPointLabels(): // in the Chart2 class // data point label types public static final int DP_NUMBER = 0 ; public static final int DP_PERCENT = 1 ; public static final int DP_CATEGORY = 2 ; public static final int DP_SYMBOL = 3 ; public static final int DP_NONE = 4 ; public static void setDataPointLabels ( XChartDocument chartDoc , int labelType ) // change label type for all data series { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); for ( XDataSeries dataSeries : dataSeriesArr ) { // visit every data series DataPointLabel dpLabel = ( DataPointLabel ) Props . getProperty ( dataSeries , \"Label\" ); dpLabel . ShowNumber = false ; // reset show types dpLabel . ShowCategoryName = false ; dpLabel . ShowLegendSymbol = false ; if ( labelType == DP_NUMBER ) dpLabel . ShowNumber = true ; else if ( labelType == DP_PERCENT ) { dpLabel . ShowNumber = true ; dpLabel . ShowNumberInPercent = true ; } else if ( labelType == DP_CATEGORY ) dpLabel . ShowCategoryName = true ; else if ( labelType == DP_SYMBOL ) dpLabel . ShowLegendSymbol = true ; else if ( labelType == DP_NONE ) {} // do nothing else System . out . println ( \"Unrecognized label type\" ); Props . setProperty ( dataSeries , \"Label\" , dataPointLabel ); } } // end of setDataPointLabels() The \"Label\" DataSeries property is inherited from DataPointProperties (see lodoc DataPointProperties ). \"Label\" is of type DataPointLabel which maintains four 'show' booleans for displaying the number and other kinds of information next to the data point. Depending on the labelType value passed to Chart2.setDataPointLabels(), one or more of these booleans are set and the \"Label\" property updated.","title":"Chapter 28. Chart2 API Overview"},{"location":"28-Chart2_API_Overview.html#chapter-28-chart2-api-overview","text":"Topics Charting Elements; Chart Creation: TableChart, ChartDocument, linking template, diagram, and data source; Modifying Chart Elements: diagram, coordinate system, chart type, data series Example folders: \"Chart2 Tests\" and \"Utils\" At over 1,600 pages the OpenOffice Developer's Guide isn't a quick read, but you might expect it to cover all the major parts of the Office API. That's mostly true, except for one omission \u2013 there's no mention of the chart2 charting module. It's absent from the guide, the online examples, and only makes a brief appearance in the Wiki, at https://wiki.openoffice.org/wiki/Chart/ . That's not to say that chart creation isn't explained in the guide; chapter 10 is all about that topic, but using the older charting module, called chart (as you might guess). One source of confusion is that both modules have a similar top-level interface to Calc via XTableChart and XChartDocument, but they rapidly diverge as you progress further into the APIs. A sure way to make code crash is to mix services and interfaces from the two modules. Since newer is obviously better, the question arises as to why the Developer's Guide skips chart2 ? The reason seems to be historical \u2013 the guide was written for OpenOffice version 3.1, which dates from the middle of 2009. The chart2 module was released two years before, in September 2007, for version 2.3. That release came with dire warnings in the Wiki about the API being unstable and subject to change, comments that are still there. I'm sure those warnings were valid back in 2007, but chart2 underwent a lot of development over the next three years before LibreOffice was forked off in September 2010. After that the pace of change slowed, mainly because the module was stable. For example, Calc's charting wizard is implemented using chart2. Since the developer's guide hasn't been updated in six years, the chart2 module hasn't received much notice. I'll be rectifying that by concentrating solely on chart2 programming; I won't be using the old chart API. The primary source of online information about chart2 is its API documentation at https://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1chart2.html , or you can access it with lodoc chart2 . The only extensive programming resource I've found on chart2 is a Japanese site ( https://hermione.s41.xrea.com/pukiwiki/index.php?OOoBasic%2FCalc%2Fchart2 ) which uses the OOoBasic version of the API. It's a great site, but often offline; one partly remedy is to use Google's cached copies of some of its pages. One problem with searching the Web for examples is that programs using the chart2 and chart modules look similar. The crucial difference for Java is that most of the chart2 services and interfaces are inside the \"com.sun.star.chart2\" package whereas the older chart services and interfaces are inside \"com.sun.star.chart\" (no \"2\"). Another way to distinguish between examples, especially for programs written in Basic, is to look at the names of the chart services. The old chart names end with the word \"Diagram\" (e.g. BarDiagram, DonutDiagram, LineDiagram) whereas the chart2 names either end with the word \"ChartType\" (e.g. BarChartType, PieChartType, LineChartType), or with no special word (e.g. Bar, Donut, Line). A good way to get a feel for chart2's functionality is to look at chapter 3 of Calc's user guide, available from https://libreoffice.org/get-help/documentation/ . It describes the charting wizard, which acts as a very nice GUI for most of the chart2 API. The chapter also introduces a lot of charting terminology (e.g. chart types, data ranges, data series) used in the API.","title":"Chapter 28. Chart2 API Overview"},{"location":"28-Chart2_API_Overview.html#1-charting-elements","text":"Different chart types share many common elements, as illustrated in Figure 1. Figure 1. Typical Chart Elements. Most of the labeled components in Figure 1 are automatically included when a chart template is instantiated; the programmer typically only has to supply text and a few property settings, such as the wall color and font size. There are ten main chart types, which are listed when the \"Chart Wizard\" is started via Calc's Insert, Chart menu item. Figures 2 shows the possibilities. Figure 2. Ten Chart Types. Most of the types offer variants, which are displayed as icons to the right of the dialog window. When you position the mouse over an icon, the name of the variant appears briefly in a tooltip, as in Figure 3. Figure 3. A Column Chart Icon with its Tooltip Name. When the checkboxes, buttons, or combo boxes are selected in the dialog, the icons change to reflect changes in the variants. The three most common variants are \"3D\", \"Stacked\" and \"Percent\". \"Stacked\" is utilized when the chart displays multiple data sequences stacked on top of each other. \"Percent\" is combined with \"Stacked\" to stack the sequences in terms of their percentage contribution to the total. A lengthy discussion about chart variants can be found in chapter 3 of the Calc User Guide, in the section \"Gallery of Chart Types\". In the chart2 API, the variants are accessed via template names, which are listed in Table 1. Chart Types Template Names Column Stacked Column, StackedColumn, PercentStackedColumn, Percent ThreeDColumnDeep, ThreeDColumnFlat, 3D StackedThreeDColumnFlat, PercentStackedThreeDColumnFlat Bar Stacked Bar, StackedBar, PercentStackedBar, Percent ThreeDBarDeep, ThreeDBarFlat, 3D StackedThreeDBarFlat, PercentStackedThreeDBarFlat Pie Donut Pie, Donut, Explode PieAllExploded, DonutAllExploded, 3D ThreeDPie, ThreeDPieAllExploded, ThreeDDonut, ThreeDDonutAllExploded Area Stacked Area, StackedArea, PercentStackedArea, Percent ThreeDArea, StackedThreeDArea, 3D PercentStackedThreeDArea Line Symbol Line, Symbol, LineSymbol, Stacked StackedLine, StackedSymbol, StackedLineSymbol, Percent PercentStackedLine, PercentStackedSymbol, 3D PercentStackedLineSymbol, ThreeDLine, ThreeDLineDeep, StackedThreeDLine, PercentStackedThreeDLine XY Line ScatterSymbol, ScatterLine, ScatterLineSymbol, (Scatter) 3D ThreeDScatter Bubble Bubble Net Line Net, NetLine, NetSymbol, FilledNet, Symbol StackedNet, StackedNetLine, Filled StackedNetSymbol, StackedFilledNet, Stacked PercentStackedNet, PercentStackedNetLine, PercentStackedNetSymbol, Percent PercentStackedFilledNet Stock Open StockLowHighClose, Volume StockOpenLowHighClose, StockVolumeLowHighClose, StockVolumeOpenLowHighClose Column Stacked ColumnWithLine, StackedColumnWithLine and Line Table 1. Chart Types and Template Names. The templates I'll be using are highlighted in bold in Table 1. The template names are closely related to the tooltip names in Calc's chart wizard. For example, the tooltip name in Figure 3 corresponds to the \"PercentStackedColumn\" template. It's also possible to create a chart using a chart type name, which are listed in Table 2. Chart Chart Type Names Column ColumnChartType Bar BarChartType Pie PieChartType Area AreaChartType Line LineChartType XY (Scatter) ScatterChartType Bubble BubbleChartType Net NetChartType, FilledNetChartType Stock CandleStickChartType Table 2. Chart Type Names. Note that a stock chart graph is drawn using a CandleStickChartType, and that there's no type name for a column and line chart because it's implemented as a combination of ColumnChartType and BarChartType. Almost all my examples will use chart templates. I'll only use chart type names when I want to add extra data to an existing chart (e.g. add a line graph to a stock chart). The chart2 module is quite complex, so I've hidden a lot of details inside methods in my Chart2.java class. It simplifies four kinds of operation: The creation of a new chart in a spreadsheet document, based on a template name. The accessing and modification of elements inside a chart, such as the title, legend, axes, and colors. The addition of extra data to a chart, such as error bars or a second graph. The embedding of a chart in a document other than a spreadsheet, namely in a text document or slide presentation. Operations no. 1 (chart creation) and no. 2 (element modification) are used by all my examples, so the rest of this chapter will give an overview of how the corresponding Chart2.java methods work. Programming details specific to particular charts will be discussed in subsequent chapters: column: chapter 29; bar, pie, area, line: chapter 30; XY (scatter): chapter 31; bubble, net, stock: chapter 32.","title":"1.  Charting Elements"},{"location":"28-Chart2_API_Overview.html#2-chart-creation","text":"Chart creation can be divided into three steps: A TableChart service is created inside the spreadsheet. The ChartDocument service is accessed inside the TableChart. The ChartDocument is initialized by linking together a chart template, diagram, and data source. The details are explained in the following sub-sections.","title":"2.  Chart Creation"},{"location":"28-Chart2_API_Overview.html#21-creating-a-table-chart","text":"XTableCharts.addNewByName() adds a new TableChart to the TableCharts collection in a spreadsheet. This is shown graphically in Figure 4, and is implemented by Chart2.addTableChart(). Figure 4. Creating a new TableChart Service. Chart2.addTableChart() is defined as: // in the Chart2 class public static void addTableChart ( XSpreadsheet sheet , String chartName , CellRangeAddress cellsRange , String cellName , int width , int height ) // create table chart at cell name and size width x height { XTableChartsSupplier chartsSupplier = Lo . qi ( XTableChartsSupplier . class , sheet ); XTableCharts tableCharts = chartsSupplier . getCharts (); com . sun . star . awt . Point pos = Calc . getCellPos ( sheet , cellName ); Rectangle rect = new Rectangle ( pos . X , pos . Y , width * 1000 , height * 1000 ); CellRangeAddress [] addrs = new CellRangeAddress [] { cellsRange }; tableCharts . addNewByName ( chartName , rect , addrs , true , true ); } // end of addTableChart() The arguments passed to Chart2.addTableChart() include the new chart's name, the cell range used as a data source, and the chart's position and dimensions when drawn in the Calc window. The position is a cell name (e.g. \"A1\"), which becomes the location of the top-left corner of the chart in the Calc window. The name is converted into a position by calling Calc.getCellPos(). The size of the chart is supplied as millimeter width and height arguments and converted into a Rectangle in 1/100mm units. My methods assume that the data range has a specific format, which is illustrated by Figure 5. Figure 5. Cell Range Data Format. The data is organized into columns, the first for the x-axis categories, and the others for the y-axis data displayed as graphs. The first row of the data range contains labels for the x-axis and the graphs. For example, the data range in Figure 5 is drawn as a Column chart in Figure 6. Figure 6. A Column Chart Using the Data in Figure 5. The assumption that the first data column are x-axis categories doesn't apply to scatter and bubble charts which use numerical x-axis values. I'll give examples of those in later chapters. The data format assumptions are used in the call to XTableCharts.addNewByName() in Chart2.addTableChart() by setting its last two arguments to true. This specifies that the top row and left column will be used as categories and/or labels. More specific format information will be supplied later.","title":"2.1.  Creating a Table Chart"},{"location":"28-Chart2_API_Overview.html#22-accessing-the-chart-document","text":"Although Chart2.addTableChart() adds a table chart to the spreadsheet, it doesn't return a reference to the new chart document. That's obtained by calling Chart2.getChartDoc(): Chart2 . addTableChart ( sheet , chartName , cellsRange , cellName , width , height ); XChartDocument chartDoc = Chart2 . getChartDoc ( sheet , chartName ); Chart2.getChartDoc() accesses the spreadsheet's collection of TableCharts, searching for the one with the given name. The matching TableChart service is treated as an XEmbeddedObjectSupplier interface, which lets its embedded chart document be referenced. These steps are illustrated by Figure 7. Figure 7. Accessing a Chart Document. Chart2.getChartDoc() implements Figure 7, using Chart2.getTableChart() to access the named table chart: // in the Chart2 class public static XChartDocument getChartDoc ( XSpreadsheet sheet , String chartName ) // return the chart doc from the sheet { // get the named table chart XTableChart tableChart = getTableChart ( sheet , chartName ); if ( tableChart == null ) return null ; // chart doc is embedded inside table chart XEmbeddedObjectSupplier eos = Lo . qi ( XEmbeddedObjectSupplier . class , tableChart ); return Lo . qi ( XChartDocument . class , eos . getEmbeddedObject ()); } // end of getChartDoc() public static XTableChart getTableChart ( XSpreadsheet sheet , String chartName ) // return the named table chart from the sheet { // get the supplier for the table charts XTableChartsSupplier chartsSupplier = Lo . qi ( XTableChartsSupplier . class , sheet ); XTableCharts tableCharts = chartsSupplier . getCharts (); XNameAccess tcAccess = Lo . qi ( XNameAccess . class , tableCharts ); // try to access the chart with the specified name XTableChart tableChart = null ; try { tableChart = Lo . qi ( XTableChart . class , tcAccess . getByName ( chartName )); } catch ( Exception ex ) { System . out . println ( \"Could not access \" + chartName ); } return tableChart ; } // end of getTableChart()","title":"2.2.  Accessing the Chart Document"},{"location":"28-Chart2_API_Overview.html#23-initializing-the-chart-document","text":"The chart document is initialized by linking three components: the chart template, the chart's diagram, and a data source, as illustrated by Figure 8. Figure 8. Initializing a Chart Document. The initialization steps in Figure 8, and the earlier calls to Chart2.addTableChart() and Chart2.getChartDoc() are carried out by Chart2.insertChart(). A typical call to insertChart() would be: CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E15:G21\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A22\" , 20 , 11 , \"Column\" ); The first line converts \"E15:G21\" into a data range (this corresponds to the cells shown in Figure 5), which is passed to Chart2.insertChart(). The \"A22\" string and the 20x11 mm dimensions specify the position and size of the chart, and the last argument (\"Column\") is the desired chart template (see Table 1). The result is the column chart shown in Figure 6. Chart2.insertChart() is: // in the Chart2 class // globals private static final String CHART_NAME = \"chart$$_\" ; public static XChartDocument insertChart ( XSpreadsheet sheet , CellRangeAddress cellsRange , String cellName , int width , int height , String diagramName ) { String chartName = CHART_NAME + ( int )( Math . random () * 10000 ); // generate a random name addTableChart ( sheet , chartName , cellsRange , cellName , width , height ); // get newly created (empty) chart XChartDocument chartDoc = getChartDoc ( sheet , chartName ); // assign chart template to the chart's diagram System . out . println ( \"Using chart template: \" + diagramName ); XDiagram diagram = chartDoc . getFirstDiagram (); XChartTypeTemplate ctTemplate = setTemplate ( chartDoc , diagram , diagramName ); if ( ctTemplate == null ) return null ; boolean hasCats = hasCategories ( diagramName ); // initialize data source XDataProvider dp = chartDoc . getDataProvider (); PropertyValue [] aProps = Props . makeProps ( new String [] { \"CellRangeRepresentation\" , \"DataRowSource\" , \"FirstCellAsLabel\" , \"HasCategories\" }, new Object [] { Calc . getRangeStr ( cellsRange , sheet ), ChartDataRowSource . COLUMNS , true , hasCats }); XDataSource ds = dp . createDataSource ( aProps ); // add data source to chart template PropertyValue [] args = Props . makeProps ( \"HasCategories\" , hasCats ); ctTemplate . changeDiagramData ( diagram , ds , args ); // apply style settings to chart doc setBackgroundColors ( chartDoc , Calc . PALE_BLUE , Calc . LIGHT_BLUE ); // background and wall colors if ( hasCats ) // charts using x-axis categories setDataPointLabels ( chartDoc , Chart2 . DP_NUMBER ); // show y-axis values printChartTypes ( chartDoc ); return chartDoc ; } // end of insertChart() insertChart() creates a new chart document by calling addTableChart() and getChartDoc(), and then proceeds to link the chart template, diagram, and data source.","title":"2.3.  Initializing the Chart Document"},{"location":"28-Chart2_API_Overview.html#get-the-diagram","text":"The chart diagram is the easiest to obtain, since it's directly accessible via the XChartDocument reference: // part of Chart2.insertChart()... XDiagram diagram = chartDoc . getFirstDiagram ();","title":"Get the Diagram"},{"location":"28-Chart2_API_Overview.html#creating-a-template","text":"Creating a chart template is a few more steps. requiring the creation of a XChartTypeManager interface inside Chart2.setTemplate(): // in the Chart2 class public static XChartTypeTemplate setTemplate ( XChartDocument chartDoc , XDiagram diagram , String diagramName ) // set diagram to use the specified chart template { try { XChartTypeManager ctMan = chartDoc . getChartTypeManager (); XMultiServiceFactory msf = Lo . qi ( XMultiServiceFactory . class , ctMan ); String templateNm = \"com.sun.star.chart2.template.\" + diagramName ; XChartTypeTemplate ctTemplate = Lo . qi ( XChartTypeTemplate . class , msf . createInstance ( templateNm )); if ( ctTemplate == null ) { System . out . println ( \"Could not create chart template \\\"\" + diagramName + \"\\\"; using a column chart\" ); ctTemplate = Lo . qi ( XChartTypeTemplate . class , msf . createInstance ( \"com.sun.star.chart2.template.Column\" )); } ctTemplate . changeDiagram ( diagram ); return ctTemplate ; } catch ( Exception ex ) { System . out . println ( \"Could not set chart to \" + diagramName ); return null ; } } // end of setTemplate() The diagramName value is one of the template names shown in Table 1 (e.g. \"Column\"). The string \"com.sun.star.chart2.template.\" is added to the front to create a fully qualified service name, which is then instantiated. If the instance creation fails, then the function falls back to creating an instance of the \"Column\" template. setTemplate() ends by calling XChartTypeTemplate.changeDiagram() which links the template to the chart's diagram.","title":"Creating a Template"},{"location":"28-Chart2_API_Overview.html#get-the-data-source","text":"Back in Chart2.insertChart(), the right-most branch of Figure 8 involves the creation of an XDataProvider instance: // part of Chart2.insertChart()... XDataProvider dp = chartDoc . getDataProvider (); This data provider converts the chart's data range into an XDataSource: // part of Chart2.insertChart()... boolean hasCats = hasCategories ( diagramName ); PropertyValue [] aProps = Props . makeProps ( new String [] { \"CellRangeRepresentation\" , \"DataRowSource\" , \"FirstCellAsLabel\" , \"HasCategories\" }, new Object [] { Calc . getRangeStr ( cellsRange , sheet ), ChartDataRowSource . COLUMNS , true , hasCats }); XDataSource ds = dp . createDataSource ( aProps ); The properties passed to XDataProvider.createDataSource() specify more details about the format of the data in Figure 5 \u2013 the data for each graph is organized into columns with the first cell being the label for the graph. The \"HasCategories\" property is set to true when the first column of the data is to be used as x-axis categories. These properties passed to createDataSource() are described in the documentation for the TabularDataProviderArguments service, which you can access using lodoc TabularDataProviderArguments . The hasCats boolean is set by examining the diagram name: if it's an XY scatter chart or bubble chart then the first column of data will not be used as x-axis categories, so the boolean is set to false: // in the Chart2 class public static boolean hasCategories ( String diagramName ) { String name = diagramName . toLowerCase (); if ( name . contains ( \"scatter\" ) || name . contains ( \"bubble\" )) return false ; return true ; } // end of hasCategories()","title":"Get the Data Source"},{"location":"28-Chart2_API_Overview.html#linking-the-template-diagram-and-data-source","text":"Now the data source can populate the diagram using the specified chart template format: // part of Chart2.insertChart()... PropertyValue [] args = Props . makeProps ( \"HasCategories\" , hasCats ); ctTemplate . changeDiagramData ( diagram , ds , args ); At this point the chart will be drawn in the Calc application window, and Chart2.insertChart() could return. Instead my code modifies the appearance of the chart in two ways: // part of Chart2.insertChart()... // apply some style settings to chart doc setBackgroundColors ( chartDoc , Calc . PALE_BLUE , Calc . LIGHT_BLUE ); // color the background and wall colors if ( hasCats ) // charts using x-axis categories setDataPointLabels ( chartDoc , Chart2 . DP_NUMBER ); // show y-axis values on the data points Chart2.setBackgroundColors() changes the background and wall colors of the chart (see Figure 6). Chart2.setDataPointLabels() switches on the displaying of the y-axis data points as numbers which appear just above the top of each column in a column chart. I'll describe how these methods work in the next section. The call to Chart2.printChartTypes() at the end of Chart2.insertChart() could be commented out since it's a diagnostic check. It prints the names of the chart types used by the template.","title":"Linking the template, diagram, and data source"},{"location":"28-Chart2_API_Overview.html#3-accessing-and-modifying-chart-elements","text":"Almost every aspect of a chart can be adjusted, including such things as its color scheme, the fonts, the scaling of the axes, the positioning of the legend, axis labels, and titles. It's also possible to augment charts with regression line details, error bars, and additional graphs. These elements are located in a number of different places in the hierarchy of services accessible through the ChartDocument service. A simplified version of this hierarchy is shown in Figure 9. Figure 9. The Hierarchy of Services Below ChartDocument. I'll supply more information about the Diagram, CoordinateSystem, ChartType, and DataSeries services as this section progresses, but Figure 9 indicates that Diagram manages the legend, floor and chart wall, CoordinateSystem is in charge of the axes, and the data points are manipulated via DataSeries. The \"1\" and \"*\" in the figure indicate that a diagram may utilize multiple coordinate systems, that a single coordinate system may display multiple chart types, and a single chart type can employ many data series. Fortunately, this generality isn't often needed for the charts created by Chart2.insertChart(). In particular, the chart diagram only uses a single coordinate system and a single chart type (most of the time).","title":"3.  Accessing and Modifying Chart Elements"},{"location":"28-Chart2_API_Overview.html#31-accessing-the-diagram","text":"A chart's Diagram service is easily reached by calling ChartDocument.getFirstDiagram(), which returns a reference to the diagram's XDiagram interface: XDiagram diagram = chartDoc . getFirstDiagram (); XDiagram contains several useful methods (e.g. getLegend(), getWall(), getFloor()), and its services hold many properties (e.g. \"StartingAngle\" used in pie charts and \"RotationVertical\" for 3D charts). This is summarized by Figure 10. Figure 10. The Diagram Service. The easiest way to access the documentation for Diagram and XDiagram is via loDoc: > loDoc chart2 diagram > loDoc xdiagram Chart2.setBackgroundColors() changes the background and wall colors of the chart through the ChartDocument and Diagram services: // in the Chart2 class public static void setBackgroundColors ( XChartDocument chartDoc , int bgColor , int wallColor ) { if ( bgColor > 0 ) { XPropertySet bgProps = chartDoc . getPageBackground (); // Props.showProps(\"Background\", bgProps); Props . setProperty ( bgProps , \"FillBackground\" , true ); Props . setProperty ( bgProps , \"FillStyle\" , FillStyle . SOLID ); Props . setProperty ( bgProps , \"FillColor\" , bgColor ); } if ( wallColor > 0 ) { XDiagram diagram = chartDoc . getFirstDiagram (); XPropertySet wallProps = diagram . getWall (); // Props.showProps(\"Wall\", wallProps); Props . setProperty ( wallProps , \"FillBackground\" , true ); Props . setProperty ( wallProps , \"FillStyle\" , FillStyle . SOLID ); Props . setProperty ( wallProps , \"FillColor\" , wallColor ); } } // end of setBackgroundColors() The chart background is manipulated with a property set accessible through XChartDocument.getPageBackground(), while the wall is reached with XDiagram.getWall(). The documentation for the getPageBackground() and getWall() methods doesn't list the contents of their property sets, so the easiest way of finding out what's available is by calling Props.showProps(). Two showProps() calls are commented out in the code above. Most chart services inherit a mix of four property classes: com.sun.star.style.CharacterProperties com.sun.star.style.ParagraphProperties com.sun.star.drawing.LineProperties com.sun.star.drawing.FillProperties Since getWall() and getPageBackground() both deal with areas in the chart, their properties come from the FillProperties class.","title":"3.1.  Accessing the Diagram"},{"location":"28-Chart2_API_Overview.html#32-accessing-the-coordinate-system","text":"Figure 10 shows that the diagram's coordinate systems are reached through XCoordinateSystemContainer.getCoordinateSystems(). Chart2.getCoordSystem() assumes that the programmer only wants the first coordinate system: // in the Chart2 class public static XCoordinateSystem getCoordSystem ( XChartDocument chartDoc ) { XDiagram diagram = chartDoc . getFirstDiagram (); XCoordinateSystemContainer coordSysCon = Lo . qi ( XCoordinateSystemContainer . class , diagram ); XCoordinateSystem [] coordSys = coordSysCon . getCoordinateSystems (); if ( coordSys . length > 1 ) System . out . println ( \"No of coord systems: \" + coordSys . length + \"; using first\" ); return coordSys [ 0 ] ; // return first } // end of getCoordSystem() The CoordinateSystem service is employed to access the chart's axes and its chart type (or types), as in Figure 11. Figure 11. The CoordinateSystem Service. I'll describe the Axis service when I look at methods for adjusting axis properties. It contains a lot of properties, which are documented online. The easiest way to access the page is with loDoc chart2 axis service . The extra lodoc arguments help to narrow the search since the word \"axis\" is used in multiple places in the chart2 and chart modules.","title":"3.2.  Accessing the Coordinate System"},{"location":"28-Chart2_API_Overview.html#33-accessing-the-chart-type","text":"Figure 11 shows that the chart types in a coordinate system are reached through XChartTypeContainer.getChartTypes(). Chart2.getChartType() assumes the programmer only wants the first chart type in the array: // in the Chart2 class public static XChartType getChartType ( XChartDocument chartDoc ) { XChartType [] chartTypes = getChartTypes ( chartDoc ); return chartTypes [ 0 ] ; // get first } public static XChartType [] getChartTypes ( XChartDocument chartDoc ) { XCoordinateSystem coordSys = getCoordSystem ( chartDoc ); XChartTypeContainer ctCon = Lo . qi ( XChartTypeContainer . class , coordSys ); return ctCon . getChartTypes (); } // end of getChartTypes() Figure 12 shows the main components of the ChartType service. Figure 12. The ChartType Service. Somewhat surprisingly, the ChartType service isn't the home for chart type related properties; instead XChartType contains methods for examining chart type \"roles\", which I'll describe later. One useful features of XChartType is getChartType() which returns the type as a string. The CandleStickChartType service inherits ChartType, and contains properties related to stock charts. Use loDoc chart2 charttype to view the online documentation for ChartType.","title":"3.3.  Accessing the Chart Type"},{"location":"28-Chart2_API_Overview.html#34-accessing-the-data-series","text":"Figure 12 shows that the data series for a chart type is accessed via XDataSeriesContainer.getDataSeries(). This is implemented by Chart2.getDataSeries(): // in the Chart2 class public static XDataSeries [] getDataSeries ( XChartDocument chartDoc ) { XChartType xChartType = getChartType ( chartDoc ); XDataSeriesContainer dsCon = Lo . qi ( XDataSeriesContainer . class , xChartType ); return dsCon . getDataSeries (); } //end of getDataSeries() The DataSeries service is one of the more complex parts of the Chart2 module because of its support for several important interfaces. I won't explain all of them just yet; Figure 13 focuses on the XDataSeries interface. Figure 13. The DataSeries Service and XDataSeries Interface. A DataSeries represents a series of data points in the chart. Changes to the look of these data points (e.g. adding numbers next to the points, or changing their shape and color) can be done in two ways. A data series as a whole maintains a set of properties, most of which are inherited from the DataPointProperties class. Typical DataPointProperies values are \"Color\", \"Shape\", \"LineWidth\". The online documentation can be accessed by calling lodoc DataPointProperties . It's also possible to adjust point properties on an individual basis by accessing a particular data point by calling XDataSeries.getDataPointByIndex(). As the method name suggests, this requires an index value for the point, which can be a little tricky to determine. I can now explain the second of the two chart changing methods called at the end of Chart2.insertChart(): Chart2.setDataPointLabels(), which switches on the displaying of the y-axis data points as numbers. The call is: // part of Chart2.insertChart()... setDataPointLabels ( chartDoc , Chart2 . DP_NUMBER ); Chart2.setDataPointLabels() uses Chart2.getDataSeries() described above, which returns an array of all the data series used in the chart. setDataPointLabels() iterates through the array and manipulates the \"Label\" property for each series. In other words, it modifies each data series property without accessing each point. The code for Chart2.setDataPointLabels(): // in the Chart2 class // data point label types public static final int DP_NUMBER = 0 ; public static final int DP_PERCENT = 1 ; public static final int DP_CATEGORY = 2 ; public static final int DP_SYMBOL = 3 ; public static final int DP_NONE = 4 ; public static void setDataPointLabels ( XChartDocument chartDoc , int labelType ) // change label type for all data series { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); for ( XDataSeries dataSeries : dataSeriesArr ) { // visit every data series DataPointLabel dpLabel = ( DataPointLabel ) Props . getProperty ( dataSeries , \"Label\" ); dpLabel . ShowNumber = false ; // reset show types dpLabel . ShowCategoryName = false ; dpLabel . ShowLegendSymbol = false ; if ( labelType == DP_NUMBER ) dpLabel . ShowNumber = true ; else if ( labelType == DP_PERCENT ) { dpLabel . ShowNumber = true ; dpLabel . ShowNumberInPercent = true ; } else if ( labelType == DP_CATEGORY ) dpLabel . ShowCategoryName = true ; else if ( labelType == DP_SYMBOL ) dpLabel . ShowLegendSymbol = true ; else if ( labelType == DP_NONE ) {} // do nothing else System . out . println ( \"Unrecognized label type\" ); Props . setProperty ( dataSeries , \"Label\" , dataPointLabel ); } } // end of setDataPointLabels() The \"Label\" DataSeries property is inherited from DataPointProperties (see lodoc DataPointProperties ). \"Label\" is of type DataPointLabel which maintains four 'show' booleans for displaying the number and other kinds of information next to the data point. Depending on the labelType value passed to Chart2.setDataPointLabels(), one or more of these booleans are set and the \"Label\" property updated.","title":"3.4.  Accessing the Data Series"},{"location":"29-Column_Charts.html","text":"Chapter 29. Column Charts \u00b6 Topics Creating a Chart Title; Creating Axis Titles; Rotating Axis Titles; What Chart Templates are Available?; Multiple Columns; 3D Pizazz; The Column and Line Chart Example folders: \"Chart2 Tests\" and \"Utils\" All the chart examples in the next four chapters come from the same program, Chart2Views.java, which loads a spreadsheet from \"chartsData.ods\". Depending on the function, a different table in the sheet is used to create a chart from a template. The main() function is: // in Chart2Views.java private static final String CHARTS_DATA = \"chartsData.ods\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + CHARTS_DATA ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- XChartDocument chartDoc = colChart ( doc , sheet ); // see sections 1-3 // String[] templateNames = Chart2.getChartTemplates(chartDoc); // section 4 // Lo.printNames(templateNames, 1); // multColChart(doc, sheet); // sections 5 & 6 // colLineChart(doc, sheet); // section 7 // barChart(doc, sheet); // pieChart(doc, sheet); // pie3DChart(doc, sheet); // donutChart(doc, sheet); // areaChart(doc, sheet); // lineChart(doc, sheet); // linesChart(doc, sheet); // scatterChart(doc, sheet); // scatterLineLogChart(doc, sheet); // scatterLineErrorChart(doc, sheet); // labeledBubbleChart(doc, sheet); // netChart(doc, sheet); // happyStockChart(doc, sheet); // stockPricesChart(doc, sheet); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() colChart() utilizes the \"Sneakers Sold this Month\" table in \"chartsData.ods\" (see Figure 1) to generate the column chart in Figure 2. Figure 1. The \"Sneakers Sold this Month\" Table. Figure 2. The Column Chart for the Table in Figure 1. colChart() is: // in Chart2Views.java private static XChartDocument colChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A2:B8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"C3\" , 15 , 11 , \"Column\" ); Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A2\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B2\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); return chartDoc ; } // end of colChart() The column chart created by Chart2.insertChart() utilizes the cell range A2:B8, which spans the two columns of the table, but not the title in cell A1. The \"C3\" argument specifies where the top-left corner of the chart will be positioned in the sheet, and 15x11 are the dimensions of the image in millimeters. Calc.gotoCell() causes the application window's view of the spreadsheet to move so that cell \"A1\" is visible, which lets the user see the sneakers table and the chart together. If the three set methods and rotateYAxisTitle() are left out of colChart(), then the generated chart will have no titles as in Figure 3. Figure 3. The Column Chart for the Table in Figure 1, with no Titles. 1. Creating a Chart Title \u00b6 Chart2.setTitle() is passed a string which becomes the chart's title. For example: // part of colChart() in Chart2Views.java... Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); utilizes the string from cell \"A1\" of the spreadsheet (see Figure 1). Setting a title requires three interfaces: XTitled, XTitle, and XFormattedString. XTitled is utilized by several chart services, as shown in Figure 4. Figure 4. Services Using the XTitled Interface. The XChartDocument interface is converted into XTitled by Chart2.setTitle(), so an XTitle object can be assigned to the chart: // in the Chart2 class public static void setTitle ( XChartDocument chartDoc , String title ) /* set the title, and use Arial, 14 pt style */ { System . out . println ( \"Chart title: \\\"\" + title + \"\\\"\" ); XTitled xTitled = Lo . qi ( XTitled . class , chartDoc ); XTitle xtitle = createTitle ( title ); if ( xtitle != null ) { xTitled . setTitleObject ( xtitle ); setXTitleFont ( xtitle , \"Arial\" , 14 ); } } // end of setTitle() The XTitle object is an instance of the Title service which inherits a wide assortment of properties related to the text's paragraph, fill, and line styling, as shown in Figure 5. Figure 5. The Title Service. Text is added to the XTitle object by Chart2.createTitle(), as an XFormattedString array: // in the Chart2 class public static XTitle createTitle ( String titleString ) { XTitle xtitle = Lo . createInstanceMCF ( XTitle . class , \"com.sun.star.chart2.Title\" ); if ( xtitle == null ) { System . out . println ( \"Unable to create xtitle interface\" ); return null ; } XFormattedString xtitleStr = Lo . createInstanceMCF ( XFormattedString . class , \"com.sun.star.chart2.FormattedString\" ); if ( xtitleStr == null ) { System . out . println ( \"Unable to create formatted string\" ); return null ; } xtitleStr . setString ( titleString ); XFormattedString [] titleArray = new XFormattedString [] { xtitleStr }; xtitle . setText ( titleArray ); return xtitle ; } // end of createTitle() The use of an XFormatttedString[] array may seem to be overkill when the title is a single string, but it also allows character properties to be associated with the string through XFormattedString2, as shown in Figure 6. Figure 6. The FormattedString Service. Character properties allow the font and point size of the title to be changed to Arial 14pt by Chart2.setXTitleFont(): // in the Chart2 class public static void setXTitleFont ( XTitle xtitle , String fontName , int ptSize ) { XFormattedString [] foStrs = xtitle . getText (); if ( foStrs != null ) { Props . setProperty ( foStrs [ 0 ] , \"CharFontName\" , fontName ); Props . setProperty ( foStrs [ 0 ] , \"CharHeight\" , ptSize ); } } // end of setXTitleFont() The \"CharFontName\" and \"CharHeight\" properties come from the CharacterProperties class. 2. Creating Axis Titles \u00b6 Setting the axes titles needs a reference to the XAxis interface. Incidentally, this interface name is a little misleading since \"X\" is the naming convention for interfaces, not a reference to the x-axis. Figure 9 in Chapter 28 shows that the XAxis interface is available via the XCoordinateSystem interface, which can be obtained by calling Chart2.getCoordSystem(). XCoordinateSystem.getAxisByDimension() can then be employed to get an axis reference. This is implemented by Chart2.getAxis(): // in the Chart2 class // globals: axis values public static final int X_AXIS = 0 ; public static final int Y_AXIS = 1 ; public static final int Z_AXIS = 2 ; public static XAxis getAxis ( XChartDocument chartDoc , int axisVal , int idx ) { XCoordinateSystem coordSys = getCoordSystem ( chartDoc ); try { return coordSys . getAxisByDimension ( axisVal , idx ); } catch ( Exception ex ) { System . out . println ( \"Could not get the axis\" ); return null ; } } // end of getAxis() XCoordinateSystem.getAxisByDimension() takes two integer arguments: the first represents the axis (x-, y-, or z-), while the second is a primary or secondary index (0 or 1) for the chosen axis. Chart2.java includes wrapper functions for Chart2.getAxis() for the most common cases: // in the Chart2 class public static XAxis getXAxis ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . X_AXIS , 0 ); } public static XAxis getYAxis ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . Y_AXIS , 0 ); } public static XAxis getXAxis2 ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . X_AXIS , 1 ); } public static XAxis getYAxis2 ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . Y_AXIS , 1 ); } Chart2.setAxisTitle() calls Chart2.getAxis() to get a reference to the correct axis, and then reuses many of the methods described earlier for setting the chart title: // in the Chart2 class public static void setAxisTitle ( XChartDocument chartDoc , String title , int axisVal , int idx ) { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return ; XTitled titledAxis = Lo . qi ( XTitled . class , axis ); XTitle xtitle = createTitle ( title ); if ( xtitle != null ) { titledAxis . setTitleObject ( xtitle ); setXTitleFont ( xtitle , \"Arial\" , 12 ); // Arial 12pt } } // end of setAxisTitle() As with Chart2.getAxis(), Chart2.java includes wrapper methods for Chart2.setAxisTitle() to simplify common axis cases: // in the Chart2 class public static void setXAxisTitle ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . X_AXIS , 0 ); } public static void setYAxisTitle ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . Y_AXIS , 0 ); } public static void setXAxis2Title ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . X_AXIS , 1 ); } public static void setYAxis2Title ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . Y_AXIS , 1 ); } 3. Rotating Axis Titles \u00b6 The default orientation for titles is horizontal, which is fine for the chart and x-axis titles, but can cause the y-axis title to occupy too much horizontal space. The solution is to call Chart2.rotateYAxisTitle() with an angle (usually 90 degrees) to turn the text counter-clockwise so it's vertically orientated (see Figure 2). The implementation accesses the XTitle interface for the axis title, and then modifies its \"TextRotation\" property from the Title service (see Figure 5). // in the Chart2 class public static void rotateYAxisTitle ( XChartDocument chartDoc , int angle ) { rotateAxisTitle ( chartDoc , Chart2 . Y_AXIS , 0 , angle ); } public static void rotateAxisTitle ( XChartDocument chartDoc , int axisVal , int idx , int angle ) // + angle is rotation counter-clockwise from horizontal { XTitle xtitle = getAxisTitle ( chartDoc , axisVal , idx ); if ( xtitle != null ) Props . setProperty ( xtitle , \"TextRotation\" , angle ); } // end of rotateAxisTitle() public static XTitle getAxisTitle ( XChartDocument chartDoc , int axisVal , int idx ) { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return null ; XTitled titledAxis = Lo . qi ( XTitled . class , axis ); return titledAxis . getTitleObject (); } // end of getAxisTitle() 4. What Chart Templates are Available? \u00b6 colChart() in Chart2Views.java returns its XChartDocument reference. This isn't necessary for rendering the chart, but allows the reference to be passed to Chart2.getChartTemplates(): // in main() in Chart2Views.java... XChartDocument chartDoc = colChart ( doc , sheet ); String [] templateNames = Chart2 . getChartTemplates ( chartDoc ); Lo . printNames ( templateNames , 1 ); The only way to list the chart templates supported by the chart2 module (i.e. those shown in Table 1 of Chapter 28) is by querying an existing chart document. That's the purpose of Chart2.getChartTemplates(): // in the Chart2 class public static String [] getChartTemplates ( XChartDocument chartDoc ) { XChartTypeManager ctMan = chartDoc . getChartTypeManager (); return Info . getAvailableServices ( ctMan ); } Normally XChartTypeManager is used to create a template instance, but Info.getAvailableServices() accesses its XMultiServiceFactory.getAvailableServiceNames() method to list the names of all its supported services, which are templates: // in the Info class public static String [] getAvailableServices ( Object obj ) { XMultiServiceFactory msf = Lo . qi ( XMultiServiceFactory . class , obj ); String [] serviceNames = msf . getAvailableServiceNames (); Arrays . sort ( serviceNames ); return serviceNames ; } // end of getAvailableServices() The output lists has 66 names, starting and ending like so: \"com.sun.star.chart2.template.Area\" \"com.sun.star.chart2.template.Bar\" \"com.sun.star.chart2.template.Bubble\" \"com.sun.star.chart2.template.Column\" \"com.sun.star.chart2.template.ColumnWithLine\" : \"com.sun.star.chart2.template.ThreeDLineDeep\" \"com.sun.star.chart2.template.ThreeDPie\" \"com.sun.star.chart2.template.ThreeDPieAllExploded\" \"com.sun.star.chart2.template.ThreeDScatter\" Sixty-four of those names appear in Chapter 28's Table 1. The two missing are \"GL3DBar\" and \"GL3DBarRoundedRectangle\", which were reported as being \"not ready for general use\" in an OpenOffice forum posting from May 2014. 5. Multiple Columns \u00b6 The multColChart() method in Chart2Views.java uses a table containing three columns of data (see Figure 7) to generate two column graphs in the same chart, as in Figure 8. Figure 7. The \"States with the Most Colleges\" Table. Figure 8. A Multiple Column Chart Generated from the Table in Figure 7. multColChart() is: // in Chart2Views.java private static void multColChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E15:G21\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A22\" , 20 , 11 , \"Column\" ); // ThreeDColumnDeep, ThreeDColumnFlat Calc . gotoCell ( doc , \"A13\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E13\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E15\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F14\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . viewLegend ( chartDoc , true ); // for a 3D version // Chart2.showAxisLabel(chartDoc, Chart2.Z_AXIS, 0, false); // Chart2.setChartShape3D(chartDoc, \"cylinder\"); // box, cylinder, cone, pyramid } // end of multColChart() The same \"Column\" chart template is used as in colChart(), and the additional column of data is treated as an extra column graph. The chart title and axis titles are added in the same way as before, and a legend is included by calling Chart2.viewLegend(): // in the Chart2 class public static void viewLegend ( XChartDocument chartDoc , boolean isVisible ) { XDiagram diagram = chartDoc . getFirstDiagram (); XLegend legend = diagram . getLegend (); if ( isVisible && ( legend == null )) { XLegend leg = Lo . createInstanceMCF ( XLegend . class , \"com.sun.star.chart2.Legend\" ); Props . setProperty ( leg , \"LineStyle\" , LineStyle . NONE ); // no outline around legend Props . setProperty ( leg , \"FillStyle\" , FillStyle . SOLID ); Props . setProperty ( leg , \"FillTransparence\" , 100 ); // transparent solid background diagram . setLegend ( leg ); } Props . setProperty ( diagram . getLegend (), \"Show\" , isVisible ); // toggle visibility } // end of viewLegend() The legend is accessible via the chart diagram service. viewLegend() creates an instance, and sets a few properties to make it look nicer. Figure 9 shows the Legend service, which defines several properties, and inherits many others from FillProperties and LineProperties. The \"LineStyle\", \"FillStyle\", and \"FillTransparence\" properties utilized in viewLegend() come from the inherited property classes, but \"Show\" is from the Legend service. Figure 9. The Legend Service. The XLegend interface contains no methods, and is used only to access the properties in its defining service. 6. 3D Pizazz \u00b6 I'm not a fan of 3D charts which are often harder to understand than their 2D equivalents, even if they do look more \"hi-tech\". But if you really want a 3D version of a chart, it's mostly just a matter of changing the template name in the call to Chart2.insertChart(). If the \"Column\" string is changed to \"ThreeDColumnDeep\" or \"ThreeDColumnFlat\" in insertChart() in multColChart(), then the charts in Figure 10 appear. Figure 10. Deep and Flat 3D Column Charts. \"deep\" orders the two 3D graphs along the z-axis, and labels the axis. The x-axis labels are rotated automatically in the top-most chart of Figure 10 because the width of the chart wasn't sufficient to draw them horizontally, and that's caused the graphs to be squashed into less vertical space. multColChart() contains two commented out lines which illustrate how a 3D graph can be changed: // part of multColChart() in Chart2Views.java... Chart2 . showAxisLabel ( chartDoc , Chart2 . Z_AXIS , 0 , false ); // hide labels Chart2 . setChartShape3D ( chartDoc , \"cylinder\" ); // shape can be: box, cylinder, cone, pyramid Chart2.showAxisLabel() is passed the boolean false to switch off the display of the z- axis labels. Chart2.setChartShape3D() changes the shape of the columns; in this case to cylinders, as in Figure 11. Figure 11. Modified Deep 3D Column Chart. Chart2.showAxisLabel() uses Chart2.getAxis() to access the XAxis interface, and then modifies its \"Show\" property: // in the Chart2 class public static void showAxisLabel ( XChartDocument chartDoc , int axisVal , int idx , boolean isVisible ) { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return ; //Props.showObjProps(\"Axis\", axis); Props . setProperty ( axis , \"Show\" , isVisible ); } // end of showAxisLabel() The Axis service contains a large assortment of properties (online documentation can be read by calling lodoc chart2 axis service ), and inherits character and line properties depicted in Figure 12. Figure 12. The Axis Service. Chart2.setChartShape3D() affects the data 'points' (which in a 3D column chart are boxes by default). This requires access to the XDataSeries array of data points by calling Chart2.getDataSeries(), and then the \"Geometry3D\" property in the DataSeries service is modified. Figure 11 in Chapter 28 shows the service and its interfaces, and most of its properties are inherited from the DataPointProperties class, including \"Geometry3D\". The code for Chart2.setChartShape3D(): // in the Chart2 class public static void setChartShape3D ( XChartDocument chartDoc , String shape ) { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); for ( XDataSeries dataSeries : dataSeriesArr ) { if ( shape . equals ( \"box\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . CUBOID ); else if ( shape . equals ( \"cylinder\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . CYLINDER ); else if ( shape . equals ( \"cone\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . CONE ); else if ( shape . equals ( \"pyramid\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . PYRAMID ); else System . out . println ( \"Did not recognize 3D shape: \" + shape ); } } // end of setChartShape3D() 7. The Column and Line Chart \u00b6 Another way to display the multiple columns of data in the \"States with the Most Colleges\" table (Figure 7) is to draw a column and line chart. The column is generated from the first data column, and the line graph uses the second column. The result is shown in Figure 13. Figure 13. A Column and Line Chart Generated from the Table in Figure 7. colLineChart() in Chart2Views.java generates Figure 13: // in Chart2Views.java private static void colLineChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E15:G21\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A22\" , 20 , 11 , \"ColumnWithLine\" ); Calc . gotoCell ( doc , \"A13\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E13\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E15\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F14\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . viewLegend ( chartDoc , true ); } // end of colLineChart() It's identical to mulColChart() except for the template string (\"ColumnWithLine\") passed to Chart2.insertChart(). A chart's coordinate system may utilize multiple chart types. Up to now a chart template (e.g. \"Column\") has been converted to a single chart type (e.g. ColumnChartType) by the chart API (specifically by the chart type manager), but the \"ColumnWithLine\" template is different. The manager implements that template using two chart types, \"ColumnChartType\" and \"LineChartType\". This is reported by Chart2.insertChart() calling Chart2.printChartTypes(): No. of chart types: 2 com.sun.star.chart2.ColumnChartType com.sun.star.chart2.LineChartType Chart2.printChartTypes() uses Chart2.getChartTypes(), which was defined earlier: // in the Chart2 class public static void printChartTypes ( XChartDocument chartDoc ) { XChartType [] chartTypes = getChartTypes ( chartDoc ); if ( chartTypes . length > 1 ) { System . out . println ( \"No. of chart types: \" + chartTypes . length ); for ( XChartType ct : chartTypes ) System . out . println ( \" \" + ct . getChartType ()); } else System . out . println ( \"Chart type: \" + chartTypes [ 0 ] . getChartType ()); } // end of printChartTypes() Why is this separation of a single template into two chart types important? The short answer is that it complicates the search for a chart template's data. For example, my earlier Chart2.getChartType() returns the first chart type in the XChartType[] array since most templates only use a single chart type: // in the Chart2 class public static XChartType getChartType ( XChartDocument chartDoc ) { XChartType [] chartTypes = getChartTypes ( chartDoc ); return chartTypes [ 0 ] ; } This method is insufficient for examining a chart created with the \"ColumnWithLine\" template since the XChartType[] array holds two chart types. A programmer will have to use findChartType(), which searches the array for the specified chart type: // in the Chart2 class public static XChartType findChartType ( XChartDocument chartDoc , String chartType ) { String srchName = \"com.sun.star.chart2.\" + chartType . toLowerCase (); XChartType [] chartTypes = getChartTypes ( chartDoc ); for ( XChartType ct : chartTypes ) { String ctName = ct . getChartType (). toLowerCase (); if ( ctName . equals ( srchName )) return ct ; } System . out . println ( \"Chart type \" + srchName + \" not found\" ); return null ; } // end of findChartType() For example, the following call returns a reference to the line chart type: XChartType lineCT = Chart2 . findChartType ( chartDoc , \"LineChartType\" ); The simple getChartType() is used in Chart2.getDataSeries(): // in the Chart2 class public static XDataSeries [] getDataSeries ( XChartDocument chartDoc ) { XChartType xChartType = getChartType ( chartDoc ); XDataSeriesContainer dsCon = Lo . qi ( XDataSeriesContainer . class , xChartType ); return dsCon . getDataSeries (); } //end of getDataSeries() This means that Chart2.getDataSeries() can only access the data associated with the column (the first chart type) in a \"ColumnWithLine\" chart document. The fix is to use a more complex version of Chart2.getDataSeries(): // in the Chart2 class public static XDataSeries [] getDataSeries ( XChartDocument chartDoc , String chartType ) // get the data series associated with the specified chart type { XChartType xChartType = findChartType ( chartDoc , chartType ); if ( xChartType == null ) return null ; XDataSeriesContainer dsCon = Lo . qi ( XDataSeriesContainer . class , xChartType ); return dsCon . getDataSeries (); } //end of getDataSeries() This version requires a chart type string argument to get the correct chart type. For example, the call: XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc , \"LineChartType\" ); returns the data series associated with the line chart type.","title":"Chapter 29. Column Charts"},{"location":"29-Column_Charts.html#chapter-29-column-charts","text":"Topics Creating a Chart Title; Creating Axis Titles; Rotating Axis Titles; What Chart Templates are Available?; Multiple Columns; 3D Pizazz; The Column and Line Chart Example folders: \"Chart2 Tests\" and \"Utils\" All the chart examples in the next four chapters come from the same program, Chart2Views.java, which loads a spreadsheet from \"chartsData.ods\". Depending on the function, a different table in the sheet is used to create a chart from a template. The main() function is: // in Chart2Views.java private static final String CHARTS_DATA = \"chartsData.ods\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + CHARTS_DATA ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- XChartDocument chartDoc = colChart ( doc , sheet ); // see sections 1-3 // String[] templateNames = Chart2.getChartTemplates(chartDoc); // section 4 // Lo.printNames(templateNames, 1); // multColChart(doc, sheet); // sections 5 & 6 // colLineChart(doc, sheet); // section 7 // barChart(doc, sheet); // pieChart(doc, sheet); // pie3DChart(doc, sheet); // donutChart(doc, sheet); // areaChart(doc, sheet); // lineChart(doc, sheet); // linesChart(doc, sheet); // scatterChart(doc, sheet); // scatterLineLogChart(doc, sheet); // scatterLineErrorChart(doc, sheet); // labeledBubbleChart(doc, sheet); // netChart(doc, sheet); // happyStockChart(doc, sheet); // stockPricesChart(doc, sheet); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() colChart() utilizes the \"Sneakers Sold this Month\" table in \"chartsData.ods\" (see Figure 1) to generate the column chart in Figure 2. Figure 1. The \"Sneakers Sold this Month\" Table. Figure 2. The Column Chart for the Table in Figure 1. colChart() is: // in Chart2Views.java private static XChartDocument colChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A2:B8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"C3\" , 15 , 11 , \"Column\" ); Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A2\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B2\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); return chartDoc ; } // end of colChart() The column chart created by Chart2.insertChart() utilizes the cell range A2:B8, which spans the two columns of the table, but not the title in cell A1. The \"C3\" argument specifies where the top-left corner of the chart will be positioned in the sheet, and 15x11 are the dimensions of the image in millimeters. Calc.gotoCell() causes the application window's view of the spreadsheet to move so that cell \"A1\" is visible, which lets the user see the sneakers table and the chart together. If the three set methods and rotateYAxisTitle() are left out of colChart(), then the generated chart will have no titles as in Figure 3. Figure 3. The Column Chart for the Table in Figure 1, with no Titles.","title":"Chapter 29. Column Charts"},{"location":"29-Column_Charts.html#1-creating-a-chart-title","text":"Chart2.setTitle() is passed a string which becomes the chart's title. For example: // part of colChart() in Chart2Views.java... Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); utilizes the string from cell \"A1\" of the spreadsheet (see Figure 1). Setting a title requires three interfaces: XTitled, XTitle, and XFormattedString. XTitled is utilized by several chart services, as shown in Figure 4. Figure 4. Services Using the XTitled Interface. The XChartDocument interface is converted into XTitled by Chart2.setTitle(), so an XTitle object can be assigned to the chart: // in the Chart2 class public static void setTitle ( XChartDocument chartDoc , String title ) /* set the title, and use Arial, 14 pt style */ { System . out . println ( \"Chart title: \\\"\" + title + \"\\\"\" ); XTitled xTitled = Lo . qi ( XTitled . class , chartDoc ); XTitle xtitle = createTitle ( title ); if ( xtitle != null ) { xTitled . setTitleObject ( xtitle ); setXTitleFont ( xtitle , \"Arial\" , 14 ); } } // end of setTitle() The XTitle object is an instance of the Title service which inherits a wide assortment of properties related to the text's paragraph, fill, and line styling, as shown in Figure 5. Figure 5. The Title Service. Text is added to the XTitle object by Chart2.createTitle(), as an XFormattedString array: // in the Chart2 class public static XTitle createTitle ( String titleString ) { XTitle xtitle = Lo . createInstanceMCF ( XTitle . class , \"com.sun.star.chart2.Title\" ); if ( xtitle == null ) { System . out . println ( \"Unable to create xtitle interface\" ); return null ; } XFormattedString xtitleStr = Lo . createInstanceMCF ( XFormattedString . class , \"com.sun.star.chart2.FormattedString\" ); if ( xtitleStr == null ) { System . out . println ( \"Unable to create formatted string\" ); return null ; } xtitleStr . setString ( titleString ); XFormattedString [] titleArray = new XFormattedString [] { xtitleStr }; xtitle . setText ( titleArray ); return xtitle ; } // end of createTitle() The use of an XFormatttedString[] array may seem to be overkill when the title is a single string, but it also allows character properties to be associated with the string through XFormattedString2, as shown in Figure 6. Figure 6. The FormattedString Service. Character properties allow the font and point size of the title to be changed to Arial 14pt by Chart2.setXTitleFont(): // in the Chart2 class public static void setXTitleFont ( XTitle xtitle , String fontName , int ptSize ) { XFormattedString [] foStrs = xtitle . getText (); if ( foStrs != null ) { Props . setProperty ( foStrs [ 0 ] , \"CharFontName\" , fontName ); Props . setProperty ( foStrs [ 0 ] , \"CharHeight\" , ptSize ); } } // end of setXTitleFont() The \"CharFontName\" and \"CharHeight\" properties come from the CharacterProperties class.","title":"1.  Creating a Chart Title"},{"location":"29-Column_Charts.html#2-creating-axis-titles","text":"Setting the axes titles needs a reference to the XAxis interface. Incidentally, this interface name is a little misleading since \"X\" is the naming convention for interfaces, not a reference to the x-axis. Figure 9 in Chapter 28 shows that the XAxis interface is available via the XCoordinateSystem interface, which can be obtained by calling Chart2.getCoordSystem(). XCoordinateSystem.getAxisByDimension() can then be employed to get an axis reference. This is implemented by Chart2.getAxis(): // in the Chart2 class // globals: axis values public static final int X_AXIS = 0 ; public static final int Y_AXIS = 1 ; public static final int Z_AXIS = 2 ; public static XAxis getAxis ( XChartDocument chartDoc , int axisVal , int idx ) { XCoordinateSystem coordSys = getCoordSystem ( chartDoc ); try { return coordSys . getAxisByDimension ( axisVal , idx ); } catch ( Exception ex ) { System . out . println ( \"Could not get the axis\" ); return null ; } } // end of getAxis() XCoordinateSystem.getAxisByDimension() takes two integer arguments: the first represents the axis (x-, y-, or z-), while the second is a primary or secondary index (0 or 1) for the chosen axis. Chart2.java includes wrapper functions for Chart2.getAxis() for the most common cases: // in the Chart2 class public static XAxis getXAxis ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . X_AXIS , 0 ); } public static XAxis getYAxis ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . Y_AXIS , 0 ); } public static XAxis getXAxis2 ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . X_AXIS , 1 ); } public static XAxis getYAxis2 ( XChartDocument chartDoc ) { return getAxis ( chartDoc , Chart2 . Y_AXIS , 1 ); } Chart2.setAxisTitle() calls Chart2.getAxis() to get a reference to the correct axis, and then reuses many of the methods described earlier for setting the chart title: // in the Chart2 class public static void setAxisTitle ( XChartDocument chartDoc , String title , int axisVal , int idx ) { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return ; XTitled titledAxis = Lo . qi ( XTitled . class , axis ); XTitle xtitle = createTitle ( title ); if ( xtitle != null ) { titledAxis . setTitleObject ( xtitle ); setXTitleFont ( xtitle , \"Arial\" , 12 ); // Arial 12pt } } // end of setAxisTitle() As with Chart2.getAxis(), Chart2.java includes wrapper methods for Chart2.setAxisTitle() to simplify common axis cases: // in the Chart2 class public static void setXAxisTitle ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . X_AXIS , 0 ); } public static void setYAxisTitle ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . Y_AXIS , 0 ); } public static void setXAxis2Title ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . X_AXIS , 1 ); } public static void setYAxis2Title ( XChartDocument chartDoc , String title ) { setAxisTitle ( chartDoc , title , Chart2 . Y_AXIS , 1 ); }","title":"2.  Creating Axis Titles"},{"location":"29-Column_Charts.html#3-rotating-axis-titles","text":"The default orientation for titles is horizontal, which is fine for the chart and x-axis titles, but can cause the y-axis title to occupy too much horizontal space. The solution is to call Chart2.rotateYAxisTitle() with an angle (usually 90 degrees) to turn the text counter-clockwise so it's vertically orientated (see Figure 2). The implementation accesses the XTitle interface for the axis title, and then modifies its \"TextRotation\" property from the Title service (see Figure 5). // in the Chart2 class public static void rotateYAxisTitle ( XChartDocument chartDoc , int angle ) { rotateAxisTitle ( chartDoc , Chart2 . Y_AXIS , 0 , angle ); } public static void rotateAxisTitle ( XChartDocument chartDoc , int axisVal , int idx , int angle ) // + angle is rotation counter-clockwise from horizontal { XTitle xtitle = getAxisTitle ( chartDoc , axisVal , idx ); if ( xtitle != null ) Props . setProperty ( xtitle , \"TextRotation\" , angle ); } // end of rotateAxisTitle() public static XTitle getAxisTitle ( XChartDocument chartDoc , int axisVal , int idx ) { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return null ; XTitled titledAxis = Lo . qi ( XTitled . class , axis ); return titledAxis . getTitleObject (); } // end of getAxisTitle()","title":"3.  Rotating Axis Titles"},{"location":"29-Column_Charts.html#4-what-chart-templates-are-available","text":"colChart() in Chart2Views.java returns its XChartDocument reference. This isn't necessary for rendering the chart, but allows the reference to be passed to Chart2.getChartTemplates(): // in main() in Chart2Views.java... XChartDocument chartDoc = colChart ( doc , sheet ); String [] templateNames = Chart2 . getChartTemplates ( chartDoc ); Lo . printNames ( templateNames , 1 ); The only way to list the chart templates supported by the chart2 module (i.e. those shown in Table 1 of Chapter 28) is by querying an existing chart document. That's the purpose of Chart2.getChartTemplates(): // in the Chart2 class public static String [] getChartTemplates ( XChartDocument chartDoc ) { XChartTypeManager ctMan = chartDoc . getChartTypeManager (); return Info . getAvailableServices ( ctMan ); } Normally XChartTypeManager is used to create a template instance, but Info.getAvailableServices() accesses its XMultiServiceFactory.getAvailableServiceNames() method to list the names of all its supported services, which are templates: // in the Info class public static String [] getAvailableServices ( Object obj ) { XMultiServiceFactory msf = Lo . qi ( XMultiServiceFactory . class , obj ); String [] serviceNames = msf . getAvailableServiceNames (); Arrays . sort ( serviceNames ); return serviceNames ; } // end of getAvailableServices() The output lists has 66 names, starting and ending like so: \"com.sun.star.chart2.template.Area\" \"com.sun.star.chart2.template.Bar\" \"com.sun.star.chart2.template.Bubble\" \"com.sun.star.chart2.template.Column\" \"com.sun.star.chart2.template.ColumnWithLine\" : \"com.sun.star.chart2.template.ThreeDLineDeep\" \"com.sun.star.chart2.template.ThreeDPie\" \"com.sun.star.chart2.template.ThreeDPieAllExploded\" \"com.sun.star.chart2.template.ThreeDScatter\" Sixty-four of those names appear in Chapter 28's Table 1. The two missing are \"GL3DBar\" and \"GL3DBarRoundedRectangle\", which were reported as being \"not ready for general use\" in an OpenOffice forum posting from May 2014.","title":"4.  What Chart Templates are Available?"},{"location":"29-Column_Charts.html#5-multiple-columns","text":"The multColChart() method in Chart2Views.java uses a table containing three columns of data (see Figure 7) to generate two column graphs in the same chart, as in Figure 8. Figure 7. The \"States with the Most Colleges\" Table. Figure 8. A Multiple Column Chart Generated from the Table in Figure 7. multColChart() is: // in Chart2Views.java private static void multColChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E15:G21\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A22\" , 20 , 11 , \"Column\" ); // ThreeDColumnDeep, ThreeDColumnFlat Calc . gotoCell ( doc , \"A13\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E13\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E15\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F14\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . viewLegend ( chartDoc , true ); // for a 3D version // Chart2.showAxisLabel(chartDoc, Chart2.Z_AXIS, 0, false); // Chart2.setChartShape3D(chartDoc, \"cylinder\"); // box, cylinder, cone, pyramid } // end of multColChart() The same \"Column\" chart template is used as in colChart(), and the additional column of data is treated as an extra column graph. The chart title and axis titles are added in the same way as before, and a legend is included by calling Chart2.viewLegend(): // in the Chart2 class public static void viewLegend ( XChartDocument chartDoc , boolean isVisible ) { XDiagram diagram = chartDoc . getFirstDiagram (); XLegend legend = diagram . getLegend (); if ( isVisible && ( legend == null )) { XLegend leg = Lo . createInstanceMCF ( XLegend . class , \"com.sun.star.chart2.Legend\" ); Props . setProperty ( leg , \"LineStyle\" , LineStyle . NONE ); // no outline around legend Props . setProperty ( leg , \"FillStyle\" , FillStyle . SOLID ); Props . setProperty ( leg , \"FillTransparence\" , 100 ); // transparent solid background diagram . setLegend ( leg ); } Props . setProperty ( diagram . getLegend (), \"Show\" , isVisible ); // toggle visibility } // end of viewLegend() The legend is accessible via the chart diagram service. viewLegend() creates an instance, and sets a few properties to make it look nicer. Figure 9 shows the Legend service, which defines several properties, and inherits many others from FillProperties and LineProperties. The \"LineStyle\", \"FillStyle\", and \"FillTransparence\" properties utilized in viewLegend() come from the inherited property classes, but \"Show\" is from the Legend service. Figure 9. The Legend Service. The XLegend interface contains no methods, and is used only to access the properties in its defining service.","title":"5.  Multiple Columns"},{"location":"29-Column_Charts.html#6-3d-pizazz","text":"I'm not a fan of 3D charts which are often harder to understand than their 2D equivalents, even if they do look more \"hi-tech\". But if you really want a 3D version of a chart, it's mostly just a matter of changing the template name in the call to Chart2.insertChart(). If the \"Column\" string is changed to \"ThreeDColumnDeep\" or \"ThreeDColumnFlat\" in insertChart() in multColChart(), then the charts in Figure 10 appear. Figure 10. Deep and Flat 3D Column Charts. \"deep\" orders the two 3D graphs along the z-axis, and labels the axis. The x-axis labels are rotated automatically in the top-most chart of Figure 10 because the width of the chart wasn't sufficient to draw them horizontally, and that's caused the graphs to be squashed into less vertical space. multColChart() contains two commented out lines which illustrate how a 3D graph can be changed: // part of multColChart() in Chart2Views.java... Chart2 . showAxisLabel ( chartDoc , Chart2 . Z_AXIS , 0 , false ); // hide labels Chart2 . setChartShape3D ( chartDoc , \"cylinder\" ); // shape can be: box, cylinder, cone, pyramid Chart2.showAxisLabel() is passed the boolean false to switch off the display of the z- axis labels. Chart2.setChartShape3D() changes the shape of the columns; in this case to cylinders, as in Figure 11. Figure 11. Modified Deep 3D Column Chart. Chart2.showAxisLabel() uses Chart2.getAxis() to access the XAxis interface, and then modifies its \"Show\" property: // in the Chart2 class public static void showAxisLabel ( XChartDocument chartDoc , int axisVal , int idx , boolean isVisible ) { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return ; //Props.showObjProps(\"Axis\", axis); Props . setProperty ( axis , \"Show\" , isVisible ); } // end of showAxisLabel() The Axis service contains a large assortment of properties (online documentation can be read by calling lodoc chart2 axis service ), and inherits character and line properties depicted in Figure 12. Figure 12. The Axis Service. Chart2.setChartShape3D() affects the data 'points' (which in a 3D column chart are boxes by default). This requires access to the XDataSeries array of data points by calling Chart2.getDataSeries(), and then the \"Geometry3D\" property in the DataSeries service is modified. Figure 11 in Chapter 28 shows the service and its interfaces, and most of its properties are inherited from the DataPointProperties class, including \"Geometry3D\". The code for Chart2.setChartShape3D(): // in the Chart2 class public static void setChartShape3D ( XChartDocument chartDoc , String shape ) { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); for ( XDataSeries dataSeries : dataSeriesArr ) { if ( shape . equals ( \"box\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . CUBOID ); else if ( shape . equals ( \"cylinder\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . CYLINDER ); else if ( shape . equals ( \"cone\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . CONE ); else if ( shape . equals ( \"pyramid\" )) Props . setProperty ( dataSeries , \"Geometry3D\" , DataPointGeometry3D . PYRAMID ); else System . out . println ( \"Did not recognize 3D shape: \" + shape ); } } // end of setChartShape3D()","title":"6.  3D Pizazz"},{"location":"29-Column_Charts.html#7-the-column-and-line-chart","text":"Another way to display the multiple columns of data in the \"States with the Most Colleges\" table (Figure 7) is to draw a column and line chart. The column is generated from the first data column, and the line graph uses the second column. The result is shown in Figure 13. Figure 13. A Column and Line Chart Generated from the Table in Figure 7. colLineChart() in Chart2Views.java generates Figure 13: // in Chart2Views.java private static void colLineChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E15:G21\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A22\" , 20 , 11 , \"ColumnWithLine\" ); Calc . gotoCell ( doc , \"A13\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E13\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E15\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F14\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . viewLegend ( chartDoc , true ); } // end of colLineChart() It's identical to mulColChart() except for the template string (\"ColumnWithLine\") passed to Chart2.insertChart(). A chart's coordinate system may utilize multiple chart types. Up to now a chart template (e.g. \"Column\") has been converted to a single chart type (e.g. ColumnChartType) by the chart API (specifically by the chart type manager), but the \"ColumnWithLine\" template is different. The manager implements that template using two chart types, \"ColumnChartType\" and \"LineChartType\". This is reported by Chart2.insertChart() calling Chart2.printChartTypes(): No. of chart types: 2 com.sun.star.chart2.ColumnChartType com.sun.star.chart2.LineChartType Chart2.printChartTypes() uses Chart2.getChartTypes(), which was defined earlier: // in the Chart2 class public static void printChartTypes ( XChartDocument chartDoc ) { XChartType [] chartTypes = getChartTypes ( chartDoc ); if ( chartTypes . length > 1 ) { System . out . println ( \"No. of chart types: \" + chartTypes . length ); for ( XChartType ct : chartTypes ) System . out . println ( \" \" + ct . getChartType ()); } else System . out . println ( \"Chart type: \" + chartTypes [ 0 ] . getChartType ()); } // end of printChartTypes() Why is this separation of a single template into two chart types important? The short answer is that it complicates the search for a chart template's data. For example, my earlier Chart2.getChartType() returns the first chart type in the XChartType[] array since most templates only use a single chart type: // in the Chart2 class public static XChartType getChartType ( XChartDocument chartDoc ) { XChartType [] chartTypes = getChartTypes ( chartDoc ); return chartTypes [ 0 ] ; } This method is insufficient for examining a chart created with the \"ColumnWithLine\" template since the XChartType[] array holds two chart types. A programmer will have to use findChartType(), which searches the array for the specified chart type: // in the Chart2 class public static XChartType findChartType ( XChartDocument chartDoc , String chartType ) { String srchName = \"com.sun.star.chart2.\" + chartType . toLowerCase (); XChartType [] chartTypes = getChartTypes ( chartDoc ); for ( XChartType ct : chartTypes ) { String ctName = ct . getChartType (). toLowerCase (); if ( ctName . equals ( srchName )) return ct ; } System . out . println ( \"Chart type \" + srchName + \" not found\" ); return null ; } // end of findChartType() For example, the following call returns a reference to the line chart type: XChartType lineCT = Chart2 . findChartType ( chartDoc , \"LineChartType\" ); The simple getChartType() is used in Chart2.getDataSeries(): // in the Chart2 class public static XDataSeries [] getDataSeries ( XChartDocument chartDoc ) { XChartType xChartType = getChartType ( chartDoc ); XDataSeriesContainer dsCon = Lo . qi ( XDataSeriesContainer . class , xChartType ); return dsCon . getDataSeries (); } //end of getDataSeries() This means that Chart2.getDataSeries() can only access the data associated with the column (the first chart type) in a \"ColumnWithLine\" chart document. The fix is to use a more complex version of Chart2.getDataSeries(): // in the Chart2 class public static XDataSeries [] getDataSeries ( XChartDocument chartDoc , String chartType ) // get the data series associated with the specified chart type { XChartType xChartType = findChartType ( chartDoc , chartType ); if ( xChartType == null ) return null ; XDataSeriesContainer dsCon = Lo . qi ( XDataSeriesContainer . class , xChartType ); return dsCon . getDataSeries (); } //end of getDataSeries() This version requires a chart type string argument to get the correct chart type. For example, the call: XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc , \"LineChartType\" ); returns the data series associated with the line chart type.","title":"7.  The Column and Line Chart"},{"location":"30-Bar_Pie_Area_Line_Charts.html","text":"Chapter 30. Bar, Pie, Area, Line Charts \u00b6 Topics The Bar Chart; The Pie Chart; 3D Pie; Donuts; The Area Chart; The Line Chart: multiple lines Example folders: \"Chart2 Tests\" and \"Utils\" This chapter continues using the Chart2Views.java example from the previous chapter, but looks at how bar, pie (including 3D and donut versions), area, and line charts can be generated from spreadsheet data. The relevant lines of Chart2Views.java are: // part of Chart2Views.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- barChart ( doc , sheet ); // see section 1 // pieChart(doc, sheet); // section 2 // pie3DChart(doc, sheet); // section 2.1 // donutChart(doc, sheet); // section 2.3 // areaChart(doc, sheet); // section 3 // lineChart(doc, sheet); // linesChart(doc, sheet); // section 4 : // more chart examples Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() 1. The Bar Chart \u00b6 A bar chart is generated by barChart() in Chart2Views.java using the \"Sneakers Sold this Month\" Table from Figure 1. Figure 1. The \"Sneakers Sold this Month\" Table. The resulting chart is shown in Figure 2. Figure 2. The Bar Chart for the Table in Figure 1. It's informative to compare the bar chart in Figure 2 with the column chart for the same data in Figure 2 of Chapter 29. The data bars and axes have been swapped, so the x-axis in the column chart is the y-axis in the bar chart, and vice versa. barChart() is: // in Chart2Views.java private static void barChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A2:B8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"B3\" , 15 , 11 , \"Bar\" ); Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A2\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B2\" )); Chart2 . rotateXAxisTitle ( chartDoc , 90 ); // rotate vertical x-axis } // end of barChart() Although the axes have been swapped in the chart drawing, the API still uses the same indices to refer to the axes in XCoordinateSystem.getAxisByDimension(). This means that \"x-axis\" is the vertical axis in a bar chart, and \"y-axis\" the horizontal. This is most apparent in the last line of barChart(): Chart2 . rotateXAxisTitle ( chartDoc , 90 ); This causes the \"x-axis\" title to rotate 90 degrees counter-clockwise, which affects the \"Brand\" string on the vertical axis of the chart (see Figure 2). 2. The Pie Chart \u00b6 pieChart() in Chart2Views.java utilizes the \"Top 5 States with the Most Elementary and Secondary Schools\" table in \"chartsData.ods\" (see Figure 3) to generate the pie chart in Figure 4. Figure 3. The \"Top 5 States\" Table. Figure 4. A Pie Chart for the Table in Figure 3. pieChart() is: // in Chart2Views.java private static void pieChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E2:F8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"B10\" , 12 , 11 , \"Pie\" ); // Pie, PieAllExploded Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E1\" )); Chart2 . setSubtitle ( chartDoc , Calc . getString ( sheet , \"F2\" )); Chart2 . viewLegend ( chartDoc , true ); } // end of pieChart() Chart2.setSubtitle() displays the secondary heading in the chart; there's little difference between it and the earlier setTitle(): // in the Chart2 class public static void setSubtitle ( XChartDocument chartDoc , String subtitle ) { XDiagram diagram = chartDoc . getFirstDiagram (); XTitled xTitled = Lo . qi ( XTitled . class , diagram ); XTitle xtitle = createTitle ( subtitle ); if ( xtitle != null ) { xTitled . setTitleObject ( xtitle ); setXTitleFont ( xtitle , \"Arial\" , 12 ); } } // end of setSubtitle() The XTitled reference for the subtitle is obtained from XDiagram, whereas the chart title is part of XChartDocument. 2.1. More 3D Pizzazz \u00b6 For some reason people like 3D pie charts, so pie3DChart() in Chart2Views.java produces one (see Figure 5) using the same table as the 2D version. Figure 5. A 3D Pie Chart for the Table in Figure 3. pie3DChart() is the same as pieChart() except that the \"ThreeDPie\" template is used: // in Chart2Views.java private static void pie3DChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E2:F8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"B10\" , 12 , 11 , \"ThreeDPie\" ); // ThreeDPie, ThreeDPieAllExploded Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E1\" )); Chart2 . setSubtitle ( chartDoc , Calc . getString ( sheet , \"F2\" )); Chart2 . viewLegend ( chartDoc , true ); : // more code explained in a moment } // end of pie3DChart() The drawback of 3D pie charts is the shape distortion caused by the perspective. For example, the red segment in the foreground of Figure 5 seems bigger than the dark blue segment at the back but that segment is numerical larger. The default rotation of a 3D pie is -60 degrees around the horizontal so its bottom edge appears to extend out of the page, and 0 degrees rotation around the vertical. These can be changed by modifying the \"RotationHorizontal\" and \"RotationVertical\" properties of the Diagram service. For example: // part of pie3DChart() in Chart2Views.java... XDiagram diagram = chartDoc . getFirstDiagram (); Props . setProperty ( diagram , \"RotationHorizontal\" , 0 ); // no horizontal rotation Props . setProperty ( diagram , \"RotationVertical\" , - 45 ); // -ve rotates left edge out of page This changes the pie chart's appearance to be as in Figure 6. Figure 6. A Rotated 3D Pie Chart for the Table in Figure 3. The easiest way to see the current values for the diagram's properties is to add a call to Props.showObjProps() to the code above: Props . showObjProps ( \"Diagram\" , diagram ); 2.2. Changing the Data Point Labels \u00b6 Two problems with Figures 5 and 6 are the small data point labels and their default font color (black) which doesn't stand out against the darker pie segments. These issues can be fixed by changing some of the font related properties for the data points. This means a return to the DataSeries service shown in Figure 7. Figure 7. The DataSeries Service and XDataSeries Interface. The DataPointProperties class appears twice in Figure 7 because it allows the data point properties to be changed in two ways. The DataPointProperties class associated with the DataSeries service allows a property change to be applied to all the points collectively. The DataPointProperties class associated with a particular point allows a property to be changed only in that point. For example, the former approach is used to change all the data point labels in the pie chart to 14 pt, bold, and white: // end of pie3DChart() in Chart2Views.java... : // change all the data points to be bold white 14pt XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc ); Props . setProperty ( ds [ 0 ] , \"CharHeight\" , 14.0 ); Props . setProperty ( ds [ 0 ] , \"CharColor\" , Calc . WHITE ); Props . setProperty ( ds [ 0 ] , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); The changes to the chart are shown in Figure 8. Figure 8. A 3D Pie Chart with Changed Data Point Labels. The second approach is employed to emphasize the \"National Average\" data point label, which is the last one in the series: // end of pie3DChart() in Chart2Views.java... : // change only the last data point to be bold white 14pt XPropertySet props = Chart2 . getDataPointProps ( chartDoc , 0 , 5 ); if ( props != null ) { Props . setProperty ( props , \"CharHeight\" , 14.0 ); Props . setProperty ( props , \"CharColor\" , Calc . WHITE ); Props . setProperty ( props , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); } This produces the chart shown in Figure 9, where only the National Average label is changed. Figure 9. A 3D Pie Chart with One Changed Data Point Label. Chart2.getDataPointProps() takes three arguments \u2013 the chart document, the index of the data series, and the index of the data point inside that series. The pie chart uses six data points, so a valid index will be between 0 and 5. If a matching data point is found by Chart2.getDataPointProps() then a reference to its properties is returned, allowing that point to be modified: // in the Chart2 class public static XPropertySet getDataPointProps ( XChartDocument chartDoc , int seriesIdx , int idx ) { XPropertySet [] propsArr = getDataPointsProps ( chartDoc , seriesIdx ); if ( propsArr == null ) return null ; if (( idx < 0 ) || ( idx >= propsArr . length )) { System . out . println ( \"No data at index \" + idx + \"; use 0 to \" + ( propsArr . length - 1 )); return null ; } return propsArr [ idx ] ; } // end getDataPointProps() A two-argument version of Chart2.getDataPointProps() returns the properties for all the data points in a series: // in the Chart2 class public static XPropertySet [] getDataPointsProps ( XChartDocument chartDoc , int seriesIdx ) // get all the properties for the data in the specified series { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); if (( seriesIdx < 0 ) || ( seriesIdx >= dataSeriesArr . length )) { System . out . println ( \"Series index is out of range\" ); return null ; } ArrayList < XPropertySet > propsList = new ArrayList < XPropertySet > (); int idx = 0 ; XPropertySet props = null ; do { try { props = dataSeriesArr [ seriesIdx ] . getDataPointByIndex ( idx ++ ); if ( props != null ) propsList . add ( props ); } catch ( com . sun . star . lang . IndexOutOfBoundsException e ) { break ; } } while ( props != null ); if ( propsList . size () == 0 ) { System . out . println ( \"No Series at index \" + seriesIdx ); return null ; } XPropertySet [] propsArr = new XPropertySet [ propsList . size () ] ; for ( int i = 0 ; i < propsList . size (); i ++ ) propsArr [ i ] = propsList . get ( i ); return propsArr ; } // end getDataPointsProps() Chart2.getDataSeries() is called to get the data series for the chart type as an array. This array is iterated over, collecting the property sets for each data point by calling XDataSeries.getDataPointByIndex(). 2.3. Anyone for Donuts? \u00b6 If a table has more than one column of data then a \"Donut\" chart can be used to show each column as a ring. donutChart() in Chart2Views.java utilizes the \"Annual Expenditure on Institutions\" table in \"chartsData.ods\" (see Figure 10) to generate the donut chart with two rings in Figure 11. Figure 10. The \"Annual Expenditure on Institutions\" Table. Figure 11. A Donut Chart for the Table in Figure 10. donutChart() is: // in Chart2Views.java private static void donutChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A44:C50\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"D43\" , 15 , 11 , \"Donut\" ); // Donut, DonutAllExploded, ThreeDDonut Calc . gotoCell ( doc , \"A48\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A43\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setSubtitle ( chartDoc , \"Outer: \" + Calc . getString ( sheet , \"B44\" ) + \"\\n\" + \"Inner: \" + Calc . getString ( sheet , \"C44\" )); } // end of donutChart() The only thing of note is the use of a more complex string for Chart2.setSubtitle() to display information about both rings. 3. The Area Chart \u00b6 areaChart() in Chart2Views.java utilizes the \"Trends in Enrollment in Public Schools in the US\" table in \"chartsData.ods\" (see Figure 12) to generate the area chart in Figure 13. Figure 12. The \"Annual Expenditure on Institutions\" Table. Figure 13. An Area Chart for the Table in Figure 12. areaChart() is: // in Chart2Views.java private static void areaChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E45:G50\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A52\" , 16 , 11 , \"Area\" ); // Area, StackedArea, PercentStackedArea Calc . gotoCell ( doc , \"A43\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E43\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E45\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F44\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); } // end of areaChart() If the \"Area\" template is replaced by \"StackedArea\" or \"PercentStackedArea\" then the two charts in Figure 14 are generated. Figure 14. Stacked and Percentage Stacked Area Charts for the Table in Figure 12. 4. The Line Chart \u00b6 linesChart() in Chart2Views.java utilizes the \"Trends in Expenditure Per Pupil\" table in \"chartsData.ods\" (see Figure 15) to generate two lines marked with symbols in Figure 16. Figure 15. The \"Trends in Expenditure Per Pupil\" Table. Figure 16. Line Charts for the Table in Figure 15. linesChart() is: // in Chart2Views.java private static void linesChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E27:G39\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A40\" , 22 , 11 , \"LineSymbol\" ); // Line, LineSymbol, StackedLineSymbol Calc . gotoCell ( doc , \"A26\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E26\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E27\" )); Chart2 . setYAxisTitle ( chartDoc , \"Expenditure per Pupil\" ); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // too crowded for data points } // end of linesChart() Chart2.setDataPointLabels() switches off the displaying of the numerical data above the symbols so the chart is less cluttered. There are many different line chart templates, as listed in Table 1 of Chapter 28. The \"Line\" template differs from \"LineSymbol\" by not including symbols over the data points.","title":"Chapter 30. Bar, Pie, Area, Line Charts"},{"location":"30-Bar_Pie_Area_Line_Charts.html#chapter-30-bar-pie-area-line-charts","text":"Topics The Bar Chart; The Pie Chart; 3D Pie; Donuts; The Area Chart; The Line Chart: multiple lines Example folders: \"Chart2 Tests\" and \"Utils\" This chapter continues using the Chart2Views.java example from the previous chapter, but looks at how bar, pie (including 3D and donut versions), area, and line charts can be generated from spreadsheet data. The relevant lines of Chart2Views.java are: // part of Chart2Views.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- barChart ( doc , sheet ); // see section 1 // pieChart(doc, sheet); // section 2 // pie3DChart(doc, sheet); // section 2.1 // donutChart(doc, sheet); // section 2.3 // areaChart(doc, sheet); // section 3 // lineChart(doc, sheet); // linesChart(doc, sheet); // section 4 : // more chart examples Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main()","title":"Chapter 30. Bar, Pie, Area, Line Charts"},{"location":"30-Bar_Pie_Area_Line_Charts.html#1-the-bar-chart","text":"A bar chart is generated by barChart() in Chart2Views.java using the \"Sneakers Sold this Month\" Table from Figure 1. Figure 1. The \"Sneakers Sold this Month\" Table. The resulting chart is shown in Figure 2. Figure 2. The Bar Chart for the Table in Figure 1. It's informative to compare the bar chart in Figure 2 with the column chart for the same data in Figure 2 of Chapter 29. The data bars and axes have been swapped, so the x-axis in the column chart is the y-axis in the bar chart, and vice versa. barChart() is: // in Chart2Views.java private static void barChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A2:B8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"B3\" , 15 , 11 , \"Bar\" ); Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A2\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B2\" )); Chart2 . rotateXAxisTitle ( chartDoc , 90 ); // rotate vertical x-axis } // end of barChart() Although the axes have been swapped in the chart drawing, the API still uses the same indices to refer to the axes in XCoordinateSystem.getAxisByDimension(). This means that \"x-axis\" is the vertical axis in a bar chart, and \"y-axis\" the horizontal. This is most apparent in the last line of barChart(): Chart2 . rotateXAxisTitle ( chartDoc , 90 ); This causes the \"x-axis\" title to rotate 90 degrees counter-clockwise, which affects the \"Brand\" string on the vertical axis of the chart (see Figure 2).","title":"1.  The Bar Chart"},{"location":"30-Bar_Pie_Area_Line_Charts.html#2-the-pie-chart","text":"pieChart() in Chart2Views.java utilizes the \"Top 5 States with the Most Elementary and Secondary Schools\" table in \"chartsData.ods\" (see Figure 3) to generate the pie chart in Figure 4. Figure 3. The \"Top 5 States\" Table. Figure 4. A Pie Chart for the Table in Figure 3. pieChart() is: // in Chart2Views.java private static void pieChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E2:F8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"B10\" , 12 , 11 , \"Pie\" ); // Pie, PieAllExploded Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E1\" )); Chart2 . setSubtitle ( chartDoc , Calc . getString ( sheet , \"F2\" )); Chart2 . viewLegend ( chartDoc , true ); } // end of pieChart() Chart2.setSubtitle() displays the secondary heading in the chart; there's little difference between it and the earlier setTitle(): // in the Chart2 class public static void setSubtitle ( XChartDocument chartDoc , String subtitle ) { XDiagram diagram = chartDoc . getFirstDiagram (); XTitled xTitled = Lo . qi ( XTitled . class , diagram ); XTitle xtitle = createTitle ( subtitle ); if ( xtitle != null ) { xTitled . setTitleObject ( xtitle ); setXTitleFont ( xtitle , \"Arial\" , 12 ); } } // end of setSubtitle() The XTitled reference for the subtitle is obtained from XDiagram, whereas the chart title is part of XChartDocument.","title":"2.  The Pie Chart"},{"location":"30-Bar_Pie_Area_Line_Charts.html#21-more-3d-pizzazz","text":"For some reason people like 3D pie charts, so pie3DChart() in Chart2Views.java produces one (see Figure 5) using the same table as the 2D version. Figure 5. A 3D Pie Chart for the Table in Figure 3. pie3DChart() is the same as pieChart() except that the \"ThreeDPie\" template is used: // in Chart2Views.java private static void pie3DChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E2:F8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"B10\" , 12 , 11 , \"ThreeDPie\" ); // ThreeDPie, ThreeDPieAllExploded Calc . gotoCell ( doc , \"A1\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E1\" )); Chart2 . setSubtitle ( chartDoc , Calc . getString ( sheet , \"F2\" )); Chart2 . viewLegend ( chartDoc , true ); : // more code explained in a moment } // end of pie3DChart() The drawback of 3D pie charts is the shape distortion caused by the perspective. For example, the red segment in the foreground of Figure 5 seems bigger than the dark blue segment at the back but that segment is numerical larger. The default rotation of a 3D pie is -60 degrees around the horizontal so its bottom edge appears to extend out of the page, and 0 degrees rotation around the vertical. These can be changed by modifying the \"RotationHorizontal\" and \"RotationVertical\" properties of the Diagram service. For example: // part of pie3DChart() in Chart2Views.java... XDiagram diagram = chartDoc . getFirstDiagram (); Props . setProperty ( diagram , \"RotationHorizontal\" , 0 ); // no horizontal rotation Props . setProperty ( diagram , \"RotationVertical\" , - 45 ); // -ve rotates left edge out of page This changes the pie chart's appearance to be as in Figure 6. Figure 6. A Rotated 3D Pie Chart for the Table in Figure 3. The easiest way to see the current values for the diagram's properties is to add a call to Props.showObjProps() to the code above: Props . showObjProps ( \"Diagram\" , diagram );","title":"2.1.  More 3D Pizzazz"},{"location":"30-Bar_Pie_Area_Line_Charts.html#22-changing-the-data-point-labels","text":"Two problems with Figures 5 and 6 are the small data point labels and their default font color (black) which doesn't stand out against the darker pie segments. These issues can be fixed by changing some of the font related properties for the data points. This means a return to the DataSeries service shown in Figure 7. Figure 7. The DataSeries Service and XDataSeries Interface. The DataPointProperties class appears twice in Figure 7 because it allows the data point properties to be changed in two ways. The DataPointProperties class associated with the DataSeries service allows a property change to be applied to all the points collectively. The DataPointProperties class associated with a particular point allows a property to be changed only in that point. For example, the former approach is used to change all the data point labels in the pie chart to 14 pt, bold, and white: // end of pie3DChart() in Chart2Views.java... : // change all the data points to be bold white 14pt XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc ); Props . setProperty ( ds [ 0 ] , \"CharHeight\" , 14.0 ); Props . setProperty ( ds [ 0 ] , \"CharColor\" , Calc . WHITE ); Props . setProperty ( ds [ 0 ] , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); The changes to the chart are shown in Figure 8. Figure 8. A 3D Pie Chart with Changed Data Point Labels. The second approach is employed to emphasize the \"National Average\" data point label, which is the last one in the series: // end of pie3DChart() in Chart2Views.java... : // change only the last data point to be bold white 14pt XPropertySet props = Chart2 . getDataPointProps ( chartDoc , 0 , 5 ); if ( props != null ) { Props . setProperty ( props , \"CharHeight\" , 14.0 ); Props . setProperty ( props , \"CharColor\" , Calc . WHITE ); Props . setProperty ( props , \"CharWeight\" , com . sun . star . awt . FontWeight . BOLD ); } This produces the chart shown in Figure 9, where only the National Average label is changed. Figure 9. A 3D Pie Chart with One Changed Data Point Label. Chart2.getDataPointProps() takes three arguments \u2013 the chart document, the index of the data series, and the index of the data point inside that series. The pie chart uses six data points, so a valid index will be between 0 and 5. If a matching data point is found by Chart2.getDataPointProps() then a reference to its properties is returned, allowing that point to be modified: // in the Chart2 class public static XPropertySet getDataPointProps ( XChartDocument chartDoc , int seriesIdx , int idx ) { XPropertySet [] propsArr = getDataPointsProps ( chartDoc , seriesIdx ); if ( propsArr == null ) return null ; if (( idx < 0 ) || ( idx >= propsArr . length )) { System . out . println ( \"No data at index \" + idx + \"; use 0 to \" + ( propsArr . length - 1 )); return null ; } return propsArr [ idx ] ; } // end getDataPointProps() A two-argument version of Chart2.getDataPointProps() returns the properties for all the data points in a series: // in the Chart2 class public static XPropertySet [] getDataPointsProps ( XChartDocument chartDoc , int seriesIdx ) // get all the properties for the data in the specified series { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); if (( seriesIdx < 0 ) || ( seriesIdx >= dataSeriesArr . length )) { System . out . println ( \"Series index is out of range\" ); return null ; } ArrayList < XPropertySet > propsList = new ArrayList < XPropertySet > (); int idx = 0 ; XPropertySet props = null ; do { try { props = dataSeriesArr [ seriesIdx ] . getDataPointByIndex ( idx ++ ); if ( props != null ) propsList . add ( props ); } catch ( com . sun . star . lang . IndexOutOfBoundsException e ) { break ; } } while ( props != null ); if ( propsList . size () == 0 ) { System . out . println ( \"No Series at index \" + seriesIdx ); return null ; } XPropertySet [] propsArr = new XPropertySet [ propsList . size () ] ; for ( int i = 0 ; i < propsList . size (); i ++ ) propsArr [ i ] = propsList . get ( i ); return propsArr ; } // end getDataPointsProps() Chart2.getDataSeries() is called to get the data series for the chart type as an array. This array is iterated over, collecting the property sets for each data point by calling XDataSeries.getDataPointByIndex().","title":"2.2.  Changing the Data Point Labels"},{"location":"30-Bar_Pie_Area_Line_Charts.html#23-anyone-for-donuts","text":"If a table has more than one column of data then a \"Donut\" chart can be used to show each column as a ring. donutChart() in Chart2Views.java utilizes the \"Annual Expenditure on Institutions\" table in \"chartsData.ods\" (see Figure 10) to generate the donut chart with two rings in Figure 11. Figure 10. The \"Annual Expenditure on Institutions\" Table. Figure 11. A Donut Chart for the Table in Figure 10. donutChart() is: // in Chart2Views.java private static void donutChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A44:C50\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"D43\" , 15 , 11 , \"Donut\" ); // Donut, DonutAllExploded, ThreeDDonut Calc . gotoCell ( doc , \"A48\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A43\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setSubtitle ( chartDoc , \"Outer: \" + Calc . getString ( sheet , \"B44\" ) + \"\\n\" + \"Inner: \" + Calc . getString ( sheet , \"C44\" )); } // end of donutChart() The only thing of note is the use of a more complex string for Chart2.setSubtitle() to display information about both rings.","title":"2.3.  Anyone for Donuts?"},{"location":"30-Bar_Pie_Area_Line_Charts.html#3-the-area-chart","text":"areaChart() in Chart2Views.java utilizes the \"Trends in Enrollment in Public Schools in the US\" table in \"chartsData.ods\" (see Figure 12) to generate the area chart in Figure 13. Figure 12. The \"Annual Expenditure on Institutions\" Table. Figure 13. An Area Chart for the Table in Figure 12. areaChart() is: // in Chart2Views.java private static void areaChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E45:G50\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A52\" , 16 , 11 , \"Area\" ); // Area, StackedArea, PercentStackedArea Calc . gotoCell ( doc , \"A43\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E43\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E45\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F44\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); } // end of areaChart() If the \"Area\" template is replaced by \"StackedArea\" or \"PercentStackedArea\" then the two charts in Figure 14 are generated. Figure 14. Stacked and Percentage Stacked Area Charts for the Table in Figure 12.","title":"3.  The Area Chart"},{"location":"30-Bar_Pie_Area_Line_Charts.html#4-the-line-chart","text":"linesChart() in Chart2Views.java utilizes the \"Trends in Expenditure Per Pupil\" table in \"chartsData.ods\" (see Figure 15) to generate two lines marked with symbols in Figure 16. Figure 15. The \"Trends in Expenditure Per Pupil\" Table. Figure 16. Line Charts for the Table in Figure 15. linesChart() is: // in Chart2Views.java private static void linesChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E27:G39\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A40\" , 22 , 11 , \"LineSymbol\" ); // Line, LineSymbol, StackedLineSymbol Calc . gotoCell ( doc , \"A26\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E26\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E27\" )); Chart2 . setYAxisTitle ( chartDoc , \"Expenditure per Pupil\" ); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // too crowded for data points } // end of linesChart() Chart2.setDataPointLabels() switches off the displaying of the numerical data above the symbols so the chart is less cluttered. There are many different line chart templates, as listed in Table 1 of Chapter 28. The \"Line\" template differs from \"LineSymbol\" by not including symbols over the data points.","title":"4.  The Line Chart"},{"location":"31-XY_Scatter_Charts.html","text":"Chapter 31. XY (Scatter) Charts \u00b6 Topics A Scatter Chart (with Regressions); Calculating Regressions; Drawing a Regression Curve; Changing Axis Scales; Adding Error Bars Example folders: \"Chart2 Tests\" and \"Utils\" This chapter continues using the Chart2Views.java example from previous chapters, but looks at how various kinds of scatter charts can be generated from spreadsheet data. A scatter chart is a good way to display (x, y) coordinate data since the x-axis values are treated as numbers not categories. In addition, regression functions can be calculated and displayed, the axis scales can be changed, and error bars added. The relevant lines of Chart2Views.java are: // part of Chart2Views.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- scatterChart ( doc , sheet ); // see sections 1-3 // scatterLineLogChart(doc, sheet); // section 4 // scatterLineErrorChart(doc, sheet); // section 5 : // more chart examples Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() 1. A Scatter Chart (with Regressions) \u00b6 scatterChart() in Chart2Views.java utilizes the \"Ice Cream Sales vs. Temperature\" table in \"chartsData.ods\" (see Figure 1) to generate the scatter chart in Figure 2. Figure 1. The \"Ice Cream Sales vs. Temperature\" Table. Figure 2. Scatter Chart for the Table in Figure 1. Note that the x-axis in Figure 1 is numerical, showing values ranging between 10.0 and 26.0. This range is calculated automatically by the template. scatterChart() is: // in Chart2Views.java private static void scatterChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A110:B122\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"C109\" , 16 , 11 , \"ScatterSymbol\" ); // ScatterSymbol, ScatterLine, ScatterLineSymbol Calc . gotoCell ( doc , \"A104\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A109\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A110\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B110\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // reduce clutter // Chart2.calcRegressions(chartDoc); // Chart2.drawRegressionCurve(chartDoc, Chart2.LINEAR); } // end of scatterChart() If the Chart2.calcRegressions() line is uncommented then several different regression functions are calculated using the chart's data. Their equations and R 2 values are printed as shown below: Linear regression curve: Curve equation: f(x) = 30.09x - 159.5 R^2 value: 0.917 Logarithmic regression curve: Curve equation: f(x) = 544.1 ln(x) - 1178 R^2 value: 0.921 Exponential regression curve: Curve equation: f(x) = 81.62 exp( 0.0826 x ) R^2 value: 0.865 Power regression curve: Curve equation: f(x) = 4.545 x^1.525 R^2 value: 0.906 Polynomial regression curve: Curve equation: f(x) = - 0.5384x^2 + 50.24x - 340.1 R^2 value: 0.921 Moving average regression curve: Curve equation: Moving average trend line with period = %PERIOD R^2 value: NaN A logarithmic or quadratic polynomial are the best matches, but linear is a close third. The \"moving average\" R 2 result is NaN (Not-a-Number) since no average of period 2 matches the data. If the Chart2.drawRegressionCurve() call is uncommented, the chart drawing will include a linear regression line and its equation and R 2 value (see Figure 3). Figure 3. Scatter Chart with Linear Regression Line for the Table in Figure 1. The regression function is f(x) = 30.09x - 159.47, and the C value is 0.92 (to 2 dp). If the constant is changed to Chart2.LOGARITHMIC in the call to Chart2.drawRegressionCurve() then the generated function is f(x) = 544.1 ln(x) \u2013 1178 with an R 2 value of 0.92. Other regression curves are represented by the Chart2 constants EXPONENTIAL, POWER, POLYNOMIAL, and MOVING_AVERAGE. 2. Calculating Regressions \u00b6 Chart2.calcRegressions() is: // in the Chart2 class // globals private static final int [] CURVE_KINDS = { LINEAR , LOGARITHMIC , EXPONENTIAL , POWER , POLYNOMIAL , MOVING_AVERAGE }; private static final String [] CURVE_NAMES = { \"Linear\" , \"Logarithmic\" , \"Exponential\" , \"Power\" , \"Polynomial\" , \"Moving average\" }; public static void calcRegressions ( XChartDocument chartDoc ) { for ( int i = 0 ; i < CURVE_KINDS . length ; i ++ ) { XRegressionCurve curve = createCurve ( CURVE_KINDS [ i ] ); System . out . println ( CURVE_NAMES [ i ] + \" regression curve:\" ); evalCurve ( chartDoc , curve ); System . out . println (); } } // end of calcRegressions() createCurve() matches the regression constants defined in CURVE_KINDS[] to regression services offered by the API: // in the Chart2 class public static XRegressionCurve createCurve ( int curveKind ) { if ( curveKind == LINEAR ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.LinearRegressionCurve\" ); else if ( curveKind == LOGARITHMIC ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.LogarithmicRegressionCurve\" ); else if ( curveKind == EXPONENTIAL ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.ExponentialRegressionCurve\" ); else if ( curveKind == POWER ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.PotentialRegressionCurve\" ); else if ( curveKind == POLYNOMIAL ) // assume degree == 2 return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.PolynomialRegressionCurve\" ); else if ( curveKind == MOVING_AVERAGE ) // assume period == 2 return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.MovingAverageRegressionCurve\" ); else { System . out . println ( \"Did not recognize regression line kind: \" + curveKind + \"; using linear\" ); return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.LinearRegressionCurve\" ); } } // end of createCurve() There are seven regression curve services in the chart2 module, all of which support the XRegressionCurve interface, as shown in Figure 4. Figure 4. The Regression Curve Services The RegressionCurve service shown in Figure 4 is not a superclass for the other services. Also note that the regression curve service for power functions is called \"PotentialRegressionCurve\". Chart2.evalCurve() uses XRegressionCurve.getCalculator() to access the XRegressionCurveCalculator interface. It sets up the data and parameters for a particular curve, and prints the results of curve fitting: // in the Chart2 class public static void evalCurve ( XChartDocument chartDoc , XRegressionCurve curve ) { XRegressionCurveCalculator curveCalc = curve . getCalculator (); int degree = 1 ; if ( getCurveType ( curve ) != LINEAR ) degree = 2 ; // assumes POLYNOMIAL curve has degree == 2 curveCalc . setRegressionProperties ( degree , false , 0 , 2 ); // args: degree, forceIntercept, interceptValue, period XDataSource dataSource = getDataSource ( chartDoc ); // printLabeledSeqs(dataSource); double [] xVals = getChartData ( dataSource , 0 ); double [] yVals = getChartData ( dataSource , 1 ); curveCalc . recalculateRegression ( xVals , yVals ); System . out . println ( \" Curve equation: \" + curveCalc . getRepresentation ()); double cc = curveCalc . getCorrelationCoefficient (); System . out . printf ( \" R^2 value: %.3f\\n\" , ( cc * cc )); // 3 dp } // end of evalCurve() The calculation is configured by calling XRegressionCurveCalculator.setRegressionProperties(), and carried out by XRegressionCurveCalculator.recalculateRegression(). The degree argument of setRegressionProperties() specifies the polynomial curve's degree, which I've hardwired to be quadratic (i.e. a degree of 2). The period argument is used when a moving average curve is being fitted. recalculateRegression() requires two arrays of x- and y- axis values for the scatter points. These are obtained from the chart's data source by calling Chart2.getDataSource() which returns the XDataSource interface for the DataSeries service. Figure 5 shows the XDataSource, XRegressionCurveContainer, and XDataSink interfaces of the DataSeries service. Figure 5. More Detailed DataSeries Service. In previous chapters, I've only used the XDataSeries interface, which offers access to the data points in the chart. The XDataSource interface, which is read-only, gives access to the underlying data that was used to create the points. The data is stored as an array of XLabeledDataSequence objects; each object contains a label and a sequence of data. Chart2.getDataSource() is defined as: // in the Chart2 class public static XDataSource getDataSource ( XChartDocument chartDoc ) { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); return Lo . qi ( XDataSource . class , dataSeriesArr [ 0 ] ); // get first } This method assumes that the programmer wants the first data source in the data series. This is adequate for most charts which only use one data source. Chart2.printLabeledSeqs() is a diagnostic function for printing all the labeled data sequences stored in an XDataSource: // in the Chart2 class public static void printLabeledSeqs ( XDataSource dataSource ) { XLabeledDataSequence [] dataSeqs = dataSource . getDataSequences (); System . out . println ( \"No. of sequences in data source: \" + dataSeqs . length ); for ( int i = 0 ; i < dataSeqs . length ; i ++ ) { Object [] labelSeq = dataSeqs [ i ] . getLabel (). getData (); System . out . print ( labelSeq [ 0 ] + \" :\" ); Object [] valsSeq = dataSeqs [ i ] . getValues (). getData (); for ( Object val : valsSeq ) System . out . print ( \" \" + val ); System . out . println (); String srRep = dataSeqs [ i ] . getValues (). getSourceRangeRepresentation (); System . out . println ( \" Source range: \" + srRep ); } } // end of printLabeledSeqs() When these function is applied to the data source for the scatter chart, the following is printed: No. of sequences in data source: 2 Temperature \u00b0C : 14.2 16.4 11.9 15.2 18.5 22.1 19.4 25.1 23.4 18.1 22.6 17.2 Source range: $examples.$A$111:$A$122 Ice Cream Sales : 215.0 325.0 185.0 332.0 406.0 522.0 412.0 614.0 544.0 421.0 445.0 408.0 Source range: $examples.$B$111:$B$122 This output shows that the data source consists of two XLabeledDataSequence objects, representing the x- and y- values in the data source (see Figure 1). These objects' data are extracted as arrays by calls to Chart2.getChartData(): // in the Chart2 class // part of evalCurve() : XDataSource dataSource = getDataSource ( chartDoc ); printLabeledSeqs ( dataSource ); double [] xVals = getChartData ( dataSource , 0 ); double [] yVals = getChartData ( dataSource , 1 ); curveCalc . recalculateRegression ( xVals , yVals ); When recalculateRegression() has finished, various results about the fitted curve can be extracted from the XRegressionCurveCalculator variable, curveCalc. evalCurve() prints the function string (using getRepresentation()) and the R 2 value (using getCorrelationCoefficient()). 3. Drawing a Regression Curve \u00b6 One of the surprising things about drawing a regression curve is that there's no need to explicitly calculate the curve's function with XRegressionCurveCalculator. Instead Chart2.drawRegressionCurve() only has to initialize the curve via the data series' XRegressionCurveContainer interface (see Figure 5). drawRegressionCurve() is: // in the Chart2 class public static void drawRegressionCurve ( XChartDocument chartDoc , int curveKind ) { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); XRegressionCurveContainer rcCon = Lo . qi ( XRegressionCurveContainer . class , dataSeriesArr [ 0 ] ); XRegressionCurve curve = createCurve ( curveKind ); rcCon . addRegressionCurve ( curve ); // calculates the curve // show equation and R^2 value XPropertySet props = curve . getEquationProperties (); Props . setProperty ( props , \"ShowCorrelationCoefficient\" , true ); Props . setProperty ( props , \"ShowEquation\" , true ); int key = getNumberFormatKey ( chartDoc , \"0.00\" ); // 2 dp if ( key != - 1 ) Props . setProperty ( props , \"NumberFormat\" , key ); } // end of drawRegressionCurve() The XDataSeries interface for the first data series in the chart is converted to XRegressionCurveContainer, and an XRegressionCurve instance added to it. This triggers the calculation of the curve's function. The rest of drawRegressionCurve() deals with how the function information is displayed on the chart. XRegressionCurve.getEquationProperties() returns a property set which is an instance of the RegressionCurveEquation class, shown in Figure 6. Figure 6. The RegressionCurveEquation Property Class. RegressionCurveEquation inherits properties related to character, fill, and line, since it controls how the curve, function string, and R 2 value are drawn on the chart. These last two are made visible by setting the \"ShowEquation\" and \"ShowCorrelationCoefficient\" properties to true, which are defined in RegressionCurveEquation. Online documentation on this class can be accessed using lodoc RegressionCurveEquation . Another useful property is \"NumberFormat\" which can be used to reduce the number of decimal places used when printing the function and R 2 value. Chart2.getNumberFormatKey() converts a number format string into a number format key, which is assigned to the \"NumberFormat\" property: // in the Chart2 class public static int getNumberFormatKey ( XChartDocument chartDoc , String nfStr ) { XNumberFormatsSupplier xfs = Lo . qi ( XNumberFormatsSupplier . class , chartDoc ); XNumberFormats nFormats = xfs . getNumberFormats (); int key = ( int ) nFormats . queryKey ( nfStr , new com . sun . star . lang . Locale ( \"en\" , \"us\" , \"\" ), false ); if ( key == - 1 ) System . out . println ( \"Could not access key for format: \\\"\" + nfStr + \"\\\"\" ); return key ; } // end of getNumberFormatKey() The string-to-key conversion is straight forward if you know what number format string to use, but there's little documentation on them. Probably the best approach is to use the Format \uf0e0 Cells menu item in a spreadsheet document, and examine the dialog in Figure 7. Figure 7. The Format Cells Dialog. When you select a given category and format, the number format string is shown in the \"Format Code\" field at the bottom of the dialog. Figure 7 shows that the format string for two decimal place numbers is \"0.00\". This string should be passed to getNumberFormatKey() in drawRegressionCurve(): int key = getNumberFormatKey ( chartDoc , \"0.00\" ); 4. Changing Axis Scales \u00b6 Another way to understand scatter data is by changing the chart's axis scaling. Alternatives to linear are logarithmic, exponential, or power, although I've found that the latter two cause the chart to be drawn incorrectly. scatterLineLogChart() in Chart2Views.java utilizes the \"Power Function Test\" table in \"chartsData.ods\" (see Figure 8). Figure 8. The \"Power Function Test\" Table. I used the formula \" =4.1*POWER(E<number>, 3.2 )\" (i.e. [*** Not rendered ***] ) to generate the \"Actual\" column from the \"Input\" column's cells. Then I manually rounded the results and copied them into the \"Output\" column. The data range passed to the Chart.insertChart() uses the \"Input\" and \"Output\" columns of the table in Figure 8. The generated scatter chart in Figure 9 uses log scaling for the axes, and fits a power function to the data points. Figure 9. Scatter Chart for the Table in Figure 8. The power function fits the data so well that the black regression line lies over the blue data curve. The regression function is f(x) = 3.89 x^2.32 (i.e. ) with R 2 = 1.00, which is close to the power formula I used to generate the \"Actual\" column data. scatterLineLogChart() is: // in Chart2Views.java private static void scatterLineLogChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E110:F120\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A121\" , 20 , 11 , \"ScatterLineSymbol\" ); Calc . gotoCell ( doc , \"A121\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E109\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E110\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F110\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); // change x- and y- axes to log scaling Chart2 . scaleXAxis ( chartDoc , Chart2 . LOGARITHMIC ); Chart2 . scaleYAxis ( chartDoc , Chart2 . LOGARITHMIC ); // LINEAR, LOGARITHMIC, (EXPONENTIAL, POWER) Chart2 . drawRegressionCurve ( chartDoc , Chart2 . POWER ); } // end of scatterLineLogChart() Chart2.scaleXAxis() and Chart2.scaleYAxis() call the more general Chart2.scaleAxis() function: // in the Chart2 class public static XAxis scaleXAxis ( XChartDocument chartDoc , int scaleType ) { return scaleAxis ( chartDoc , Chart2 . X_AXIS , 0 , scaleType ); } public static XAxis scaleYAxis ( XChartDocument chartDoc , int scaleType ) { return scaleAxis ( chartDoc , Chart2 . Y_AXIS , 0 , scaleType ); } Chart2.scaleAxis() utilizes XAxis.getScaleData() and XAxis.setScaleData() to access and modify the axis scales: // in the Chart2 class public static XAxis scaleAxis ( XChartDocument chartDoc , int axisVal , int idx , int scaleType ) /* scaleTypes: LINEAR, LOGARITHMIC, EXPONENTIAL, POWER, but latter two seem unstable */ { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return null ; ScaleData sd = axis . getScaleData (); if ( scaleType == LINEAR ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.LinearScaling\" ); else if ( scaleType == LOGARITHMIC ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.LogarithmicScaling\" ); else if ( scaleType == EXPONENTIAL ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.ExponentialScaling\" ); else if ( scaleType == POWER ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.PowerScaling\" ); else System . out . println ( \"Did not recognize scaling: \" + scaleType ); axis . setScaleData ( sd ); return axis ; } // end of scaleAxis() The different scaling services all support the XScaling interface, as illustrated by Figure 10. Figure 10. The Scaling Services. 5. Adding Error Bars \u00b6 scatterLineErrorChart() in Chart2Views.java employs the \"Impact Data : 1018 Cold Rolled\" table in \"chartsData.ods\" (see Figure 11). Figure 11. The \"Impact Data : 1018 Cold Rolled\" Table. The data range passed to the Chart.insertChart() uses the \"Temperature\" and \"Mean\" columns of the table; the \"Stderr\" column is added separately to generate error bars along the y-axis. The resulting scatter chart is shown in Figure 12. Figure 12. Scatter Chart with Error Bars for the Table in Figure 11. scatterLineLogChart() is: // in Chart2Views.java private static void scatterLineErrorChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A142:B146\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"F115\" , 14 , 16 , \"ScatterLineSymbol\" ); Calc . gotoCell ( doc , \"A123\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A141\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A142\" )); Chart2 . setYAxisTitle ( chartDoc , \"Impact Energy (Joules)\" ); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); // y-axis error bars String sheetName = Calc . getSheetName ( sheet ); String errorLabel = sheetName + \".\" + \"C142\" ; String errorRange = sheetName + \".\" + \"C143:C146\" ; Chart2 . setYErrorBars ( chartDoc , errorLabel , errorRange ); } // end of scatterLineErrorChart() The new feature in scatterLineErrorChart() is the call to Chart2.setYErrorBars(), which I'll explain over the next four subsections. 5.1. Creating New Chart Data \u00b6 The secret to adding extra data to a chart is XDataSink.setData(). XDataSink is yet another interface for the DataSeries service (see Figure 5). There are several stages required, which are depicted in Figure 13. Figure 13. Using XDataSink to Add Data to a Chart. The DataProvider service produces two XDataSequence objects which are combined to become a XLabeledDataSequence object. An array of these objects is passed to XDataSink.setData(). The DataProvider service is accessed with one line of code: XDataProvider dp = chartDoc . getDataProvider (); Chart2.createLDSeq() creates a XLabeledDataSequence instance from two XDataSequence objects, one acting as a label the other as data. The XDataSequence object representing the data must have its \"Role\" property set to indicate the type of the data. // in the Chart2 class public static XLabeledDataSequence createLDSeq ( XDataProvider dp , String role , String dataLabel , String dataRange ) // create labeled data sequence using label and data; // the data has the specified role { // create data sequence for the label XDataSequence labelSeq = dp . createDataSequenceByRangeRepresentation ( dataLabel ); // create data sequence for the data XDataSequence dataSeq = dp . createDataSequenceByRangeRepresentation ( dataRange ); XPropertySet dsProps = Lo . qi ( XPropertySet . class , dataSeq ); Props . setProperty ( dsProps , \"Role\" , role ); //specify data role (type) // create labeled data sequence using label and data seqs XLabeledDataSequence ldSeq = Lo . createInstanceMCF ( XLabeledDataSequence . class , \"com.sun.star.chart2.data.LabeledDataSequence\" ); ldSeq . setLabel ( labelSeq ); // add label ldSeq . setValues ( dataSeq ); // add data return ldSeq ; } // end of createLDSeq() Four arguments are passed to createLDSeq(): a reference to the XDataProvider interface, a role string, a label, and a data range. For example: // part of Chart2.setYErrorBars(); see section 5.4 below : String label = sheetName + \".\" + \"C142\" ; String dataRange = sheetName + \".\" + \"C143:C146\" ; XLabeledDataSequence lds = Chart2 . createLDSeq ( dp , \"error-bars-y-positive\" , label , dataRange ); Role strings are defined in DataSequenceRole, which is documented on the page that describes chart2's data submodule (call lodoc chart2 data module , and scroll to the bottom). XDataSink.setData() can accept multiple XLabeledDataSequence objects in an array, making it possible to add several kinds of data to the chart at once. This is just as well since I need to add two XLabeledDataSequence objects, one for the error bars above the data points (i.e. up the y-axis), and another for the error bars below the points (i.e. down the y-axis). The code for doing this: // part of Chart2.setYErrorBars(); see section 5.4 below : XDataSink dataSink = ... // create the data sink XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence posErrSeq = // bars above data points createLDSeq ( dp , \"error-bars-y-positive\" , dataLabel , dataRange ); XLabeledDataSequence negErrSeq = // bars below the data points createLDSeq ( dp , \"error-bars-y-negative\" , dataLabel , dataRange ); XLabeledDataSequence [] ldSeqArr = { posErrSeq , negErrSeq }; // build array // add the two error bars to the data sink dataSink . setData ( ldSeqArr ); // add the data sink to the chart ... This code fragment leaves two topics unexplained: how the data sink is initially created, and how the data sink is linked to the chart. 5.2. Creating the Data Sink \u00b6 The data sink for error bars relies on the ErrorBar service, which is shown in Figure 14. Figure 14. The ErrorBar Service The ErrorBar service stores error bar properties and implements the XDataSink interface. The following code fragment creates an instance of the ErrorBar service, sets some of its properties, and converts it to an XDataSink: // part of Chart2.setYErrorBars(); see section 5.4 below : XPropertySet props = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.chart2.ErrorBar\" ); Props . setProperty ( props , \"ShowPositiveError\" , true ); Props . setProperty ( props , \"ShowNegativeError\" , true ); Props . setProperty ( props , \"ErrorBarStyle\" , ErrorBarStyle . FROM_DATA ); XDataSink dataSink = Lo . qi ( XDataSink . class , props ); For details on the ErrorBar service, execute lodoc chart2 ErrorBar . 5.3. Linking the Data Sink to the Chart \u00b6 Once the data sink has been filled with XLabeledDataSequence objects, it can be linked to the data series in the chart. For error bars this is done via the properties \"ErrorBarX\" and \"ErrorBarY\". For example, the following code assigns a data sink to the data series' \"ErrorBarY\" property: // part of Chart2.setYErrorBars(); see section 5.4 below : XDataSeries [] dsa = getDataSeries ( chartDoc ); XDataSeries ds = dsa [ 0 ] ; Props . setProperty ( ds , \"ErrorBarY\" , props ); Note that the value assigned to \"ErrorBarY\" is not an XDataSink interface (e.g. not dataSink from the earlier code fragment) but its property set (i.e. props). 5.4. Bringing it All Together \u00b6 Chart2.setYErrorBars() combines the previous code fragments into a single method: the data sink is created (as a property set), XLabeledDataSequence data is added to it, and then the sink is linked to the chart's data series: // in the Chart2 class public static void setYErrorBars ( XChartDocument chartDoc , String dataLabel , String dataRange ) // see sections 5.1 \u2013 5.3. for details of this code { // initialize error bar properties XPropertySet errorBarProps = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.chart2.ErrorBar\" ); Props . setProperty ( errorBarProps , \"ShowPositiveError\" , true ); Props . setProperty ( errorBarProps , \"ShowNegativeError\" , true ); Props . setProperty ( errorBarProps , \"ErrorBarStyle\" , ErrorBarStyle . FROM_DATA ); // convert into data sink XDataSink dataSink = Lo . qi ( XDataSink . class , errorBarProps ); // use data provider to create labeled data sequences // for the +/- error ranges XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence posErrSeq = createLDSeq ( dp , \"error-bars-y-positive\" , dataLabel , dataRange ); XLabeledDataSequence negErrSeq = createLDSeq ( dp , \"error-bars-y-negative\" , dataLabel , dataRange ); XLabeledDataSequence [] ldSeqArr = { posErrSeq , negErrSeq }; // store the error bar data sequences in the data sink dataSink . setData ( ldSeqArr ); // store error bar in data series XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); XDataSeries dataSeries = dataSeriesArr [ 0 ] ; Props . setProperty ( dataSeries , \"ErrorBarY\" , errorBarProps ); } // end of setYErrorBars() This is not our last visit to DataSink and XDataSink. I'll use their features again in the next chapter.","title":"Chapter 31. XY (Scatter) Charts"},{"location":"31-XY_Scatter_Charts.html#chapter-31-xy-scatter-charts","text":"Topics A Scatter Chart (with Regressions); Calculating Regressions; Drawing a Regression Curve; Changing Axis Scales; Adding Error Bars Example folders: \"Chart2 Tests\" and \"Utils\" This chapter continues using the Chart2Views.java example from previous chapters, but looks at how various kinds of scatter charts can be generated from spreadsheet data. A scatter chart is a good way to display (x, y) coordinate data since the x-axis values are treated as numbers not categories. In addition, regression functions can be calculated and displayed, the axis scales can be changed, and error bars added. The relevant lines of Chart2Views.java are: // part of Chart2Views.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- scatterChart ( doc , sheet ); // see sections 1-3 // scatterLineLogChart(doc, sheet); // section 4 // scatterLineErrorChart(doc, sheet); // section 5 : // more chart examples Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main()","title":"Chapter 31. XY (Scatter) Charts"},{"location":"31-XY_Scatter_Charts.html#1-a-scatter-chart-with-regressions","text":"scatterChart() in Chart2Views.java utilizes the \"Ice Cream Sales vs. Temperature\" table in \"chartsData.ods\" (see Figure 1) to generate the scatter chart in Figure 2. Figure 1. The \"Ice Cream Sales vs. Temperature\" Table. Figure 2. Scatter Chart for the Table in Figure 1. Note that the x-axis in Figure 1 is numerical, showing values ranging between 10.0 and 26.0. This range is calculated automatically by the template. scatterChart() is: // in Chart2Views.java private static void scatterChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A110:B122\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"C109\" , 16 , 11 , \"ScatterSymbol\" ); // ScatterSymbol, ScatterLine, ScatterLineSymbol Calc . gotoCell ( doc , \"A104\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A109\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A110\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B110\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // reduce clutter // Chart2.calcRegressions(chartDoc); // Chart2.drawRegressionCurve(chartDoc, Chart2.LINEAR); } // end of scatterChart() If the Chart2.calcRegressions() line is uncommented then several different regression functions are calculated using the chart's data. Their equations and R 2 values are printed as shown below: Linear regression curve: Curve equation: f(x) = 30.09x - 159.5 R^2 value: 0.917 Logarithmic regression curve: Curve equation: f(x) = 544.1 ln(x) - 1178 R^2 value: 0.921 Exponential regression curve: Curve equation: f(x) = 81.62 exp( 0.0826 x ) R^2 value: 0.865 Power regression curve: Curve equation: f(x) = 4.545 x^1.525 R^2 value: 0.906 Polynomial regression curve: Curve equation: f(x) = - 0.5384x^2 + 50.24x - 340.1 R^2 value: 0.921 Moving average regression curve: Curve equation: Moving average trend line with period = %PERIOD R^2 value: NaN A logarithmic or quadratic polynomial are the best matches, but linear is a close third. The \"moving average\" R 2 result is NaN (Not-a-Number) since no average of period 2 matches the data. If the Chart2.drawRegressionCurve() call is uncommented, the chart drawing will include a linear regression line and its equation and R 2 value (see Figure 3). Figure 3. Scatter Chart with Linear Regression Line for the Table in Figure 1. The regression function is f(x) = 30.09x - 159.47, and the C value is 0.92 (to 2 dp). If the constant is changed to Chart2.LOGARITHMIC in the call to Chart2.drawRegressionCurve() then the generated function is f(x) = 544.1 ln(x) \u2013 1178 with an R 2 value of 0.92. Other regression curves are represented by the Chart2 constants EXPONENTIAL, POWER, POLYNOMIAL, and MOVING_AVERAGE.","title":"1.  A Scatter Chart (with Regressions)"},{"location":"31-XY_Scatter_Charts.html#2-calculating-regressions","text":"Chart2.calcRegressions() is: // in the Chart2 class // globals private static final int [] CURVE_KINDS = { LINEAR , LOGARITHMIC , EXPONENTIAL , POWER , POLYNOMIAL , MOVING_AVERAGE }; private static final String [] CURVE_NAMES = { \"Linear\" , \"Logarithmic\" , \"Exponential\" , \"Power\" , \"Polynomial\" , \"Moving average\" }; public static void calcRegressions ( XChartDocument chartDoc ) { for ( int i = 0 ; i < CURVE_KINDS . length ; i ++ ) { XRegressionCurve curve = createCurve ( CURVE_KINDS [ i ] ); System . out . println ( CURVE_NAMES [ i ] + \" regression curve:\" ); evalCurve ( chartDoc , curve ); System . out . println (); } } // end of calcRegressions() createCurve() matches the regression constants defined in CURVE_KINDS[] to regression services offered by the API: // in the Chart2 class public static XRegressionCurve createCurve ( int curveKind ) { if ( curveKind == LINEAR ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.LinearRegressionCurve\" ); else if ( curveKind == LOGARITHMIC ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.LogarithmicRegressionCurve\" ); else if ( curveKind == EXPONENTIAL ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.ExponentialRegressionCurve\" ); else if ( curveKind == POWER ) return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.PotentialRegressionCurve\" ); else if ( curveKind == POLYNOMIAL ) // assume degree == 2 return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.PolynomialRegressionCurve\" ); else if ( curveKind == MOVING_AVERAGE ) // assume period == 2 return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.MovingAverageRegressionCurve\" ); else { System . out . println ( \"Did not recognize regression line kind: \" + curveKind + \"; using linear\" ); return Lo . createInstanceMCF ( XRegressionCurve . class , \"com.sun.star.chart2.LinearRegressionCurve\" ); } } // end of createCurve() There are seven regression curve services in the chart2 module, all of which support the XRegressionCurve interface, as shown in Figure 4. Figure 4. The Regression Curve Services The RegressionCurve service shown in Figure 4 is not a superclass for the other services. Also note that the regression curve service for power functions is called \"PotentialRegressionCurve\". Chart2.evalCurve() uses XRegressionCurve.getCalculator() to access the XRegressionCurveCalculator interface. It sets up the data and parameters for a particular curve, and prints the results of curve fitting: // in the Chart2 class public static void evalCurve ( XChartDocument chartDoc , XRegressionCurve curve ) { XRegressionCurveCalculator curveCalc = curve . getCalculator (); int degree = 1 ; if ( getCurveType ( curve ) != LINEAR ) degree = 2 ; // assumes POLYNOMIAL curve has degree == 2 curveCalc . setRegressionProperties ( degree , false , 0 , 2 ); // args: degree, forceIntercept, interceptValue, period XDataSource dataSource = getDataSource ( chartDoc ); // printLabeledSeqs(dataSource); double [] xVals = getChartData ( dataSource , 0 ); double [] yVals = getChartData ( dataSource , 1 ); curveCalc . recalculateRegression ( xVals , yVals ); System . out . println ( \" Curve equation: \" + curveCalc . getRepresentation ()); double cc = curveCalc . getCorrelationCoefficient (); System . out . printf ( \" R^2 value: %.3f\\n\" , ( cc * cc )); // 3 dp } // end of evalCurve() The calculation is configured by calling XRegressionCurveCalculator.setRegressionProperties(), and carried out by XRegressionCurveCalculator.recalculateRegression(). The degree argument of setRegressionProperties() specifies the polynomial curve's degree, which I've hardwired to be quadratic (i.e. a degree of 2). The period argument is used when a moving average curve is being fitted. recalculateRegression() requires two arrays of x- and y- axis values for the scatter points. These are obtained from the chart's data source by calling Chart2.getDataSource() which returns the XDataSource interface for the DataSeries service. Figure 5 shows the XDataSource, XRegressionCurveContainer, and XDataSink interfaces of the DataSeries service. Figure 5. More Detailed DataSeries Service. In previous chapters, I've only used the XDataSeries interface, which offers access to the data points in the chart. The XDataSource interface, which is read-only, gives access to the underlying data that was used to create the points. The data is stored as an array of XLabeledDataSequence objects; each object contains a label and a sequence of data. Chart2.getDataSource() is defined as: // in the Chart2 class public static XDataSource getDataSource ( XChartDocument chartDoc ) { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); return Lo . qi ( XDataSource . class , dataSeriesArr [ 0 ] ); // get first } This method assumes that the programmer wants the first data source in the data series. This is adequate for most charts which only use one data source. Chart2.printLabeledSeqs() is a diagnostic function for printing all the labeled data sequences stored in an XDataSource: // in the Chart2 class public static void printLabeledSeqs ( XDataSource dataSource ) { XLabeledDataSequence [] dataSeqs = dataSource . getDataSequences (); System . out . println ( \"No. of sequences in data source: \" + dataSeqs . length ); for ( int i = 0 ; i < dataSeqs . length ; i ++ ) { Object [] labelSeq = dataSeqs [ i ] . getLabel (). getData (); System . out . print ( labelSeq [ 0 ] + \" :\" ); Object [] valsSeq = dataSeqs [ i ] . getValues (). getData (); for ( Object val : valsSeq ) System . out . print ( \" \" + val ); System . out . println (); String srRep = dataSeqs [ i ] . getValues (). getSourceRangeRepresentation (); System . out . println ( \" Source range: \" + srRep ); } } // end of printLabeledSeqs() When these function is applied to the data source for the scatter chart, the following is printed: No. of sequences in data source: 2 Temperature \u00b0C : 14.2 16.4 11.9 15.2 18.5 22.1 19.4 25.1 23.4 18.1 22.6 17.2 Source range: $examples.$A$111:$A$122 Ice Cream Sales : 215.0 325.0 185.0 332.0 406.0 522.0 412.0 614.0 544.0 421.0 445.0 408.0 Source range: $examples.$B$111:$B$122 This output shows that the data source consists of two XLabeledDataSequence objects, representing the x- and y- values in the data source (see Figure 1). These objects' data are extracted as arrays by calls to Chart2.getChartData(): // in the Chart2 class // part of evalCurve() : XDataSource dataSource = getDataSource ( chartDoc ); printLabeledSeqs ( dataSource ); double [] xVals = getChartData ( dataSource , 0 ); double [] yVals = getChartData ( dataSource , 1 ); curveCalc . recalculateRegression ( xVals , yVals ); When recalculateRegression() has finished, various results about the fitted curve can be extracted from the XRegressionCurveCalculator variable, curveCalc. evalCurve() prints the function string (using getRepresentation()) and the R 2 value (using getCorrelationCoefficient()).","title":"2.  Calculating Regressions"},{"location":"31-XY_Scatter_Charts.html#3-drawing-a-regression-curve","text":"One of the surprising things about drawing a regression curve is that there's no need to explicitly calculate the curve's function with XRegressionCurveCalculator. Instead Chart2.drawRegressionCurve() only has to initialize the curve via the data series' XRegressionCurveContainer interface (see Figure 5). drawRegressionCurve() is: // in the Chart2 class public static void drawRegressionCurve ( XChartDocument chartDoc , int curveKind ) { XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); XRegressionCurveContainer rcCon = Lo . qi ( XRegressionCurveContainer . class , dataSeriesArr [ 0 ] ); XRegressionCurve curve = createCurve ( curveKind ); rcCon . addRegressionCurve ( curve ); // calculates the curve // show equation and R^2 value XPropertySet props = curve . getEquationProperties (); Props . setProperty ( props , \"ShowCorrelationCoefficient\" , true ); Props . setProperty ( props , \"ShowEquation\" , true ); int key = getNumberFormatKey ( chartDoc , \"0.00\" ); // 2 dp if ( key != - 1 ) Props . setProperty ( props , \"NumberFormat\" , key ); } // end of drawRegressionCurve() The XDataSeries interface for the first data series in the chart is converted to XRegressionCurveContainer, and an XRegressionCurve instance added to it. This triggers the calculation of the curve's function. The rest of drawRegressionCurve() deals with how the function information is displayed on the chart. XRegressionCurve.getEquationProperties() returns a property set which is an instance of the RegressionCurveEquation class, shown in Figure 6. Figure 6. The RegressionCurveEquation Property Class. RegressionCurveEquation inherits properties related to character, fill, and line, since it controls how the curve, function string, and R 2 value are drawn on the chart. These last two are made visible by setting the \"ShowEquation\" and \"ShowCorrelationCoefficient\" properties to true, which are defined in RegressionCurveEquation. Online documentation on this class can be accessed using lodoc RegressionCurveEquation . Another useful property is \"NumberFormat\" which can be used to reduce the number of decimal places used when printing the function and R 2 value. Chart2.getNumberFormatKey() converts a number format string into a number format key, which is assigned to the \"NumberFormat\" property: // in the Chart2 class public static int getNumberFormatKey ( XChartDocument chartDoc , String nfStr ) { XNumberFormatsSupplier xfs = Lo . qi ( XNumberFormatsSupplier . class , chartDoc ); XNumberFormats nFormats = xfs . getNumberFormats (); int key = ( int ) nFormats . queryKey ( nfStr , new com . sun . star . lang . Locale ( \"en\" , \"us\" , \"\" ), false ); if ( key == - 1 ) System . out . println ( \"Could not access key for format: \\\"\" + nfStr + \"\\\"\" ); return key ; } // end of getNumberFormatKey() The string-to-key conversion is straight forward if you know what number format string to use, but there's little documentation on them. Probably the best approach is to use the Format \uf0e0 Cells menu item in a spreadsheet document, and examine the dialog in Figure 7. Figure 7. The Format Cells Dialog. When you select a given category and format, the number format string is shown in the \"Format Code\" field at the bottom of the dialog. Figure 7 shows that the format string for two decimal place numbers is \"0.00\". This string should be passed to getNumberFormatKey() in drawRegressionCurve(): int key = getNumberFormatKey ( chartDoc , \"0.00\" );","title":"3.  Drawing a Regression Curve"},{"location":"31-XY_Scatter_Charts.html#4-changing-axis-scales","text":"Another way to understand scatter data is by changing the chart's axis scaling. Alternatives to linear are logarithmic, exponential, or power, although I've found that the latter two cause the chart to be drawn incorrectly. scatterLineLogChart() in Chart2Views.java utilizes the \"Power Function Test\" table in \"chartsData.ods\" (see Figure 8). Figure 8. The \"Power Function Test\" Table. I used the formula \" =4.1*POWER(E<number>, 3.2 )\" (i.e. [*** Not rendered ***] ) to generate the \"Actual\" column from the \"Input\" column's cells. Then I manually rounded the results and copied them into the \"Output\" column. The data range passed to the Chart.insertChart() uses the \"Input\" and \"Output\" columns of the table in Figure 8. The generated scatter chart in Figure 9 uses log scaling for the axes, and fits a power function to the data points. Figure 9. Scatter Chart for the Table in Figure 8. The power function fits the data so well that the black regression line lies over the blue data curve. The regression function is f(x) = 3.89 x^2.32 (i.e. ) with R 2 = 1.00, which is close to the power formula I used to generate the \"Actual\" column data. scatterLineLogChart() is: // in Chart2Views.java private static void scatterLineLogChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E110:F120\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A121\" , 20 , 11 , \"ScatterLineSymbol\" ); Calc . gotoCell ( doc , \"A121\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E109\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E110\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"F110\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); // change x- and y- axes to log scaling Chart2 . scaleXAxis ( chartDoc , Chart2 . LOGARITHMIC ); Chart2 . scaleYAxis ( chartDoc , Chart2 . LOGARITHMIC ); // LINEAR, LOGARITHMIC, (EXPONENTIAL, POWER) Chart2 . drawRegressionCurve ( chartDoc , Chart2 . POWER ); } // end of scatterLineLogChart() Chart2.scaleXAxis() and Chart2.scaleYAxis() call the more general Chart2.scaleAxis() function: // in the Chart2 class public static XAxis scaleXAxis ( XChartDocument chartDoc , int scaleType ) { return scaleAxis ( chartDoc , Chart2 . X_AXIS , 0 , scaleType ); } public static XAxis scaleYAxis ( XChartDocument chartDoc , int scaleType ) { return scaleAxis ( chartDoc , Chart2 . Y_AXIS , 0 , scaleType ); } Chart2.scaleAxis() utilizes XAxis.getScaleData() and XAxis.setScaleData() to access and modify the axis scales: // in the Chart2 class public static XAxis scaleAxis ( XChartDocument chartDoc , int axisVal , int idx , int scaleType ) /* scaleTypes: LINEAR, LOGARITHMIC, EXPONENTIAL, POWER, but latter two seem unstable */ { XAxis axis = getAxis ( chartDoc , axisVal , idx ); if ( axis == null ) return null ; ScaleData sd = axis . getScaleData (); if ( scaleType == LINEAR ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.LinearScaling\" ); else if ( scaleType == LOGARITHMIC ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.LogarithmicScaling\" ); else if ( scaleType == EXPONENTIAL ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.ExponentialScaling\" ); else if ( scaleType == POWER ) sd . Scaling = Lo . createInstanceMCF ( XScaling . class , \"com.sun.star.chart2.PowerScaling\" ); else System . out . println ( \"Did not recognize scaling: \" + scaleType ); axis . setScaleData ( sd ); return axis ; } // end of scaleAxis() The different scaling services all support the XScaling interface, as illustrated by Figure 10. Figure 10. The Scaling Services.","title":"4.  Changing Axis Scales"},{"location":"31-XY_Scatter_Charts.html#5-adding-error-bars","text":"scatterLineErrorChart() in Chart2Views.java employs the \"Impact Data : 1018 Cold Rolled\" table in \"chartsData.ods\" (see Figure 11). Figure 11. The \"Impact Data : 1018 Cold Rolled\" Table. The data range passed to the Chart.insertChart() uses the \"Temperature\" and \"Mean\" columns of the table; the \"Stderr\" column is added separately to generate error bars along the y-axis. The resulting scatter chart is shown in Figure 12. Figure 12. Scatter Chart with Error Bars for the Table in Figure 11. scatterLineLogChart() is: // in Chart2Views.java private static void scatterLineErrorChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A142:B146\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"F115\" , 14 , 16 , \"ScatterLineSymbol\" ); Calc . gotoCell ( doc , \"A123\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A141\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A142\" )); Chart2 . setYAxisTitle ( chartDoc , \"Impact Energy (Joules)\" ); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); // y-axis error bars String sheetName = Calc . getSheetName ( sheet ); String errorLabel = sheetName + \".\" + \"C142\" ; String errorRange = sheetName + \".\" + \"C143:C146\" ; Chart2 . setYErrorBars ( chartDoc , errorLabel , errorRange ); } // end of scatterLineErrorChart() The new feature in scatterLineErrorChart() is the call to Chart2.setYErrorBars(), which I'll explain over the next four subsections.","title":"5.  Adding Error Bars"},{"location":"31-XY_Scatter_Charts.html#51-creating-new-chart-data","text":"The secret to adding extra data to a chart is XDataSink.setData(). XDataSink is yet another interface for the DataSeries service (see Figure 5). There are several stages required, which are depicted in Figure 13. Figure 13. Using XDataSink to Add Data to a Chart. The DataProvider service produces two XDataSequence objects which are combined to become a XLabeledDataSequence object. An array of these objects is passed to XDataSink.setData(). The DataProvider service is accessed with one line of code: XDataProvider dp = chartDoc . getDataProvider (); Chart2.createLDSeq() creates a XLabeledDataSequence instance from two XDataSequence objects, one acting as a label the other as data. The XDataSequence object representing the data must have its \"Role\" property set to indicate the type of the data. // in the Chart2 class public static XLabeledDataSequence createLDSeq ( XDataProvider dp , String role , String dataLabel , String dataRange ) // create labeled data sequence using label and data; // the data has the specified role { // create data sequence for the label XDataSequence labelSeq = dp . createDataSequenceByRangeRepresentation ( dataLabel ); // create data sequence for the data XDataSequence dataSeq = dp . createDataSequenceByRangeRepresentation ( dataRange ); XPropertySet dsProps = Lo . qi ( XPropertySet . class , dataSeq ); Props . setProperty ( dsProps , \"Role\" , role ); //specify data role (type) // create labeled data sequence using label and data seqs XLabeledDataSequence ldSeq = Lo . createInstanceMCF ( XLabeledDataSequence . class , \"com.sun.star.chart2.data.LabeledDataSequence\" ); ldSeq . setLabel ( labelSeq ); // add label ldSeq . setValues ( dataSeq ); // add data return ldSeq ; } // end of createLDSeq() Four arguments are passed to createLDSeq(): a reference to the XDataProvider interface, a role string, a label, and a data range. For example: // part of Chart2.setYErrorBars(); see section 5.4 below : String label = sheetName + \".\" + \"C142\" ; String dataRange = sheetName + \".\" + \"C143:C146\" ; XLabeledDataSequence lds = Chart2 . createLDSeq ( dp , \"error-bars-y-positive\" , label , dataRange ); Role strings are defined in DataSequenceRole, which is documented on the page that describes chart2's data submodule (call lodoc chart2 data module , and scroll to the bottom). XDataSink.setData() can accept multiple XLabeledDataSequence objects in an array, making it possible to add several kinds of data to the chart at once. This is just as well since I need to add two XLabeledDataSequence objects, one for the error bars above the data points (i.e. up the y-axis), and another for the error bars below the points (i.e. down the y-axis). The code for doing this: // part of Chart2.setYErrorBars(); see section 5.4 below : XDataSink dataSink = ... // create the data sink XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence posErrSeq = // bars above data points createLDSeq ( dp , \"error-bars-y-positive\" , dataLabel , dataRange ); XLabeledDataSequence negErrSeq = // bars below the data points createLDSeq ( dp , \"error-bars-y-negative\" , dataLabel , dataRange ); XLabeledDataSequence [] ldSeqArr = { posErrSeq , negErrSeq }; // build array // add the two error bars to the data sink dataSink . setData ( ldSeqArr ); // add the data sink to the chart ... This code fragment leaves two topics unexplained: how the data sink is initially created, and how the data sink is linked to the chart.","title":"5.1.  Creating New Chart Data"},{"location":"31-XY_Scatter_Charts.html#52-creating-the-data-sink","text":"The data sink for error bars relies on the ErrorBar service, which is shown in Figure 14. Figure 14. The ErrorBar Service The ErrorBar service stores error bar properties and implements the XDataSink interface. The following code fragment creates an instance of the ErrorBar service, sets some of its properties, and converts it to an XDataSink: // part of Chart2.setYErrorBars(); see section 5.4 below : XPropertySet props = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.chart2.ErrorBar\" ); Props . setProperty ( props , \"ShowPositiveError\" , true ); Props . setProperty ( props , \"ShowNegativeError\" , true ); Props . setProperty ( props , \"ErrorBarStyle\" , ErrorBarStyle . FROM_DATA ); XDataSink dataSink = Lo . qi ( XDataSink . class , props ); For details on the ErrorBar service, execute lodoc chart2 ErrorBar .","title":"5.2.  Creating the Data Sink"},{"location":"31-XY_Scatter_Charts.html#53-linking-the-data-sink-to-the-chart","text":"Once the data sink has been filled with XLabeledDataSequence objects, it can be linked to the data series in the chart. For error bars this is done via the properties \"ErrorBarX\" and \"ErrorBarY\". For example, the following code assigns a data sink to the data series' \"ErrorBarY\" property: // part of Chart2.setYErrorBars(); see section 5.4 below : XDataSeries [] dsa = getDataSeries ( chartDoc ); XDataSeries ds = dsa [ 0 ] ; Props . setProperty ( ds , \"ErrorBarY\" , props ); Note that the value assigned to \"ErrorBarY\" is not an XDataSink interface (e.g. not dataSink from the earlier code fragment) but its property set (i.e. props).","title":"5.3.  Linking the Data Sink to the Chart"},{"location":"31-XY_Scatter_Charts.html#54-bringing-it-all-together","text":"Chart2.setYErrorBars() combines the previous code fragments into a single method: the data sink is created (as a property set), XLabeledDataSequence data is added to it, and then the sink is linked to the chart's data series: // in the Chart2 class public static void setYErrorBars ( XChartDocument chartDoc , String dataLabel , String dataRange ) // see sections 5.1 \u2013 5.3. for details of this code { // initialize error bar properties XPropertySet errorBarProps = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.chart2.ErrorBar\" ); Props . setProperty ( errorBarProps , \"ShowPositiveError\" , true ); Props . setProperty ( errorBarProps , \"ShowNegativeError\" , true ); Props . setProperty ( errorBarProps , \"ErrorBarStyle\" , ErrorBarStyle . FROM_DATA ); // convert into data sink XDataSink dataSink = Lo . qi ( XDataSink . class , errorBarProps ); // use data provider to create labeled data sequences // for the +/- error ranges XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence posErrSeq = createLDSeq ( dp , \"error-bars-y-positive\" , dataLabel , dataRange ); XLabeledDataSequence negErrSeq = createLDSeq ( dp , \"error-bars-y-negative\" , dataLabel , dataRange ); XLabeledDataSequence [] ldSeqArr = { posErrSeq , negErrSeq }; // store the error bar data sequences in the data sink dataSink . setData ( ldSeqArr ); // store error bar in data series XDataSeries [] dataSeriesArr = getDataSeries ( chartDoc ); XDataSeries dataSeries = dataSeriesArr [ 0 ] ; Props . setProperty ( dataSeries , \"ErrorBarY\" , errorBarProps ); } // end of setYErrorBars() This is not our last visit to DataSink and XDataSink. I'll use their features again in the next chapter.","title":"5.4.  Bringing it All Together"},{"location":"32-Bubble_Net_Stock_Charts.html","text":"Chapter 32. Bubble, Net, Stock Charts \u00b6 Topics The Bubble Chart; The Net Chart; The Stock Chart: basic and modified candle sticks; Stock Chart and Line Graph Example folders: \"Chart2 Tests\" and \"Utils\" This chapter concludes my use of the Chart2Views.java example by looking at how bubble, net and stock charts can be generated from spreadsheet data. The relevant lines of Chart2Views.java are: // part of Chart2Views.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- labeledBubbleChart ( doc , sheet ); // see section 1 // netChart(doc, sheet); // section 2 // happyStockChart(doc, sheet); // section 3 // stockPricesChart(doc, sheet); // section 4 Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() 1. The Bubble Chart \u00b6 A bubble chart is a variation of a scatter chart where each data point shows the relationship between three variables. Two variables are used for a bubble's (x, y) coordinate, and the third affects the bubble's size. labeledBubbleChart() in Chart2Views.java utilizes the \"World data\" table in \"chartsData.ods\" (see Figure 1). Figure 1. The \"World data\" Table. The data range passed to the Chart.insertChart() uses the first three columns of the table; the \"Country\" column is added separately. The generated scatter chart is shown in Figure 2. Figure 2. Bubble Chart for the Table in Figure 1. labeledBubbleChart() is: // in Chart2Views.java private static void labeledBubbleChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"H63:J93\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A62\" , 18 , 11 , \"Bubble\" ); Calc . gotoCell ( doc , \"A62\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"H62\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"H63\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"I63\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . viewLegend ( chartDoc , true ); // change the data points XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc ); Props . setProperty ( ds [ 0 ] , \"Transparency\" , 50 ); // 100 == fully transparent Props . setProperty ( ds [ 0 ] , \"BorderStyle\" , LineStyle . SOLID ); Props . setProperty ( ds [ 0 ] , \"BorderColor\" , Calc . RED ); Props . setProperty ( ds [ 0 ] , \"LabelPlacement\" , Chart2 . DP_CENTER ); // Chart2.setDataPointLabels(chartDoc, Chart2.DP_NUMBER); /* String sheetName = Calc.getSheetName(sheet); String label = sheetName + \".\" + \"K63\"; String names = sheetName + \".\" + \"K64:K93\"; Chart2.addCatLabels(chartDoc, label, names); */ } // end of labeledBubbleChart() The transparency and border properties of all the data points are set via the DataPointProperties class for the data series. Without transparency, large bubbles could obscure or completely hide smaller bubbles. If the call to Chart2.setDataPointLabels() is uncommented, the result is messy, as shown in Figure 3. Figure 3. Numerically Labeled Bubble Chart for the Table in Figure 1. Instead of labeling the bubbles with population sizes, it would be better to use the \"Country\" values (see Figure 1). Chart2.addCatLabels() implements this feature, producing Figure 4. Figure 4. Category Labeled Bubble Chart for the Table in Figure 1. Chart2.addCatLabels() employs the \"Country\" data to create an XLabeledDataSequence object which is assigned the role \"categories\". It is then assigned to the x-axis as category-based scale data: // in the Chart2 class public static void addCatLabels ( XChartDocument chartDoc , String dataLabel , String dataRange ) { // create 'categories' labeled data sequence XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence dLSeq = createLDSeq ( dp , \"categories\" , dataLabel , dataRange ); // assign sequence to x-axis as category scale data XAxis axis = getAxis ( chartDoc , X_AXIS , 0 ); if ( axis == null ) return ; ScaleData sd = axis . getScaleData (); sd . Categories = dLSeq ; axis . setScaleData ( sd ); setDataPointLabels ( chartDoc , Chart2 . DP_CATEGORY ); // label the data points with categories } // end of addCatLabels() When setDataPointLabels() displays category data for the points, the new x-axis categories are utilized. 2. The Net Chart \u00b6 The net chart (also called a radar chart) is useful for comparing multiple columns of data (often between three and eight columns) in a 2D arrangement that resembles a spider's web. Although net charts have an interesting look, a lot of people dislike them (e.g. see \"A Critique of Radar Charts\" by Graham Odds at https://blog.scottlogic.com/2011/09/23/a-critique-of-radar-charts.html ). netChart() in Chart2Views.java utilizes the \"No of Calls per Day\" table in \"chartsData.ods\" (see Figure 5). Figure 5. The \"No of Calls per Day\" Table. The generated net chart is shown in Figure 6. Figure 6. Net Chart for the Table in Figure 5. netChart() is: // in Chart2Views.java private static void netChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A56:D63\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"E55\" , 16 , 11 , \"NetLine\" ); // Net, NetLine, NetSymbol // StackedNet, PercentStackedNet Calc . gotoCell ( doc , \"E55\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A55\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // reverse x-axis so days increase clockwise around net XAxis xAxis = Chart2 . getXAxis ( chartDoc ); ScaleData sd = xAxis . getScaleData (); sd . Orientation = AxisOrientation . REVERSE ; xAxis . setScaleData ( sd ); } // end of netChart() Different net chart templates allow points to be shown, the areas filled with color, and the lines to be stacked or displayed as percentages. netChart() changes the x-axis which wraps around the circumference of the chart. By default, the axis is drawn in a counter-clockwise direction starting from the top of the net. This order doesn't seem right for the days of the week in this example, so I made the order clockwise, as in Figure 6. 3. The Stock Chart \u00b6 A stock chart is a specialized column graph for displaying stocks and shares information. All stock chart templates require at least three columns of data concerning the lowest price, highest price, and closing price of a stock (or share). It's also possible to include two other columns that detail the stock's opening price and transaction volume. The stock template names reflect the data columns they utilize: StockLowHighClose StockOpenLowHighClose StockVolumeLowHighClose StockVolumeOpenLowHighClose The names also indicate the ordering of the columns in the data range supplied to the template. For example, \"StockVolumeOpenLowHighClose\" requires five columns of data in the order: transaction volume, opening price, lowest price, highest price, and closing price. happyStockChart() in Chart2Views.java utilizes the \"Happy Systems (HASY)\" table in \"chartsData.ods\" (see Figure 7). Figure 7. The \"Happy Systems (HASY)\" Table. The table has six columns, the first being the x-axis categories, which are usually dates. The other columns follow the order required by the \"StockVolumeOpenLowHighClose\" template. The generated stock chart is shown in Figure 8. Figure 8. Stock Chart for the Table in Figure 7. The chart is made up of two graphs with a common x-axis: a column graph for the stock volume on each day, and a candle-stick graph showing the lowest, opening, closing, and highest stock values. Figure 9 gives details of how these elements are drawn. Figure 9. The Elements of a Stock Chart. The thin red lines drawn on the columns in Figure 9 denote the range between the lowest and highest stock value on that day. The white and black blocks represent the stock's change between its opening and closing price. A white block (often called a \"white day\") means the price has increased, while black (a \"black day\") means that it has decreased. happyStockChart() is: // in Chart2Views.java private static void happyStockChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A86:F104\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A105\" , 25 , 14 , \"StockVolumeOpenLowHighClose\" ); Calc . gotoCell ( doc , \"A105\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A85\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A86\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B86\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . setYAxis2Title ( chartDoc , \"Stock Value\" ); Chart2 . rotateYAxis2Title ( chartDoc , 90 ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // too cluttered if numerical data is shown // change 2nd y-axis min and max; default is poor ($0 - $20) XAxis yAxis2 = Chart2 . getYAxis2 ( chartDoc ); ScaleData sd = yAxis2 . getScaleData (); sd . Minimum = 83 ; sd . Maximum = 103 ; yAxis2 . setScaleData ( sd ); // more stock chart code; explained in a moment... } // end of happyStockChart() happyStockChart() sets and rotates the secondary y-axis title, which appears on the right of the chart. Chart2.setYAxis2Title() and Chart2.rotateYAxis2Title() are implemented in the same way as Chart2.setYAxisTitle() and Chart2.rotateYAxisTitle() described in Chapter 29, section 3. happyStockChart() also changes the second y-axis' range; the default shows prices between $0 and $20, which is too low. New minimum and maximum values are assigned to the axis' scale data. 3.1. Modifying the Chart Dates \u00b6 A common problem is that date information clutters the stock chart, making it harder to read. Figure 8 shows that the stock template is clever enough to only draw every second date, but this is still too much information for the limited space. One solution is to increase the x-axis interval so a tick mark (and date string) is only drawn for every third day, as in Figure 10. Figure 10. Stock Chart with Three-day Intervals for the X-Axis. Changing the interval is implemented by adjusting the time increment for the x-axis in its ScaleData object: // part of happyStockChart() in Chart2Views.java... : // change x-axis type from number to date XAxis xAxis = Chart2 . getXAxis ( chartDoc ); sd = xAxis . getScaleData (); sd . AxisType = AxisType . DATE ; // set major increment to 3 days TimeInterval ti = new TimeInterval ( 3 , TimeUnit . DAY ); TimeIncrement tc = new TimeIncrement (); tc . MajorTimeInterval = ti ; sd . TimeIncrement = tc ; xAxis . setScaleData ( sd ); Before the interval can be changed, the axis type must be changed to be of type DATE. Information on the ScaleData class can be accessed by calling lodoc chart2 scaledata . Another technique for making the dates easier to read is to rotate their labels. The following code rotates each label counter-clockwise by 45 degrees: // part of happyStockChart() in Chart2Views.java... : XAxis xAxis = Chart2 . getXAxis ( chartDoc ); Props . setProperty ( xAxis , \"TextRotation\" , 45 ); The resulting chart is shown in Figure 11. Figure 11. Stock Chart with Rotated X-Axis Labels. Note that the template has automatically switched back to showing every date instead of every second one in Figure 8. 3.2. Changing the Stock Values Appearance \u00b6 This section describes two changes to the candle stick part of the chart: adjusting the colors used in the \"white days\" and \"black days\" blocks, and making the high-low stock line easier to read. The results appear in Figure 12. Figure 12. Stock Chart with Modified Candle Sticks. A stock chart is made up of two chart types: a column chart type for the volume information, and a candle stick chart type for the stock prices. This information can be listed by calling Chart2.printChartTypes(): // in happyStockChart() Chart2Views . javaChart2 . printChartTypes ( chartDoc ); It produces: No. of chart types: 2 com.sun.star.chart2.ColumnChartType com.sun.star.chart2.CandleStickChartType In order to affect the candle stick chart type's data it is necessary to access its XChartType instance. This can be done with the two-argument version of Chart2.findChartType(): // in happyStockChart() XChartType candleCT = Chart2 . findChartType ( chartDoc , \"CandleStickChartType\" ); Figure 13 shows that the XChartType interface is supported by the ChartType service, and the CandleStickChartType subclass. Figure 13. The ChartType Service. CandleStickChartType contains some useful properties, including \"WhiteDay\" and \"BlackDay\" (for details call lodoc chart2 CandleStickChartType ). These properties store sets containing multiple values from the FillProperties and LineProperties services. They can be accessed like so: // part of happyStockChart() in Chart2Views.java... : XChartType candleCT = Chart2 . findChartType ( chartDoc , \"CandleStickChartType\" ); XPropertySet props = Lo . qi ( XPropertySet . class , Props . getProperty ( candleCT , \"WhiteDay\" )); Props . showObjProps ( \"WhiteDay\" , props ); Props . setProperty ( props , \"FillColor\" , Calc . GREEN ); The same sort of change can be done to the \"FillColor\" property inside the \"BlackDay\" property set. Both changes are implemented inside Chart2.colorStockBars(): // in the Chart2 class public static void colorStockBars ( XChartType ct , int wDayColor , int bDayColor ) { if ( ! ct . getChartType (). equals ( \"com.sun.star.chart2.CandleStickChartType\" )) System . out . println ( \"Chart type not a candle stick: \" + ct . getChartType ()); else { XPropertySet props = Lo . qi ( XPropertySet . class , Props . getProperty ( ct , \"WhiteDay\" )); Props . setProperty ( props , \"FillColor\" , wDayColor ); props = Lo . qi ( XPropertySet . class , Props . getProperty ( ct , \"BlackDay\" )); Props . setProperty ( props , \"FillColor\" , bDayColor ); } } // end of colorStockBars() Chart2.findChartType() and Chart2.colorStockBars() are called at the end of happyStockChart() to change the \"white day\" blocks to green and the \"black day\" blocks to red: // part of happyStockChart() in Chart2Views.java... : XChartType candleCT = Chart2 . findChartType ( chartDoc , \"CandleStickChartType\" ); Chart2 . colorStockBars ( candleCT , Calc . GREEN , Calc . RED ); Making the high-low lines thicker and yellow requires access to the data series in the candle stick chart type (as shown in Figure 13). This is implemented by using the two- argument version of Chart2.getDataSeries(): XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc , \"CandleStickChartType\" ); The high-low lines are adjusted via the \"LineWidth\" and \"Color\" properties in the series. The code at the end of happyStockChart() is: // part of happyStockChart() in Chart2Views.java... : XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc , \"CandleStickChartType\" ); Props . setProperty ( ds [ 0 ] , \"LineWidth\" , 120 ); // in 1/100 mm Props . setProperty ( ds [ 0 ] , \"Color\" , Calc . YELLOW ); 4. Adding a Line Graph to a Stock Chart \u00b6 stockPricesChart() in Chart2Views.java utilizes the \"Calc Guide Stock Prices\" table in \"chartsData.ods\" (see Figure 14). Figure 14. The \"Calc Guide Stock Prices\" Table. The stock chart is created using the first five columns, excluding the \"Pork Bellies\" data. There's no \"Volume\" column for the stocks, so the \"StockOpenLowHighClose\" template is employed. The stock chart is shown in Figure 15. Figure 15. Stock Chart for the Table in Figure 14. stockPricesChart() is: // in Chart2Views.java private static void stockPricesChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E141:I146\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"E148\" , 12 , 11 , \"StockOpenLowHighClose\" ); Calc . gotoCell ( doc , \"A139\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E140\" )); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E141\" )); Chart2 . setYAxisTitle ( chartDoc , \"Dollars\" ); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); // more code for adding the \"Pork Bellies\" line... } // end of stockPricesChart() A line graph showing the movement of \"Pork Bellies\" is added to the chart by Chart2.addStockLine(). The additional code at the end of stockPricesChart() is: // part of stockPricesChart() in Chart2Views.java... : String sheetName = Calc . getSheetName ( sheet ); String porkLabel = sheetName + \".\" + \"J141\" ; String porkPoints = sheetName + \".\" + \"J142:J146\" ; Chart2 . addStockLine ( chartDoc , porkLabel , porkPoints ); Chart2 . viewLegend ( chartDoc , true ); The resulting change to the stock chart is shown in Figure 16. Figure 16. Stock Chart with Line Graph for the Table in Figure 15. A data series belongs to a chart type, which is part of the coordinates system. Therefore the first task is to obtain the chart's coordinate system. A new line chart type is added to it, and an empty data series is inserted into the chart type. The addition of a new chart type to the chart's coordinate system is preformed by Chart2.addChartType(). The following adds a line chart type: // part of Chart2.addStockLine(); see below... XChartType ct = Chart2 . addChartType ( chartDoc , \"LineChartType\" ); Chart2.addChartType() uses Chart2.getCoordSystem() to get the chart's coordinate system, and then converts it into an XChartTypeContainer so the new chart type can be added: // in the Chart2 class public static XChartType addChartType ( XChartDocument chartDoc , String chartType ) { // create new chart type XChartType ct = Lo . createInstanceMCF ( XChartType . class , \"com.sun.star.chart2.\" + chartType ); if ( ct == null ) { System . out . println ( \"Unable to create XChartType: \" + chartType ); return ct ; } // add chart type to coord system XCoordinateSystem coordSys = getCoordSystem ( chartDoc ); XChartTypeContainer ctCon = Lo . qi ( XChartTypeContainer . class , coordSys ); ctCon . addChartType ( ct ); return ct ; } // end of addChartType() Chart2.addChartType() returns a reference to the new chart type, and an empty data series is added to it by converting the chart type into an XDataSeriesContainer: // part of Chart2.addStockLine(); see below... : XChartType ct = addChartType ( chartDoc , \"LineChartType\" ); XDataSeriesContainer dataSeriesCnt = Lo . qi ( XDataSeriesContainer . class , ct ); // create (empty) data series in the line chart XDataSeries ds = Lo . createInstanceMCF ( XDataSeries . class , \"com.sun.star.chart2.DataSeries\" ); if ( ds == null ) { System . out . println ( \"Unable to create XDataSeries: \" + ds ); return ; } dataSeriesCnt . addDataSeries ( ds ); This empty data series is filled with data points via its XDataSink interface, using the steps shown in Chapter 31, section 5.1, Figure 13. A DataProvider service is required so that two XDataSequence objects can be instantiated, one for the label of an XLabeledDataSequence object, the other for its data. The XDataSequence object representing the data must have its \"Role\" property set to \"values-y\" since it will become the y-coordinates of the line graph. The task of building the XLabeledDataSequence object is handled by Chart2.createLDSeq(), which I used in Chapter 31, section 5.1 to add error bars to a scatter chart, and in section 1 to place category labels in a bubble chart. The code is: // part of Chart2.addStockLine(); see below... : // treat series as a data sink XDataSink dataSink = Lo . qi ( XDataSink . class , ds ); // build a sequence representing the y-axis data XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence dLSeq = createLDSeq ( dp , \"values-y\" , dataLabel , dataRange ); // add sequence to the sink XLabeledDataSequence [] ldSeqArr = { dLSeq }; dataSink . setData ( ldSeqArr ); All the preceding code fragments of this section are wrapped up inside Chart2.addStockLine(): // in the Chart2 class public static void addStockLine ( XChartDocument chartDoc , String dataLabel , String dataRange ) { // add (empty) line chart to the doc XChartType ct = addChartType ( chartDoc , \"LineChartType\" ); XDataSeriesContainer dataSeriesCnt = Lo . qi ( XDataSeriesContainer . class , ct ); // create (empty) data series in the line chart XDataSeries ds = Lo . createInstanceMCF ( XDataSeries . class , \"com.sun.star.chart2.DataSeries\" ); if ( ds == null ) { System . out . println ( \"Unable to create XDataSeries: \" + ds ); return ; } Props . setProperty ( ds , \"Color\" , 0xFF0000 ); dataSeriesCnt . addDataSeries ( ds ); // treat series as a data sink XDataSink dataSink = Lo . qi ( XDataSink . class , ds ); // build a sequence representing the y-axis data XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence dLSeq = createLDSeq ( dp , \"values-y\" , dataLabel , dataRange ); // add sequence to the sink XLabeledDataSequence [] ldSeqArr = { dLSeq }; dataSink . setData ( ldSeqArr ); } // end of addStockLine() Chart2.addStockLine() is passed a reference to the chart document, and references to the label and data for the line graph: // part of stockPricesChart() in Chart2Views.java... : String sheetName = Calc . getSheetName ( sheet ); String porkLabel = sheetName + \".\" + \"J141\" ; String porkPoints = sheetName + \".\" + \"J142:J146\" ; Chart2 . addStockLine ( chartDoc , porkLabel , porkPoints );","title":"Chapter 32. Bubble, Net, Stock Charts"},{"location":"32-Bubble_Net_Stock_Charts.html#chapter-32-bubble-net-stock-charts","text":"Topics The Bubble Chart; The Net Chart; The Stock Chart: basic and modified candle sticks; Stock Chart and Line Graph Example folders: \"Chart2 Tests\" and \"Utils\" This chapter concludes my use of the Chart2Views.java example by looking at how bubble, net and stock charts can be generated from spreadsheet data. The relevant lines of Chart2Views.java are: // part of Chart2Views.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( CHARTS_DATA , loader ); GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // ---- use different chart templates ---- labeledBubbleChart ( doc , sheet ); // see section 1 // netChart(doc, sheet); // section 2 // happyStockChart(doc, sheet); // section 3 // stockPricesChart(doc, sheet); // section 4 Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main()","title":"Chapter 32. Bubble, Net, Stock Charts"},{"location":"32-Bubble_Net_Stock_Charts.html#1-the-bubble-chart","text":"A bubble chart is a variation of a scatter chart where each data point shows the relationship between three variables. Two variables are used for a bubble's (x, y) coordinate, and the third affects the bubble's size. labeledBubbleChart() in Chart2Views.java utilizes the \"World data\" table in \"chartsData.ods\" (see Figure 1). Figure 1. The \"World data\" Table. The data range passed to the Chart.insertChart() uses the first three columns of the table; the \"Country\" column is added separately. The generated scatter chart is shown in Figure 2. Figure 2. Bubble Chart for the Table in Figure 1. labeledBubbleChart() is: // in Chart2Views.java private static void labeledBubbleChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"H63:J93\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A62\" , 18 , 11 , \"Bubble\" ); Calc . gotoCell ( doc , \"A62\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"H62\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"H63\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"I63\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . viewLegend ( chartDoc , true ); // change the data points XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc ); Props . setProperty ( ds [ 0 ] , \"Transparency\" , 50 ); // 100 == fully transparent Props . setProperty ( ds [ 0 ] , \"BorderStyle\" , LineStyle . SOLID ); Props . setProperty ( ds [ 0 ] , \"BorderColor\" , Calc . RED ); Props . setProperty ( ds [ 0 ] , \"LabelPlacement\" , Chart2 . DP_CENTER ); // Chart2.setDataPointLabels(chartDoc, Chart2.DP_NUMBER); /* String sheetName = Calc.getSheetName(sheet); String label = sheetName + \".\" + \"K63\"; String names = sheetName + \".\" + \"K64:K93\"; Chart2.addCatLabels(chartDoc, label, names); */ } // end of labeledBubbleChart() The transparency and border properties of all the data points are set via the DataPointProperties class for the data series. Without transparency, large bubbles could obscure or completely hide smaller bubbles. If the call to Chart2.setDataPointLabels() is uncommented, the result is messy, as shown in Figure 3. Figure 3. Numerically Labeled Bubble Chart for the Table in Figure 1. Instead of labeling the bubbles with population sizes, it would be better to use the \"Country\" values (see Figure 1). Chart2.addCatLabels() implements this feature, producing Figure 4. Figure 4. Category Labeled Bubble Chart for the Table in Figure 1. Chart2.addCatLabels() employs the \"Country\" data to create an XLabeledDataSequence object which is assigned the role \"categories\". It is then assigned to the x-axis as category-based scale data: // in the Chart2 class public static void addCatLabels ( XChartDocument chartDoc , String dataLabel , String dataRange ) { // create 'categories' labeled data sequence XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence dLSeq = createLDSeq ( dp , \"categories\" , dataLabel , dataRange ); // assign sequence to x-axis as category scale data XAxis axis = getAxis ( chartDoc , X_AXIS , 0 ); if ( axis == null ) return ; ScaleData sd = axis . getScaleData (); sd . Categories = dLSeq ; axis . setScaleData ( sd ); setDataPointLabels ( chartDoc , Chart2 . DP_CATEGORY ); // label the data points with categories } // end of addCatLabels() When setDataPointLabels() displays category data for the points, the new x-axis categories are utilized.","title":"1.  The Bubble Chart"},{"location":"32-Bubble_Net_Stock_Charts.html#2-the-net-chart","text":"The net chart (also called a radar chart) is useful for comparing multiple columns of data (often between three and eight columns) in a 2D arrangement that resembles a spider's web. Although net charts have an interesting look, a lot of people dislike them (e.g. see \"A Critique of Radar Charts\" by Graham Odds at https://blog.scottlogic.com/2011/09/23/a-critique-of-radar-charts.html ). netChart() in Chart2Views.java utilizes the \"No of Calls per Day\" table in \"chartsData.ods\" (see Figure 5). Figure 5. The \"No of Calls per Day\" Table. The generated net chart is shown in Figure 6. Figure 6. Net Chart for the Table in Figure 5. netChart() is: // in Chart2Views.java private static void netChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A56:D63\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"E55\" , 16 , 11 , \"NetLine\" ); // Net, NetLine, NetSymbol // StackedNet, PercentStackedNet Calc . gotoCell ( doc , \"E55\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A55\" )); Chart2 . viewLegend ( chartDoc , true ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // reverse x-axis so days increase clockwise around net XAxis xAxis = Chart2 . getXAxis ( chartDoc ); ScaleData sd = xAxis . getScaleData (); sd . Orientation = AxisOrientation . REVERSE ; xAxis . setScaleData ( sd ); } // end of netChart() Different net chart templates allow points to be shown, the areas filled with color, and the lines to be stacked or displayed as percentages. netChart() changes the x-axis which wraps around the circumference of the chart. By default, the axis is drawn in a counter-clockwise direction starting from the top of the net. This order doesn't seem right for the days of the week in this example, so I made the order clockwise, as in Figure 6.","title":"2.  The Net Chart"},{"location":"32-Bubble_Net_Stock_Charts.html#3-the-stock-chart","text":"A stock chart is a specialized column graph for displaying stocks and shares information. All stock chart templates require at least three columns of data concerning the lowest price, highest price, and closing price of a stock (or share). It's also possible to include two other columns that detail the stock's opening price and transaction volume. The stock template names reflect the data columns they utilize: StockLowHighClose StockOpenLowHighClose StockVolumeLowHighClose StockVolumeOpenLowHighClose The names also indicate the ordering of the columns in the data range supplied to the template. For example, \"StockVolumeOpenLowHighClose\" requires five columns of data in the order: transaction volume, opening price, lowest price, highest price, and closing price. happyStockChart() in Chart2Views.java utilizes the \"Happy Systems (HASY)\" table in \"chartsData.ods\" (see Figure 7). Figure 7. The \"Happy Systems (HASY)\" Table. The table has six columns, the first being the x-axis categories, which are usually dates. The other columns follow the order required by the \"StockVolumeOpenLowHighClose\" template. The generated stock chart is shown in Figure 8. Figure 8. Stock Chart for the Table in Figure 7. The chart is made up of two graphs with a common x-axis: a column graph for the stock volume on each day, and a candle-stick graph showing the lowest, opening, closing, and highest stock values. Figure 9 gives details of how these elements are drawn. Figure 9. The Elements of a Stock Chart. The thin red lines drawn on the columns in Figure 9 denote the range between the lowest and highest stock value on that day. The white and black blocks represent the stock's change between its opening and closing price. A white block (often called a \"white day\") means the price has increased, while black (a \"black day\") means that it has decreased. happyStockChart() is: // in Chart2Views.java private static void happyStockChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A86:F104\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"A105\" , 25 , 14 , \"StockVolumeOpenLowHighClose\" ); Calc . gotoCell ( doc , \"A105\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A85\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A86\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B86\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Chart2 . setYAxis2Title ( chartDoc , \"Stock Value\" ); Chart2 . rotateYAxis2Title ( chartDoc , 90 ); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); // too cluttered if numerical data is shown // change 2nd y-axis min and max; default is poor ($0 - $20) XAxis yAxis2 = Chart2 . getYAxis2 ( chartDoc ); ScaleData sd = yAxis2 . getScaleData (); sd . Minimum = 83 ; sd . Maximum = 103 ; yAxis2 . setScaleData ( sd ); // more stock chart code; explained in a moment... } // end of happyStockChart() happyStockChart() sets and rotates the secondary y-axis title, which appears on the right of the chart. Chart2.setYAxis2Title() and Chart2.rotateYAxis2Title() are implemented in the same way as Chart2.setYAxisTitle() and Chart2.rotateYAxisTitle() described in Chapter 29, section 3. happyStockChart() also changes the second y-axis' range; the default shows prices between $0 and $20, which is too low. New minimum and maximum values are assigned to the axis' scale data.","title":"3.  The Stock Chart"},{"location":"32-Bubble_Net_Stock_Charts.html#31-modifying-the-chart-dates","text":"A common problem is that date information clutters the stock chart, making it harder to read. Figure 8 shows that the stock template is clever enough to only draw every second date, but this is still too much information for the limited space. One solution is to increase the x-axis interval so a tick mark (and date string) is only drawn for every third day, as in Figure 10. Figure 10. Stock Chart with Three-day Intervals for the X-Axis. Changing the interval is implemented by adjusting the time increment for the x-axis in its ScaleData object: // part of happyStockChart() in Chart2Views.java... : // change x-axis type from number to date XAxis xAxis = Chart2 . getXAxis ( chartDoc ); sd = xAxis . getScaleData (); sd . AxisType = AxisType . DATE ; // set major increment to 3 days TimeInterval ti = new TimeInterval ( 3 , TimeUnit . DAY ); TimeIncrement tc = new TimeIncrement (); tc . MajorTimeInterval = ti ; sd . TimeIncrement = tc ; xAxis . setScaleData ( sd ); Before the interval can be changed, the axis type must be changed to be of type DATE. Information on the ScaleData class can be accessed by calling lodoc chart2 scaledata . Another technique for making the dates easier to read is to rotate their labels. The following code rotates each label counter-clockwise by 45 degrees: // part of happyStockChart() in Chart2Views.java... : XAxis xAxis = Chart2 . getXAxis ( chartDoc ); Props . setProperty ( xAxis , \"TextRotation\" , 45 ); The resulting chart is shown in Figure 11. Figure 11. Stock Chart with Rotated X-Axis Labels. Note that the template has automatically switched back to showing every date instead of every second one in Figure 8.","title":"3.1.  Modifying the Chart Dates"},{"location":"32-Bubble_Net_Stock_Charts.html#32-changing-the-stock-values-appearance","text":"This section describes two changes to the candle stick part of the chart: adjusting the colors used in the \"white days\" and \"black days\" blocks, and making the high-low stock line easier to read. The results appear in Figure 12. Figure 12. Stock Chart with Modified Candle Sticks. A stock chart is made up of two chart types: a column chart type for the volume information, and a candle stick chart type for the stock prices. This information can be listed by calling Chart2.printChartTypes(): // in happyStockChart() Chart2Views . javaChart2 . printChartTypes ( chartDoc ); It produces: No. of chart types: 2 com.sun.star.chart2.ColumnChartType com.sun.star.chart2.CandleStickChartType In order to affect the candle stick chart type's data it is necessary to access its XChartType instance. This can be done with the two-argument version of Chart2.findChartType(): // in happyStockChart() XChartType candleCT = Chart2 . findChartType ( chartDoc , \"CandleStickChartType\" ); Figure 13 shows that the XChartType interface is supported by the ChartType service, and the CandleStickChartType subclass. Figure 13. The ChartType Service. CandleStickChartType contains some useful properties, including \"WhiteDay\" and \"BlackDay\" (for details call lodoc chart2 CandleStickChartType ). These properties store sets containing multiple values from the FillProperties and LineProperties services. They can be accessed like so: // part of happyStockChart() in Chart2Views.java... : XChartType candleCT = Chart2 . findChartType ( chartDoc , \"CandleStickChartType\" ); XPropertySet props = Lo . qi ( XPropertySet . class , Props . getProperty ( candleCT , \"WhiteDay\" )); Props . showObjProps ( \"WhiteDay\" , props ); Props . setProperty ( props , \"FillColor\" , Calc . GREEN ); The same sort of change can be done to the \"FillColor\" property inside the \"BlackDay\" property set. Both changes are implemented inside Chart2.colorStockBars(): // in the Chart2 class public static void colorStockBars ( XChartType ct , int wDayColor , int bDayColor ) { if ( ! ct . getChartType (). equals ( \"com.sun.star.chart2.CandleStickChartType\" )) System . out . println ( \"Chart type not a candle stick: \" + ct . getChartType ()); else { XPropertySet props = Lo . qi ( XPropertySet . class , Props . getProperty ( ct , \"WhiteDay\" )); Props . setProperty ( props , \"FillColor\" , wDayColor ); props = Lo . qi ( XPropertySet . class , Props . getProperty ( ct , \"BlackDay\" )); Props . setProperty ( props , \"FillColor\" , bDayColor ); } } // end of colorStockBars() Chart2.findChartType() and Chart2.colorStockBars() are called at the end of happyStockChart() to change the \"white day\" blocks to green and the \"black day\" blocks to red: // part of happyStockChart() in Chart2Views.java... : XChartType candleCT = Chart2 . findChartType ( chartDoc , \"CandleStickChartType\" ); Chart2 . colorStockBars ( candleCT , Calc . GREEN , Calc . RED ); Making the high-low lines thicker and yellow requires access to the data series in the candle stick chart type (as shown in Figure 13). This is implemented by using the two- argument version of Chart2.getDataSeries(): XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc , \"CandleStickChartType\" ); The high-low lines are adjusted via the \"LineWidth\" and \"Color\" properties in the series. The code at the end of happyStockChart() is: // part of happyStockChart() in Chart2Views.java... : XDataSeries [] ds = Chart2 . getDataSeries ( chartDoc , \"CandleStickChartType\" ); Props . setProperty ( ds [ 0 ] , \"LineWidth\" , 120 ); // in 1/100 mm Props . setProperty ( ds [ 0 ] , \"Color\" , Calc . YELLOW );","title":"3.2.  Changing the Stock Values Appearance"},{"location":"32-Bubble_Net_Stock_Charts.html#4-adding-a-line-graph-to-a-stock-chart","text":"stockPricesChart() in Chart2Views.java utilizes the \"Calc Guide Stock Prices\" table in \"chartsData.ods\" (see Figure 14). Figure 14. The \"Calc Guide Stock Prices\" Table. The stock chart is created using the first five columns, excluding the \"Pork Bellies\" data. There's no \"Volume\" column for the stocks, so the \"StockOpenLowHighClose\" template is employed. The stock chart is shown in Figure 15. Figure 15. Stock Chart for the Table in Figure 14. stockPricesChart() is: // in Chart2Views.java private static void stockPricesChart ( XSpreadsheetDocument doc , XSpreadsheet sheet ) { CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"E141:I146\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"E148\" , 12 , 11 , \"StockOpenLowHighClose\" ); Calc . gotoCell ( doc , \"A139\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"E140\" )); Chart2 . setDataPointLabels ( chartDoc , Chart2 . DP_NONE ); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"E141\" )); Chart2 . setYAxisTitle ( chartDoc , \"Dollars\" ); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); // more code for adding the \"Pork Bellies\" line... } // end of stockPricesChart() A line graph showing the movement of \"Pork Bellies\" is added to the chart by Chart2.addStockLine(). The additional code at the end of stockPricesChart() is: // part of stockPricesChart() in Chart2Views.java... : String sheetName = Calc . getSheetName ( sheet ); String porkLabel = sheetName + \".\" + \"J141\" ; String porkPoints = sheetName + \".\" + \"J142:J146\" ; Chart2 . addStockLine ( chartDoc , porkLabel , porkPoints ); Chart2 . viewLegend ( chartDoc , true ); The resulting change to the stock chart is shown in Figure 16. Figure 16. Stock Chart with Line Graph for the Table in Figure 15. A data series belongs to a chart type, which is part of the coordinates system. Therefore the first task is to obtain the chart's coordinate system. A new line chart type is added to it, and an empty data series is inserted into the chart type. The addition of a new chart type to the chart's coordinate system is preformed by Chart2.addChartType(). The following adds a line chart type: // part of Chart2.addStockLine(); see below... XChartType ct = Chart2 . addChartType ( chartDoc , \"LineChartType\" ); Chart2.addChartType() uses Chart2.getCoordSystem() to get the chart's coordinate system, and then converts it into an XChartTypeContainer so the new chart type can be added: // in the Chart2 class public static XChartType addChartType ( XChartDocument chartDoc , String chartType ) { // create new chart type XChartType ct = Lo . createInstanceMCF ( XChartType . class , \"com.sun.star.chart2.\" + chartType ); if ( ct == null ) { System . out . println ( \"Unable to create XChartType: \" + chartType ); return ct ; } // add chart type to coord system XCoordinateSystem coordSys = getCoordSystem ( chartDoc ); XChartTypeContainer ctCon = Lo . qi ( XChartTypeContainer . class , coordSys ); ctCon . addChartType ( ct ); return ct ; } // end of addChartType() Chart2.addChartType() returns a reference to the new chart type, and an empty data series is added to it by converting the chart type into an XDataSeriesContainer: // part of Chart2.addStockLine(); see below... : XChartType ct = addChartType ( chartDoc , \"LineChartType\" ); XDataSeriesContainer dataSeriesCnt = Lo . qi ( XDataSeriesContainer . class , ct ); // create (empty) data series in the line chart XDataSeries ds = Lo . createInstanceMCF ( XDataSeries . class , \"com.sun.star.chart2.DataSeries\" ); if ( ds == null ) { System . out . println ( \"Unable to create XDataSeries: \" + ds ); return ; } dataSeriesCnt . addDataSeries ( ds ); This empty data series is filled with data points via its XDataSink interface, using the steps shown in Chapter 31, section 5.1, Figure 13. A DataProvider service is required so that two XDataSequence objects can be instantiated, one for the label of an XLabeledDataSequence object, the other for its data. The XDataSequence object representing the data must have its \"Role\" property set to \"values-y\" since it will become the y-coordinates of the line graph. The task of building the XLabeledDataSequence object is handled by Chart2.createLDSeq(), which I used in Chapter 31, section 5.1 to add error bars to a scatter chart, and in section 1 to place category labels in a bubble chart. The code is: // part of Chart2.addStockLine(); see below... : // treat series as a data sink XDataSink dataSink = Lo . qi ( XDataSink . class , ds ); // build a sequence representing the y-axis data XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence dLSeq = createLDSeq ( dp , \"values-y\" , dataLabel , dataRange ); // add sequence to the sink XLabeledDataSequence [] ldSeqArr = { dLSeq }; dataSink . setData ( ldSeqArr ); All the preceding code fragments of this section are wrapped up inside Chart2.addStockLine(): // in the Chart2 class public static void addStockLine ( XChartDocument chartDoc , String dataLabel , String dataRange ) { // add (empty) line chart to the doc XChartType ct = addChartType ( chartDoc , \"LineChartType\" ); XDataSeriesContainer dataSeriesCnt = Lo . qi ( XDataSeriesContainer . class , ct ); // create (empty) data series in the line chart XDataSeries ds = Lo . createInstanceMCF ( XDataSeries . class , \"com.sun.star.chart2.DataSeries\" ); if ( ds == null ) { System . out . println ( \"Unable to create XDataSeries: \" + ds ); return ; } Props . setProperty ( ds , \"Color\" , 0xFF0000 ); dataSeriesCnt . addDataSeries ( ds ); // treat series as a data sink XDataSink dataSink = Lo . qi ( XDataSink . class , ds ); // build a sequence representing the y-axis data XDataProvider dp = chartDoc . getDataProvider (); XLabeledDataSequence dLSeq = createLDSeq ( dp , \"values-y\" , dataLabel , dataRange ); // add sequence to the sink XLabeledDataSequence [] ldSeqArr = { dLSeq }; dataSink . setData ( ldSeqArr ); } // end of addStockLine() Chart2.addStockLine() is passed a reference to the chart document, and references to the label and data for the line graph: // part of stockPricesChart() in Chart2Views.java... : String sheetName = Calc . getSheetName ( sheet ); String porkLabel = sheetName + \".\" + \"J141\" ; String porkPoints = sheetName + \".\" + \"J142:J146\" ; Chart2 . addStockLine ( chartDoc , porkLabel , porkPoints );","title":"4.  Adding a Line Graph to a Stock Chart"},{"location":"33-Charts_in_Others_Docs.html","text":"Chapter 33. Using Charts in Other Documents \u00b6 Topics Copy-and-Paste Dispatches; Adding a Chart to a Text Document; Adding a Chart to a Slide Document; Saving the Chart as an Image Example folders: \"Chart2 Tests\" and \"Utils\" This chapter describes two examples, TextChart.java and SlideChart.java, which illustrate a copy-and-paste approach to adding charts to text and slide documents. SlideChart.java also shows how to save a chart as an image file. There are three tricky aspects to coding with the clipboard. Clipboard manipulation requires the use of UNO dispatch commands (namely \".uno:Copy\" and \".uno:Paste\"). The function that sends out a dispatch command returns immediately, but Office may take a few milliseconds to process the request. This often introduces a timing issue because the next step in the program should be delayed in order to give the dispatch time to be processed. Another timing problem is that dispatch commands assume that the Office application window is visible and active. Office can be made the focus of the OS, but the few milliseconds between achieving this and sending the dispatch may be enough for another OS process to pull the focus away from Office. The dispatch will then arrive at the wrong process, with unpredictable results. Clipboard programming usually involves two documents. In this case, the spreadsheet that generates the chart, and the text or slide document that receives the image. One of the limitations of my support classes is that many methods assume only one document is open at a time. To be safe, the program should close the spreadsheet before the text or slide document is opened or created. Bearing all these issues in mind, is there a better approach for placing a chart in a non- spreadsheet document? The answer should be OLE (Object Linking and Embedding), which is Windows' solution to this very problem. Unfortunately, I was unable to get this mechanism to work via the API; the best I achieved was the creation of an empty chart in a text document, without any data. Looking back through old forum posts, it appears that OLE didn't work in the old chart module either. I'll look again at clipboard programming in Chapter 43, when I consider using Java's copy-and-paste API, and describe more general examples using Writer, Calc, Impress, and Base documents. 1. Adding a Chart to a Text Document \u00b6 TextChart.java generates a column chart using the \"Sneakers Sold this Month\" table from chartsData.ods, copies it to the clipboard, and closes the spreadsheet. Then a text document is created, and the chart image is pasted into it, resulting in the page shown in Figure 1. Figure 1. Text Document with a Chart Image. TextChart.java relies on my Write support class from Part 2. The \"Hello LibreOffice.\" paragraph is written into a new document, then the chart is pasted in from the clipboard, a paragraph (\"Figure 1. Sneakers Bar Chart\") added as a figure legend, and another paragraph (\"Some more text\u2026\") added at the end for good measure. The document is saved to \"hello.odt\" and the program ends. main() is: // in TextChart.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); boolean hasChart = makeColChart ( loader , \"chartsData.ods\" ); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // to make the doc visible XTextCursor cursor = Write . getCursor ( doc ); cursor . gotoEnd ( false ); // make sure at end of doc before appending Write . appendPara ( cursor , \"Hello LibreOffice.\\n\" ); if ( hasChart ) { Lo . delay ( 1000 ); Lo . dispatchCmd ( \"Paste\" ); } // add chart legend Write . appendPara ( cursor , \"Figure 1. Sneakers Column Chart.\\n\" ); Write . stylePrevParagraph ( cursor , \"ParaAdjust\" , com . sun . star . style . ParagraphAdjust . CENTER ); Write . appendPara ( cursor , \"Some more text...\\n\" ); Lo . saveDoc ( doc , \"hello.odt\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() It's important that the text document is visible and in focus, so GUI.setVisible() is called after the document's creation. There's also a call to Lo.delay() before the paste ( Lo.dispatchCmd(\"Paste\") ) to ensure that earlier text writes have time to finish. 1.1. Making the Chart \u00b6 TextChart.java uses makeColChart() to generate a chart from a spreadsheet: // in TextChart.java private static boolean makeColChart ( XComponentLoader loader , String fnm ) // draw a column chart; uses \"Sneakers Sold this Month\" table // this method appears in TextChart.java and SlideChart.java { XSpreadsheetDocument ssdoc = Calc . openDoc ( fnm , loader ); if ( ssdoc == null ) { System . out . println ( \"Could not open \" + fnm ); return false ; } GUI . setVisible ( ssdoc , true ); // or selection not copied XSpreadsheet sheet = Calc . getSheet ( ssdoc , 0 ); CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A2:B8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"C3\" , 15 , 11 , \"Column\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A2\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B2\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Lo . delay ( 1000 ); Chart2 . copyChart ( ssdoc , sheet ); Lo . closeDoc ( ssdoc ); return true ; } // end of makeColChart() makeColChart() uses the table from chartsData.ods shown in Figure 2 to generate the chart in Figure 1. Figure 2. The \"Sneakers Sold this Month\" Table. The only new feature in makeColChart() is the call to Chart2.copyChart() which copies the chart to the clipboard. Two easy to overlook parts of makeColChart() are the call to GUI.setVisible(), which makes the spreadsheet and chart visible and active, and the call to Lo.delay() before Chart2.copyChart(). This ensures that there's enough time for the graph to be drawn before the \".uno:Copy\" dispatch. Also note that the spreadsheet is closed before makeColChart() returns. This stops the subsequent creation of the text document back in main() from being possibly affected by an open spreadsheet 1.2. Copying a Chart \u00b6 Chart2.copyChart() obtains a reference to the chart as an XShape, which makes it possible to select it with an XSelectionSupplier. This selection is used automatically as the data for the \".uno:Copy\" dispatch. copyChart() is: // in the Chart2 class public static void copyChart ( XSpreadsheetDocument ssdoc , XSpreadsheet sheet ) { XShape chartShape = getChartShape ( sheet ); XComponent doc = Lo . qi ( XComponent . class , ssdoc ); XSelectionSupplier supplier = GUI . getSelectionSupplier ( doc ); supplier . select (( Object ) chartShape ); Lo . dispatchCmd ( \"Copy\" ); } // end of copyChart() Every spreadsheet is also a draw page, so the Spreadsheet service has an XDrawPageSupplier interface, and its getDrawPage() method returns an XDrawPage reference. For example: // part of Chart2.getChartShape(); see below... XDrawPageSupplier pageSupplier = Lo . qi ( XDrawPageSupplier . class , sheet ); XDrawPage drawPage = pageSupplier . getDrawPage (); The shapes in a draw page can be accessed by index. Also each shape has a \"CLSID\" property which can be used to identify 'special' shapes representing math formulae or charts. The search for a chart shape is coded as: // part of Chart2.getChartShape(); see below... XShape shape = null ; String classID ; int numShapes = drawPage . getCount (); for ( int i = 0 ; i < numShapes ; i ++ ) { // loop through shapes try { shape = Lo . qi ( XShape . class , drawPage . getByIndex ( i )); classID = ( String ) Props . getProperty ( shape , \"CLSID\" ); if ( classID . toLowerCase (). equals ( Lo . CHART_CLSID )) // check if shape's class ID is for a chart break ; } catch ( Exception e ) {} } These two pieces of code are combined in Chart2.getChartShape(): // in the Chart2 class public static XShape getChartShape ( XSpreadsheet sheet ) { XDrawPageSupplier pageSupplier = Lo . qi ( XDrawPageSupplier . class , sheet ); XDrawPage drawPage = pageSupplier . getDrawPage (); XShape shape = null ; String classID ; int numShapes = drawPage . getCount (); for ( int i = 0 ; i < numShapes ; i ++ ) { try { shape = Lo . qi ( XShape . class , drawPage . getByIndex ( i )); classID = ( String ) Props . getProperty ( shape , \"CLSID\" ); if ( classID . toLowerCase (). equals ( Lo . CHART_CLSID )) break ; } catch ( Exception e ) {} } return shape ; } // end of getChartShape() 2. Adding a Chart to a Slide Document \u00b6 SlideChart.java generates the same column chart as TableChart.java, using almost the same version of makeColChart(). After the chart has been copied to the clipboard and the spreadsheet closed, a slide document is created and the chart pasted onto the first slide. The chart appears in the center of the slide by default, but is moved down to make room for some text. The end result is shown in Figure 3. Figure 3. Slide Document with a Chart Shape. The main() function of SlideChart.java is: // in SlideChart.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); boolean hasChart = makeColChart ( loader , \"chartsData.ods\" ); XComponent doc = Draw . createImpressDoc ( loader ); if ( doc == null ) { System . out . println ( \"Draw doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); XText body = Draw . bulletsSlide ( currSlide , \"Sneakers Are Selling!\" ); Draw . addBullet ( body , 0 , \"Sneaker profits have increased\" ); if ( hasChart ) { Lo . delay ( 1000 ); Lo . dispatchCmd ( \"Paste\" ); } // find and move picture XShape oleShape = Draw . findShapeByType ( currSlide , \"com.sun.star.drawing.OLE2Shape\" ); if ( oleShape != null ) { Size slideSize = Draw . getSlideSize ( currSlide ); Size shapeSize = Draw . getSize ( oleShape ); Point shapePos = Draw . getPosition ( oleShape ); int y = slideSize . Height - shapeSize . Height - 20 ; Draw . setPosition ( oleShape , shapePos . X , y ); // move pic down } Lo . saveDoc ( doc , \"makeslide.odp\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The chart is pasted into the slide as an OLE2Shape object, which allows it to be found by Draw.findShapeByType(). The shape is moved down the slide by calculating a new (x, y) coordinate for its top-left corner, and calling Draw.setPosition(). 3. Saving the Chart as an Image \u00b6 The only change to makeColChart() in SlideChart.java is the addition of the line: // in makeColChart() in SlideChart.java Images . saveImage ( Chart2 . getChartImage ( sheet ), \"chartImage.png\" ); This saves the chart as a PNG image, which can be loaded by other applications. Images.saveImage() accepts a BufferedImage argument and filename: // in Images class public static void saveImage ( BufferedImage im , String fnm ) { try { System . out . println ( \"Saving image to \" + fnm ); ImageIO . write ( im , \"png\" , new File ( fnm )); } catch ( java . io . IOException e ) { System . out . println ( \"Could not save image to \" + fnm + \": \" + e ); } } // end of saveImage() Chart2.getChartImage() finds the chart in the spreadsheet and returns it as a BufferedImage object. // in the Chart2 class public static BufferedImage getChartImage ( XSpreadsheet sheet ) { XShape chartShape = Chart2 . getChartShape ( sheet ); if ( chartShape == null ) { System . out . println ( \"Could not find a chart\" ); return null ; } XGraphic graphic = Lo . qi ( XGraphic . class , Props . getProperty ( chartShape , \"Graphic\" ) ); if ( graphic == null ) { System . out . println ( \"No chart graphic found\" ); return null ; } String tempFnm = FileIO . createTempFile ( \"png\" ); if ( tempFnm == null ) { System . out . println ( \"Could not create a temp file for graphic\" ); return null ; } Images . saveGraphic ( graphic , tempFnm , \"png\" ); BufferedImage im = Images . loadImage ( tempFnm ); FileIO . deleteFile ( tempFnm ); return im ; } // end of getChartImage() Chart2.getChartImage() finds the chart in the sheet by using Chart2.getChartShape() described earlier. The shape is cast to an Office graphics object, of type XGraphic. getChartImage() then creates a temporary file to store the XGraphic image, which is immediately re-loaded as a BufferedImage. This is a bit nasty, but the only way I've found to convert XGraphic to BufferedImage.","title":"Chapter 33. Using Charts in Other Documents"},{"location":"33-Charts_in_Others_Docs.html#chapter-33-using-charts-in-other-documents","text":"Topics Copy-and-Paste Dispatches; Adding a Chart to a Text Document; Adding a Chart to a Slide Document; Saving the Chart as an Image Example folders: \"Chart2 Tests\" and \"Utils\" This chapter describes two examples, TextChart.java and SlideChart.java, which illustrate a copy-and-paste approach to adding charts to text and slide documents. SlideChart.java also shows how to save a chart as an image file. There are three tricky aspects to coding with the clipboard. Clipboard manipulation requires the use of UNO dispatch commands (namely \".uno:Copy\" and \".uno:Paste\"). The function that sends out a dispatch command returns immediately, but Office may take a few milliseconds to process the request. This often introduces a timing issue because the next step in the program should be delayed in order to give the dispatch time to be processed. Another timing problem is that dispatch commands assume that the Office application window is visible and active. Office can be made the focus of the OS, but the few milliseconds between achieving this and sending the dispatch may be enough for another OS process to pull the focus away from Office. The dispatch will then arrive at the wrong process, with unpredictable results. Clipboard programming usually involves two documents. In this case, the spreadsheet that generates the chart, and the text or slide document that receives the image. One of the limitations of my support classes is that many methods assume only one document is open at a time. To be safe, the program should close the spreadsheet before the text or slide document is opened or created. Bearing all these issues in mind, is there a better approach for placing a chart in a non- spreadsheet document? The answer should be OLE (Object Linking and Embedding), which is Windows' solution to this very problem. Unfortunately, I was unable to get this mechanism to work via the API; the best I achieved was the creation of an empty chart in a text document, without any data. Looking back through old forum posts, it appears that OLE didn't work in the old chart module either. I'll look again at clipboard programming in Chapter 43, when I consider using Java's copy-and-paste API, and describe more general examples using Writer, Calc, Impress, and Base documents.","title":"Chapter 33. Using Charts in Other Documents"},{"location":"33-Charts_in_Others_Docs.html#1-adding-a-chart-to-a-text-document","text":"TextChart.java generates a column chart using the \"Sneakers Sold this Month\" table from chartsData.ods, copies it to the clipboard, and closes the spreadsheet. Then a text document is created, and the chart image is pasted into it, resulting in the page shown in Figure 1. Figure 1. Text Document with a Chart Image. TextChart.java relies on my Write support class from Part 2. The \"Hello LibreOffice.\" paragraph is written into a new document, then the chart is pasted in from the clipboard, a paragraph (\"Figure 1. Sneakers Bar Chart\") added as a figure legend, and another paragraph (\"Some more text\u2026\") added at the end for good measure. The document is saved to \"hello.odt\" and the program ends. main() is: // in TextChart.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); boolean hasChart = makeColChart ( loader , \"chartsData.ods\" ); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // to make the doc visible XTextCursor cursor = Write . getCursor ( doc ); cursor . gotoEnd ( false ); // make sure at end of doc before appending Write . appendPara ( cursor , \"Hello LibreOffice.\\n\" ); if ( hasChart ) { Lo . delay ( 1000 ); Lo . dispatchCmd ( \"Paste\" ); } // add chart legend Write . appendPara ( cursor , \"Figure 1. Sneakers Column Chart.\\n\" ); Write . stylePrevParagraph ( cursor , \"ParaAdjust\" , com . sun . star . style . ParagraphAdjust . CENTER ); Write . appendPara ( cursor , \"Some more text...\\n\" ); Lo . saveDoc ( doc , \"hello.odt\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() It's important that the text document is visible and in focus, so GUI.setVisible() is called after the document's creation. There's also a call to Lo.delay() before the paste ( Lo.dispatchCmd(\"Paste\") ) to ensure that earlier text writes have time to finish.","title":"1.  Adding a Chart to a Text Document"},{"location":"33-Charts_in_Others_Docs.html#11-making-the-chart","text":"TextChart.java uses makeColChart() to generate a chart from a spreadsheet: // in TextChart.java private static boolean makeColChart ( XComponentLoader loader , String fnm ) // draw a column chart; uses \"Sneakers Sold this Month\" table // this method appears in TextChart.java and SlideChart.java { XSpreadsheetDocument ssdoc = Calc . openDoc ( fnm , loader ); if ( ssdoc == null ) { System . out . println ( \"Could not open \" + fnm ); return false ; } GUI . setVisible ( ssdoc , true ); // or selection not copied XSpreadsheet sheet = Calc . getSheet ( ssdoc , 0 ); CellRangeAddress rangeAddr = Calc . getAddress ( sheet , \"A2:B8\" ); XChartDocument chartDoc = Chart2 . insertChart ( sheet , rangeAddr , \"C3\" , 15 , 11 , \"Column\" ); Chart2 . setTitle ( chartDoc , Calc . getString ( sheet , \"A1\" )); Chart2 . setXAxisTitle ( chartDoc , Calc . getString ( sheet , \"A2\" )); Chart2 . setYAxisTitle ( chartDoc , Calc . getString ( sheet , \"B2\" )); Chart2 . rotateYAxisTitle ( chartDoc , 90 ); Lo . delay ( 1000 ); Chart2 . copyChart ( ssdoc , sheet ); Lo . closeDoc ( ssdoc ); return true ; } // end of makeColChart() makeColChart() uses the table from chartsData.ods shown in Figure 2 to generate the chart in Figure 1. Figure 2. The \"Sneakers Sold this Month\" Table. The only new feature in makeColChart() is the call to Chart2.copyChart() which copies the chart to the clipboard. Two easy to overlook parts of makeColChart() are the call to GUI.setVisible(), which makes the spreadsheet and chart visible and active, and the call to Lo.delay() before Chart2.copyChart(). This ensures that there's enough time for the graph to be drawn before the \".uno:Copy\" dispatch. Also note that the spreadsheet is closed before makeColChart() returns. This stops the subsequent creation of the text document back in main() from being possibly affected by an open spreadsheet","title":"1.1.  Making the Chart"},{"location":"33-Charts_in_Others_Docs.html#12-copying-a-chart","text":"Chart2.copyChart() obtains a reference to the chart as an XShape, which makes it possible to select it with an XSelectionSupplier. This selection is used automatically as the data for the \".uno:Copy\" dispatch. copyChart() is: // in the Chart2 class public static void copyChart ( XSpreadsheetDocument ssdoc , XSpreadsheet sheet ) { XShape chartShape = getChartShape ( sheet ); XComponent doc = Lo . qi ( XComponent . class , ssdoc ); XSelectionSupplier supplier = GUI . getSelectionSupplier ( doc ); supplier . select (( Object ) chartShape ); Lo . dispatchCmd ( \"Copy\" ); } // end of copyChart() Every spreadsheet is also a draw page, so the Spreadsheet service has an XDrawPageSupplier interface, and its getDrawPage() method returns an XDrawPage reference. For example: // part of Chart2.getChartShape(); see below... XDrawPageSupplier pageSupplier = Lo . qi ( XDrawPageSupplier . class , sheet ); XDrawPage drawPage = pageSupplier . getDrawPage (); The shapes in a draw page can be accessed by index. Also each shape has a \"CLSID\" property which can be used to identify 'special' shapes representing math formulae or charts. The search for a chart shape is coded as: // part of Chart2.getChartShape(); see below... XShape shape = null ; String classID ; int numShapes = drawPage . getCount (); for ( int i = 0 ; i < numShapes ; i ++ ) { // loop through shapes try { shape = Lo . qi ( XShape . class , drawPage . getByIndex ( i )); classID = ( String ) Props . getProperty ( shape , \"CLSID\" ); if ( classID . toLowerCase (). equals ( Lo . CHART_CLSID )) // check if shape's class ID is for a chart break ; } catch ( Exception e ) {} } These two pieces of code are combined in Chart2.getChartShape(): // in the Chart2 class public static XShape getChartShape ( XSpreadsheet sheet ) { XDrawPageSupplier pageSupplier = Lo . qi ( XDrawPageSupplier . class , sheet ); XDrawPage drawPage = pageSupplier . getDrawPage (); XShape shape = null ; String classID ; int numShapes = drawPage . getCount (); for ( int i = 0 ; i < numShapes ; i ++ ) { try { shape = Lo . qi ( XShape . class , drawPage . getByIndex ( i )); classID = ( String ) Props . getProperty ( shape , \"CLSID\" ); if ( classID . toLowerCase (). equals ( Lo . CHART_CLSID )) break ; } catch ( Exception e ) {} } return shape ; } // end of getChartShape()","title":"1.2.  Copying a Chart"},{"location":"33-Charts_in_Others_Docs.html#2-adding-a-chart-to-a-slide-document","text":"SlideChart.java generates the same column chart as TableChart.java, using almost the same version of makeColChart(). After the chart has been copied to the clipboard and the spreadsheet closed, a slide document is created and the chart pasted onto the first slide. The chart appears in the center of the slide by default, but is moved down to make room for some text. The end result is shown in Figure 3. Figure 3. Slide Document with a Chart Shape. The main() function of SlideChart.java is: // in SlideChart.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); boolean hasChart = makeColChart ( loader , \"chartsData.ods\" ); XComponent doc = Draw . createImpressDoc ( loader ); if ( doc == null ) { System . out . println ( \"Draw doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XDrawPage currSlide = Draw . getSlide ( doc , 0 ); XText body = Draw . bulletsSlide ( currSlide , \"Sneakers Are Selling!\" ); Draw . addBullet ( body , 0 , \"Sneaker profits have increased\" ); if ( hasChart ) { Lo . delay ( 1000 ); Lo . dispatchCmd ( \"Paste\" ); } // find and move picture XShape oleShape = Draw . findShapeByType ( currSlide , \"com.sun.star.drawing.OLE2Shape\" ); if ( oleShape != null ) { Size slideSize = Draw . getSlideSize ( currSlide ); Size shapeSize = Draw . getSize ( oleShape ); Point shapePos = Draw . getPosition ( oleShape ); int y = slideSize . Height - shapeSize . Height - 20 ; Draw . setPosition ( oleShape , shapePos . X , y ); // move pic down } Lo . saveDoc ( doc , \"makeslide.odp\" ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The chart is pasted into the slide as an OLE2Shape object, which allows it to be found by Draw.findShapeByType(). The shape is moved down the slide by calculating a new (x, y) coordinate for its top-left corner, and calling Draw.setPosition().","title":"2.  Adding a Chart to a Slide Document"},{"location":"33-Charts_in_Others_Docs.html#3-saving-the-chart-as-an-image","text":"The only change to makeColChart() in SlideChart.java is the addition of the line: // in makeColChart() in SlideChart.java Images . saveImage ( Chart2 . getChartImage ( sheet ), \"chartImage.png\" ); This saves the chart as a PNG image, which can be loaded by other applications. Images.saveImage() accepts a BufferedImage argument and filename: // in Images class public static void saveImage ( BufferedImage im , String fnm ) { try { System . out . println ( \"Saving image to \" + fnm ); ImageIO . write ( im , \"png\" , new File ( fnm )); } catch ( java . io . IOException e ) { System . out . println ( \"Could not save image to \" + fnm + \": \" + e ); } } // end of saveImage() Chart2.getChartImage() finds the chart in the spreadsheet and returns it as a BufferedImage object. // in the Chart2 class public static BufferedImage getChartImage ( XSpreadsheet sheet ) { XShape chartShape = Chart2 . getChartShape ( sheet ); if ( chartShape == null ) { System . out . println ( \"Could not find a chart\" ); return null ; } XGraphic graphic = Lo . qi ( XGraphic . class , Props . getProperty ( chartShape , \"Graphic\" ) ); if ( graphic == null ) { System . out . println ( \"No chart graphic found\" ); return null ; } String tempFnm = FileIO . createTempFile ( \"png\" ); if ( tempFnm == null ) { System . out . println ( \"Could not create a temp file for graphic\" ); return null ; } Images . saveGraphic ( graphic , tempFnm , \"png\" ); BufferedImage im = Images . loadImage ( tempFnm ); FileIO . deleteFile ( tempFnm ); return im ; } // end of getChartImage() Chart2.getChartImage() finds the chart in the sheet by using Chart2.getChartShape() described earlier. The shape is cast to an Office graphics object, of type XGraphic. getChartImage() then creates a temporary file to store the XGraphic image, which is immediately re-loaded as a BufferedImage. This is a bit nasty, but the only way I've found to convert XGraphic to BufferedImage.","title":"3.  Saving the Chart as an Image"},{"location":"34%20Part%206%20Base.html","text":"Part 6 Base \u00b6","title":"Part 6 Base"},{"location":"34%20Part%206%20Base.html#part-6-base","text":"","title":"Part 6 Base"},{"location":"34-JDBC_to_Base_API.html","text":"Chapter 34. From JDBC to the Base API \u00b6 Topics Three Database Modules: sdbc, sdbcx, sdb; A Little JDBC; From JDBC to sdbc Example folders: \"Base Tests\" and \"Utils\" Base offers a graphical interface for the building and manipulation of relational databases, including tools for the creation of forms and reports based on the tabular data. These features are explained at length in the Base Handbook, available at https://libreoffice.org/get-help/documentation/ . Base can access many types of SQL databases, including Microsoft Access, MySQL, Oracle, and PostgreSQL, and is able to create its own HSQLDB databases embedded inside Office ODB documents. HSQLDB (also known as HyperSQL) is coded in Java ( https://hsqldb.org/ ), a dependency that caused the LibreOffice development team to look for a replacement database engine in 2013. They decided on Firebird ( https://firebirdsql.org/ ) which was coded in C until version 2.5, then moved to C++. A detailed rationale for the change is available as a series of links at https://en.libreofficeforum.org/node/6062/ . Currently (in LibreOffice 5.3), the default embedded database for ODB documents is still HSQLDB, with Firebird available as an 'experimental feature', turned on via Office's Tools, Options, Advanced menu dialog. This adds a \"Firebird Embedded\" option so either kind of database can be created by Base. The Firebird feature is labeled as 'unsafe', but seems perfectly reliable on Windows, although some HSQLDB functionality isn't available yet in embedded Firebird databases. This Part contains examples using both HSQLDB and Firebird. Base's API is explained in chapter 12 of the Developer's Guide available at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . Alternatively, you can read the chapter online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Database_Access/ (use loGuide \"Database Access\" ). The guide's database examples are at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Database . 1. Three Database Modules \u00b6 The API is spread across three modules: sdbc, sdbcx, and sdb, whose structure is summarized in Figure 1. Figure 1. The Database Modules in LibreOffice. Office's core database functionality is in the sdbc module, which can be thought of as an Office version of Java's JDBC (Java Database Connectivity) API. This means that JDBC classes such as Connection, Statement, and ResultSet appear in the sdbc module, but are generally split in two to become Office service and interface classes. For example, sdbc contains services called Connection, Statement, and ResultSet, and interfaces called XConnection, XStatement, and XResultSet. The sdbcx module holds classes related to the schema (metadata) associated with databases, catalogs, tables, views, groups, users, columns, indexes, and keys. Much of this kind of data can also be manipulated at the SQL level, via DDL (Data Definition Language) statements such as CREATE and ALTER, or via the MetaDatabase classes borrowed from JDBC in the sdbc module. The sdb module offers higher-level abstractions, allowing the manipulation of other kinds of tabular data aside from databases. It makes it easy to manipulate databases embedded inside ODB documents, and also supports features such as row sets, persistent queries, and database authentication. One drawback of this hierarchy is the appearance of same-named services across modules. For instance, there are three ResultSet services, one each in the sdbc, sdbcx, and sdb modules. Fortunately, the interactive inheritance diagrams used in the LibreOffice documentation (e.g. at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1sdbc_1_1ResultSet.html ) makes it quite easy to jump between the services (e.g. see lodoc ResultSet ). 2. A Little JDBC \u00b6 The easiest way to understand the sdbc module is to have a reasonable knowledge of Java's JDBC, which is simpler and contains similar functionality. This short section on JDBC is only meant to be a refresher; if you haven\u2019t encountered the API before, you should refer to longer explanations found in beginner/intermediate Java texts. Three that I like are: Introduction to Java Programming, Comprehensive Version Y. Daniel Liang, Pearson, 2014, 10 th Edition https://cs.armstrong.edu/liang/ (Chapters 32 and 35 relate to JDBC; chapter 35 is online, behind a login/password. However the material was printed in earlier versions, up to the 6 th edition in 2007.) Java How To Program (Early Objects) Paul Deitel, Harvey Deitel, Pearson, 2014, 10 th Edition https://deitel.com/Books/Java/JavaHowtoProgram10eEarlyObjects/tabid/3656/Default.aspx (Chapter 24 is about JDBC) Core Java, Volume II \u2013 Advanced Features Cay S. Horstmann, Gary Cornell, Prentice Hall, 2016, 10 th Edition https://informit.com/store/core-java-volume-ii-advanced-features-9780137081608/ (Chapter 4 is about JDBC. It covers more topics than the Liang and Deitel chapters.) All these chapters introduce SQL, but it's worthwhile studying it separately since it utilizes a very different programming model from Java, based on relational algebra and tuples. One book I've used recently is: Sams Teach Yourself SQL in 10 Minutes Ben Forta, Sams, 2012, 4 th edition https://forta.com/books/0672336073/ I'll be using a small subset of SQL: CREATE TABLE and INSERT to build tables, and simple SELECT statements to query them. 2.1. Using JDBC \u00b6 Figure 2 shows the main stages in how JDBC is used to access a database. Figure 2. Using JDBC. The first step involves loading the database driver, which registers it with JDBC's DriveManager. JDBC 4 introduced the ability to automatic detect and load a driver if its JAR file includes configuration information. This capability isn't part of sdbc though, perhaps because Base was developed in 2003-2005, and JDBC 4 was released at the end of 2006. Class.forName() is used to load the driver, as in: Class . forName ( \"org.firebirdsql.jdbc.FBDriver\" ); A communications link through the driver to a database is represented by a Connection object, which is created by calling DriverManager.getConnection() with a the database's URL. For instance: Connection conn = DriverManager . getConnection ( \"jdbc:firebirdsql:embedded:crossrate.fdb\" ); The URL's format varies from one driver to the next, but always starts with \"jdbc:\" followed by the driver protocol name. The address may include a machine hostname and port number if the database is located across the network. The example above specifies the crossrate.fdb Firebird database in the same directory as the Java program. If a database requires a login and password, they can be included as extra arguments in the getConnection() call. A SQL statement is sent across the link via a Statement object, which is created by Connection.createStatement(): Statement statement = conn . createStatement (); The SQL statement is written as a string, and sent to the database using one of Statement's execute methods. For example: ResultSet rs = statement . executeQuery ( \"SELECT * FROM Crossrate\" ); The results are returned as a ResultSet object, which can be thought of as a table of answers with a cursor pointing to a particular row in that table. The cursor is initially assigned to just before the first row, and can be moved down a row with ResultSet.next(). Typical code for iterating through all the rows is: while ( rs . next ()) { // look at a row of the result set } A particular cell on a row is accessed using the table's corresponding column name, or the column index (which starts at 1). For example: while ( rs . next ()) System . out . println ( rs . getString ( \"FromCurrency\" )); This loop prints all the data in the \"FromCurrency\" column of the result set. The ResultSet class offers a large collection of getXXX() methods that return SQL data as Java types. 2.2. A Simple JDBC Program \u00b6 All the preceding code snippets come together in SimpleJDBC.java: // SimpleJDBC.java public static void main ( String [] args ) { try { Class . forName ( \"org.firebirdsql.jdbc.FBDriver\" ); // requires Jaybird and Firebird // connect to the database Connection conn = DriverManager . getConnection ( \"jdbc:firebirdsql:embedded:crossrate.fdb\" , \"sysdba\" , \"masterkeys\" ); // login, password Statement statement = conn . createStatement (); // Execute a SQL query ResultSet rs = statement . executeQuery ( \"SELECT * FROM Crossrate\" ); // Print the result set SimpleDateFormat sdf = new SimpleDateFormat ( \"dd-MM-yyyy\" ); System . out . println ( \"FromCurrency \\tToCurrency \\t ConvRate \\tUpdateDate\" ); System . out . println ( \"=============================\" ); while ( rs . next ()) System . out . println ( rs . getString ( \"FromCurrency\" ) + \", \\t\" + rs . getString ( \"ToCurrency\" ) + \", \\t\" + rs . getFloat ( \"ConvRate\" ) + \", \\t\" + sdf . format ( rs . getTimestamp ( \"UpdateDate\" )) ); // 4th column returns java.sql.Timestamp System . out . println ( \"=============================\" ); // Close down (should really be in a finally block) rs . close (); statement . close (); conn . close (); } catch ( ClassNotFoundException e ) // for Class.forName() { System . out . println ( \"Failed to load driver: \\n \" + e ); } catch ( SQLException e ) { for ( Throwable t : e ) System . out . println ( t ); // to handle a 'chain' of SQLExceptions } } // end of main() Figure 3 shows the command window output of this program. Figure 3. Compiling and Running SimpleJDBC.java. One of the harder parts of using JDBC is including the driver in the compilation and execution steps for a program. I've done it by writing two Windows batch scripts, called compile.bat and run.bat, which can be seen in action in Figure 3. These scripts hide the arguments of the javac.exe and java.exe commands which tell Java where to look for the driver's JAR. compile.bat is: javac - cp \"D:\\jaybird\\jaybird-full-2.2.5.jar;.\" %* run.bat is: java - cp \"D:\\jaybird\\jaybird-full-2.2.5.jar;.\" - Djava . library . path = \"D:\\jaybird\" %* Jaybird is the JDBC driver for Firebird (available from https://firebirdsql.org/en/jdbc-driver/ ). The java.library.path argument in the call to java.exe locates the directory holding Jaybird's DLL. Fortunately, this driver location issue won't concern us when using sdbc, since the Office API already includes the necessary drivers. 2.3. A More Detailed Execution Diagram \u00b6 Now that I've introduced the classes and methods used in a simple JDBC program, its possible to draw a more technical version of Figure 2, as Figure 4. Figure 4. The Classes and Methods used in Typical JDBC Programs. Figure 4's blue boxes represent JDBC classes, and the arrows are labeled with the methods used to create objects. SimpleJDBC.java uses the DriveManager, Connection, Statement, and ResultSet classes shown in the figure, but there are a few other useful ones. DataSource allows the low-level details used to address a database in DriveManager.getConection() to be hidden behind a JNDI logical name. DataSource also hides how a connection is created, or perhaps reused if there are a pool of connections. RowSet abstracts away from manipulating databases to allowing access to more general tabular data, covering such things as CSV text files and spreadsheets. RowSet combines the functionality of DriveManager, Connection, and Statement, and is a subclass of ResultSet. The two metadata classes in Figure 4 hold schema data for database and result sets. ResultSetMetaData is particularly useful when instantiating a Swing JTable component to display results graphically. PreparedStatement lets SQL statements include Java-level parameters (denoted by '?'s). A PreparedStatement can be compiled and perhaps cached for speed, but is still open to changes so different queries can be sent to the database. 3. From JDBC to sdbc \u00b6 There's a mostly direct mapping from Figure 4's JDBC Class/method diagram to sdbc interface classes, which is depicted in Figure 5. Figure 5. The Interfaces and Methods used in Typical sdbc Programs. Figure 5's blue boxes are interfaces in the sdbc module which, following the Office style, all start with \"X\". Not shown are the corresponding services which hold the data/properties associated with the interface methods. The service names are almost always the same as the interfaces but without the \"X\". For instance, the services for XConnection, XStatement, and XResultSet are Connection, Statement, and ResultSet. Figure 5 uses interface names rather than services since the interfaces contain the methods, and so it\u2019s their documentation that should be searched for method details. Recall that this can be done with my \"lodoc\" batch utility. For example, lodoc XConnection loads the LibreOffice documentation webpage for XConnection. Another drawback of service names is that many aren't unique. For example, there are two Connection services \u2013 one in sdbc and another in the sdb module. I'm going to spend several chapters explaining Figure 5. The examples will access databases using XOfficeDatabaseDocument, XRowSet, XDatabaseContext, and XDriverManager, in the order denoted by the numbers along the top of Figure 5. XOfficeDatabase documents are covered first, in Chapter 35, XRowSet and XDatabaseContext in Chapter 36, and XDriverManager in Chapter 37. In Chapter 38, I'll describe a fifth technique, based on the fact that an ODB file is a zipped folder. It's possible to employ zip-related classes (located in the java.util.zip package) to extract the folder's database files, and use HSQLDB or Firebird to access them through JDBC. This approach side-steps Office's API but requires JDBC drivers for HyperSQL and Firebird.","title":"Chapter 34. From JDBC to the Base API"},{"location":"34-JDBC_to_Base_API.html#chapter-34-from-jdbc-to-the-base-api","text":"Topics Three Database Modules: sdbc, sdbcx, sdb; A Little JDBC; From JDBC to sdbc Example folders: \"Base Tests\" and \"Utils\" Base offers a graphical interface for the building and manipulation of relational databases, including tools for the creation of forms and reports based on the tabular data. These features are explained at length in the Base Handbook, available at https://libreoffice.org/get-help/documentation/ . Base can access many types of SQL databases, including Microsoft Access, MySQL, Oracle, and PostgreSQL, and is able to create its own HSQLDB databases embedded inside Office ODB documents. HSQLDB (also known as HyperSQL) is coded in Java ( https://hsqldb.org/ ), a dependency that caused the LibreOffice development team to look for a replacement database engine in 2013. They decided on Firebird ( https://firebirdsql.org/ ) which was coded in C until version 2.5, then moved to C++. A detailed rationale for the change is available as a series of links at https://en.libreofficeforum.org/node/6062/ . Currently (in LibreOffice 5.3), the default embedded database for ODB documents is still HSQLDB, with Firebird available as an 'experimental feature', turned on via Office's Tools, Options, Advanced menu dialog. This adds a \"Firebird Embedded\" option so either kind of database can be created by Base. The Firebird feature is labeled as 'unsafe', but seems perfectly reliable on Windows, although some HSQLDB functionality isn't available yet in embedded Firebird databases. This Part contains examples using both HSQLDB and Firebird. Base's API is explained in chapter 12 of the Developer's Guide available at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . Alternatively, you can read the chapter online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Database_Access/ (use loGuide \"Database Access\" ). The guide's database examples are at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Database .","title":"Chapter 34. From JDBC to the Base API"},{"location":"34-JDBC_to_Base_API.html#1-three-database-modules","text":"The API is spread across three modules: sdbc, sdbcx, and sdb, whose structure is summarized in Figure 1. Figure 1. The Database Modules in LibreOffice. Office's core database functionality is in the sdbc module, which can be thought of as an Office version of Java's JDBC (Java Database Connectivity) API. This means that JDBC classes such as Connection, Statement, and ResultSet appear in the sdbc module, but are generally split in two to become Office service and interface classes. For example, sdbc contains services called Connection, Statement, and ResultSet, and interfaces called XConnection, XStatement, and XResultSet. The sdbcx module holds classes related to the schema (metadata) associated with databases, catalogs, tables, views, groups, users, columns, indexes, and keys. Much of this kind of data can also be manipulated at the SQL level, via DDL (Data Definition Language) statements such as CREATE and ALTER, or via the MetaDatabase classes borrowed from JDBC in the sdbc module. The sdb module offers higher-level abstractions, allowing the manipulation of other kinds of tabular data aside from databases. It makes it easy to manipulate databases embedded inside ODB documents, and also supports features such as row sets, persistent queries, and database authentication. One drawback of this hierarchy is the appearance of same-named services across modules. For instance, there are three ResultSet services, one each in the sdbc, sdbcx, and sdb modules. Fortunately, the interactive inheritance diagrams used in the LibreOffice documentation (e.g. at https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1sdbc_1_1ResultSet.html ) makes it quite easy to jump between the services (e.g. see lodoc ResultSet ).","title":"1.  Three Database Modules"},{"location":"34-JDBC_to_Base_API.html#2-a-little-jdbc","text":"The easiest way to understand the sdbc module is to have a reasonable knowledge of Java's JDBC, which is simpler and contains similar functionality. This short section on JDBC is only meant to be a refresher; if you haven\u2019t encountered the API before, you should refer to longer explanations found in beginner/intermediate Java texts. Three that I like are: Introduction to Java Programming, Comprehensive Version Y. Daniel Liang, Pearson, 2014, 10 th Edition https://cs.armstrong.edu/liang/ (Chapters 32 and 35 relate to JDBC; chapter 35 is online, behind a login/password. However the material was printed in earlier versions, up to the 6 th edition in 2007.) Java How To Program (Early Objects) Paul Deitel, Harvey Deitel, Pearson, 2014, 10 th Edition https://deitel.com/Books/Java/JavaHowtoProgram10eEarlyObjects/tabid/3656/Default.aspx (Chapter 24 is about JDBC) Core Java, Volume II \u2013 Advanced Features Cay S. Horstmann, Gary Cornell, Prentice Hall, 2016, 10 th Edition https://informit.com/store/core-java-volume-ii-advanced-features-9780137081608/ (Chapter 4 is about JDBC. It covers more topics than the Liang and Deitel chapters.) All these chapters introduce SQL, but it's worthwhile studying it separately since it utilizes a very different programming model from Java, based on relational algebra and tuples. One book I've used recently is: Sams Teach Yourself SQL in 10 Minutes Ben Forta, Sams, 2012, 4 th edition https://forta.com/books/0672336073/ I'll be using a small subset of SQL: CREATE TABLE and INSERT to build tables, and simple SELECT statements to query them.","title":"2.  A Little JDBC"},{"location":"34-JDBC_to_Base_API.html#21-using-jdbc","text":"Figure 2 shows the main stages in how JDBC is used to access a database. Figure 2. Using JDBC. The first step involves loading the database driver, which registers it with JDBC's DriveManager. JDBC 4 introduced the ability to automatic detect and load a driver if its JAR file includes configuration information. This capability isn't part of sdbc though, perhaps because Base was developed in 2003-2005, and JDBC 4 was released at the end of 2006. Class.forName() is used to load the driver, as in: Class . forName ( \"org.firebirdsql.jdbc.FBDriver\" ); A communications link through the driver to a database is represented by a Connection object, which is created by calling DriverManager.getConnection() with a the database's URL. For instance: Connection conn = DriverManager . getConnection ( \"jdbc:firebirdsql:embedded:crossrate.fdb\" ); The URL's format varies from one driver to the next, but always starts with \"jdbc:\" followed by the driver protocol name. The address may include a machine hostname and port number if the database is located across the network. The example above specifies the crossrate.fdb Firebird database in the same directory as the Java program. If a database requires a login and password, they can be included as extra arguments in the getConnection() call. A SQL statement is sent across the link via a Statement object, which is created by Connection.createStatement(): Statement statement = conn . createStatement (); The SQL statement is written as a string, and sent to the database using one of Statement's execute methods. For example: ResultSet rs = statement . executeQuery ( \"SELECT * FROM Crossrate\" ); The results are returned as a ResultSet object, which can be thought of as a table of answers with a cursor pointing to a particular row in that table. The cursor is initially assigned to just before the first row, and can be moved down a row with ResultSet.next(). Typical code for iterating through all the rows is: while ( rs . next ()) { // look at a row of the result set } A particular cell on a row is accessed using the table's corresponding column name, or the column index (which starts at 1). For example: while ( rs . next ()) System . out . println ( rs . getString ( \"FromCurrency\" )); This loop prints all the data in the \"FromCurrency\" column of the result set. The ResultSet class offers a large collection of getXXX() methods that return SQL data as Java types.","title":"2.1.  Using JDBC"},{"location":"34-JDBC_to_Base_API.html#22-a-simple-jdbc-program","text":"All the preceding code snippets come together in SimpleJDBC.java: // SimpleJDBC.java public static void main ( String [] args ) { try { Class . forName ( \"org.firebirdsql.jdbc.FBDriver\" ); // requires Jaybird and Firebird // connect to the database Connection conn = DriverManager . getConnection ( \"jdbc:firebirdsql:embedded:crossrate.fdb\" , \"sysdba\" , \"masterkeys\" ); // login, password Statement statement = conn . createStatement (); // Execute a SQL query ResultSet rs = statement . executeQuery ( \"SELECT * FROM Crossrate\" ); // Print the result set SimpleDateFormat sdf = new SimpleDateFormat ( \"dd-MM-yyyy\" ); System . out . println ( \"FromCurrency \\tToCurrency \\t ConvRate \\tUpdateDate\" ); System . out . println ( \"=============================\" ); while ( rs . next ()) System . out . println ( rs . getString ( \"FromCurrency\" ) + \", \\t\" + rs . getString ( \"ToCurrency\" ) + \", \\t\" + rs . getFloat ( \"ConvRate\" ) + \", \\t\" + sdf . format ( rs . getTimestamp ( \"UpdateDate\" )) ); // 4th column returns java.sql.Timestamp System . out . println ( \"=============================\" ); // Close down (should really be in a finally block) rs . close (); statement . close (); conn . close (); } catch ( ClassNotFoundException e ) // for Class.forName() { System . out . println ( \"Failed to load driver: \\n \" + e ); } catch ( SQLException e ) { for ( Throwable t : e ) System . out . println ( t ); // to handle a 'chain' of SQLExceptions } } // end of main() Figure 3 shows the command window output of this program. Figure 3. Compiling and Running SimpleJDBC.java. One of the harder parts of using JDBC is including the driver in the compilation and execution steps for a program. I've done it by writing two Windows batch scripts, called compile.bat and run.bat, which can be seen in action in Figure 3. These scripts hide the arguments of the javac.exe and java.exe commands which tell Java where to look for the driver's JAR. compile.bat is: javac - cp \"D:\\jaybird\\jaybird-full-2.2.5.jar;.\" %* run.bat is: java - cp \"D:\\jaybird\\jaybird-full-2.2.5.jar;.\" - Djava . library . path = \"D:\\jaybird\" %* Jaybird is the JDBC driver for Firebird (available from https://firebirdsql.org/en/jdbc-driver/ ). The java.library.path argument in the call to java.exe locates the directory holding Jaybird's DLL. Fortunately, this driver location issue won't concern us when using sdbc, since the Office API already includes the necessary drivers.","title":"2.2.  A Simple JDBC Program"},{"location":"34-JDBC_to_Base_API.html#23-a-more-detailed-execution-diagram","text":"Now that I've introduced the classes and methods used in a simple JDBC program, its possible to draw a more technical version of Figure 2, as Figure 4. Figure 4. The Classes and Methods used in Typical JDBC Programs. Figure 4's blue boxes represent JDBC classes, and the arrows are labeled with the methods used to create objects. SimpleJDBC.java uses the DriveManager, Connection, Statement, and ResultSet classes shown in the figure, but there are a few other useful ones. DataSource allows the low-level details used to address a database in DriveManager.getConection() to be hidden behind a JNDI logical name. DataSource also hides how a connection is created, or perhaps reused if there are a pool of connections. RowSet abstracts away from manipulating databases to allowing access to more general tabular data, covering such things as CSV text files and spreadsheets. RowSet combines the functionality of DriveManager, Connection, and Statement, and is a subclass of ResultSet. The two metadata classes in Figure 4 hold schema data for database and result sets. ResultSetMetaData is particularly useful when instantiating a Swing JTable component to display results graphically. PreparedStatement lets SQL statements include Java-level parameters (denoted by '?'s). A PreparedStatement can be compiled and perhaps cached for speed, but is still open to changes so different queries can be sent to the database.","title":"2.3.  A More Detailed Execution Diagram"},{"location":"34-JDBC_to_Base_API.html#3-from-jdbc-to-sdbc","text":"There's a mostly direct mapping from Figure 4's JDBC Class/method diagram to sdbc interface classes, which is depicted in Figure 5. Figure 5. The Interfaces and Methods used in Typical sdbc Programs. Figure 5's blue boxes are interfaces in the sdbc module which, following the Office style, all start with \"X\". Not shown are the corresponding services which hold the data/properties associated with the interface methods. The service names are almost always the same as the interfaces but without the \"X\". For instance, the services for XConnection, XStatement, and XResultSet are Connection, Statement, and ResultSet. Figure 5 uses interface names rather than services since the interfaces contain the methods, and so it\u2019s their documentation that should be searched for method details. Recall that this can be done with my \"lodoc\" batch utility. For example, lodoc XConnection loads the LibreOffice documentation webpage for XConnection. Another drawback of service names is that many aren't unique. For example, there are two Connection services \u2013 one in sdbc and another in the sdb module. I'm going to spend several chapters explaining Figure 5. The examples will access databases using XOfficeDatabaseDocument, XRowSet, XDatabaseContext, and XDriverManager, in the order denoted by the numbers along the top of Figure 5. XOfficeDatabase documents are covered first, in Chapter 35, XRowSet and XDatabaseContext in Chapter 36, and XDriverManager in Chapter 37. In Chapter 38, I'll describe a fifth technique, based on the fact that an ODB file is a zipped folder. It's possible to employ zip-related classes (located in the java.util.zip package) to extract the folder's database files, and use HSQLDB or Firebird to access them through JDBC. This approach side-steps Office's API but requires JDBC drivers for HyperSQL and Firebird.","title":"3.  From JDBC to sdbc"},{"location":"35-Examining_Base_Docs.html","text":"Chapter 35. Examining Base Documents \u00b6 Topics Querying an Embedded HSQLDB Database; Using Metadata when Querying; Debugging Database Code; Creating a Base Document; Processing Multiple SQL Commands; Displaying Table Relationships; Prepared Statements; Scrollable and Updatable Result Sets; Converting a Database to Text Example folders: \"Base Tests\" and \"Utils\" This chapter looks at programming with Base documents using the XOfficeDatabaseDocument interface, which was labelled with a (1) in Figure 5 of the previous chapter. Figure 1 repeats that figure but without the alternative query approaches (labels (2), (3), and (4)). Figure 1. Querying a Base Document. XOfficeDatabaseDocument accesses a database via the ODB document that's connected to the database. The connection can take two forms \u2013 the database can be embedded inside the ODB file, or the connection can be a URL which links to an external database. Most of my examples will utilize ODB files that contain embedded databases. 1. Querying an Embedded HSQLDB Database \u00b6 The following SimpleQuery.java example shows how to query a HSQLDB database embedded inside an ODB file called liangTables.odb. It has three tables, called Course, Enrollment, and Student. Figure 2 shows the data in the Course table, displayed by Base. The filename reflects the fact that the database is based on one in Y. Daniel Liang's \"Introduction to Java Programming\" textbook. Figure 2. The Course Table in liangTables.odb. Although SimpleQuery.java only queries liangTables.odb, the support methods it utilizes are capable of accessing other kinds of ODB document, including ones containing embedded Firebird databases, and database URLs. The main() method for SimpleQuery.java is given below: private static final String FNM = \"liangTables.odb\" ; // in SimpleQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( FNM , loader ); if ( dbDoc == null ) { System . out . println ( \"Could not open database \" + FNM ); Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XStatement statement = conn . createStatement (); // first query XResultSet rs = statement . executeQuery ( \"SELECT * FROM \\\"Course\\\"\" ); XRow xRow = Lo . qi ( XRow . class , rs ); System . out . println ( \"CourseID \\tSubjectID \\tCourseNumber \\tTitle \\tNumOfCredits\" ); System . out . println ( \"=========================\" ); while ( rs . next ()) System . out . println ( xRow . getString ( 1 ) + \", \\t\" + xRow . getString ( 2 ) + \", \\t\" + xRow . getInt ( 3 ) + \", \\t\" + xRow . getString ( 4 ) + \", \" + xRow . getInt ( 5 ) ); System . out . println ( \"=========================\" ); // second query rs = statement . executeQuery ( \"SELECT \\\"courseNumber\\\", \\\"title\\\" FROM \\\"Course\\\"\" ); xRow = Lo . qi ( XRow . class , rs ); XColumnLocate xLoc = Lo . qi ( XColumnLocate . class , rs ); System . out . println ( \"CourseNumber \\tTitle\" ); System . out . println ( \"====================================\" ); while ( rs . next ()) System . out . println ( xRow . getString ( xLoc . findColumn ( \"courseNumber\" )) + \", \\t\" + xRow . getString ( xLoc . findColumn ( \"title\" )) ); System . out . println ( \"====================================\" ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() The code is similar to the JDBC program described in the previous chapter, but uses the sdbc interface, starting with XOfficeDatabaseDocument. Base.openBaseDoc() loads the document as an instance of XComponent, then casts it to XOfficeDatabaseDocument. The relationship between XOfficeDatabaseDocument and XComponent is shown in Figure 3. Figure 3. Obtaining an OfficeDataBaseDocument Instance. The Base.openBaseDoc() method: // in the Base class public static XOfficeDatabaseDocument openBaseDoc ( String fnm , XComponentLoader loader ) { XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Document is null\" ); return null ; } if ( Info . reportDocType ( doc ) != Lo . BASE ) { System . out . println ( \"Not a database doc; closing \" + fnm ); Lo . closeDoc ( doc ); return null ; } // cast XComponent to XOfficeDatabaseDocument XOfficeDatabaseDocument dbDoc = Lo . qi ( XOfficeDatabaseDocument . class , doc ); if ( dbDoc == null ) { System . out . println ( \"Not a database doc; closing \" + fnm ); Lo . closeDoc ( doc ); return null ; } return dbDoc ; } // end of openDoc() Database details, such as whether it's embedded inside or linked to the ODB file, and its type (e.g. HSQLDB, Firebird), are stored in the DataSource service, which is accessed by XOfficeDatabaseDocument.getDataSource(): // in SimpleQuery.java... XDataSource dataSource = dbDoc . getDataSource (); The simplest way of using the data source is to connect to the database by calling getConnection(): XConnection conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XConnection.createStatement() returns an XStatement reference, which can be used to send SQL queries to the database. A query's result set is stored in an XResultSet instance: // in SimpleQuery.java... XStatement statement = conn . createStatement (); XResultSet rs = statement . executeQuery ( \"SELECT * FROM \\\"Course\\\"\" ); Sdbc differs a little from JDBC in how the rows of a result set are examined. A row is represented by a XRow instance which is a cast of XResultSet. However, the set's cursor is still moved through the rows using XResultSet.next(): // in SimpleQuery.java... XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) System . out . println ( xRow . getString ( 1 ) + \", \\t\" + xRow . getString ( 2 ) + \", \\t\" + xRow . getInt ( 3 ) + \", \\t\" + xRow . getString ( 4 ) + \", \" + xRow . getInt ( 5 ) ); Access to data through XRow.getXXX() methods is only possible with column indices. Column names can be used indirectly via XColumnLocate.findColumn() which maps names to indices: // in SimpleQuery.java... rs = statement . executeQuery ( \"SELECT \\\"courseNumber\\\", \\\"title\\\" FROM \\\"Course\\\"\" ); xRow = Lo . qi ( XRow . class , rs ); XColumnLocate xLoc = Lo . qi ( XColumnLocate . class , rs ); System . out . println ( \"CourseNumber \\tTitle\" ); System . out . println ( \"====================================\" ); while ( rs . next ()) System . out . println ( xRow . getString ( xLoc . findColumn ( \"courseNumber\" )) + \", \\t\" + xRow . getString ( xLoc . findColumn ( \"title\" )) ); System . out . println ( \"====================================\" ); The output from SimpleQuery.java is shown in Figure 4. Figure 4. SimpleQuery.java Output. The program ends by closing the connection to the database (with Base.closeConnection()) and the ODB file (with Base.closeBaseDoc()). Both methods cast their arguments to XCloseable, and then call XCloseable.close(). 2. Using Metadata when Querying a Base Document \u00b6 Metadata is information about a database, such as a table's schema, and driver and database engine details. There are four sources of such information in the Base API: the DataSource service; the DatabaseDefinition services; the sdbc metadata services, DatabaseMetaData and ResultSetMetaData. SimpleQuery.java is hardwired to query the Course table in the liangTables.odb database, and prints rather ugly looking output (see Figure 4). Both these issues can be addressed by utilizing database metadata information, as in DBQuery.java described next. I'll use the program to illustrate how the four metadata services can be employed. 2.1. The DataSource Service \u00b6 The DataSource service is depicted in Figure 5. Figure 5. The DataSource Service and Interface. A simple way to access a data source's properties is with my Props.java utility class. For example, the following code prints all of its properties: // part of DBQuery.java... XOfficeDatabaseDocument dbDoc = ... // reference to a Base doc; XDataSource dataSource = dbDoc . getDataSource (); Props . showObjProps ( \"Data Source\" , dataSource ); This information includes the data source type (e.g. whether it is an embedded HSQLDB or Firebird database), whether a password is required to access the tables, and whether the database is read-only. My Base utility class includes several methods that access this information individually. For example: // part of DBQuery.java... System . out . println ( \"Database type: \" + Base . getDataSourceType ( dbDoc )); System . out . println ( \"Is embedded? \" + Base . isEmbedded ( dbDoc )); XDataSource dataSource = dbDoc . getDataSource (); Base . printDataSourceInfo ( dataSource ); System . out . println ( \"Is password required: \" + Base . isPasswordRequired ( dataSource )); System . out . println ( \"Is read-only: \" + Base . isReadOnly ( dataSource )); For the liangTables.odb file, the listed details are: Database type : sdbc : embedded : hsqldb Is embedded ? true Data Source Properties Info == [ Lcom . sun . star . beans . PropertyValue ; @cf768c IsPasswordRequired == false IsReadOnly == false // ... many more lines // : Is password required : false Is read - only : false 2.2. The DatabaseDefinition Services \u00b6 After a database connection is established, metadata about the structure of the database, its tables, columns, user and group permissions, becomes available. It's accessible through services in the sdbcx module, starting from DatabaseDefinition shown in Figure 6. Figure 6. Accessing Database MetaData via a Connection. For example, Base.getTablesNames() casts an XConnection reference to a XTablesSupplier, which gives access to information about the database's tables: // in the Base class public static ArrayList < String > getTablesNames ( XConnection conn ) { XTablesSupplier tblsSupplier = Lo . qi ( XTablesSupplier . class , conn ); XNameAccess tables = tblsSupplier . getTables (); String [] tableNms = tables . getElementNames (); return new ArrayList < String > ( Arrays . asList ( tableNms )); } // end of getTablesNames() Base.getTablesNames() is called in DBQuery.java like so: // part of DBQuery.java... XConnection conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password ArrayList < String > tableNames = Base . getTablesNames ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); The names of the three tables in liangTables.odb are reported as: No. of tables: 3 [Course, Enrollment, Student] Just as XTablesSupplier is for supplying table information, there are similarly named 'Supplier' interfaces for retrieving details about the database's views, groups, and user accounts. Base.displayTablesInfo() prints all of this information, but the output can be very large if there are more than one or two tables in the database. 2.3. The DatabaseMetaData Service \u00b6 Another way to obtain metadata is to utilize the JDBC-inspired XDatabaseMetaData interface by calling XConnection.getMetaData(): XConnection conn = ... // a connection to the database; XDatabaseMetaData md = conn . getMetaData (); The metadata includes database engine and driver details, as reported by Base.reportDBInfo(): // in the Base class public static void reportDBInfo ( XConnection conn ) { try { XDatabaseMetaData md = conn . getMetaData (); String productName = md . getDatabaseProductName (); String productVersion = md . getDatabaseProductVersion (); if (( productName == null ) || productName . equals ( \"\" )) System . out . println ( \"No database info found\" ); else System . out . println ( \"DB: \" + productName + \" v.\" + productVersion ); String driverName = md . getDriverName (); String driverVersion = md . getDriverVersion (); if (( driverName == null ) || driverName . equals ( \"\" )) System . out . println ( \"No driver info found\" ); else System . out . println ( \"SDBC driver: \" + driverName + \" v.\" + driverVersion ); } catch ( SQLException e ) { System . out . println ( e ); } } // end of reportDBInfo() The output for liangTables.odb shows that it utilizes HSQLDB: DB: HSQL Database Engine v.1.8.0 SDBC driver: HSQL Database Engine Driver v.1.8.0 Unfortunately the XDatabaseMetaData methods don't return anything useful for embedded Firebird databases. The output is: No database info found No driver info found However, data source metadata is available for Firebird via Base.getDataSourceType(): System . out . println ( \"Database type: \" + Base . getDataSourceType ( dbDoc )); For the same Firebird database, it reports: Database type: sdbc:embedded:firebird This illustrates that the functionalities of the HSQLDB and Firebird engines aren't identical, and that the DataSource (section 2.1) and DataDefinition services (section 2.2) may produce more information than the sdbc metadata approach (this section). Base.reportSQLTypes() and Base.reportFunctionSupport() utilize XDatabaseMetaData. The former returns a list of SQL types, and the latter a list of functions supported by the database engine; their use is illustrated in DBQuery.java. 2.4. The ResultSetMetaData Service \u00b6 XResultSetMetaData data allows a result set to be better formatted. It's used in Base.printResultSet() to print results sets and in Base.displayResultSet() to fill a scrollable JTable displayed inside a JFrame. The following query prints a result set to standard output: // part of DBQuery.java... ArrayList < String > tableNames = Base . getTablesNames ( conn ); XResultSet rs = Base . executeQuery ( \"SELECT * FROM \\\"\" + tableNames . get ( 0 ) + \"\\\"\" , conn ); Base . printResultSet ( rs ); The query employs the first string from the tableNames list as the SELECT's table. The output for liangTables.odb is: courseId, subjectId, courseNumber, title, numOfCredits -------------------------------------------------------------- 11111, CSCI, 1301, Introduction to Java I, 4 11112, CSCI, 1302, Introduction to Java II, 3 11113, CSCI, 3720, Database Systems, 4 The formatting isn't perfect since its quite tricky to determine the maximum width required for a column. Base.printResultSet() uses XResultSetMetaData to determine the number of columns and their names: // in the Base class public static void printResultSet ( XResultSet rs ) { if ( rs == null ) { System . out . println ( \"No results set to print\" ); return ; } try { XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); int tableWidth = 0 ; int numCols = rsmd . getColumnCount (); String colName ; for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) { System . out . print ( \", \" ); tableWidth += 2 ; } colName = rsmd . getColumnName ( i + 1 ); System . out . printf ( \"%10s\" , colName ); tableWidth += Math . max ( colName . length (), 10 ); } System . out . println (); for ( int i = 0 ; i < tableWidth ; i ++ ) System . out . print ( \"-\" ); System . out . println (); XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) { for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) System . out . print ( \", \" ); System . out . printf ( \"%10s\" , xRow . getString ( i + 1 ) ); } System . out . println (); } System . out . println (); } catch ( SQLException e ) { System . out . println ( e ); } } // end of printResultSet() Fortunately, the hard work of writing a good ASCII-based table printer has already been done by Hami Galip Torun with his DBTablePrinter class, available from https://github.com/htorun/dbtableprinter/ . It offers printTable() and printResultSet() for printing a JDBC table and result set in beautiful ASCII. I made a few small changes to his class to allow it to handle sdbc tables and result sets, which consisted mainly of changing the Connection, Statement, and ResultSet names to XConnection, XStatement, and XResultSet. I've also renamed the class as BaseTablePrinter so I could keep using Torun's original DBTablePrinter for printing JDBC results. The result set shown above is printed by: // part of DBQuery.java... BaseTablePrinter . printResultSet ( rs ); The output: Printing 3 rows from table Course +----------+-----------+--------------+-------------------------+--------------+ | courseId | subjectId | courseNumber | title | numOfCredits | +----------+-----------+--------------+-------------------------+--------------+ | 11111 | CSCI | 1301 | Introduction to Java I | 4 | +----------+-----------+--------------+-------------------------+--------------+ | 11112 | CSCI | 1302 | Introduction to Java II | 3 | +----------+-----------+--------------+-------------------------+--------------+ | 11113 | CSCI | 3720 | Database Systems | 4 | +----------+-----------+--------------+-------------------------+--------------+ A graphical display is implemented by my Base.displayResultSet(), which uses the result set to fill a JTable GUI component inside a JFrame. This result set from above is displayed by: // part of DBQuery.java... Base . displayResultSet ( rs ); Figure 7 shows the JFrame. Figure 7. The Result Set Displayed in a Window. There are some problems with the layout: too much vertical space below the table, and column formatting which shows all the data, but not all the headings. However, the user can resize the window and columns, so these drawbacks aren't serious. displayResultSet() is coded as: // in the Base class public static void displayResultSet ( XResultSet rs ) { displayResultSet ( rs , \"Result set\" , 0 ); } public static void displayResultSet ( XResultSet rs , String title , int offset ) { if ( rs == null ) { System . out . println ( \"No results set to display\" ); return ; } try { XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); // names of columns int numCols = rsmd . getColumnCount (); String [] headers = new String [ numCols ] ; for ( int i = 0 ; i < numCols ; i ++ ) { headers [ i ] = rsmd . getColumnName ( i + 1 ); } // create table with column heads DefaultTableModel tableModel = new DefaultTableModel ( headers , 0 ); JTable table = new JTable ( tableModel ); // fill table with XResultSet contents, one row at a time XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) tableModel . addRow ( getRow ( xRow , numCols )); // resize columns so data is visible table . setAutoResizeMode ( JTable . AUTO_RESIZE_ALL_COLUMNS ); resizeColumnWidth ( table ); SwingUtilities . invokeLater ( new Runnable () { public void run () { JFrame frame = new JFrame (); frame . setBounds ( offset , offset , 400 , 200 ); frame . setTitle ( title ); frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ); // so JFrame closure doesn't kill the main prog frame . add ( new JScrollPane ( table ), BorderLayout . CENTER ); frame . setVisible ( true ); } }); } catch ( SQLException e ) { System . out . println ( e ); } } // end of displayResultSet() This sdbc display code is different from the JDBC version in only two ways. The first is the use of XResultSetMetaDataSupplier to access the result set's metadata: // part of Base.displayResultSet()... XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); The second is the utilization of an XRow instance to refer to each row in the result set: // part of Base.displayResultSet()... XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) tableModel . addRow ( getRow ( xRow , numCols )); 3. Debugging Database Code \u00b6 A useful way to debug larger programs is to display the database tables they're manipulating. The simplest way of doing this is to open the tables inside Base. A call to GUI.setVisible() makes Base and the loaded file visible. However, Base's default behavior is to display its Forms view rather than the Tables view. Even after changing to the Tables view, only the names of the tables are listed not their contents. Base.showTables() deals with these issues, so that the following call: // part of DBQuery.java... Base . showTables ( dbDoc ); Lo . waitEnter (); produces the windows shown in Figure 8 when liangTables.odb is being processed. Figure 8. The liangTables.odb Tables in Base. The call to Lo.waitEnter() gives the user a chance to examine the tables before the program continues. A drawback of this approach is that having open table windows at the end of the program often causes Office to crash after Lo.closeOffice() is called. Base.showTables() utilizes a series of dispatch commands to make the GUI visible, show the Tables view, and open the tables in separate windows: // in the Base class public static void showTables ( XOfficeDatabaseDocument dbDoc ) // open windows for all the tables in the doc { showTablesView ( dbDoc ); Lo . delay ( 500 ); // wait for Tables View to appear Lo . dispatchCmd ( \"SelectAll\" ); Lo . dispatchCmd ( \"DBTableOpen\" ); // open all tables } // end of showTables() public static void showTablesView ( XOfficeDatabaseDocument dbDoc ) // make Base visible, and switch to its Table view { XComponent doc = Lo . qi ( XComponent . class , dbDoc ); GUI . setVisible ( doc , true ); Lo . delay ( 500 ); // wait for GUI to appear Lo . dispatchCmd ( \"DBViewTables\" ); } // end of showTablesView() As usual, using dispatches makes the code very fragile. For example, consider the \"SelectAll\" dispatch which causes Office to select all the table names in the Tables View. To be more precise, \"SelectAll\" selects everything in the active window, which should be the Tables view, but could easily be something else if the user clicked on another window at the wrong time. My Base class offers two alternatives to showTables(): Base.printDatabase() and Base.displayDatabase(); the first builds upon Hami Galip Torun's class to generate textual output of every table in the database, while the second uses my Base.displayResultSet() to render each table in its own JFrame. They are called like so: // part of DBQuery.java... Base . printDatabase ( conn ); Base . displayDatabase ( conn ); Base.displayDatabase() is a better choice for displaying large databases since each JFrame can be resized and is scrollable, as in Figure 9. Figure 9. The liangTables.odb Tables shown in JFrames. 4. Creating a Base Document \u00b6 The DBCreate.java example creates a new document called spies.odb which holds a single table of \"top-secret\" information on spies. Figure 10 shows the table inside Base. Figure 10. The SPIES Table inside spies.odb. The example employs Base.createBaseDoc() to create an embedded database (which can be either HSQLDB or Firebird). The main() function for DBCreate.java is: private static final String FNM = \"spies.odb\" ; // in DBCreate.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . createBaseDoc ( FNM , Base . HSQLDB , loader ); // Base.FIREBIRD, loader); if ( dbDoc == null ) { Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // create a table in the database Base . exec ( \"CREATE TABLE SPIES \" + \"( FIRSTNAME VARCHAR(50), LASTNAME VARCHAR(50), ID VARCHAR(50), PRIMARY KEY (ID) )\" , conn ); Base . exec ( \"INSERT INTO SPIES VALUES( 'James', 'Bond', '007')\" , conn ); Base . exec ( \"INSERT INTO SPIES VALUES( 'Johnny', 'English', '013')\" , conn ); Base . exec ( \"INSERT INTO SPIES VALUES( 'Maxwell', 'Smart', 'Agent 86')\" , conn ); XFlushable flusher = Lo . qi ( XFlushable . class , dataSource ); flusher . flush (); // needed or data not saved to file; can only be called once // test the database with a query System . out . println (); XResultSet rs = Base . executeQuery ( \"SELECT * FROM SPIES\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() There's something missing from main() \u2013 there's no call to a 'save' function to save the new spies.odb file before the program exits. There's no need because of how the spies.odb file and database are created in two phases. First, Base.createBaseDoc() creates an ODB file with an empty embedded database. The file is saved by createBaseDoc(), then reloaded, and a reference returned by the method. This unusual behavior is necessary or no link (an XConnection) can be opened to the new database. The second phase employs SQL DDL and DML commands to create and populate a table inside the file. The unusual part of this phase is the need to finish off with a call to XFlushable.flush(). This ensures that the table is written out to the embedded database in the file. The final part of the try-catch block is a test to see if the SPIES table can be successfully queried. The BaseTablePrinter.printResultSet() output is: Printing 3 rows from table SPIES +-----------+----------+----------+ | FIRSTNAME | LASTNAME | ID | +-----------+----------+----------+ | James | Bond | 007 | +-----------+----------+----------+ | Johnny | English | 013 | +-----------+----------+----------+ | Maxwell | Smart | Agent 86 | +-----------+----------+----------+ Base.createBaseDoc() is defined as: // in the Base class // globals public static final int UNKNOWN = 0 ; public static final int HSQLDB = 1 ; public static final int FIREBIRD = 2 ; public static final String HSQL_EMBEDDED = \"sdbc:embedded:hsqldb\" ; public static final String FIREBIRD_EMBEDDED = \"sdbc:embedded:firebird\" ; public static XOfficeDatabaseDocument createBaseDoc ( String fnm , int dbType , XComponentLoader loader ) { if (( dbType != HSQLDB ) && ( dbType != FIREBIRD )) { System . out . println ( \"Unknown db type; using HSQLDB\" ); dbType = HSQLDB ; } XComponent doc = Lo . createDoc ( \"sdatabase\" , loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); return null ; } XOfficeDatabaseDocument dbDoc = Lo . qi ( XOfficeDatabaseDocument . class , doc ); XDataSource dataSource = dbDoc . getDataSource (); String sourceStr = ( dbType == FIREBIRD ) ? FIREBIRD_EMBEDDED : HSQL_EMBEDDED ; Props . setProperty ( dataSource , \"URL\" , sourceStr ); System . out . println ( \"Created a \\\"\" + sourceStr + \"\\\" Base document in \" + fnm ); // save, close, reopen, // or no subsequent connection can be made to database Base . saveBaseDoc ( dbDoc , fnm ); Base . closeBaseDoc ( dbDoc ); return openBaseDoc ( fnm , loader ); } // end of createBaseDoc() public static void saveBaseDoc ( XOfficeDatabaseDocument dbDoc , String fnm ) { XComponent doc = Lo . qi ( XComponent . class , dbDoc ); Lo . saveDoc ( doc , fnm ); } Base.createBaseDoc() utilizes Lo.createDoc() to create an empty ODB document, and then sets its data source to be an embedded HSQLDB or Firebird database. The URL property in the DataSource service is assigned \"sdbc:embedded:hsqldb\" or \"sdbc:embedded:firebird\". Viewing Database Creation \u00b6 It's sometimes useful to observe the stages in a database's creation, and that's most easily achieved by making Base's GUI visible during DBCreate.java's execution. GUI.setVisible() is called at the start of the program: // part of DBCreate.java... GUI . setVisible ( dbDoc , true ); Of course, Base's tables view will not show anything initially since the database is empty. More surprisingly, the view remains empty after the SQL commands have finished and XFlushable.flush() has been called. The table view must be 'refreshed' in order for the new tables to be listed, which is done by Base.refreshTables(): // part of DBCreate.java... Base . refreshTables ( conn ); // place after the call to XFlushable.flush() Base . showTablesView ( dbDoc ); Base.refreshTables() is implemented as: // in the Base class public static void refreshTables ( XConnection conn ) { XTablesSupplier suppTables = Lo . qi ( XTablesSupplier . class , conn ); XRefreshable refresh = Lo . qi ( XRefreshable . class , suppTables . getTables ()); refresh . refresh (); } // end of refreshTables() 5. Processing Multiple SQL Commands \u00b6 The simplest way to build databases with more tables and data is by storing the necessary DDL and DML commands in a text file. This can be loaded by Base.readCmds(), as in the DBCmdsQuery.java example. main() creates an ODB document with an empty embedded HSQLDB database, builds its tables by executing the commands loaded by Base.readCmds(), and displays the tables inside Base: // in DBCmdsCreate.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: java DBCmdsCreate <cmds fnm>\" ); return ; } String fnm = Info . getName ( args [ 0 ] ) + \".odb\" ; XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . createBaseDoc ( fnm , Base . HSQLDB , loader ); // Base.FIREBIRD, loader); if ( dbDoc == null ) { Lo . closeOffice (); return ; } ArrayList < String > cmds = Base . readCmds ( args [ 0 ] ); if ( cmds == null ) { System . out . println ( \"No commands to process\" ); Lo . closeOffice (); return ; } System . out . println ( \"Read in \" + cmds . size () + \" commands\" ); XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password processCmds ( cmds , conn ); XFlushable flusher = Lo . qi ( XFlushable . class , dataSource ); flusher . flush (); // needed or data not saved to file // must refresh the connection or the tables // will not be visible inside Base Base . refreshTables ( conn ); Base . showTables ( dbDoc ); // Office may not close cleanly while showing tables Lo . waitEnter (); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() private static void processCmds ( ArrayList < String > cmds , XConnection conn ) // filter out SELECTs since only creating in this example { for ( String cmd : cmds ) { if ( cmd . startsWith ( \"SELECT\" )) System . out . println ( \"Ignoring: \\\"\" + cmd + \"\\\"\" ); else Base . exec ( cmd , conn ); } } // end of processCmds() Base.readCmds() is a standard piece of Java for reading lines from a file, returning them in a list. Each line is assumed to start with \"CREATE\", \"INSERT\", \"UPDATE\", \"DELETE\", or SELECT\". processCmds() in DBCmdsCreate.java skips over \"SELECT\" queries. Base.exec() hides the details of creating an Statement object, and deciding whether to call XStatement.execute() for \"CREATE\" commands, XStatement.executeUpdate() for \"INSERT\", \"UPDATE\", and DELETE\", or XStatement.executeQuery() for \"SELECT\". After the commands have been processed, it's necessary to flush the newly created tables to the file and refresh Base's Table view. The call: run DBCmdsCreate liangTables . txt creates liangTables.odb and populates it with three tables called Course, Enrollment, and Student, which can be seen in Figure 8. The DBCmdsQuery.java example uses the same Base.readCmds() to read in queries applied to a database. The only difference from DBCmdsCreate.java is that a database is opened with Base.openBaseDoc() rather than created from scratch. 6. Displaying Table Relationships \u00b6 A good way to understand the relationships between multiple tables in a database is with a relation design diagram, which is generated by the Tools, Relationships menu item in Base. For example, the diagram for the three tables in liangTables.odb is shown in Figure 11. Figure 11. The Relation Design Diagram for liangTables.odb. Unfortunately, there's no way to generate relation design diagrams programmatically except via dispatch commands. Another problem is that there's no API or Base menu item for saving a diagram as an image. My solution uses Java's Robot class to send the keys to Windows to trigger a screenshot of the currently active window. My code reads the image from the clipboard and saves it to a file. This programming mishmash is demoed by DBRels.java: // in DBRels.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run DBRels <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( args [ 0 ] , loader ); if ( dbDoc == null ) { System . out . println ( \"Could not open database \" + args [ 0 ] ); Lo . closeOffice (); return ; } if ( Base . isFirebirdEmbedded ( dbDoc )) System . out . println ( \"Embedded Firebird does not support relation design\" ); else { GUI . setVisible ( dbDoc , true ); Lo . delay ( 500 ); // wait for GUI to appear Lo . dispatchCmd ( \"DBRelationDesign\" ); // open the relation design diagram window in Base Lo . delay ( 1000 ); JNAUtils . shootWindow (); // take a screenshot of the currently active window Lo . delay ( 1000 ); // read an image from the clipboard, and save it BufferedImage im = Clip . readImage (); if ( im != null ) Images . saveImage ( im , \"relations.png\" ); Lo . dispatchCmd ( \"CloseWin\" ); // close relation design window Lo . delay ( 500 ); } Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() JNAUtils.shootWindow() doesn't utilize the JNA library, but its use of OS-level functionality means it doesn't really belong in any of my other Office support classes. The code: // in the JNA class public static void shootWindow () // take a screenshot of the window in focus { EventQueue . invokeLater ( new Runnable () { public void run () { try { Robot r = new Robot (); r . keyPress ( KeyEvent . VK_ALT ); // press <alt> <print screen> r . keyPress ( KeyEvent . VK_PRINTSCREEN ); r . keyRelease ( KeyEvent . VK_ALT ); System . out . println ( \"Screenshot of window completed\" ); } catch ( AWTException e ) { System . out . println ( \"Unable to do screenshot: \" + e ); } } }); } // end of shootWindow() Of course, there's a danger that the user (or OS) will move the window focus away from the relation design window, causing the wrong window to be screenshot and stored on the clipboard. Clip.readImage() converts the first Bitmap it finds on the system clipboard into a BufferedImage. I'll talk about my Clipboard support class in Chapter 43. The image is saved to relations.png, which is shown in Figure 12. Figure 12. Part of the relations.png Image. Figure 12 isn't the same as Figure 11 because I rearranged and resized the boxes before snapping the image. Figure 12 shows the original layout produced by Base. Another issue with Base's relation design tool is that it's currently not implemented for embedded Firebird databases. This explains the call to Base.isFirebirdEmbedded() in DBRels.java which lets the diagram creation be skipped. isFirebirdEmbedded() examines the document's DataSource \"URL\" property to see if it contains the string \"sdbc:embedded:firebird\": // in the Base class // globals public static final String HSQL_EMBEDDED = \"sdbc:embedded:hsqldb\" ; public static final String FIREBIRD_EMBEDDED = \"sdbc:embedded:firebird\" ; public static boolean isFirebirdEmbedded ( XOfficeDatabaseDocument dbDoc ) { String embedFnm = getDataSourceType ( dbDoc ); if ( embedFnm == null ) return false ; return ( embedFnm . equals ( FIREBIRD_EMBEDDED )); } public static boolean isHSQLEmbedded ( XOfficeDatabaseDocument dbDoc ) { String embedFnm = getDataSourceType ( dbDoc ); if ( embedFnm == null ) return false ; return ( embedFnm . equals ( HSQL_EMBEDDED )); } public static String getDataSourceType ( XOfficeDatabaseDocument dbDoc ) { if ( dbDoc == null ) { System . out . println ( \"Database is null\" ); return null ; } XDataSource dataSource = dbDoc . getDataSource (); if ( dataSource == null ) { System . out . println ( \"DataSource is null\" ); return null ; } else return ( String ) Props . getProperty ( dataSource , \"URL\" ); } // end of getDataSourceType() There's also an isHSQLEmbedded() method for checking if the document contains an embedded HSQLDB database. 7. Prepared Statements \u00b6 Sdbc supports prepared statements, which are SQL commands with Java-level parameters (denoted by '?'s). The PreparedStatement service stores properties related to how the result set is created, and XPreparedStatement contains the methods. PreparedSales.java shows how prepared statements are created and used. It starts by creating a salesman.odb file containing a SALESMAN table with 5 rows of data. Figure 13 shows the table inside Base. Figure 13. The Initial SALESMAN Table in salesman.odb. At this point, PreparedSales.java calls updatePs(): // in PreparedSales.java private static void updatePs ( XConnection conn ) throws SQLException // update the table with a prepared statement; 4 changes made { XPreparedStatement preStmt = conn . prepareStatement ( \"UPDATE SALESMAN SET STREET = ? WHERE SNR = ?\" ); // change STREET for Joseph (SNR == 1) to 34 Main Road XParameters ps = Lo . qi ( XParameters . class , preStmt ); ps . setString ( 1 , \"34 Main Road\" ); ps . setInt ( 2 , 1 ); preStmt . executeUpdate (); // change STREET for George (SNR == 4) to Marryland ps . setString ( 1 , \"Marryland\" ); ps . setInt ( 2 , 4 ); preStmt . executeUpdate (); // 2nd change of STREET of George to Michigan road // (since SNR is still == 4) ps . setString ( 1 , \"Michigan road\" ); preStmt . executeUpdate (); // change STREET for Jane (SNR == 3) to Bond Street ps . setString ( 1 , \"Bond Street\" ); ps . setInt ( 2 , 3 ); int numRowsChanged = preStmt . executeUpdate (); System . out . println ( \"No. of rows changed by executeUpdate(): \" + numRowsChanged ); // == 1 } // end of updatePs() The prepared statement is an UPDATE command which can change the STREET entry for a given SNR value, but the street and SNR values are specified as \"?\"s. updatePs() changes rows 1, 4, and 2 of SNR a total of four times (row 4 is changed twice). The final result is shown in Figure 14. Figure 14. The Updated SALESMAN Table in salesman.odb. Office's XPreparedStatement methods are similar to those in JDBC's PreparedStatement, except that the set() methods for the \"?\"s are in the XParameters interface. 8. Scrollable and Updatable Result Sets \u00b6 Sdbc's scrollable and updatable result set features are borrowed from JDBC. Scrollability lets the result set's cursor move backwards and jump to a particular row. It can be combined with sensitivity, which allows the set to be automatically updated when the database is modified. An updatable result set means that changes made to the result set's data will trigger updates to the database. Before you become too excited, there's some bad news. Result sets in the current version of Base's HSQLDB (v.1.8) support scrollability, but not sensitivity or updatability. The situation is worse for the current version of Base's Firebird (v. 2.5.2) which doesn't support any of these features; only forward movement of the cursor through the result set is possible. The engine's capabilities are likely to improve in the future, so it's a good idea to check their status when you want to use them. Base.reportResultSetSupport() prints relevant information by examining the XDatabaseMetaData interface: // in the Base class public static void reportResultSetSupport ( XConnection conn ) { try { XDatabaseMetaData md = conn . getMetaData (); System . out . println ( \"Resultset Capabilities:\" ); printTypeConcurrency ( md , ResultSetType . FORWARD_ONLY , \"forward only\" ); printTypeConcurrency ( md , ResultSetType . SCROLL_INSENSITIVE , \"scrollable; db insensitive\" ); printTypeConcurrency ( md , ResultSetType . SCROLL_SENSITIVE , \"scrollable; db sensitive\" ); } catch ( SQLException e ) { System . out . println ( e ); } } // end of reportResultSetSupport() private static void printTypeConcurrency ( XDatabaseMetaData md , int type , String typeStr ) throws SQLException /* Possible ResultSet Type Values: FORWARD_ONLY: The result set is not scrollable (default) SCROLL_INSENSITIVE: The result set is scrollable but not sensitive to database changes. SCROLL_SENSITIVE: The result set is scrollable and sensitive to database changes. Possible 'Concurrency' Values: READ_ONLY: The result set cannot be used to update the database (default) UPDATABLE: The result set can be used to update the database. */ { if ( md . supportsResultSetType ( type )) { System . out . print ( \" Supports \" + typeStr ); if ( md . supportsResultSetConcurrency ( type , ResultSetConcurrency . READ_ONLY )) System . out . print ( \" + read-only\" ); if ( md . supportsResultSetConcurrency ( type , ResultSetConcurrency . UPDATABLE )) System . out . print ( \" + updatable\" ); System . out . println (); } } // end of printTypeConcurrency() FancyRS.java contains an example call: // part of FancyRS.java... Base . reportResultSetSupport ( conn ); The output for an embedded HSQLDB database is: Supports forward only + read only Supports scrollable; db insensitive + read-only The following is printed for an embedded Firebird database: Supports forward only + read-only FancyRS.java shows how scrollable and updatable result sets might be utilized if they were available. The program begins by creating a sales.odb document which can either hold an embedded HSQLDB or Firebird database with a small SALES table. The table printed in ASCII is: +--------+--------+-----+--------+------------+---------+ | SALENR | COS_NR | SNR | NAME | SALEDATE | PRICE | +--------+--------+-----+--------+------------+---------+ | 1 | 100 | 1 | Linux | 2016-02-12 | 15.000 | +--------+--------+-----+--------+------------+---------+ | 2 | 101 | 2 | Beef | 2016-10-18 | 15.780 | +--------+--------+-----+--------+------------+---------+ | 3 | 104 | 4 | Juice | 2016-08-09 | 1.500 | +--------+--------+-----+--------+------------+---------+ The database and table are constructed in main(): // global private static final String FNM = \"sales.odb\" ; // in FancyRS.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . createBaseDoc ( FNM , Base . HSQLDB , loader ); // Base.FIREBIRD, loader); // date bug with Firebird if ( dbDoc == null ) { Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); Base . exec ( \"CREATE TABLE SALES \" + \"(SALENR INTEGER NOT NULL, \" + \" COS_NR INTEGER, SNR INTEGER, NAME VARCHAR(50),\" + \" SALEDATE DATE, PRICE FLOAT(10), PRIMARY KEY(SALENR) )\" , conn ); Base . exec ( \"INSERT INTO SALES \" + \"VALUES (1, '100', '1','Linux','2016-02-12',15)\" , conn ); Base . exec ( \"INSERT INTO SALES \" + \"VALUES (2, '101', '2','Beef','2016-10-18',15.78)\" , conn ); Base . exec ( \"INSERT INTO SALES \" + \"VALUES (3, '104', '4','Juice','2016-08-09',1.5)\" , conn ); XFlushable flusher = Lo . qi ( XFlushable . class , dataSource ); flusher . flush (); System . out . println (); System . out . println ( \"DataSource type: \" + Base . getDataSourceType ( dbDoc )); Base . reportDBInfo ( conn ); Base . reportResultSetSupport ( conn ); System . out . println (); XResultSet rs = Base . executeQuery ( \"SELECT * FROM SALES\" , conn ); BaseTablePrinter . printResultSet ( rs ); useScrollable ( conn ); useUpdatable ( conn ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() 8.1. A Firebird Date Bug \u00b6 FancyRS.java creates the correct embedded HSQLDB database printed above, but if the database type is changed to embedded Firebird (i.e. by changing the second argument of Base.createBaseDoc()), then a well-known LibreOffice/Firebird bug reveals itself. The SALESDATE column of the table will contain the wrong year and month, as shown below: +--------+--------+-----+--------+------------+---------+ | SALENR | COS_NR | SNR | NAME | SALEDATE | PRICE | +--------+--------+-----+--------+------------+---------+ | 1 | 100 | 1 | Linux | 0116-01-12 | 15.000 | +--------+--------+-----+--------+------------+---------+ | 2 | 101 | 2 | Beef | 0116-09-18 | 15.780 | +--------+--------+-----+--------+------------+---------+ | 3 | 104 | 4 | Juice | 0116-07-09 | 1.500 | +--------+--------+-----+--------+------------+---------+ The century is set to 01, and each month is decremented by one. This bug is discussed at https://libreoffice-bugs.freedesktop.narkive.com/fPfsZXpa/bug-91324-new-embedded-firebird-current-date-gives-wrong-date-back . 8.2. Using a Scrollable Result Set \u00b6 useScrollable() in FancyRS.java creates a scrollable result set which is neither sensitive to database changes nor can update the underlying database. In other words, its result set type is assigned ResultSetType.SCROLL_INSENSITIVE and its concurrency is ResultSetConcurrency.READ_ONLY. (For JDBC programmers, these are equivalent to the JDBC constants TYPE_SCROLL_INSENSITIVE and CONCUR_READ_ONLY.) useScrollable() obtains a result set for the NAME and PRICE columns of the SALES table, and prints them in reverse by moving backwards through the result set. The output for the embedded HSQLDB version of the database is: Report name and price backwards: Juice: 1.5 Beef: 15.78 Linux: 15.0 The output when the database is embedded Firebird: Report name and price backwards: useScrollable(): The driver does not support the function 'afterLast not supported in firebird'. The useScrollable() function: // in FancyRS.java private static void useScrollable ( XConnection conn ) { try { XStatement stmt = conn . createStatement (); Props . setProperty ( stmt , \"ResultSetType\" , ResultSetType . SCROLL_INSENSITIVE ); // does not update if there are changes to the database Props . setProperty ( stmt , \"ResultSetConcurrency\" , ResultSetConcurrency . READ_ONLY ); // does not update the database XResultSet srs = stmt . executeQuery ( \"SELECT NAME, PRICE FROM SALES\" ); System . out . println ( \"\\nReport name and price backwards:\" ); // report in reverse order (works for HSQLDB, but // not supported by Firebird) XRow row = Lo . qi ( XRow . class , srs ); srs . afterLast (); while ( srs . previous ()) // name: price printed System . out . println ( \" \" + row . getString ( 1 ) + \": \" + row . getFloat ( 2 )); System . out . println (); } catch ( SQLException e ) { System . out . println ( \"useScrollable(): \" + e . getMessage () + \"\\n\" ); } } // end of useScrollable() 8.3. Using an Updatable Result Set \u00b6 useUpdatable() in FancyRS.java tries to create a result set that is insensitive to database changes but can write its own changes to the database. In other words, its result set type is assigned ResultSetType.SCROLL_INSENSITIVE and its concurrency is ResultSetConcurrency.UPDATABLE. (For JDBC programmers, these are equivalent to TYPE_SCROLL_INSENSITIVE and CONCUR_UPDATABLE.) Since neither of the embedded databases support updating result sets, the code will raise an exception when the XResultSetUpdate methods are called. The code for useUpdatable(): // in FancyRS.java private static void useUpdatable ( XConnection conn ) { try { XStatement stmt = conn . createStatement (); Props . setProperty ( stmt , \"ResultSetType\" , ResultSetType . SCROLL_INSENSITIVE ); // does not update if there are changes to the database Props . setProperty ( stmt , \"ResultSetConcurrency\" , ResultSetConcurrency . UPDATABLE ); // tries to update the database XResultSet srs = stmt . executeQuery ( \"SELECT NAME, PRICE FROM SALES\" ); srs . next (); XRowUpdate updateRow = Lo . qi ( XRowUpdate . class , srs ); updateRow . updateFloat ( 2 , 25 ); // not possible since UPDATABLE downgraded to read-only; // an exception occurs XResultSetUpdate updateRs = Lo . qi ( XResultSetUpdate . class , srs ); updateRs . updateRow (); // this call tries to update the data in DBMS; // an exception would occur if execution reached here XResultSet rs = Base . executeQuery ( \"SELECT * FROM SALES\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( SQLException e ) { System . out . println ( \"useUpdatable(): \" + e . getMessage () + \"\\n\" ); } } // end of useUpdatable() The database is updated in two steps: first a row in the result set is updated, by casting the current row to XRowUpdate, and calling one of its update() methods. Then the modified row is written back to the database by casting the row to XResultSetUpdate and calling updateRow(). An exception is raised when XRowUpdate.updateXXX() is called since sdbc (and JDBC) react to the non-support of updating result sets by downgrading the concurrency setting to ResultSetConcurrency.READ_ONLY. 9. Converting a Database to Text \u00b6 Base doesn't have an export feature for saving a database as text. One solution is to utilize the \"INTO TEXT\" form of the SELECT command, as in: SELECT * INTO TEXT FOO FROM SALES This will store the SALES table as comma-separated rows in the FOO.csv file. Unfortunately, although \"INTO TEXT\" is in HSQLDB (e.g. see https://hsqldb.org/doc/guide/ch06.html ), it isn't currently part of the embedded Firebird engine. A more general approach is to obtain the result set for SELECT * FROM SALES, then use Java to write each row into a text file in CSV format. This is implemented by Base.saveDatabase() and Base.saveTable(): // in the Base class public static void saveDatabase ( XConnection conn ) { if ( conn == null ) { System . out . println ( \"Connection is null\" ); return ; } ArrayList < String > tableNames = getTablesNames ( conn ); if ( tableNames == null ) System . out . println ( \"No tables found in database\" ); else { for ( String tableName : tableNames ) saveTable ( tableName , conn ); } } // end of saveDatabase() public static void saveTable ( String tableName , XConnection conn ) { try { XStatement statement = conn . createStatement (); XResultSet rs = statement . executeQuery ( \"SELECT * FROM \" + tableName ); System . out . println ( \"Saving table: \" + tableName ); saveResultSet ( rs , tableName + \".csv\" ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to save table: \" + tableName ); System . out . println ( e ); } } // end of saveTable() Base.saveDatabase() uses Base.getTablesNames() to get a list of table names, and saveTable() is called for each one. saveTable() creates a CSV file for its table by calling saveResultSet(), which writes the column headers and each row of the table data to the file: // in the Base class public static void saveResultSet ( XResultSet rs , String fnm ) { System . out . println ( \" Writing result set to \" + fnm ); try { BufferedWriter bw = new BufferedWriter ( new FileWriter ( fnm )); XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); int numCols = rsmd . getColumnCount (); // include the headers row StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) sb . append ( \",\" ); sb . append ( rsmd . getColumnName ( i + 1 ) ); } bw . write ( sb . toString ()); bw . newLine (); // add data rows XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) { sb = new StringBuilder (); for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) sb . append ( \",\" ); sb . append ( xRow . getString ( i + 1 )); } bw . write ( sb . toString ()); bw . newLine (); } bw . close (); } catch ( java . lang . Exception e ) { System . out . println ( \"Unable to store result set to \" + fnm ); System . out . println ( e ); } } // end of saveResultSet(); SaveToCSV.java shows how to call Base.saveDatabase(): // in SaveToCSV.java XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( args [ 0 ] , loader ); XDataSource dataSource = dbDoc . getDataSource (); XConnection conn = dataSource . getConnection ( \"\" , \"\" ); Base . saveDatabase ( conn ); There are third-party libraries for reading and writing CSV files. For example, OpenCSV ( https://opencsv.sourceforge.net/ ) includes a CSVWriter.writeAll() method for storing a JDBC result set. I can't utilize it (without changes) since the sdbc result set is a different type.","title":"Chapter 35. Examining Base Documents"},{"location":"35-Examining_Base_Docs.html#chapter-35-examining-base-documents","text":"Topics Querying an Embedded HSQLDB Database; Using Metadata when Querying; Debugging Database Code; Creating a Base Document; Processing Multiple SQL Commands; Displaying Table Relationships; Prepared Statements; Scrollable and Updatable Result Sets; Converting a Database to Text Example folders: \"Base Tests\" and \"Utils\" This chapter looks at programming with Base documents using the XOfficeDatabaseDocument interface, which was labelled with a (1) in Figure 5 of the previous chapter. Figure 1 repeats that figure but without the alternative query approaches (labels (2), (3), and (4)). Figure 1. Querying a Base Document. XOfficeDatabaseDocument accesses a database via the ODB document that's connected to the database. The connection can take two forms \u2013 the database can be embedded inside the ODB file, or the connection can be a URL which links to an external database. Most of my examples will utilize ODB files that contain embedded databases.","title":"Chapter 35. Examining Base Documents"},{"location":"35-Examining_Base_Docs.html#1-querying-an-embedded-hsqldb-database","text":"The following SimpleQuery.java example shows how to query a HSQLDB database embedded inside an ODB file called liangTables.odb. It has three tables, called Course, Enrollment, and Student. Figure 2 shows the data in the Course table, displayed by Base. The filename reflects the fact that the database is based on one in Y. Daniel Liang's \"Introduction to Java Programming\" textbook. Figure 2. The Course Table in liangTables.odb. Although SimpleQuery.java only queries liangTables.odb, the support methods it utilizes are capable of accessing other kinds of ODB document, including ones containing embedded Firebird databases, and database URLs. The main() method for SimpleQuery.java is given below: private static final String FNM = \"liangTables.odb\" ; // in SimpleQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( FNM , loader ); if ( dbDoc == null ) { System . out . println ( \"Could not open database \" + FNM ); Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XStatement statement = conn . createStatement (); // first query XResultSet rs = statement . executeQuery ( \"SELECT * FROM \\\"Course\\\"\" ); XRow xRow = Lo . qi ( XRow . class , rs ); System . out . println ( \"CourseID \\tSubjectID \\tCourseNumber \\tTitle \\tNumOfCredits\" ); System . out . println ( \"=========================\" ); while ( rs . next ()) System . out . println ( xRow . getString ( 1 ) + \", \\t\" + xRow . getString ( 2 ) + \", \\t\" + xRow . getInt ( 3 ) + \", \\t\" + xRow . getString ( 4 ) + \", \" + xRow . getInt ( 5 ) ); System . out . println ( \"=========================\" ); // second query rs = statement . executeQuery ( \"SELECT \\\"courseNumber\\\", \\\"title\\\" FROM \\\"Course\\\"\" ); xRow = Lo . qi ( XRow . class , rs ); XColumnLocate xLoc = Lo . qi ( XColumnLocate . class , rs ); System . out . println ( \"CourseNumber \\tTitle\" ); System . out . println ( \"====================================\" ); while ( rs . next ()) System . out . println ( xRow . getString ( xLoc . findColumn ( \"courseNumber\" )) + \", \\t\" + xRow . getString ( xLoc . findColumn ( \"title\" )) ); System . out . println ( \"====================================\" ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() The code is similar to the JDBC program described in the previous chapter, but uses the sdbc interface, starting with XOfficeDatabaseDocument. Base.openBaseDoc() loads the document as an instance of XComponent, then casts it to XOfficeDatabaseDocument. The relationship between XOfficeDatabaseDocument and XComponent is shown in Figure 3. Figure 3. Obtaining an OfficeDataBaseDocument Instance. The Base.openBaseDoc() method: // in the Base class public static XOfficeDatabaseDocument openBaseDoc ( String fnm , XComponentLoader loader ) { XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Document is null\" ); return null ; } if ( Info . reportDocType ( doc ) != Lo . BASE ) { System . out . println ( \"Not a database doc; closing \" + fnm ); Lo . closeDoc ( doc ); return null ; } // cast XComponent to XOfficeDatabaseDocument XOfficeDatabaseDocument dbDoc = Lo . qi ( XOfficeDatabaseDocument . class , doc ); if ( dbDoc == null ) { System . out . println ( \"Not a database doc; closing \" + fnm ); Lo . closeDoc ( doc ); return null ; } return dbDoc ; } // end of openDoc() Database details, such as whether it's embedded inside or linked to the ODB file, and its type (e.g. HSQLDB, Firebird), are stored in the DataSource service, which is accessed by XOfficeDatabaseDocument.getDataSource(): // in SimpleQuery.java... XDataSource dataSource = dbDoc . getDataSource (); The simplest way of using the data source is to connect to the database by calling getConnection(): XConnection conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XConnection.createStatement() returns an XStatement reference, which can be used to send SQL queries to the database. A query's result set is stored in an XResultSet instance: // in SimpleQuery.java... XStatement statement = conn . createStatement (); XResultSet rs = statement . executeQuery ( \"SELECT * FROM \\\"Course\\\"\" ); Sdbc differs a little from JDBC in how the rows of a result set are examined. A row is represented by a XRow instance which is a cast of XResultSet. However, the set's cursor is still moved through the rows using XResultSet.next(): // in SimpleQuery.java... XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) System . out . println ( xRow . getString ( 1 ) + \", \\t\" + xRow . getString ( 2 ) + \", \\t\" + xRow . getInt ( 3 ) + \", \\t\" + xRow . getString ( 4 ) + \", \" + xRow . getInt ( 5 ) ); Access to data through XRow.getXXX() methods is only possible with column indices. Column names can be used indirectly via XColumnLocate.findColumn() which maps names to indices: // in SimpleQuery.java... rs = statement . executeQuery ( \"SELECT \\\"courseNumber\\\", \\\"title\\\" FROM \\\"Course\\\"\" ); xRow = Lo . qi ( XRow . class , rs ); XColumnLocate xLoc = Lo . qi ( XColumnLocate . class , rs ); System . out . println ( \"CourseNumber \\tTitle\" ); System . out . println ( \"====================================\" ); while ( rs . next ()) System . out . println ( xRow . getString ( xLoc . findColumn ( \"courseNumber\" )) + \", \\t\" + xRow . getString ( xLoc . findColumn ( \"title\" )) ); System . out . println ( \"====================================\" ); The output from SimpleQuery.java is shown in Figure 4. Figure 4. SimpleQuery.java Output. The program ends by closing the connection to the database (with Base.closeConnection()) and the ODB file (with Base.closeBaseDoc()). Both methods cast their arguments to XCloseable, and then call XCloseable.close().","title":"1.  Querying an Embedded HSQLDB Database"},{"location":"35-Examining_Base_Docs.html#2-using-metadata-when-querying-a-base-document","text":"Metadata is information about a database, such as a table's schema, and driver and database engine details. There are four sources of such information in the Base API: the DataSource service; the DatabaseDefinition services; the sdbc metadata services, DatabaseMetaData and ResultSetMetaData. SimpleQuery.java is hardwired to query the Course table in the liangTables.odb database, and prints rather ugly looking output (see Figure 4). Both these issues can be addressed by utilizing database metadata information, as in DBQuery.java described next. I'll use the program to illustrate how the four metadata services can be employed.","title":"2.  Using Metadata when Querying a Base Document"},{"location":"35-Examining_Base_Docs.html#21-the-datasource-service","text":"The DataSource service is depicted in Figure 5. Figure 5. The DataSource Service and Interface. A simple way to access a data source's properties is with my Props.java utility class. For example, the following code prints all of its properties: // part of DBQuery.java... XOfficeDatabaseDocument dbDoc = ... // reference to a Base doc; XDataSource dataSource = dbDoc . getDataSource (); Props . showObjProps ( \"Data Source\" , dataSource ); This information includes the data source type (e.g. whether it is an embedded HSQLDB or Firebird database), whether a password is required to access the tables, and whether the database is read-only. My Base utility class includes several methods that access this information individually. For example: // part of DBQuery.java... System . out . println ( \"Database type: \" + Base . getDataSourceType ( dbDoc )); System . out . println ( \"Is embedded? \" + Base . isEmbedded ( dbDoc )); XDataSource dataSource = dbDoc . getDataSource (); Base . printDataSourceInfo ( dataSource ); System . out . println ( \"Is password required: \" + Base . isPasswordRequired ( dataSource )); System . out . println ( \"Is read-only: \" + Base . isReadOnly ( dataSource )); For the liangTables.odb file, the listed details are: Database type : sdbc : embedded : hsqldb Is embedded ? true Data Source Properties Info == [ Lcom . sun . star . beans . PropertyValue ; @cf768c IsPasswordRequired == false IsReadOnly == false // ... many more lines // : Is password required : false Is read - only : false","title":"2.1.  The DataSource Service"},{"location":"35-Examining_Base_Docs.html#22-the-databasedefinition-services","text":"After a database connection is established, metadata about the structure of the database, its tables, columns, user and group permissions, becomes available. It's accessible through services in the sdbcx module, starting from DatabaseDefinition shown in Figure 6. Figure 6. Accessing Database MetaData via a Connection. For example, Base.getTablesNames() casts an XConnection reference to a XTablesSupplier, which gives access to information about the database's tables: // in the Base class public static ArrayList < String > getTablesNames ( XConnection conn ) { XTablesSupplier tblsSupplier = Lo . qi ( XTablesSupplier . class , conn ); XNameAccess tables = tblsSupplier . getTables (); String [] tableNms = tables . getElementNames (); return new ArrayList < String > ( Arrays . asList ( tableNms )); } // end of getTablesNames() Base.getTablesNames() is called in DBQuery.java like so: // part of DBQuery.java... XConnection conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password ArrayList < String > tableNames = Base . getTablesNames ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); The names of the three tables in liangTables.odb are reported as: No. of tables: 3 [Course, Enrollment, Student] Just as XTablesSupplier is for supplying table information, there are similarly named 'Supplier' interfaces for retrieving details about the database's views, groups, and user accounts. Base.displayTablesInfo() prints all of this information, but the output can be very large if there are more than one or two tables in the database.","title":"2.2.  The DatabaseDefinition Services"},{"location":"35-Examining_Base_Docs.html#23-the-databasemetadata-service","text":"Another way to obtain metadata is to utilize the JDBC-inspired XDatabaseMetaData interface by calling XConnection.getMetaData(): XConnection conn = ... // a connection to the database; XDatabaseMetaData md = conn . getMetaData (); The metadata includes database engine and driver details, as reported by Base.reportDBInfo(): // in the Base class public static void reportDBInfo ( XConnection conn ) { try { XDatabaseMetaData md = conn . getMetaData (); String productName = md . getDatabaseProductName (); String productVersion = md . getDatabaseProductVersion (); if (( productName == null ) || productName . equals ( \"\" )) System . out . println ( \"No database info found\" ); else System . out . println ( \"DB: \" + productName + \" v.\" + productVersion ); String driverName = md . getDriverName (); String driverVersion = md . getDriverVersion (); if (( driverName == null ) || driverName . equals ( \"\" )) System . out . println ( \"No driver info found\" ); else System . out . println ( \"SDBC driver: \" + driverName + \" v.\" + driverVersion ); } catch ( SQLException e ) { System . out . println ( e ); } } // end of reportDBInfo() The output for liangTables.odb shows that it utilizes HSQLDB: DB: HSQL Database Engine v.1.8.0 SDBC driver: HSQL Database Engine Driver v.1.8.0 Unfortunately the XDatabaseMetaData methods don't return anything useful for embedded Firebird databases. The output is: No database info found No driver info found However, data source metadata is available for Firebird via Base.getDataSourceType(): System . out . println ( \"Database type: \" + Base . getDataSourceType ( dbDoc )); For the same Firebird database, it reports: Database type: sdbc:embedded:firebird This illustrates that the functionalities of the HSQLDB and Firebird engines aren't identical, and that the DataSource (section 2.1) and DataDefinition services (section 2.2) may produce more information than the sdbc metadata approach (this section). Base.reportSQLTypes() and Base.reportFunctionSupport() utilize XDatabaseMetaData. The former returns a list of SQL types, and the latter a list of functions supported by the database engine; their use is illustrated in DBQuery.java.","title":"2.3.  The DatabaseMetaData Service"},{"location":"35-Examining_Base_Docs.html#24-the-resultsetmetadata-service","text":"XResultSetMetaData data allows a result set to be better formatted. It's used in Base.printResultSet() to print results sets and in Base.displayResultSet() to fill a scrollable JTable displayed inside a JFrame. The following query prints a result set to standard output: // part of DBQuery.java... ArrayList < String > tableNames = Base . getTablesNames ( conn ); XResultSet rs = Base . executeQuery ( \"SELECT * FROM \\\"\" + tableNames . get ( 0 ) + \"\\\"\" , conn ); Base . printResultSet ( rs ); The query employs the first string from the tableNames list as the SELECT's table. The output for liangTables.odb is: courseId, subjectId, courseNumber, title, numOfCredits -------------------------------------------------------------- 11111, CSCI, 1301, Introduction to Java I, 4 11112, CSCI, 1302, Introduction to Java II, 3 11113, CSCI, 3720, Database Systems, 4 The formatting isn't perfect since its quite tricky to determine the maximum width required for a column. Base.printResultSet() uses XResultSetMetaData to determine the number of columns and their names: // in the Base class public static void printResultSet ( XResultSet rs ) { if ( rs == null ) { System . out . println ( \"No results set to print\" ); return ; } try { XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); int tableWidth = 0 ; int numCols = rsmd . getColumnCount (); String colName ; for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) { System . out . print ( \", \" ); tableWidth += 2 ; } colName = rsmd . getColumnName ( i + 1 ); System . out . printf ( \"%10s\" , colName ); tableWidth += Math . max ( colName . length (), 10 ); } System . out . println (); for ( int i = 0 ; i < tableWidth ; i ++ ) System . out . print ( \"-\" ); System . out . println (); XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) { for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) System . out . print ( \", \" ); System . out . printf ( \"%10s\" , xRow . getString ( i + 1 ) ); } System . out . println (); } System . out . println (); } catch ( SQLException e ) { System . out . println ( e ); } } // end of printResultSet() Fortunately, the hard work of writing a good ASCII-based table printer has already been done by Hami Galip Torun with his DBTablePrinter class, available from https://github.com/htorun/dbtableprinter/ . It offers printTable() and printResultSet() for printing a JDBC table and result set in beautiful ASCII. I made a few small changes to his class to allow it to handle sdbc tables and result sets, which consisted mainly of changing the Connection, Statement, and ResultSet names to XConnection, XStatement, and XResultSet. I've also renamed the class as BaseTablePrinter so I could keep using Torun's original DBTablePrinter for printing JDBC results. The result set shown above is printed by: // part of DBQuery.java... BaseTablePrinter . printResultSet ( rs ); The output: Printing 3 rows from table Course +----------+-----------+--------------+-------------------------+--------------+ | courseId | subjectId | courseNumber | title | numOfCredits | +----------+-----------+--------------+-------------------------+--------------+ | 11111 | CSCI | 1301 | Introduction to Java I | 4 | +----------+-----------+--------------+-------------------------+--------------+ | 11112 | CSCI | 1302 | Introduction to Java II | 3 | +----------+-----------+--------------+-------------------------+--------------+ | 11113 | CSCI | 3720 | Database Systems | 4 | +----------+-----------+--------------+-------------------------+--------------+ A graphical display is implemented by my Base.displayResultSet(), which uses the result set to fill a JTable GUI component inside a JFrame. This result set from above is displayed by: // part of DBQuery.java... Base . displayResultSet ( rs ); Figure 7 shows the JFrame. Figure 7. The Result Set Displayed in a Window. There are some problems with the layout: too much vertical space below the table, and column formatting which shows all the data, but not all the headings. However, the user can resize the window and columns, so these drawbacks aren't serious. displayResultSet() is coded as: // in the Base class public static void displayResultSet ( XResultSet rs ) { displayResultSet ( rs , \"Result set\" , 0 ); } public static void displayResultSet ( XResultSet rs , String title , int offset ) { if ( rs == null ) { System . out . println ( \"No results set to display\" ); return ; } try { XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); // names of columns int numCols = rsmd . getColumnCount (); String [] headers = new String [ numCols ] ; for ( int i = 0 ; i < numCols ; i ++ ) { headers [ i ] = rsmd . getColumnName ( i + 1 ); } // create table with column heads DefaultTableModel tableModel = new DefaultTableModel ( headers , 0 ); JTable table = new JTable ( tableModel ); // fill table with XResultSet contents, one row at a time XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) tableModel . addRow ( getRow ( xRow , numCols )); // resize columns so data is visible table . setAutoResizeMode ( JTable . AUTO_RESIZE_ALL_COLUMNS ); resizeColumnWidth ( table ); SwingUtilities . invokeLater ( new Runnable () { public void run () { JFrame frame = new JFrame (); frame . setBounds ( offset , offset , 400 , 200 ); frame . setTitle ( title ); frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ); // so JFrame closure doesn't kill the main prog frame . add ( new JScrollPane ( table ), BorderLayout . CENTER ); frame . setVisible ( true ); } }); } catch ( SQLException e ) { System . out . println ( e ); } } // end of displayResultSet() This sdbc display code is different from the JDBC version in only two ways. The first is the use of XResultSetMetaDataSupplier to access the result set's metadata: // part of Base.displayResultSet()... XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); The second is the utilization of an XRow instance to refer to each row in the result set: // part of Base.displayResultSet()... XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) tableModel . addRow ( getRow ( xRow , numCols ));","title":"2.4.  The ResultSetMetaData Service"},{"location":"35-Examining_Base_Docs.html#3-debugging-database-code","text":"A useful way to debug larger programs is to display the database tables they're manipulating. The simplest way of doing this is to open the tables inside Base. A call to GUI.setVisible() makes Base and the loaded file visible. However, Base's default behavior is to display its Forms view rather than the Tables view. Even after changing to the Tables view, only the names of the tables are listed not their contents. Base.showTables() deals with these issues, so that the following call: // part of DBQuery.java... Base . showTables ( dbDoc ); Lo . waitEnter (); produces the windows shown in Figure 8 when liangTables.odb is being processed. Figure 8. The liangTables.odb Tables in Base. The call to Lo.waitEnter() gives the user a chance to examine the tables before the program continues. A drawback of this approach is that having open table windows at the end of the program often causes Office to crash after Lo.closeOffice() is called. Base.showTables() utilizes a series of dispatch commands to make the GUI visible, show the Tables view, and open the tables in separate windows: // in the Base class public static void showTables ( XOfficeDatabaseDocument dbDoc ) // open windows for all the tables in the doc { showTablesView ( dbDoc ); Lo . delay ( 500 ); // wait for Tables View to appear Lo . dispatchCmd ( \"SelectAll\" ); Lo . dispatchCmd ( \"DBTableOpen\" ); // open all tables } // end of showTables() public static void showTablesView ( XOfficeDatabaseDocument dbDoc ) // make Base visible, and switch to its Table view { XComponent doc = Lo . qi ( XComponent . class , dbDoc ); GUI . setVisible ( doc , true ); Lo . delay ( 500 ); // wait for GUI to appear Lo . dispatchCmd ( \"DBViewTables\" ); } // end of showTablesView() As usual, using dispatches makes the code very fragile. For example, consider the \"SelectAll\" dispatch which causes Office to select all the table names in the Tables View. To be more precise, \"SelectAll\" selects everything in the active window, which should be the Tables view, but could easily be something else if the user clicked on another window at the wrong time. My Base class offers two alternatives to showTables(): Base.printDatabase() and Base.displayDatabase(); the first builds upon Hami Galip Torun's class to generate textual output of every table in the database, while the second uses my Base.displayResultSet() to render each table in its own JFrame. They are called like so: // part of DBQuery.java... Base . printDatabase ( conn ); Base . displayDatabase ( conn ); Base.displayDatabase() is a better choice for displaying large databases since each JFrame can be resized and is scrollable, as in Figure 9. Figure 9. The liangTables.odb Tables shown in JFrames.","title":"3.  Debugging Database Code"},{"location":"35-Examining_Base_Docs.html#4-creating-a-base-document","text":"The DBCreate.java example creates a new document called spies.odb which holds a single table of \"top-secret\" information on spies. Figure 10 shows the table inside Base. Figure 10. The SPIES Table inside spies.odb. The example employs Base.createBaseDoc() to create an embedded database (which can be either HSQLDB or Firebird). The main() function for DBCreate.java is: private static final String FNM = \"spies.odb\" ; // in DBCreate.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . createBaseDoc ( FNM , Base . HSQLDB , loader ); // Base.FIREBIRD, loader); if ( dbDoc == null ) { Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // create a table in the database Base . exec ( \"CREATE TABLE SPIES \" + \"( FIRSTNAME VARCHAR(50), LASTNAME VARCHAR(50), ID VARCHAR(50), PRIMARY KEY (ID) )\" , conn ); Base . exec ( \"INSERT INTO SPIES VALUES( 'James', 'Bond', '007')\" , conn ); Base . exec ( \"INSERT INTO SPIES VALUES( 'Johnny', 'English', '013')\" , conn ); Base . exec ( \"INSERT INTO SPIES VALUES( 'Maxwell', 'Smart', 'Agent 86')\" , conn ); XFlushable flusher = Lo . qi ( XFlushable . class , dataSource ); flusher . flush (); // needed or data not saved to file; can only be called once // test the database with a query System . out . println (); XResultSet rs = Base . executeQuery ( \"SELECT * FROM SPIES\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() There's something missing from main() \u2013 there's no call to a 'save' function to save the new spies.odb file before the program exits. There's no need because of how the spies.odb file and database are created in two phases. First, Base.createBaseDoc() creates an ODB file with an empty embedded database. The file is saved by createBaseDoc(), then reloaded, and a reference returned by the method. This unusual behavior is necessary or no link (an XConnection) can be opened to the new database. The second phase employs SQL DDL and DML commands to create and populate a table inside the file. The unusual part of this phase is the need to finish off with a call to XFlushable.flush(). This ensures that the table is written out to the embedded database in the file. The final part of the try-catch block is a test to see if the SPIES table can be successfully queried. The BaseTablePrinter.printResultSet() output is: Printing 3 rows from table SPIES +-----------+----------+----------+ | FIRSTNAME | LASTNAME | ID | +-----------+----------+----------+ | James | Bond | 007 | +-----------+----------+----------+ | Johnny | English | 013 | +-----------+----------+----------+ | Maxwell | Smart | Agent 86 | +-----------+----------+----------+ Base.createBaseDoc() is defined as: // in the Base class // globals public static final int UNKNOWN = 0 ; public static final int HSQLDB = 1 ; public static final int FIREBIRD = 2 ; public static final String HSQL_EMBEDDED = \"sdbc:embedded:hsqldb\" ; public static final String FIREBIRD_EMBEDDED = \"sdbc:embedded:firebird\" ; public static XOfficeDatabaseDocument createBaseDoc ( String fnm , int dbType , XComponentLoader loader ) { if (( dbType != HSQLDB ) && ( dbType != FIREBIRD )) { System . out . println ( \"Unknown db type; using HSQLDB\" ); dbType = HSQLDB ; } XComponent doc = Lo . createDoc ( \"sdatabase\" , loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); return null ; } XOfficeDatabaseDocument dbDoc = Lo . qi ( XOfficeDatabaseDocument . class , doc ); XDataSource dataSource = dbDoc . getDataSource (); String sourceStr = ( dbType == FIREBIRD ) ? FIREBIRD_EMBEDDED : HSQL_EMBEDDED ; Props . setProperty ( dataSource , \"URL\" , sourceStr ); System . out . println ( \"Created a \\\"\" + sourceStr + \"\\\" Base document in \" + fnm ); // save, close, reopen, // or no subsequent connection can be made to database Base . saveBaseDoc ( dbDoc , fnm ); Base . closeBaseDoc ( dbDoc ); return openBaseDoc ( fnm , loader ); } // end of createBaseDoc() public static void saveBaseDoc ( XOfficeDatabaseDocument dbDoc , String fnm ) { XComponent doc = Lo . qi ( XComponent . class , dbDoc ); Lo . saveDoc ( doc , fnm ); } Base.createBaseDoc() utilizes Lo.createDoc() to create an empty ODB document, and then sets its data source to be an embedded HSQLDB or Firebird database. The URL property in the DataSource service is assigned \"sdbc:embedded:hsqldb\" or \"sdbc:embedded:firebird\".","title":"4.  Creating a Base Document"},{"location":"35-Examining_Base_Docs.html#viewing-database-creation","text":"It's sometimes useful to observe the stages in a database's creation, and that's most easily achieved by making Base's GUI visible during DBCreate.java's execution. GUI.setVisible() is called at the start of the program: // part of DBCreate.java... GUI . setVisible ( dbDoc , true ); Of course, Base's tables view will not show anything initially since the database is empty. More surprisingly, the view remains empty after the SQL commands have finished and XFlushable.flush() has been called. The table view must be 'refreshed' in order for the new tables to be listed, which is done by Base.refreshTables(): // part of DBCreate.java... Base . refreshTables ( conn ); // place after the call to XFlushable.flush() Base . showTablesView ( dbDoc ); Base.refreshTables() is implemented as: // in the Base class public static void refreshTables ( XConnection conn ) { XTablesSupplier suppTables = Lo . qi ( XTablesSupplier . class , conn ); XRefreshable refresh = Lo . qi ( XRefreshable . class , suppTables . getTables ()); refresh . refresh (); } // end of refreshTables()","title":"Viewing Database Creation"},{"location":"35-Examining_Base_Docs.html#5-processing-multiple-sql-commands","text":"The simplest way to build databases with more tables and data is by storing the necessary DDL and DML commands in a text file. This can be loaded by Base.readCmds(), as in the DBCmdsQuery.java example. main() creates an ODB document with an empty embedded HSQLDB database, builds its tables by executing the commands loaded by Base.readCmds(), and displays the tables inside Base: // in DBCmdsCreate.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: java DBCmdsCreate <cmds fnm>\" ); return ; } String fnm = Info . getName ( args [ 0 ] ) + \".odb\" ; XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . createBaseDoc ( fnm , Base . HSQLDB , loader ); // Base.FIREBIRD, loader); if ( dbDoc == null ) { Lo . closeOffice (); return ; } ArrayList < String > cmds = Base . readCmds ( args [ 0 ] ); if ( cmds == null ) { System . out . println ( \"No commands to process\" ); Lo . closeOffice (); return ; } System . out . println ( \"Read in \" + cmds . size () + \" commands\" ); XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password processCmds ( cmds , conn ); XFlushable flusher = Lo . qi ( XFlushable . class , dataSource ); flusher . flush (); // needed or data not saved to file // must refresh the connection or the tables // will not be visible inside Base Base . refreshTables ( conn ); Base . showTables ( dbDoc ); // Office may not close cleanly while showing tables Lo . waitEnter (); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() private static void processCmds ( ArrayList < String > cmds , XConnection conn ) // filter out SELECTs since only creating in this example { for ( String cmd : cmds ) { if ( cmd . startsWith ( \"SELECT\" )) System . out . println ( \"Ignoring: \\\"\" + cmd + \"\\\"\" ); else Base . exec ( cmd , conn ); } } // end of processCmds() Base.readCmds() is a standard piece of Java for reading lines from a file, returning them in a list. Each line is assumed to start with \"CREATE\", \"INSERT\", \"UPDATE\", \"DELETE\", or SELECT\". processCmds() in DBCmdsCreate.java skips over \"SELECT\" queries. Base.exec() hides the details of creating an Statement object, and deciding whether to call XStatement.execute() for \"CREATE\" commands, XStatement.executeUpdate() for \"INSERT\", \"UPDATE\", and DELETE\", or XStatement.executeQuery() for \"SELECT\". After the commands have been processed, it's necessary to flush the newly created tables to the file and refresh Base's Table view. The call: run DBCmdsCreate liangTables . txt creates liangTables.odb and populates it with three tables called Course, Enrollment, and Student, which can be seen in Figure 8. The DBCmdsQuery.java example uses the same Base.readCmds() to read in queries applied to a database. The only difference from DBCmdsCreate.java is that a database is opened with Base.openBaseDoc() rather than created from scratch.","title":"5.  Processing Multiple SQL Commands"},{"location":"35-Examining_Base_Docs.html#6-displaying-table-relationships","text":"A good way to understand the relationships between multiple tables in a database is with a relation design diagram, which is generated by the Tools, Relationships menu item in Base. For example, the diagram for the three tables in liangTables.odb is shown in Figure 11. Figure 11. The Relation Design Diagram for liangTables.odb. Unfortunately, there's no way to generate relation design diagrams programmatically except via dispatch commands. Another problem is that there's no API or Base menu item for saving a diagram as an image. My solution uses Java's Robot class to send the keys to Windows to trigger a screenshot of the currently active window. My code reads the image from the clipboard and saves it to a file. This programming mishmash is demoed by DBRels.java: // in DBRels.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run DBRels <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( args [ 0 ] , loader ); if ( dbDoc == null ) { System . out . println ( \"Could not open database \" + args [ 0 ] ); Lo . closeOffice (); return ; } if ( Base . isFirebirdEmbedded ( dbDoc )) System . out . println ( \"Embedded Firebird does not support relation design\" ); else { GUI . setVisible ( dbDoc , true ); Lo . delay ( 500 ); // wait for GUI to appear Lo . dispatchCmd ( \"DBRelationDesign\" ); // open the relation design diagram window in Base Lo . delay ( 1000 ); JNAUtils . shootWindow (); // take a screenshot of the currently active window Lo . delay ( 1000 ); // read an image from the clipboard, and save it BufferedImage im = Clip . readImage (); if ( im != null ) Images . saveImage ( im , \"relations.png\" ); Lo . dispatchCmd ( \"CloseWin\" ); // close relation design window Lo . delay ( 500 ); } Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() JNAUtils.shootWindow() doesn't utilize the JNA library, but its use of OS-level functionality means it doesn't really belong in any of my other Office support classes. The code: // in the JNA class public static void shootWindow () // take a screenshot of the window in focus { EventQueue . invokeLater ( new Runnable () { public void run () { try { Robot r = new Robot (); r . keyPress ( KeyEvent . VK_ALT ); // press <alt> <print screen> r . keyPress ( KeyEvent . VK_PRINTSCREEN ); r . keyRelease ( KeyEvent . VK_ALT ); System . out . println ( \"Screenshot of window completed\" ); } catch ( AWTException e ) { System . out . println ( \"Unable to do screenshot: \" + e ); } } }); } // end of shootWindow() Of course, there's a danger that the user (or OS) will move the window focus away from the relation design window, causing the wrong window to be screenshot and stored on the clipboard. Clip.readImage() converts the first Bitmap it finds on the system clipboard into a BufferedImage. I'll talk about my Clipboard support class in Chapter 43. The image is saved to relations.png, which is shown in Figure 12. Figure 12. Part of the relations.png Image. Figure 12 isn't the same as Figure 11 because I rearranged and resized the boxes before snapping the image. Figure 12 shows the original layout produced by Base. Another issue with Base's relation design tool is that it's currently not implemented for embedded Firebird databases. This explains the call to Base.isFirebirdEmbedded() in DBRels.java which lets the diagram creation be skipped. isFirebirdEmbedded() examines the document's DataSource \"URL\" property to see if it contains the string \"sdbc:embedded:firebird\": // in the Base class // globals public static final String HSQL_EMBEDDED = \"sdbc:embedded:hsqldb\" ; public static final String FIREBIRD_EMBEDDED = \"sdbc:embedded:firebird\" ; public static boolean isFirebirdEmbedded ( XOfficeDatabaseDocument dbDoc ) { String embedFnm = getDataSourceType ( dbDoc ); if ( embedFnm == null ) return false ; return ( embedFnm . equals ( FIREBIRD_EMBEDDED )); } public static boolean isHSQLEmbedded ( XOfficeDatabaseDocument dbDoc ) { String embedFnm = getDataSourceType ( dbDoc ); if ( embedFnm == null ) return false ; return ( embedFnm . equals ( HSQL_EMBEDDED )); } public static String getDataSourceType ( XOfficeDatabaseDocument dbDoc ) { if ( dbDoc == null ) { System . out . println ( \"Database is null\" ); return null ; } XDataSource dataSource = dbDoc . getDataSource (); if ( dataSource == null ) { System . out . println ( \"DataSource is null\" ); return null ; } else return ( String ) Props . getProperty ( dataSource , \"URL\" ); } // end of getDataSourceType() There's also an isHSQLEmbedded() method for checking if the document contains an embedded HSQLDB database.","title":"6.  Displaying Table Relationships"},{"location":"35-Examining_Base_Docs.html#7-prepared-statements","text":"Sdbc supports prepared statements, which are SQL commands with Java-level parameters (denoted by '?'s). The PreparedStatement service stores properties related to how the result set is created, and XPreparedStatement contains the methods. PreparedSales.java shows how prepared statements are created and used. It starts by creating a salesman.odb file containing a SALESMAN table with 5 rows of data. Figure 13 shows the table inside Base. Figure 13. The Initial SALESMAN Table in salesman.odb. At this point, PreparedSales.java calls updatePs(): // in PreparedSales.java private static void updatePs ( XConnection conn ) throws SQLException // update the table with a prepared statement; 4 changes made { XPreparedStatement preStmt = conn . prepareStatement ( \"UPDATE SALESMAN SET STREET = ? WHERE SNR = ?\" ); // change STREET for Joseph (SNR == 1) to 34 Main Road XParameters ps = Lo . qi ( XParameters . class , preStmt ); ps . setString ( 1 , \"34 Main Road\" ); ps . setInt ( 2 , 1 ); preStmt . executeUpdate (); // change STREET for George (SNR == 4) to Marryland ps . setString ( 1 , \"Marryland\" ); ps . setInt ( 2 , 4 ); preStmt . executeUpdate (); // 2nd change of STREET of George to Michigan road // (since SNR is still == 4) ps . setString ( 1 , \"Michigan road\" ); preStmt . executeUpdate (); // change STREET for Jane (SNR == 3) to Bond Street ps . setString ( 1 , \"Bond Street\" ); ps . setInt ( 2 , 3 ); int numRowsChanged = preStmt . executeUpdate (); System . out . println ( \"No. of rows changed by executeUpdate(): \" + numRowsChanged ); // == 1 } // end of updatePs() The prepared statement is an UPDATE command which can change the STREET entry for a given SNR value, but the street and SNR values are specified as \"?\"s. updatePs() changes rows 1, 4, and 2 of SNR a total of four times (row 4 is changed twice). The final result is shown in Figure 14. Figure 14. The Updated SALESMAN Table in salesman.odb. Office's XPreparedStatement methods are similar to those in JDBC's PreparedStatement, except that the set() methods for the \"?\"s are in the XParameters interface.","title":"7.  Prepared Statements"},{"location":"35-Examining_Base_Docs.html#8-scrollable-and-updatable-result-sets","text":"Sdbc's scrollable and updatable result set features are borrowed from JDBC. Scrollability lets the result set's cursor move backwards and jump to a particular row. It can be combined with sensitivity, which allows the set to be automatically updated when the database is modified. An updatable result set means that changes made to the result set's data will trigger updates to the database. Before you become too excited, there's some bad news. Result sets in the current version of Base's HSQLDB (v.1.8) support scrollability, but not sensitivity or updatability. The situation is worse for the current version of Base's Firebird (v. 2.5.2) which doesn't support any of these features; only forward movement of the cursor through the result set is possible. The engine's capabilities are likely to improve in the future, so it's a good idea to check their status when you want to use them. Base.reportResultSetSupport() prints relevant information by examining the XDatabaseMetaData interface: // in the Base class public static void reportResultSetSupport ( XConnection conn ) { try { XDatabaseMetaData md = conn . getMetaData (); System . out . println ( \"Resultset Capabilities:\" ); printTypeConcurrency ( md , ResultSetType . FORWARD_ONLY , \"forward only\" ); printTypeConcurrency ( md , ResultSetType . SCROLL_INSENSITIVE , \"scrollable; db insensitive\" ); printTypeConcurrency ( md , ResultSetType . SCROLL_SENSITIVE , \"scrollable; db sensitive\" ); } catch ( SQLException e ) { System . out . println ( e ); } } // end of reportResultSetSupport() private static void printTypeConcurrency ( XDatabaseMetaData md , int type , String typeStr ) throws SQLException /* Possible ResultSet Type Values: FORWARD_ONLY: The result set is not scrollable (default) SCROLL_INSENSITIVE: The result set is scrollable but not sensitive to database changes. SCROLL_SENSITIVE: The result set is scrollable and sensitive to database changes. Possible 'Concurrency' Values: READ_ONLY: The result set cannot be used to update the database (default) UPDATABLE: The result set can be used to update the database. */ { if ( md . supportsResultSetType ( type )) { System . out . print ( \" Supports \" + typeStr ); if ( md . supportsResultSetConcurrency ( type , ResultSetConcurrency . READ_ONLY )) System . out . print ( \" + read-only\" ); if ( md . supportsResultSetConcurrency ( type , ResultSetConcurrency . UPDATABLE )) System . out . print ( \" + updatable\" ); System . out . println (); } } // end of printTypeConcurrency() FancyRS.java contains an example call: // part of FancyRS.java... Base . reportResultSetSupport ( conn ); The output for an embedded HSQLDB database is: Supports forward only + read only Supports scrollable; db insensitive + read-only The following is printed for an embedded Firebird database: Supports forward only + read-only FancyRS.java shows how scrollable and updatable result sets might be utilized if they were available. The program begins by creating a sales.odb document which can either hold an embedded HSQLDB or Firebird database with a small SALES table. The table printed in ASCII is: +--------+--------+-----+--------+------------+---------+ | SALENR | COS_NR | SNR | NAME | SALEDATE | PRICE | +--------+--------+-----+--------+------------+---------+ | 1 | 100 | 1 | Linux | 2016-02-12 | 15.000 | +--------+--------+-----+--------+------------+---------+ | 2 | 101 | 2 | Beef | 2016-10-18 | 15.780 | +--------+--------+-----+--------+------------+---------+ | 3 | 104 | 4 | Juice | 2016-08-09 | 1.500 | +--------+--------+-----+--------+------------+---------+ The database and table are constructed in main(): // global private static final String FNM = \"sales.odb\" ; // in FancyRS.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . createBaseDoc ( FNM , Base . HSQLDB , loader ); // Base.FIREBIRD, loader); // date bug with Firebird if ( dbDoc == null ) { Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); Base . exec ( \"CREATE TABLE SALES \" + \"(SALENR INTEGER NOT NULL, \" + \" COS_NR INTEGER, SNR INTEGER, NAME VARCHAR(50),\" + \" SALEDATE DATE, PRICE FLOAT(10), PRIMARY KEY(SALENR) )\" , conn ); Base . exec ( \"INSERT INTO SALES \" + \"VALUES (1, '100', '1','Linux','2016-02-12',15)\" , conn ); Base . exec ( \"INSERT INTO SALES \" + \"VALUES (2, '101', '2','Beef','2016-10-18',15.78)\" , conn ); Base . exec ( \"INSERT INTO SALES \" + \"VALUES (3, '104', '4','Juice','2016-08-09',1.5)\" , conn ); XFlushable flusher = Lo . qi ( XFlushable . class , dataSource ); flusher . flush (); System . out . println (); System . out . println ( \"DataSource type: \" + Base . getDataSourceType ( dbDoc )); Base . reportDBInfo ( conn ); Base . reportResultSetSupport ( conn ); System . out . println (); XResultSet rs = Base . executeQuery ( \"SELECT * FROM SALES\" , conn ); BaseTablePrinter . printResultSet ( rs ); useScrollable ( conn ); useUpdatable ( conn ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main()","title":"8.  Scrollable and Updatable Result Sets"},{"location":"35-Examining_Base_Docs.html#81-a-firebird-date-bug","text":"FancyRS.java creates the correct embedded HSQLDB database printed above, but if the database type is changed to embedded Firebird (i.e. by changing the second argument of Base.createBaseDoc()), then a well-known LibreOffice/Firebird bug reveals itself. The SALESDATE column of the table will contain the wrong year and month, as shown below: +--------+--------+-----+--------+------------+---------+ | SALENR | COS_NR | SNR | NAME | SALEDATE | PRICE | +--------+--------+-----+--------+------------+---------+ | 1 | 100 | 1 | Linux | 0116-01-12 | 15.000 | +--------+--------+-----+--------+------------+---------+ | 2 | 101 | 2 | Beef | 0116-09-18 | 15.780 | +--------+--------+-----+--------+------------+---------+ | 3 | 104 | 4 | Juice | 0116-07-09 | 1.500 | +--------+--------+-----+--------+------------+---------+ The century is set to 01, and each month is decremented by one. This bug is discussed at https://libreoffice-bugs.freedesktop.narkive.com/fPfsZXpa/bug-91324-new-embedded-firebird-current-date-gives-wrong-date-back .","title":"8.1.  A Firebird Date Bug"},{"location":"35-Examining_Base_Docs.html#82-using-a-scrollable-result-set","text":"useScrollable() in FancyRS.java creates a scrollable result set which is neither sensitive to database changes nor can update the underlying database. In other words, its result set type is assigned ResultSetType.SCROLL_INSENSITIVE and its concurrency is ResultSetConcurrency.READ_ONLY. (For JDBC programmers, these are equivalent to the JDBC constants TYPE_SCROLL_INSENSITIVE and CONCUR_READ_ONLY.) useScrollable() obtains a result set for the NAME and PRICE columns of the SALES table, and prints them in reverse by moving backwards through the result set. The output for the embedded HSQLDB version of the database is: Report name and price backwards: Juice: 1.5 Beef: 15.78 Linux: 15.0 The output when the database is embedded Firebird: Report name and price backwards: useScrollable(): The driver does not support the function 'afterLast not supported in firebird'. The useScrollable() function: // in FancyRS.java private static void useScrollable ( XConnection conn ) { try { XStatement stmt = conn . createStatement (); Props . setProperty ( stmt , \"ResultSetType\" , ResultSetType . SCROLL_INSENSITIVE ); // does not update if there are changes to the database Props . setProperty ( stmt , \"ResultSetConcurrency\" , ResultSetConcurrency . READ_ONLY ); // does not update the database XResultSet srs = stmt . executeQuery ( \"SELECT NAME, PRICE FROM SALES\" ); System . out . println ( \"\\nReport name and price backwards:\" ); // report in reverse order (works for HSQLDB, but // not supported by Firebird) XRow row = Lo . qi ( XRow . class , srs ); srs . afterLast (); while ( srs . previous ()) // name: price printed System . out . println ( \" \" + row . getString ( 1 ) + \": \" + row . getFloat ( 2 )); System . out . println (); } catch ( SQLException e ) { System . out . println ( \"useScrollable(): \" + e . getMessage () + \"\\n\" ); } } // end of useScrollable()","title":"8.2.  Using a Scrollable Result Set"},{"location":"35-Examining_Base_Docs.html#83-using-an-updatable-result-set","text":"useUpdatable() in FancyRS.java tries to create a result set that is insensitive to database changes but can write its own changes to the database. In other words, its result set type is assigned ResultSetType.SCROLL_INSENSITIVE and its concurrency is ResultSetConcurrency.UPDATABLE. (For JDBC programmers, these are equivalent to TYPE_SCROLL_INSENSITIVE and CONCUR_UPDATABLE.) Since neither of the embedded databases support updating result sets, the code will raise an exception when the XResultSetUpdate methods are called. The code for useUpdatable(): // in FancyRS.java private static void useUpdatable ( XConnection conn ) { try { XStatement stmt = conn . createStatement (); Props . setProperty ( stmt , \"ResultSetType\" , ResultSetType . SCROLL_INSENSITIVE ); // does not update if there are changes to the database Props . setProperty ( stmt , \"ResultSetConcurrency\" , ResultSetConcurrency . UPDATABLE ); // tries to update the database XResultSet srs = stmt . executeQuery ( \"SELECT NAME, PRICE FROM SALES\" ); srs . next (); XRowUpdate updateRow = Lo . qi ( XRowUpdate . class , srs ); updateRow . updateFloat ( 2 , 25 ); // not possible since UPDATABLE downgraded to read-only; // an exception occurs XResultSetUpdate updateRs = Lo . qi ( XResultSetUpdate . class , srs ); updateRs . updateRow (); // this call tries to update the data in DBMS; // an exception would occur if execution reached here XResultSet rs = Base . executeQuery ( \"SELECT * FROM SALES\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( SQLException e ) { System . out . println ( \"useUpdatable(): \" + e . getMessage () + \"\\n\" ); } } // end of useUpdatable() The database is updated in two steps: first a row in the result set is updated, by casting the current row to XRowUpdate, and calling one of its update() methods. Then the modified row is written back to the database by casting the row to XResultSetUpdate and calling updateRow(). An exception is raised when XRowUpdate.updateXXX() is called since sdbc (and JDBC) react to the non-support of updating result sets by downgrading the concurrency setting to ResultSetConcurrency.READ_ONLY.","title":"8.3.  Using an Updatable Result Set"},{"location":"35-Examining_Base_Docs.html#9-converting-a-database-to-text","text":"Base doesn't have an export feature for saving a database as text. One solution is to utilize the \"INTO TEXT\" form of the SELECT command, as in: SELECT * INTO TEXT FOO FROM SALES This will store the SALES table as comma-separated rows in the FOO.csv file. Unfortunately, although \"INTO TEXT\" is in HSQLDB (e.g. see https://hsqldb.org/doc/guide/ch06.html ), it isn't currently part of the embedded Firebird engine. A more general approach is to obtain the result set for SELECT * FROM SALES, then use Java to write each row into a text file in CSV format. This is implemented by Base.saveDatabase() and Base.saveTable(): // in the Base class public static void saveDatabase ( XConnection conn ) { if ( conn == null ) { System . out . println ( \"Connection is null\" ); return ; } ArrayList < String > tableNames = getTablesNames ( conn ); if ( tableNames == null ) System . out . println ( \"No tables found in database\" ); else { for ( String tableName : tableNames ) saveTable ( tableName , conn ); } } // end of saveDatabase() public static void saveTable ( String tableName , XConnection conn ) { try { XStatement statement = conn . createStatement (); XResultSet rs = statement . executeQuery ( \"SELECT * FROM \" + tableName ); System . out . println ( \"Saving table: \" + tableName ); saveResultSet ( rs , tableName + \".csv\" ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to save table: \" + tableName ); System . out . println ( e ); } } // end of saveTable() Base.saveDatabase() uses Base.getTablesNames() to get a list of table names, and saveTable() is called for each one. saveTable() creates a CSV file for its table by calling saveResultSet(), which writes the column headers and each row of the table data to the file: // in the Base class public static void saveResultSet ( XResultSet rs , String fnm ) { System . out . println ( \" Writing result set to \" + fnm ); try { BufferedWriter bw = new BufferedWriter ( new FileWriter ( fnm )); XResultSetMetaDataSupplier rsMetaSupp = Lo . qi ( XResultSetMetaDataSupplier . class , rs ); XResultSetMetaData rsmd = rsMetaSupp . getMetaData (); int numCols = rsmd . getColumnCount (); // include the headers row StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) sb . append ( \",\" ); sb . append ( rsmd . getColumnName ( i + 1 ) ); } bw . write ( sb . toString ()); bw . newLine (); // add data rows XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) { sb = new StringBuilder (); for ( int i = 0 ; i < numCols ; i ++ ) { if ( i > 0 ) sb . append ( \",\" ); sb . append ( xRow . getString ( i + 1 )); } bw . write ( sb . toString ()); bw . newLine (); } bw . close (); } catch ( java . lang . Exception e ) { System . out . println ( \"Unable to store result set to \" + fnm ); System . out . println ( e ); } } // end of saveResultSet(); SaveToCSV.java shows how to call Base.saveDatabase(): // in SaveToCSV.java XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( args [ 0 ] , loader ); XDataSource dataSource = dbDoc . getDataSource (); XConnection conn = dataSource . getConnection ( \"\" , \"\" ); Base . saveDatabase ( conn ); There are third-party libraries for reading and writing CSV files. For example, OpenCSV ( https://opencsv.sourceforge.net/ ) includes a CSVWriter.writeAll() method for storing a JDBC result set. I can't utilize it (without changes) since the sdbc result set is a different type.","title":"9.  Converting a Database to Text"},{"location":"36-RowSets_DB_Context.html","text":"Chapter 36. Using RowSets and Database Context \u00b6 Topics Using RowSets; Using the Database Context; Copying Data From Base To Calc Example folders: \"Base Tests\" and \"Utils\" This chapter looks at programming with the XRowSet and XDatabaseContext interfaces, which were labelled (2) and (3) in Figure 5 of the Chapter 34. Figure 1 repeats that figure but without the alternative query approaches (labels (1) and (4)). Figure 1. Querying a Base Document. 1. Using RowSets \u00b6 Base's RowSet offers much the same functionality as JDBC's RowSet in that it abstracts away from connecting Java to a database towards queries applied to general tabular data. This means that a row set can access different types of information include flat files, spreadsheets, and ODB files. The JDBC RowSet is implemented in a different way from the sdb row set \u2013 JDBC supports several RowSet subclasses, including JdbcRowSet, CachedRowSet and WebRowSet, none of which are present in the Base API. Instead the different ways of manipulating files are specified by setting properties in a RowSet object before it is executed. Figure 2 shows that row set properties are distributed between two RowSet services, one in the sdbc module, the other in the higher-level sdb module. Figure 2. The RowSet Services and Interfaces. Although the XRowSet interface's most important method is execute(), it inherits XResultSet which adds other useful functions. One benefit is that an executed row set, which contains results, can be passed to the BaseTablePrinter class for ASCII printing. Aside from the documentation webpages for the two RowSet services, a good summary of row set properties can be found in \"The RowSet Service\" section of the Developer's Guide in chapter 12. The same information is online at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Usage/ (or use loguide \"Database usage\" ). My personal view is that the RowSet service is overly complex, trying to combine too many ways of accessing databases and tabular data. It's easier to use separate services aimed at specific forms of data. For example, XOfficeDatabaseDocument for ODB files, XDatabaseContext for URLs, and XDriverManager for none-ODB data such as CSV files and e-mail address books. I'll discuss XDatabaseContext in section 2 and XDriverManager in the next chapter. Another 'black mark' against RowSet is that the my example below hangs after closing a row set; Lo.killOffice() must be called to end the program. UseRowSets.java executes a row set containing a simple SQL query: // in UseRowSets.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); execQuery (); Lo . closeOffice (); Lo . killOffice (); // needed to clean-up after XRowSet } // end of main() private static void execQuery () { try { System . out . println ( \"Initializing rowset...\" ); XRowSet xRowSet = Base . rowSetQuery ( \"liangTables.odb\" , \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); // add rowset listener xRowSet . addRowSetListener ( new XRowSetListener () { public void cursorMoved ( EventObject e ) { System . out . println ( \"Cursor moved\" ); } public void rowChanged ( EventObject e ) { System . out . println ( \"Row changed\" ); } public void rowSetChanged ( EventObject e ) { System . out . println ( \"RowSet changed\" ); } public void disposing ( EventObject e ) { System . out . println ( \"RowSet being destroyed\" ); } }); System . out . println ( \"Executing rowset...\" ); xRowSet . execute (); BaseTablePrinter . printResultSet ( xRowSet ); // possible since XRowSet is a subclass of XResultSet // dispose of row set XComponent xComp = Lo . qi ( XComponent . class , xRowSet ); xComp . dispose (); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of execQuery() The tricky initialization of RowSet properties is handled by Base.rowSetQuery(): // in the Base class public static XRowSet rowSetQuery ( String fnm , String query ) { XRowSet xRowSet = Lo . createInstanceMCF ( XRowSet . class , \"com.sun.star.sdb.RowSet\" ); Props . setProperty ( xRowSet , \"DataSourceName\" , FileIO . fnmToURL ( fnm )); Props . setProperty ( xRowSet , \"CommandType\" , CommandType . COMMAND ); // TABLE, QUERY or COMMAND Props . setProperty ( xRowSet , \"Command\" , query ); // command could be a table, query name, or SQL, // depending on the CommandType // set these if your database requires a login // Props.setProperty(xRowSet, \"User\", \"\"); // Props.setProperty(xRowSet, \"Password\", \"\"); // more attributes are defined in sdb and sdbc Rowset... return xRowSet ; } // end of rowSetQuery() Base.rowSetQuery() shows that initializing a row set is less work than directly obtaining an ODB data source, connecting to the database, and creating a Statement service. The equivalent of executing a statement is the call to XRowset.execute(), carried out by execQuery() in UseRowSets.java: xRowSet.execute(); Once the row set has been populated, it's passed to BaseTablePrinter.printResultSet() where it's treated as an XResultSet instance: // in execQuery()... BaseTablePrinter . printResultSet ( xRowSet ); Listening to the Row Set \u00b6 execQuery() shows how it's possible to attach a listener to a row set, which is woken up when the result set cursor moves or the set is changed. The anonymous XRowSetListener in execQuery() prints a short message if any of its handlers are triggered; their output can be seen in Figure 3. Figure 3. The Execution of UseRowSets.java. Termination Problem after Closing a Row Set \u00b6 The disposal of the row set is easy: // at the end of execQuery()... XComponent xComp = Lo . qi ( XComponent . class , xRowSet ); xComp . dispose (); Back in main(), Lo.closeOffice() is executed, returns, but then the program hangs. A call to Lo.killOffice() (which utilizes Window's taskkill) is needed to terminate the program and Office. 2. Using the Database Context \u00b6 Sdbc's XDatabaseContext lets the programmer access Base's database context, which is a container for data sources (see Figure 1). Data sources map names to databases, hiding the low-level details of the driver's protocol, and whether the database is embedded in an ODB file or located at the other end of a URL. Base's database context performs a similar role to JNDI for data sources in JDBC. Figure 4 shows the DatabaseContext service and some of its important interfaces. Figure 4. The DatabaseContext Service and Interfaces. 2.1. Registered Data Sources \u00b6 It's possible to add (or register) new data sources to Base's database context, but I won't be using that feature. Currently registered sources are listed by Base.printRegisteredDataSources(): // in the Base class public static void printRegisteredDataSources () // print all registered datasources { XDatabaseRegistrations dbRegs = Lo . createInstanceMCF ( XDatabaseRegistrations . class , \"com.sun.star.sdb.DatabaseContext\" ); XNameAccess nmsAccess = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.sdb.DatabaseContext\" ); String dsNames [] = nmsAccess . getElementNames (); System . out . println ( \"Registered Data Sources (\" + dsNames . length + \")\" ); for ( int i = 0 ; i < dsNames . length ; ++ i ) { String dbLoc = null ; try { dbLoc = dbRegs . getDatabaseLocation ( dsNames [ i ] ); } catch ( com . sun . star . uno . Exception e ) {} System . out . println ( \" \" + dsNames [ i ] + \" in \" + dbLoc ); } System . out . println (); } // end of printRegisteredDataSources() The method iterates through the data source names in the database context, printing the locations of their associated databases. The output for my version of Base is: Registered Data Sources (1) Bibliography in file:///C:/Users/Dell/AppData/Roaming/LibreOffice/4/user/database/biblio.odb Only a \"Bibliography\" data source is stored in the database context, which maps to an ODB file called biblio.odb. 2.2. Accessing a File Using a Data Source \u00b6 New data sources can be created in the database context, which offers a way to access ODB files without having to explicitly open them as documents. For example, the DataSourcer.java example shows how \"liangTables.odb\" can be queried without having to first instantiate XOfficeDatabaseDocument (i.e. without opening the ODB file). // in DataSourcer.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); Base . printRegisteredDataSources (); // explained above XConnection conn = null ; try { XDataSource dataSource = Base . getFileDataSource ( \"liangTables.odb\" ); // no office document opened conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XResultSet rs = Base . executeQuery ( \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); Lo . killOffice (); // needed when Base.getFileDataSource() used } // end of main() The database context is manipulated by Base.getFileDataSource(): // in the Base class public static XDataSource getFileDataSource ( String fnm ) { try { String fileURL = FileIO . fnmToURL ( fnm ); XNameAccess nmsAccess = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.sdb.DatabaseContext\" ); XDataSource ds = Lo . qi ( XDataSource . class , nmsAccess . getByName ( fileURL ) ); if ( ds == null ) { System . out . println ( \"No data source for \" + fnm ); return null ; } else { System . out . println ( \"Found data source for \" + fnm ); return ds ; } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to access data source for \" + fnm + \": \" + e . getMessage ()); return null ; } } // end of getFileDataSource() The database context's XNameAccess interface is used to map the supplied filename to a data source. Back in main() of DataSourcer.java, the Student table in the database is queried using the data source, and then the program closes the connection and Office. There's no need to close an XOfficeDatabaseDocument document, (e.g. by calling Base.closeBaseDoc(dbDoc)) since one was never opened. Unfortunately, DataSourcer.java needs to call Lo.killOffice() or the program will hang after the return of Lo.closeOffice(). This is similar to the row set problem in UseRowSets.java in the previus section. 3. Copying Data From Base To Calc \u00b6 There are a few places in my Office support classes where the code assumes only one document is open at a time. For programs that copy data from one document to another, problems can be avoided by using an intermediate data structure. The usual strategy is to read the data from the first document, then close the file before the second document is opened, and then the data is added to it. This situation arises when copying database records (stored in a Base document) to a spreadsheet (a Calc document). An alternative solution to using an intermediate data structure is to access the database as a data source instead of as a XOfficeDatabaseDocument object. This means that only a single Calc document is manipulated by the program so no problems arise with my support classes. This approach is implemented in StoreInCalc.java: // globals private static final String FNM = \"liangTables.odb\" ; private static final String CALC_FNM = \"liangCalc.ods\" ; // in StoreInCalc.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } System . out . println ( \"Created a Calc document\" ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); if ( sheet == null ) { System . out . println ( \"No spreadsheet found\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // show the new sheet Object [][] rsa = queryDB ( FNM , \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); if ( rsa != null ) fillSheet ( sheet , rsa ); Lo . delay ( 3000 ); // wait for visible sheet to be changed Lo . saveDoc ( doc , CALC_FNM ); Lo . closeDoc ( doc ); Lo . closeOffice (); // Lo.killOffice(); // needed when getFileDataSource() used } // end of main() The program creates a XSpreadsheetDocument object, which is left open while queryDB() queries the database. The result set is returned as a 2D array called rsa, which fillSheet() uses to populate the spreadsheet. The document is saved and Office closed. queryDB() accesses the database as a data source, not as a document: // in StoreInCalc.java private static Object [][] queryDB ( String fnm , String query ) { Object [][] rsa = null ; XConnection conn = null ; try { XDataSource dataSource = Base . getFileDataSource ( fnm ); conn = dataSource . getConnection ( \"\" , \"\" ); XResultSet rs = Base . executeQuery ( query , conn ); rsa = Base . getResultSetArr ( rs ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); return rsa ; } // end of queryDB() Base.getResultSetArr() returns the result set as a 2D array of Objects. It builds the array by traversing the result set a row at a time, creating a one-dimensional array for each row. The data structure could be a defined as a 2D array of strings, except that the Calc API requires an object array fillSheet() uses XCellRangeData.setDataArray() to add the array to the sheet: // in StoreInCalc.java private static void fillSheet ( XSpreadsheet sheet , Object [][] rsa ) { try { XCellRange cellRange = sheet . getCellRangeByPosition ( 0 , 0 , rsa [ 0 ] . length - 1 , rsa . length - 1 ); XCellRangeData xData = Lo . qi ( XCellRangeData . class , cellRange ); xData . setDataArray ( rsa ); } catch ( Exception e ) { System . out . println ( \"Could not writes values to cells\" ); } } // end of fillSheet()","title":"Chapter 36. Using RowSets and Database Context"},{"location":"36-RowSets_DB_Context.html#chapter-36-using-rowsets-and-database-context","text":"Topics Using RowSets; Using the Database Context; Copying Data From Base To Calc Example folders: \"Base Tests\" and \"Utils\" This chapter looks at programming with the XRowSet and XDatabaseContext interfaces, which were labelled (2) and (3) in Figure 5 of the Chapter 34. Figure 1 repeats that figure but without the alternative query approaches (labels (1) and (4)). Figure 1. Querying a Base Document.","title":"Chapter 36. Using RowSets and Database Context"},{"location":"36-RowSets_DB_Context.html#1-using-rowsets","text":"Base's RowSet offers much the same functionality as JDBC's RowSet in that it abstracts away from connecting Java to a database towards queries applied to general tabular data. This means that a row set can access different types of information include flat files, spreadsheets, and ODB files. The JDBC RowSet is implemented in a different way from the sdb row set \u2013 JDBC supports several RowSet subclasses, including JdbcRowSet, CachedRowSet and WebRowSet, none of which are present in the Base API. Instead the different ways of manipulating files are specified by setting properties in a RowSet object before it is executed. Figure 2 shows that row set properties are distributed between two RowSet services, one in the sdbc module, the other in the higher-level sdb module. Figure 2. The RowSet Services and Interfaces. Although the XRowSet interface's most important method is execute(), it inherits XResultSet which adds other useful functions. One benefit is that an executed row set, which contains results, can be passed to the BaseTablePrinter class for ASCII printing. Aside from the documentation webpages for the two RowSet services, a good summary of row set properties can be found in \"The RowSet Service\" section of the Developer's Guide in chapter 12. The same information is online at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Usage/ (or use loguide \"Database usage\" ). My personal view is that the RowSet service is overly complex, trying to combine too many ways of accessing databases and tabular data. It's easier to use separate services aimed at specific forms of data. For example, XOfficeDatabaseDocument for ODB files, XDatabaseContext for URLs, and XDriverManager for none-ODB data such as CSV files and e-mail address books. I'll discuss XDatabaseContext in section 2 and XDriverManager in the next chapter. Another 'black mark' against RowSet is that the my example below hangs after closing a row set; Lo.killOffice() must be called to end the program. UseRowSets.java executes a row set containing a simple SQL query: // in UseRowSets.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); execQuery (); Lo . closeOffice (); Lo . killOffice (); // needed to clean-up after XRowSet } // end of main() private static void execQuery () { try { System . out . println ( \"Initializing rowset...\" ); XRowSet xRowSet = Base . rowSetQuery ( \"liangTables.odb\" , \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); // add rowset listener xRowSet . addRowSetListener ( new XRowSetListener () { public void cursorMoved ( EventObject e ) { System . out . println ( \"Cursor moved\" ); } public void rowChanged ( EventObject e ) { System . out . println ( \"Row changed\" ); } public void rowSetChanged ( EventObject e ) { System . out . println ( \"RowSet changed\" ); } public void disposing ( EventObject e ) { System . out . println ( \"RowSet being destroyed\" ); } }); System . out . println ( \"Executing rowset...\" ); xRowSet . execute (); BaseTablePrinter . printResultSet ( xRowSet ); // possible since XRowSet is a subclass of XResultSet // dispose of row set XComponent xComp = Lo . qi ( XComponent . class , xRowSet ); xComp . dispose (); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of execQuery() The tricky initialization of RowSet properties is handled by Base.rowSetQuery(): // in the Base class public static XRowSet rowSetQuery ( String fnm , String query ) { XRowSet xRowSet = Lo . createInstanceMCF ( XRowSet . class , \"com.sun.star.sdb.RowSet\" ); Props . setProperty ( xRowSet , \"DataSourceName\" , FileIO . fnmToURL ( fnm )); Props . setProperty ( xRowSet , \"CommandType\" , CommandType . COMMAND ); // TABLE, QUERY or COMMAND Props . setProperty ( xRowSet , \"Command\" , query ); // command could be a table, query name, or SQL, // depending on the CommandType // set these if your database requires a login // Props.setProperty(xRowSet, \"User\", \"\"); // Props.setProperty(xRowSet, \"Password\", \"\"); // more attributes are defined in sdb and sdbc Rowset... return xRowSet ; } // end of rowSetQuery() Base.rowSetQuery() shows that initializing a row set is less work than directly obtaining an ODB data source, connecting to the database, and creating a Statement service. The equivalent of executing a statement is the call to XRowset.execute(), carried out by execQuery() in UseRowSets.java: xRowSet.execute(); Once the row set has been populated, it's passed to BaseTablePrinter.printResultSet() where it's treated as an XResultSet instance: // in execQuery()... BaseTablePrinter . printResultSet ( xRowSet );","title":"1.  Using RowSets"},{"location":"36-RowSets_DB_Context.html#listening-to-the-row-set","text":"execQuery() shows how it's possible to attach a listener to a row set, which is woken up when the result set cursor moves or the set is changed. The anonymous XRowSetListener in execQuery() prints a short message if any of its handlers are triggered; their output can be seen in Figure 3. Figure 3. The Execution of UseRowSets.java.","title":"Listening to the Row Set"},{"location":"36-RowSets_DB_Context.html#termination-problem-after-closing-a-row-set","text":"The disposal of the row set is easy: // at the end of execQuery()... XComponent xComp = Lo . qi ( XComponent . class , xRowSet ); xComp . dispose (); Back in main(), Lo.closeOffice() is executed, returns, but then the program hangs. A call to Lo.killOffice() (which utilizes Window's taskkill) is needed to terminate the program and Office.","title":"Termination Problem after Closing a Row Set"},{"location":"36-RowSets_DB_Context.html#2-using-the-database-context","text":"Sdbc's XDatabaseContext lets the programmer access Base's database context, which is a container for data sources (see Figure 1). Data sources map names to databases, hiding the low-level details of the driver's protocol, and whether the database is embedded in an ODB file or located at the other end of a URL. Base's database context performs a similar role to JNDI for data sources in JDBC. Figure 4 shows the DatabaseContext service and some of its important interfaces. Figure 4. The DatabaseContext Service and Interfaces.","title":"2.  Using the Database Context"},{"location":"36-RowSets_DB_Context.html#21-registered-data-sources","text":"It's possible to add (or register) new data sources to Base's database context, but I won't be using that feature. Currently registered sources are listed by Base.printRegisteredDataSources(): // in the Base class public static void printRegisteredDataSources () // print all registered datasources { XDatabaseRegistrations dbRegs = Lo . createInstanceMCF ( XDatabaseRegistrations . class , \"com.sun.star.sdb.DatabaseContext\" ); XNameAccess nmsAccess = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.sdb.DatabaseContext\" ); String dsNames [] = nmsAccess . getElementNames (); System . out . println ( \"Registered Data Sources (\" + dsNames . length + \")\" ); for ( int i = 0 ; i < dsNames . length ; ++ i ) { String dbLoc = null ; try { dbLoc = dbRegs . getDatabaseLocation ( dsNames [ i ] ); } catch ( com . sun . star . uno . Exception e ) {} System . out . println ( \" \" + dsNames [ i ] + \" in \" + dbLoc ); } System . out . println (); } // end of printRegisteredDataSources() The method iterates through the data source names in the database context, printing the locations of their associated databases. The output for my version of Base is: Registered Data Sources (1) Bibliography in file:///C:/Users/Dell/AppData/Roaming/LibreOffice/4/user/database/biblio.odb Only a \"Bibliography\" data source is stored in the database context, which maps to an ODB file called biblio.odb.","title":"2.1.  Registered Data Sources"},{"location":"36-RowSets_DB_Context.html#22-accessing-a-file-using-a-data-source","text":"New data sources can be created in the database context, which offers a way to access ODB files without having to explicitly open them as documents. For example, the DataSourcer.java example shows how \"liangTables.odb\" can be queried without having to first instantiate XOfficeDatabaseDocument (i.e. without opening the ODB file). // in DataSourcer.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); Base . printRegisteredDataSources (); // explained above XConnection conn = null ; try { XDataSource dataSource = Base . getFileDataSource ( \"liangTables.odb\" ); // no office document opened conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XResultSet rs = Base . executeQuery ( \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); Lo . killOffice (); // needed when Base.getFileDataSource() used } // end of main() The database context is manipulated by Base.getFileDataSource(): // in the Base class public static XDataSource getFileDataSource ( String fnm ) { try { String fileURL = FileIO . fnmToURL ( fnm ); XNameAccess nmsAccess = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.sdb.DatabaseContext\" ); XDataSource ds = Lo . qi ( XDataSource . class , nmsAccess . getByName ( fileURL ) ); if ( ds == null ) { System . out . println ( \"No data source for \" + fnm ); return null ; } else { System . out . println ( \"Found data source for \" + fnm ); return ds ; } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Unable to access data source for \" + fnm + \": \" + e . getMessage ()); return null ; } } // end of getFileDataSource() The database context's XNameAccess interface is used to map the supplied filename to a data source. Back in main() of DataSourcer.java, the Student table in the database is queried using the data source, and then the program closes the connection and Office. There's no need to close an XOfficeDatabaseDocument document, (e.g. by calling Base.closeBaseDoc(dbDoc)) since one was never opened. Unfortunately, DataSourcer.java needs to call Lo.killOffice() or the program will hang after the return of Lo.closeOffice(). This is similar to the row set problem in UseRowSets.java in the previus section.","title":"2.2.  Accessing a File Using a Data Source"},{"location":"36-RowSets_DB_Context.html#3-copying-data-from-base-to-calc","text":"There are a few places in my Office support classes where the code assumes only one document is open at a time. For programs that copy data from one document to another, problems can be avoided by using an intermediate data structure. The usual strategy is to read the data from the first document, then close the file before the second document is opened, and then the data is added to it. This situation arises when copying database records (stored in a Base document) to a spreadsheet (a Calc document). An alternative solution to using an intermediate data structure is to access the database as a data source instead of as a XOfficeDatabaseDocument object. This means that only a single Calc document is manipulated by the program so no problems arise with my support classes. This approach is implemented in StoreInCalc.java: // globals private static final String FNM = \"liangTables.odb\" ; private static final String CALC_FNM = \"liangCalc.ods\" ; // in StoreInCalc.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } System . out . println ( \"Created a Calc document\" ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); if ( sheet == null ) { System . out . println ( \"No spreadsheet found\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); // show the new sheet Object [][] rsa = queryDB ( FNM , \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); if ( rsa != null ) fillSheet ( sheet , rsa ); Lo . delay ( 3000 ); // wait for visible sheet to be changed Lo . saveDoc ( doc , CALC_FNM ); Lo . closeDoc ( doc ); Lo . closeOffice (); // Lo.killOffice(); // needed when getFileDataSource() used } // end of main() The program creates a XSpreadsheetDocument object, which is left open while queryDB() queries the database. The result set is returned as a 2D array called rsa, which fillSheet() uses to populate the spreadsheet. The document is saved and Office closed. queryDB() accesses the database as a data source, not as a document: // in StoreInCalc.java private static Object [][] queryDB ( String fnm , String query ) { Object [][] rsa = null ; XConnection conn = null ; try { XDataSource dataSource = Base . getFileDataSource ( fnm ); conn = dataSource . getConnection ( \"\" , \"\" ); XResultSet rs = Base . executeQuery ( query , conn ); rsa = Base . getResultSetArr ( rs ); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); return rsa ; } // end of queryDB() Base.getResultSetArr() returns the result set as a 2D array of Objects. It builds the array by traversing the result set a row at a time, creating a one-dimensional array for each row. The data structure could be a defined as a 2D array of strings, except that the Calc API requires an object array fillSheet() uses XCellRangeData.setDataArray() to add the array to the sheet: // in StoreInCalc.java private static void fillSheet ( XSpreadsheet sheet , Object [][] rsa ) { try { XCellRange cellRange = sheet . getCellRangeByPosition ( 0 , 0 , rsa [ 0 ] . length - 1 , rsa . length - 1 ); XCellRangeData xData = Lo . qi ( XCellRangeData . class , cellRange ); xData . setDataArray ( rsa ); } catch ( Exception e ) { System . out . println ( \"Could not writes values to cells\" ); } } // end of fillSheet()","title":"3.  Copying Data From Base To Calc"},{"location":"37-Driver_Manager.html","text":"Chapter 37. Using the Driver Manager \u00b6 Topics Querying a CSV File; Querying an Access File; Querying a Calc Spreadsheet; Querying a Thunderbird Address Book Example folders: \"Base Tests\" and \"Utils\" This chapter looks at programming with the XDriveManager interface, which were labelled (4) in Figure 5 of the Chapter 34. Figure 1 repeats that figure but without the alternative query approaches (labels (1), (2) and (3)). Figure 1. Querying a Document. XDriverManager offers a low-level driver approach for accessing databases, which is similar to JDBC's DriverManager. It's rarely used to access Office databases, which are more conveniently manipulated using XOfficeDatabaseDocument (see Chapter 35). More commonly XDriverManager is employed for non-Office databases, such as MS Access files, and tabular data inside CSV files, Calc spreadsheets, and e-mail address books. This chapter includes examples of how to query these kinds of files. The drawback of using a driver manager is the low-level information that the programmer has to supply, including the driver name, the file's URL, and the connection properties. A good source for this information is the Developer's Guide, in the \"Driver Specifics\" section of chapter 12. It's also accessible online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Driver_Specifics/ (or use loGuide \"Database Driver Specifics\" ). Unfortunately, the guide was last updated in 2008 for OpenOffice 3.1, and some details have changed since then. A better approach is to query Base's DriverManager at run time which will supply data for the version of Office that you're using. Figure 2 shows the relevant parts of the DriverManager service and its interfaces. Figure 2. The DriveManager Service and Some of its Interfaces. The XEnumerationAccess interface offers a convenient way to list all the drivers currently known to Base. When the programmer calls XDriveAcccess.getDriverByURL(), one of these is selected based on the URL's database protocol. XDriver.getPropertyInfo() gives access to the properties that can be set in the driver's connection. These interfaces and methods are utilized by my Base.getSupportedDrivers() and Base.printDriverProperties() functions, as seen in CSVQuery.java explained next. 1. Querying a CSV File \u00b6 CSVQuery.java opens a CSV file, examines its us-500 table, and prints the first names of the people resident in New York City: // part of CSVQuery.java... XResultSet rs = Base . executeQuery ( \"SELECT \\\"first_name\\\" FROM \\\"us-500\\\" WHERE \\\"City\\\" = 'New York'\" , conn ); BaseTablePrinter . printResultSet ( rs ); The novel parts of CSVQuery.java are how it sets up the database connection and how it determines the table's format. The main() function: // global private static final String FNM = \"us-500.csv\" ; // in CSVQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } ArrayList < String > driveNms = Base . getSupportedDrivers (); System . out . println ( \"Drivers (\" + driveNms . size () + \"):\" ); for ( String driveNm : driveNms ) System . out . println ( \" \" + driveNm ); System . out . println (); String url = \"sdbc:flat:\" + FileIO . fnmToURL ( FNM ); System . out . println ( \"Using URL: \" + url ); XDriver driver = Base . getDriverByURL ( url ); Base . printDriverProperties ( driver , url ); // set up properties for a CSV file with no password PropertyValue [] props = Props . makeProps ( new String [] { \"user\" , \"password\" , \"JavaDriverClass\" , \"Extension\" , \"HeaderLine\" , \"FieldDelimiter\" , \"StringDelimiter\" }, new Object [] { \"\" , \"\" , \"com.sun.star.comp.sdbc.flat.ODriver\" , \"csv\" , true , \",\" , \"\\\"\\\"\" } ); XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( url , props ); // ArrayList<String> tableNames = Base.getTablesNames(conn); ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); // reports all CSV tables ?? XResultSet rs = Base . executeQuery ( \"SELECT \\\"first_name\\\" FROM \\\"us-500\\\" WHERE \\\"City\\\" = 'New York'\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main() The XDriverManager interface is obtained by Base.getDriverManager(): // in the Base class public static XDriverManager getDriverManager () { return Lo . createInstanceMCF ( XDriverManager . class , \"com.sun.star.sdbc.DriverManager\" ); } Base.getSupportedDrivers() returns a list of all the Base drivers: // in the Base class public static ArrayList < String > getSupportedDrivers () { XDriverManager dm = getDriverManager (); XEnumerationAccess enumAccess = Lo . qi ( XEnumerationAccess . class , dm ); XEnumeration driversEnum = enumAccess . createEnumeration (); if ( driversEnum == null ) { System . out . println ( \"No drivers found\" ); return null ; } ArrayList < String > drivers = new ArrayList < String > (); while ( driversEnum . hasMoreElements ()) { try { drivers . add ( Info . getImplementationName ( driversEnum . nextElement ()) ); } catch ( com . sun . star . uno . Exception e ) {} } return drivers ; } // end of getSupportedDrivers() The XDriverManager interface is cast to XEnumerationAccess, which can loop through the drivers and access their names. The list on one of my test machines is: Drivers (11): com.sun.star.comp.sdbc.ODBCDriver com.sun.star.comp.sdbc.JDBCDriver com.sun.star.comp.sdbc.MorkDriver com.sun.star.comp.sdbc.ado.ODriver com.sun.star.comp.sdbc.calc.ODriver com.sun.star.comp.sdbc.dbase.ODriver com.sun.star.comp.sdbc.firebird.Driver com.sun.star.comp.sdbc.flat.ODriver com.sun.star.sdbcx.comp.hsqldb.Driver org.openoffice.comp.connectivity.pq.Driver.noext org.openoffice.comp.drivers.MySQL.Driver CSVQuery.java uses the \"flat\" driver to access the CSV file. Later examples in this chapter employ the ADO, Calc, and Mork drivers for an Access database, a Calc spreadsheet, and a Thunderbird address book. There's no need for the programmer to explicitly load a driver, since Base does it automatically based on the database protocol in the file's URL. The URL is constructed with the following code: // part of CSVQuery.java... String url = \"sdbc:flat:\" + FileIO . fnmToURL ( FNM ); System . out . println ( \"Using URL: \" + url ); XDriver driver = Base . getDriverByURL ( url ); The database protocol is set to be \"sdbc:flat\", and the local file is converted to \"file://\" URL form; the resulting URL is: sdbc : flat : file : ///C:/Users/Ad/Desktop/LibreOffice Tests/ Base Tests / us - 500. csv Base.getDriverByURL() is: // in the Base class public static XDriver getDriverByURL ( String url ) { XDriverAccess driverAccess = Lo . createInstanceMCF ( XDriverAccess . class , \"com.sun.star.sdbc.DriverManager\" ); return driverAccess . getDriverByURL ( url ); } // end of getDriverByURL() Base . printDriverProperties () prints the driver ' s name , and its properties : // in the Base class public static void printDriverProperties ( XDriver driver , String url ) { if ( driver == null ) { System . out . println ( \"Driver is null\" ); return ; } try { System . out . println ( \"Driver Name: \" + Info . getImplementationName ( driver )); DriverPropertyInfo [] dpInfo = driver . getPropertyInfo ( url , null ); if ( dpInfo == null ) { System . out . println ( \"Properties info for the driver is null\" ); return ; } System . out . println ( \"No. of Driver properties: \" + dpInfo . length ); for ( int i = 0 ; i < dpInfo . length ; i ++ ) System . out . println ( \" \" + dpInfo [ i ] . Name + \" = \" + dpInfo [ i ] . Value ); System . out . println (); } catch ( SQLException e ) { System . out . println ( \"No properties info for the driver\" ); } } // end of printDriverProperties() The method utilizes XDriver.getPropertyInfo() (see Figure 2) to access an array of DriverProperty objects. The information printed for the CSV file's \"flat\" driver is: Driver Name: com.sun.star.comp.sdbc.flat.ODriver No. of Driver properties: 11 CharSet = Extension = .* ShowDeleted = 0 EnableSQL92Check = 0 UseRelativePath = 0 URL = FieldDelimiter = HeaderLine = 0 StringDelimiter = 0 DecimalDelimiter = 0 ThousandDelimiter = 0 Knowing the property names is a good start, but what do they do? Connection properties are defined across several classes which inherit the ConnectionProperties class, as shown in Figure 3. Figure 3. Connection Properties and Subclasses. The most relevant class for the CSV flat file is FlatConnectionProperties, although some properties are also inherited from FileConnectionProperties and ConnectionProperties. Some experimentation is required to decide which properties to set, but a good source of answers are the OpenOffice and LibreOffice forums where people have dealt with similar questions before. The properties are passed to the connection by calling XDriverManager.getConnectionWithInfo(): // part of CSVQuery.java... // set up properties for a CSV file with no password PropertyValue [] props = Props . makeProps ( new String [] { \"user\" , \"password\" , \"JavaDriverClass\" , \"Extension\" , \"HeaderLine\" , \"FieldDelimiter\" , \"StringDelimiter\" }, new Object [] { \"\" , \"\" , \"com.sun.star.comp.sdbc.flat.ODriver\" , \"csv\" , true , \",\" , \"\\\"\\\"\" } ); XConnection conn = dm . getConnectionWithInfo ( url , props ); 2. Finding out about Tables \u00b6 A common need when querying databases is knowing their table schemas. In my earlier ODB document examples, I used classes from the sdbcx module to get schema information (see Figure 10). For example, Base.getTablesNames() accesses information about all the tables in the database: // in the Base class public static ArrayList < String > getTablesNames ( XConnection conn ) { XTablesSupplier tblsSupplier = Lo . qi ( XTablesSupplier . class , conn ); XNameAccess tables = tblsSupplier . getTables (); String [] tableNms = tables . getElementNames (); return new ArrayList < String > ( Arrays . asList ( tableNms )); } // end of getTablesNames() This technique doesn't work with non-Office databases, such as CSV files, Access databases, and spreadsheets. If Base.getTablesNames() is passed a connection to these then the XTablesSupplier instance is set to null. Fortunately, there's an alternative, lower-level approach based on using the DatabaseMetaData service (see Figure 1), as implemented in getTablesNamesMD(): // in the Base class public static ArrayList < String > getTablesNamesMD ( XConnection conn ) // get table names using DatabaseMetaData { ArrayList < String > names = new ArrayList < String > (); try { XDatabaseMetaData dm = conn . getMetaData (); XResultSet rs = dm . getTables ( null , null , \"%\" , new String [] { \"TABLE\" }); XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) names . add ( xRow . getString ( 3 )); // 3 == table name } catch ( SQLException e ) { System . out . println ( e ); } return names ; } // end of getTablesNamesMD() Table schema details are retrieved by querying XDatabaseMetaData, which lets Base.getTablesNamesMD() return a list of table names. The bad news is that the generated list is incorrect, including every CSV file name in the current directory. This meant that I had to hardwire the \"us-500\" table name into the query in CSVQuery.java. rather than use the Base.getTablesNamesMD() data. 3. Querying an Access File \u00b6 AccessQuery.java is almost the same as CSVQuery.java, except for the change in driver and the connection properties. The list of drivers printed by Base.getSupportedDrivers() suggests that I should use the ADO driver to connect to Microsoft Access files since ActiveX Data Objects (ADO) is one of Microsoft's technologies for database access. The documentation on how to use this driver is quite sparse and out of date. The URL protocol is given as \"sdbc:ado: \", with two examples: sdbc:ado:PROVIDER=Microsoft.Jet.OLEDB.4.0; DATA SOURCE= c:\\northwind.mdb sdbc:ado:Provider=msdaora;data source=testdb The first is the most relevant, but only supports the old Access file format (MDB). For ACCDB files (Access 2007 and later), it must be revised to: \"sdbc:ado:PROVIDER=Microsoft.ACE.OLEDB.12.0;DATA SOURCE=\". Base.getTablesNamesMD() returns slightly incorrect results when it examines Access files. For example, a database with four tables is reported to have five, one of them the empty string: No. of tables: 5 [AuthorISBN, Authors, Publishers, Titles, ] The main() function for AccessQuery.java: //private static final String FNM = \"Books.mdb\"; private static final String FNM = \"Books.accdb\" ; // in AccessQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } String url = \"sdbc:ado:PROVIDER=Microsoft.ACE.OLEDB.12.0; DATA SOURCE=\" + FileIO . getAbsolutePath ( FNM ); // for accdb *and* mdb files System . out . println ( \"Using URL: \" + url ); XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( url , null ); // no connection properties needed ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); // table list includes an empty string XResultSet rs = Base . executeQuery ( \"SELECT * FROM \\\"Authors\\\"\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main() 4. Querying a Calc Spreadsheet \u00b6 CalcQuery.java examines the \"Marks\" spreadsheet in totals.ods. The Calc driver treats each named sheet in the spreadsheet as a separate table. This time, Base.getTablesNamesMD() returns a correct list of the sheet names. private static final String FNM = \"totals.ods\" ; // in CalcQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } String url = \"sdbc:calc:\" + FileIO . fnmToURL ( FNM ); System . out . println ( \"Using URL: \" + url ); XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( url , null ); // no connection properties needed ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); XResultSet rs = Base . executeQuery ( \"SELECT \\\"Stud. No.\\\", \\\"Fin/45\\\" FROM \\\"Marks\\\" WHERE \\\"Fin/45\\\" < 20\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main() 5. Querying a Thunderbird Address Book \u00b6 One reason for Office being able to access the address books of e-mail software is for implementing mail merge applications. ThunderbirdQuery.java examines the personal addresses in Thunderbird ( https://mozilla.org/en-US/thunderbird/ ). The Office documentation at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Driver_Specifics/ mentions support for Mozilla, Outlook, Outlook Express and LDAP, but several forum posts describe updates and changes. \"sdbc:address:mozilla\" supports SeaMonkey Mail, the 2006 replacement for the Mozilla e-mail reader ( https://seamonkey-project.org/ ), and \"sdbc:address:thunderbird\" connects to Thunderbird. Base uses the Mork driver (com.sun.star.comp.sdbc.MorkDriver) to access both SeaMonkey and Thunderbird. The Thunderbird e-mail reader on my test machine has two address books, called \"Personal Address Book\" and \"Collected Addresses\", as shown in Figure 4. Figure 4. My Thunderbird Address Books. When I use Base.getTablesNamesMD() to list the 'tables' inside Thunderbird, it reports slightly different names : [AddressBook, CollectedAddressBook] These changes made me suspicious about the rest of the table's schema, including the names of the table's columns. Inside Thunderbird, the e-mail column is labeled \"Email\" (as shown in Figure 4), but is that what Base sees? Base.displayTablesSchema() lists the table and column information for the connected database, using sdbcx to get the table names. However, there's a meta data variant which utilizes Base.getTablesNamesMD(), as shown below: // in the Base class public static void displayTablesSchema ( XConnection conn ) { displayTablesSchema ( conn , true ); } public static void displayTablesSchema ( XConnection conn , boolean useSDBCX ) { ArrayList < String > tableNames = ( useSDBCX ) ? getTablesNames ( conn ) : getTablesNamesMD ( conn ); // choose to use SDBCX or DatabaseMetaData if ( tableNames == null ) System . out . println ( \"No tables found in database\" ); else { System . out . println ( \"No. of tables: \" + tableNames . size ()); ArrayList < String > columnNames ; for ( String tableName : tableNames ) { System . out . print ( \" \" + tableName + \":\" ); columnNames = getColumnNames ( conn , tableName ); if ( columnNames == null ) System . out . println ( \" -- no column names --\" ); else { for ( String colName : columnNames ) System . out . print ( \" \\\"\" + colName + \"\\\"\" ); System . out . println ( \"\\n\" ); } } } } // end of displayTablesSchema() public static ArrayList < String > getColumnNames ( XConnection conn , String tableName ) { ArrayList < String > names = new ArrayList < String > (); try { XDatabaseMetaData dm = conn . getMetaData (); XResultSet rs = dm . getColumns ( null , null , tableName , \"%\" ); XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) names . add ( xRow . getString ( 4 )); // 4 == column name } catch ( SQLException e ) { System . out . println ( e ); } return names ; } // end of getColumnNames() A Base.displayTablesSchema(conn,false) call produces the following information when the connection is linked to Thunderbird: No. of tables: 2 AddressBook: \"Department\" \"Last Name\" \"Comments\" \"Mobile\" \"Phone (Work)\" \"City (Work)\" \"City\" \"Job Title\" \"Custom 3\" \"Work Address 2\" \"Custom 2\" \"Birth Month\" \"Company\" \"ZIP/Postal (Home)\" \"Custom 1\" \"Custom 4\" \"Birth Day\" \"Web Page (Work)\" \"Nickname\" \"Web Page (Home)\" \"Birth Year\" \"Fax\" \"First Name\" \"Address 1\" \"Phone (Home)\" \"State\" \"State (Work)\" \"Display Name\" \"Country\" \"Pager\" \"E-mail (2)\" \"Work Address\" \"Country (Work)\" \"Zip/Postal (Work)\" \"Address 2\" \"E-mail\" \"Mail Format\" CollectedAddressBook: \"Department\" \"Last Name\" \"Comments\" \"Mobile\" \"Phone (Work)\" \"City (Work)\" \"City\" \"Job Title\" \"Custom 3\" \"Work Address 2\" \"Custom 2\" \"Birth Month\" \"Company\" \"ZIP/Postal (Home)\" \"Custom 1\" \"Custom 4\" \"Birth Day\" \"Web Page (Work)\" \"Nickname\" \"Web Page (Home)\" \"Birth Year\" \"Fax\" \"First Name\" \"Address 1\" \"Phone (Home)\" \"State\" \"State (Work)\" \"Display Name\" \"Country\" \"Pager\" \"E- mail (2)\" \"Work Address\" \"Country (Work)\" \"Zip/Postal (Work)\" \"Address 2\" \"E-mail\" \"Mail Format\" The \"AddressBook\" table contains two e-mail related column names: \"E-mail\" and \"E-mail (2)\". As a consequence, I wrote the query to retrieve all the e-mail addresses from the Personal Address Book as: XResultSet rs = Base.executeQuery( \"SELECT \\\"E-mail\\\" FROM \\\"AddressBook\\\"\", conn); BaseTablePrinter.printResultSet(rs); This produces textual output which matches that in Figure 4: Printing 8 rows from table AddressBook +------------------------------+ | E-mail | +------------------------------+ | timgarner@compuserve.com | +------------------------------+ | Rohini.Deb@cenveo.com | +------------------------------+ | Patty_Mon@mcgraw-hill.com | +------------------------------+ | nutteen@gmail.com | +------------------------------+ | lors.davison@googlemail.com | +------------------------------+ | lordkiller.davison@gmail.com | +------------------------------+ | lecturer@coe.psu.ac.th | +------------------------------+ | engteacher@eng.psu.ac.th | +------------------------------+ The main() function of ThunderbirdQuery.java: // in ThunderbirdQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( \"sdbc:address:thunderbird\" , null ); ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); Base . displayTablesSchema ( conn , false ); // use getTablesNamesMD() XResultSet rs = Base . executeQuery ( \"SELECT \\\"E-mail\\\" FROM \\\"AddressBook\\\"\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main()","title":"Chapter 37. Using the Driver Manager"},{"location":"37-Driver_Manager.html#chapter-37-using-the-driver-manager","text":"Topics Querying a CSV File; Querying an Access File; Querying a Calc Spreadsheet; Querying a Thunderbird Address Book Example folders: \"Base Tests\" and \"Utils\" This chapter looks at programming with the XDriveManager interface, which were labelled (4) in Figure 5 of the Chapter 34. Figure 1 repeats that figure but without the alternative query approaches (labels (1), (2) and (3)). Figure 1. Querying a Document. XDriverManager offers a low-level driver approach for accessing databases, which is similar to JDBC's DriverManager. It's rarely used to access Office databases, which are more conveniently manipulated using XOfficeDatabaseDocument (see Chapter 35). More commonly XDriverManager is employed for non-Office databases, such as MS Access files, and tabular data inside CSV files, Calc spreadsheets, and e-mail address books. This chapter includes examples of how to query these kinds of files. The drawback of using a driver manager is the low-level information that the programmer has to supply, including the driver name, the file's URL, and the connection properties. A good source for this information is the Developer's Guide, in the \"Driver Specifics\" section of chapter 12. It's also accessible online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Driver_Specifics/ (or use loGuide \"Database Driver Specifics\" ). Unfortunately, the guide was last updated in 2008 for OpenOffice 3.1, and some details have changed since then. A better approach is to query Base's DriverManager at run time which will supply data for the version of Office that you're using. Figure 2 shows the relevant parts of the DriverManager service and its interfaces. Figure 2. The DriveManager Service and Some of its Interfaces. The XEnumerationAccess interface offers a convenient way to list all the drivers currently known to Base. When the programmer calls XDriveAcccess.getDriverByURL(), one of these is selected based on the URL's database protocol. XDriver.getPropertyInfo() gives access to the properties that can be set in the driver's connection. These interfaces and methods are utilized by my Base.getSupportedDrivers() and Base.printDriverProperties() functions, as seen in CSVQuery.java explained next.","title":"Chapter 37. Using the Driver Manager"},{"location":"37-Driver_Manager.html#1-querying-a-csv-file","text":"CSVQuery.java opens a CSV file, examines its us-500 table, and prints the first names of the people resident in New York City: // part of CSVQuery.java... XResultSet rs = Base . executeQuery ( \"SELECT \\\"first_name\\\" FROM \\\"us-500\\\" WHERE \\\"City\\\" = 'New York'\" , conn ); BaseTablePrinter . printResultSet ( rs ); The novel parts of CSVQuery.java are how it sets up the database connection and how it determines the table's format. The main() function: // global private static final String FNM = \"us-500.csv\" ; // in CSVQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } ArrayList < String > driveNms = Base . getSupportedDrivers (); System . out . println ( \"Drivers (\" + driveNms . size () + \"):\" ); for ( String driveNm : driveNms ) System . out . println ( \" \" + driveNm ); System . out . println (); String url = \"sdbc:flat:\" + FileIO . fnmToURL ( FNM ); System . out . println ( \"Using URL: \" + url ); XDriver driver = Base . getDriverByURL ( url ); Base . printDriverProperties ( driver , url ); // set up properties for a CSV file with no password PropertyValue [] props = Props . makeProps ( new String [] { \"user\" , \"password\" , \"JavaDriverClass\" , \"Extension\" , \"HeaderLine\" , \"FieldDelimiter\" , \"StringDelimiter\" }, new Object [] { \"\" , \"\" , \"com.sun.star.comp.sdbc.flat.ODriver\" , \"csv\" , true , \",\" , \"\\\"\\\"\" } ); XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( url , props ); // ArrayList<String> tableNames = Base.getTablesNames(conn); ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); // reports all CSV tables ?? XResultSet rs = Base . executeQuery ( \"SELECT \\\"first_name\\\" FROM \\\"us-500\\\" WHERE \\\"City\\\" = 'New York'\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main() The XDriverManager interface is obtained by Base.getDriverManager(): // in the Base class public static XDriverManager getDriverManager () { return Lo . createInstanceMCF ( XDriverManager . class , \"com.sun.star.sdbc.DriverManager\" ); } Base.getSupportedDrivers() returns a list of all the Base drivers: // in the Base class public static ArrayList < String > getSupportedDrivers () { XDriverManager dm = getDriverManager (); XEnumerationAccess enumAccess = Lo . qi ( XEnumerationAccess . class , dm ); XEnumeration driversEnum = enumAccess . createEnumeration (); if ( driversEnum == null ) { System . out . println ( \"No drivers found\" ); return null ; } ArrayList < String > drivers = new ArrayList < String > (); while ( driversEnum . hasMoreElements ()) { try { drivers . add ( Info . getImplementationName ( driversEnum . nextElement ()) ); } catch ( com . sun . star . uno . Exception e ) {} } return drivers ; } // end of getSupportedDrivers() The XDriverManager interface is cast to XEnumerationAccess, which can loop through the drivers and access their names. The list on one of my test machines is: Drivers (11): com.sun.star.comp.sdbc.ODBCDriver com.sun.star.comp.sdbc.JDBCDriver com.sun.star.comp.sdbc.MorkDriver com.sun.star.comp.sdbc.ado.ODriver com.sun.star.comp.sdbc.calc.ODriver com.sun.star.comp.sdbc.dbase.ODriver com.sun.star.comp.sdbc.firebird.Driver com.sun.star.comp.sdbc.flat.ODriver com.sun.star.sdbcx.comp.hsqldb.Driver org.openoffice.comp.connectivity.pq.Driver.noext org.openoffice.comp.drivers.MySQL.Driver CSVQuery.java uses the \"flat\" driver to access the CSV file. Later examples in this chapter employ the ADO, Calc, and Mork drivers for an Access database, a Calc spreadsheet, and a Thunderbird address book. There's no need for the programmer to explicitly load a driver, since Base does it automatically based on the database protocol in the file's URL. The URL is constructed with the following code: // part of CSVQuery.java... String url = \"sdbc:flat:\" + FileIO . fnmToURL ( FNM ); System . out . println ( \"Using URL: \" + url ); XDriver driver = Base . getDriverByURL ( url ); The database protocol is set to be \"sdbc:flat\", and the local file is converted to \"file://\" URL form; the resulting URL is: sdbc : flat : file : ///C:/Users/Ad/Desktop/LibreOffice Tests/ Base Tests / us - 500. csv Base.getDriverByURL() is: // in the Base class public static XDriver getDriverByURL ( String url ) { XDriverAccess driverAccess = Lo . createInstanceMCF ( XDriverAccess . class , \"com.sun.star.sdbc.DriverManager\" ); return driverAccess . getDriverByURL ( url ); } // end of getDriverByURL() Base . printDriverProperties () prints the driver ' s name , and its properties : // in the Base class public static void printDriverProperties ( XDriver driver , String url ) { if ( driver == null ) { System . out . println ( \"Driver is null\" ); return ; } try { System . out . println ( \"Driver Name: \" + Info . getImplementationName ( driver )); DriverPropertyInfo [] dpInfo = driver . getPropertyInfo ( url , null ); if ( dpInfo == null ) { System . out . println ( \"Properties info for the driver is null\" ); return ; } System . out . println ( \"No. of Driver properties: \" + dpInfo . length ); for ( int i = 0 ; i < dpInfo . length ; i ++ ) System . out . println ( \" \" + dpInfo [ i ] . Name + \" = \" + dpInfo [ i ] . Value ); System . out . println (); } catch ( SQLException e ) { System . out . println ( \"No properties info for the driver\" ); } } // end of printDriverProperties() The method utilizes XDriver.getPropertyInfo() (see Figure 2) to access an array of DriverProperty objects. The information printed for the CSV file's \"flat\" driver is: Driver Name: com.sun.star.comp.sdbc.flat.ODriver No. of Driver properties: 11 CharSet = Extension = .* ShowDeleted = 0 EnableSQL92Check = 0 UseRelativePath = 0 URL = FieldDelimiter = HeaderLine = 0 StringDelimiter = 0 DecimalDelimiter = 0 ThousandDelimiter = 0 Knowing the property names is a good start, but what do they do? Connection properties are defined across several classes which inherit the ConnectionProperties class, as shown in Figure 3. Figure 3. Connection Properties and Subclasses. The most relevant class for the CSV flat file is FlatConnectionProperties, although some properties are also inherited from FileConnectionProperties and ConnectionProperties. Some experimentation is required to decide which properties to set, but a good source of answers are the OpenOffice and LibreOffice forums where people have dealt with similar questions before. The properties are passed to the connection by calling XDriverManager.getConnectionWithInfo(): // part of CSVQuery.java... // set up properties for a CSV file with no password PropertyValue [] props = Props . makeProps ( new String [] { \"user\" , \"password\" , \"JavaDriverClass\" , \"Extension\" , \"HeaderLine\" , \"FieldDelimiter\" , \"StringDelimiter\" }, new Object [] { \"\" , \"\" , \"com.sun.star.comp.sdbc.flat.ODriver\" , \"csv\" , true , \",\" , \"\\\"\\\"\" } ); XConnection conn = dm . getConnectionWithInfo ( url , props );","title":"1.  Querying a CSV File"},{"location":"37-Driver_Manager.html#2-finding-out-about-tables","text":"A common need when querying databases is knowing their table schemas. In my earlier ODB document examples, I used classes from the sdbcx module to get schema information (see Figure 10). For example, Base.getTablesNames() accesses information about all the tables in the database: // in the Base class public static ArrayList < String > getTablesNames ( XConnection conn ) { XTablesSupplier tblsSupplier = Lo . qi ( XTablesSupplier . class , conn ); XNameAccess tables = tblsSupplier . getTables (); String [] tableNms = tables . getElementNames (); return new ArrayList < String > ( Arrays . asList ( tableNms )); } // end of getTablesNames() This technique doesn't work with non-Office databases, such as CSV files, Access databases, and spreadsheets. If Base.getTablesNames() is passed a connection to these then the XTablesSupplier instance is set to null. Fortunately, there's an alternative, lower-level approach based on using the DatabaseMetaData service (see Figure 1), as implemented in getTablesNamesMD(): // in the Base class public static ArrayList < String > getTablesNamesMD ( XConnection conn ) // get table names using DatabaseMetaData { ArrayList < String > names = new ArrayList < String > (); try { XDatabaseMetaData dm = conn . getMetaData (); XResultSet rs = dm . getTables ( null , null , \"%\" , new String [] { \"TABLE\" }); XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) names . add ( xRow . getString ( 3 )); // 3 == table name } catch ( SQLException e ) { System . out . println ( e ); } return names ; } // end of getTablesNamesMD() Table schema details are retrieved by querying XDatabaseMetaData, which lets Base.getTablesNamesMD() return a list of table names. The bad news is that the generated list is incorrect, including every CSV file name in the current directory. This meant that I had to hardwire the \"us-500\" table name into the query in CSVQuery.java. rather than use the Base.getTablesNamesMD() data.","title":"2.  Finding out about Tables"},{"location":"37-Driver_Manager.html#3-querying-an-access-file","text":"AccessQuery.java is almost the same as CSVQuery.java, except for the change in driver and the connection properties. The list of drivers printed by Base.getSupportedDrivers() suggests that I should use the ADO driver to connect to Microsoft Access files since ActiveX Data Objects (ADO) is one of Microsoft's technologies for database access. The documentation on how to use this driver is quite sparse and out of date. The URL protocol is given as \"sdbc:ado: \", with two examples: sdbc:ado:PROVIDER=Microsoft.Jet.OLEDB.4.0; DATA SOURCE= c:\\northwind.mdb sdbc:ado:Provider=msdaora;data source=testdb The first is the most relevant, but only supports the old Access file format (MDB). For ACCDB files (Access 2007 and later), it must be revised to: \"sdbc:ado:PROVIDER=Microsoft.ACE.OLEDB.12.0;DATA SOURCE=\". Base.getTablesNamesMD() returns slightly incorrect results when it examines Access files. For example, a database with four tables is reported to have five, one of them the empty string: No. of tables: 5 [AuthorISBN, Authors, Publishers, Titles, ] The main() function for AccessQuery.java: //private static final String FNM = \"Books.mdb\"; private static final String FNM = \"Books.accdb\" ; // in AccessQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } String url = \"sdbc:ado:PROVIDER=Microsoft.ACE.OLEDB.12.0; DATA SOURCE=\" + FileIO . getAbsolutePath ( FNM ); // for accdb *and* mdb files System . out . println ( \"Using URL: \" + url ); XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( url , null ); // no connection properties needed ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); // table list includes an empty string XResultSet rs = Base . executeQuery ( \"SELECT * FROM \\\"Authors\\\"\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main()","title":"3.  Querying an Access File"},{"location":"37-Driver_Manager.html#4-querying-a-calc-spreadsheet","text":"CalcQuery.java examines the \"Marks\" spreadsheet in totals.ods. The Calc driver treats each named sheet in the spreadsheet as a separate table. This time, Base.getTablesNamesMD() returns a correct list of the sheet names. private static final String FNM = \"totals.ods\" ; // in CalcQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } String url = \"sdbc:calc:\" + FileIO . fnmToURL ( FNM ); System . out . println ( \"Using URL: \" + url ); XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( url , null ); // no connection properties needed ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); XResultSet rs = Base . executeQuery ( \"SELECT \\\"Stud. No.\\\", \\\"Fin/45\\\" FROM \\\"Marks\\\" WHERE \\\"Fin/45\\\" < 20\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main()","title":"4.  Querying a Calc Spreadsheet"},{"location":"37-Driver_Manager.html#5-querying-a-thunderbird-address-book","text":"One reason for Office being able to access the address books of e-mail software is for implementing mail merge applications. ThunderbirdQuery.java examines the personal addresses in Thunderbird ( https://mozilla.org/en-US/thunderbird/ ). The Office documentation at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Database/Driver_Specifics/ mentions support for Mozilla, Outlook, Outlook Express and LDAP, but several forum posts describe updates and changes. \"sdbc:address:mozilla\" supports SeaMonkey Mail, the 2006 replacement for the Mozilla e-mail reader ( https://seamonkey-project.org/ ), and \"sdbc:address:thunderbird\" connects to Thunderbird. Base uses the Mork driver (com.sun.star.comp.sdbc.MorkDriver) to access both SeaMonkey and Thunderbird. The Thunderbird e-mail reader on my test machine has two address books, called \"Personal Address Book\" and \"Collected Addresses\", as shown in Figure 4. Figure 4. My Thunderbird Address Books. When I use Base.getTablesNamesMD() to list the 'tables' inside Thunderbird, it reports slightly different names : [AddressBook, CollectedAddressBook] These changes made me suspicious about the rest of the table's schema, including the names of the table's columns. Inside Thunderbird, the e-mail column is labeled \"Email\" (as shown in Figure 4), but is that what Base sees? Base.displayTablesSchema() lists the table and column information for the connected database, using sdbcx to get the table names. However, there's a meta data variant which utilizes Base.getTablesNamesMD(), as shown below: // in the Base class public static void displayTablesSchema ( XConnection conn ) { displayTablesSchema ( conn , true ); } public static void displayTablesSchema ( XConnection conn , boolean useSDBCX ) { ArrayList < String > tableNames = ( useSDBCX ) ? getTablesNames ( conn ) : getTablesNamesMD ( conn ); // choose to use SDBCX or DatabaseMetaData if ( tableNames == null ) System . out . println ( \"No tables found in database\" ); else { System . out . println ( \"No. of tables: \" + tableNames . size ()); ArrayList < String > columnNames ; for ( String tableName : tableNames ) { System . out . print ( \" \" + tableName + \":\" ); columnNames = getColumnNames ( conn , tableName ); if ( columnNames == null ) System . out . println ( \" -- no column names --\" ); else { for ( String colName : columnNames ) System . out . print ( \" \\\"\" + colName + \"\\\"\" ); System . out . println ( \"\\n\" ); } } } } // end of displayTablesSchema() public static ArrayList < String > getColumnNames ( XConnection conn , String tableName ) { ArrayList < String > names = new ArrayList < String > (); try { XDatabaseMetaData dm = conn . getMetaData (); XResultSet rs = dm . getColumns ( null , null , tableName , \"%\" ); XRow xRow = Lo . qi ( XRow . class , rs ); while ( rs . next ()) names . add ( xRow . getString ( 4 )); // 4 == column name } catch ( SQLException e ) { System . out . println ( e ); } return names ; } // end of getColumnNames() A Base.displayTablesSchema(conn,false) call produces the following information when the connection is linked to Thunderbird: No. of tables: 2 AddressBook: \"Department\" \"Last Name\" \"Comments\" \"Mobile\" \"Phone (Work)\" \"City (Work)\" \"City\" \"Job Title\" \"Custom 3\" \"Work Address 2\" \"Custom 2\" \"Birth Month\" \"Company\" \"ZIP/Postal (Home)\" \"Custom 1\" \"Custom 4\" \"Birth Day\" \"Web Page (Work)\" \"Nickname\" \"Web Page (Home)\" \"Birth Year\" \"Fax\" \"First Name\" \"Address 1\" \"Phone (Home)\" \"State\" \"State (Work)\" \"Display Name\" \"Country\" \"Pager\" \"E-mail (2)\" \"Work Address\" \"Country (Work)\" \"Zip/Postal (Work)\" \"Address 2\" \"E-mail\" \"Mail Format\" CollectedAddressBook: \"Department\" \"Last Name\" \"Comments\" \"Mobile\" \"Phone (Work)\" \"City (Work)\" \"City\" \"Job Title\" \"Custom 3\" \"Work Address 2\" \"Custom 2\" \"Birth Month\" \"Company\" \"ZIP/Postal (Home)\" \"Custom 1\" \"Custom 4\" \"Birth Day\" \"Web Page (Work)\" \"Nickname\" \"Web Page (Home)\" \"Birth Year\" \"Fax\" \"First Name\" \"Address 1\" \"Phone (Home)\" \"State\" \"State (Work)\" \"Display Name\" \"Country\" \"Pager\" \"E- mail (2)\" \"Work Address\" \"Country (Work)\" \"Zip/Postal (Work)\" \"Address 2\" \"E-mail\" \"Mail Format\" The \"AddressBook\" table contains two e-mail related column names: \"E-mail\" and \"E-mail (2)\". As a consequence, I wrote the query to retrieve all the e-mail addresses from the Personal Address Book as: XResultSet rs = Base.executeQuery( \"SELECT \\\"E-mail\\\" FROM \\\"AddressBook\\\"\", conn); BaseTablePrinter.printResultSet(rs); This produces textual output which matches that in Figure 4: Printing 8 rows from table AddressBook +------------------------------+ | E-mail | +------------------------------+ | timgarner@compuserve.com | +------------------------------+ | Rohini.Deb@cenveo.com | +------------------------------+ | Patty_Mon@mcgraw-hill.com | +------------------------------+ | nutteen@gmail.com | +------------------------------+ | lors.davison@googlemail.com | +------------------------------+ | lordkiller.davison@gmail.com | +------------------------------+ | lecturer@coe.psu.ac.th | +------------------------------+ | engteacher@eng.psu.ac.th | +------------------------------+ The main() function of ThunderbirdQuery.java: // in ThunderbirdQuery.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XDriverManager dm = Base . getDriverManager (); if ( dm == null ) { System . out . println ( \"Could not access Driver manager\" ); Lo . closeOffice (); return ; } XConnection conn = null ; try { conn = dm . getConnectionWithInfo ( \"sdbc:address:thunderbird\" , null ); ArrayList < String > tableNames = Base . getTablesNamesMD ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); Base . displayTablesSchema ( conn , false ); // use getTablesNamesMD() XResultSet rs = Base . executeQuery ( \"SELECT \\\"E-mail\\\" FROM \\\"AddressBook\\\"\" , conn ); BaseTablePrinter . printResultSet ( rs ); } catch ( Exception e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Lo . closeOffice (); } // end of main()","title":"5.  Querying a Thunderbird Address Book"},{"location":"38-ODB_as_Zip.html","text":"Chapter 38. Treating an ODB File as a Zipped Folder \u00b6 Topics Extracting a Database from an ODB File; Querying an Extracted HSQLDB Database; Querying an Extracted Firebird Database Example folders: \"Base Tests\" and \"Utils\" An ODB document can be manipulated as a zipped folder, using tools such as 7-zip ( https://7-zip.org/ ). This means that it's possible to use Java zip classes (in the java.util.zip package) to extract a database from the ODB file. The advantage of this technique is that the resulting HSQLDB or Firebird database can be accessed through Java's JDBC without using the sdbc, sdbcx, or sdb modules in the Office API. The Office download includes a copy of the HSQLDB database engine (stored in \\program\\classes\\hsqldb.jar) so there's no need to download any software for manipulating HyperSQL databases through JDBC. However, Firebird programming requires Firebird's embedded engine and its JDBC driver, called Jaybird. I'll discuss the details of how to run HSQLDB and Firebird databases after explaining how to extract them from ODB documents. EmbeddedQuery.java shows all the top-level stages: // in EmbeddedQuery.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run EmbeddedQuery <fnm>\" ); return ; } ArrayList < String > dbFnms = Base . extractEmbedded ( args [ 0 ] ); if ( dbFnms == null ) return ; System . out . println ( \"Is this a Firebird embedded database? \" + Jdbc . isFirebirdEmbedded ( dbFnms )); System . out . println ( \"Is this an HSQLDB embedded database? \" + Jdbc . isHSQLEmbedded ( dbFnms )); Connection conn = null ; try { conn = Jdbc . connectToDB ( dbFnms ); if ( conn == null ) return ; ArrayList < String > tableNames = Jdbc . getTablesNames ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); ResultSet rs = Jdbc . executeQuery ( \"SELECT * FROM \\\"\" + tableNames . get ( 0 ) + \"\\\"\" , conn ); DBTablePrinter . printResultSet ( rs ); conn . close (); } catch ( SQLException e ) { System . out . println ( e ); } // FileIO.deleteFiles(dbFnms); } // end of main() 1. Extracting a Database from an ODB File \u00b6 Base.extractEmbedded() first determines if the ODB file contains an embedded HSQLDB or Firebird database since the unzipping steps are slightly different for each one. // in the Base class // globals public static final int HSQLDB = 1 ; public static final int FIREBIRD = 2 ; public static final String HSQL_EMBEDDED = \"sdbc:embedded:hsqldb\" ; public static final String FIREBIRD_EMBEDDED = \"sdbc:embedded:firebird\" ; public static ArrayList < String > extractEmbedded ( String fnm ) { String embedFnm = getEmbeddedFnm ( fnm ); if ( embedFnm == null ) { System . out . println ( fnm + \" is not an embedded HSQL/Firebird database\" ); return null ; } else if ( embedFnm . equals ( HSQL_EMBEDDED )) { System . out . println ( fnm + \" is an embedded HSQL database\" ); return unzipFiles ( fnm , HSQLDB ); } else if ( embedFnm . equals ( FIREBIRD_EMBEDDED )) { System . out . println ( fnm + \" is an embedded Firebird database\" ); return unzipFiles ( fnm , FIREBIRD ); } else { System . out . println ( fnm + \" holds an unknown embedded db: \" + embedFnm ); return null ; } } // end of extractEmbedded() In earlier chapters I retrieved the database type by examining the connection properties of the driver, but I don't want to use that technique here since it requires the Office API. One alternative is to look for information inside the ODB document. If an ODB file is opened as a zipped folder, the top-level always contains a content.xml file and a database/ folder, as in Figure 1. Figure 1. Inside an ODB Document. content.xml stores information about the database type inside its element. The \"xlink:href\" attribute is assigned \"sdbc:embedded.hsqldb\" for an embedded HSQLDB database, and \"sdbc:embedded:firebird\" for embedded Firebird. The \"xlink:href\" attribute inside content.xml for the liangTable.odb document is shown in Figure 2, which indicates that it's an embedded HSQLDB database. Figure 2. Part of content.xml for liangTables.odb. Incidentally, I used a Notepad++ plugin called XMLTools to format the XML in Figure 2, which makes it much easier to read. Base.getEmbeddedFnm() unzips content.xml so the \"xlink:href\" attribute of the element can be extracted: // in the Base class // globals public static final String TEMP_DIR = \"baseTmp/\" ; public static String getEmbeddedFnm ( String fnm ) { FileIO . makeDirectory ( TEMP_DIR ); String contentFnm = TEMP_DIR + \"content.xml\" ; if ( unzipContent ( fnm , contentFnm )) { String embedRes = getEmbeddedResource ( contentFnm ); FileIO . deleteFile ( contentFnm ); return embedRes ; } else { System . out . println ( \"Could not find content.xml inside \" + fnm ); return null ; } } // end of getEmbeddedFnm() Base.unzipContent() extracts content.xml, storing it temporarily in the baseTmp/ subdirectory. Base.getEmbeddedResource() accesses the element inside the file, returning the string assigned to its \"xlink:href\" attribute. This value may be null if the attribute isn't present, or it may contain the URL string of an external database. Back in Base.extractEmbedded(), if the document contains an embedded database then the next step is to copy the database files from the zipped file into the baseTemp/ folder. The extraction details are similar but not quite the same for embedded HSQLDB and Firebird databases, as can be seen by looking inside the database/ folders for the two kinds of database. Figure 3 shows the contents of an HSQLDB database/ folder on the left and a Firebird database/ folder on the right. Figure 3. Contents of a HSQLDB database/ folder (a) and a Firebird database/ folder (b). A HSQLDB database consists of several files (called backup, data, log, properties, and script) while the Firebird database is just one file (firebird.fdb). The HSQLDB \"script\" file contains table definitions, and the data for non-cached tables, while the \"data\" file contains the data for cached tables. The \"backup\" file is a compressed backup of the last known consistent state of the data file. The \"log\" file contains recent changes to the database, and the \"properties\" file stores database settings. Base.unzipFiles() unzips all of the files it finds inside database/, but changes the names of the HSQLDB files so they are all called \"hsqlDatabase\" but with different extensions based on their zip names. The new names are hsqlDatabase.backup, hsqlDatabase.data, hsqlDatabase.log, hsqlDatabase.properties, and hsqlDatabase.script, which makes them easy for JDBC to load at run time. No change is made to the name of the extracted firebird.fdb file. Base.extractEmbedded() returns a list of the files it has extracted from the ODB file. Back in EmbeddedQuery.java, Jdbc.isFirebirdEmbedded() and Jdbc.isHSQLEmbedded() examine this list to determine what kind of database was retrieved. 2. Querying an Extracted HSQLDB Database \u00b6 There's no need to use Base inside EmbeddedQuery.java; all database manipulations can be done with JDBC, along with the help of my Jdbc.java support class. The relevant lines in EmbeddedQuery.java are: // part of EmbeddedQuery.java... Connection conn = null ; try { conn = Jdbc . connectToDB ( dbFnms ); if ( conn == null ) return ; ArrayList < String > tableNames = Jdbc . getTablesNames ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); ResultSet rs = Jdbc . executeQuery ( \"SELECT * FROM \\\"\" + tableNames . get ( 0 ) + \"\\\"\" , conn ); // Jdbc.printResultSet(rs); DBTablePrinter . printResultSet ( rs ); // Jdbc.displayResultSet(rs); conn . close (); } I won\u2019t bother describing most of my Jdbc.java support methods (e.g. getTablesNames(), executeQuery(), printResultSet(), and displayResultSet()) since they're virtually identical to the same-named Base.java methods. The main difference is that they use JDBC's Connection, Statement, and ResultSet classes instead of sdbc's XConnection, XStatement, and XResultSet interfaces. I'm also using Hami Galip Torun's original DBTablePrinter class rather than my modified BaseTablePrinter version. Jdbc.connectToDB() uses Jdbc.isHSQLEmbedded() and Jdbc.isFirebirdEmbedded() to decide which connect methods are used for HSQLDB and Firebird. // in the Jdbc class public static Connection connectToDB ( ArrayList < String > fnms ) { if ( isHSQLEmbedded ( fnms )) return connectToHSQL ( Base . TEMP_DIR + Base . HSQL_FNM ); else if ( isFirebirdEmbedded ( fnms )) return connectToFB ( Base . TEMP_DIR + Base . FB_FNM + \".fdb\" ); else { System . out . println ( \"Unrecognized embedded database\" ); return null ; } } // end of connectToDB() I'll explain the details of connectToHSQL() here, and connectToFB() in the next section. The HSQLDB website ( https://hsqldb.org/ ) contains a lot of documentation on how to utilize JDBC, but one thing to remember is that Office's hsqldb.jar is version 1.8 of the engine. The most prominent documentation at the HSQLDB website is for the current version (v.2.3 as I write this). Fortunately, the older 1.8. documentation is still around, beginning at https://hsqldb.org/doc/1.8/guide/ , and a short JDBC example is in Appendix B at https://hsqldb.org/doc/1.8/guide/apb.html . Jdbc.connectToHSQL() is based on that example: // in the Jdbc class public static Connection connectToHSQL ( String filePath ) { Connection conn = null ; try { Class . forName ( \"org.hsqldb.jdbcDriver\" ); conn = DriverManager . getConnection ( \"jdbc:hsqldb:file:\" + filePath + \";shutdown=true\" , \"SA\" , \"\" ); // force db closure (shutdown) at connection close // otherwise data, log and lock will not be deleted } catch ( ClassNotFoundException e ) { System . out . println ( \"Failed to load JDBC-HSQLDB driver\" ); } catch ( SQLException e ) { System . out . println ( e ); } return conn ; } // end of connectToHSQL() Using HSQLDB Interactively: SqlTool \u00b6 It's useful to be able to examine a database without having to write Java code first; HSQLDB includes SqlTool for that purpose. SqlTool is explained at length in chapter 8 of the user guide for HSQLDB 1.8 at https://hsqldb.org/doc/1.8/guide/ch08.html . It's also possible to get help at runtime by calling hsqldb.jar with the \"--help\" argument: java - jar < OFFICE > \\ program \\ classes \\ hsqldb . jar -- help Figure 4 shows the help generated when the JAR file is called inside the \\program\\classes folder. Figure 4. Using SqlTool inside hsqldb.jar. 3. Querying an Extracted Firebird Database \u00b6 Accessing a Firebird database without passing through the Office API is a bit more work than for HSQLDB since there's no JAR file inside Office containing the necessary JDBC driver. The easiest thing is to download the embedded version of Firebird from https://firebirdsql.org/en/downloads/ , making sure to grab either the 32-bit or 64- bit version for your OS. This should be unzipped to a convenient location (e.g. d:\\firebird), and the path added to Window's PATH environment variable. Bug When I added Firebird 2.5.5 to PATH this caused a problem whenever I subsequently opened embedded Firebird databases in Base! Office issued a Runtime error r6034, related to the Microsoft Visual C++ runtime library. This is triggered by the presence of a mscvcr80.dll file in the downloaded firebird/ directory which duplicates one in Windows. One solution is to move Microsoft.VC80.CRT.manifest, msvcp80.dll, and msvcr80.dll (i.e. three files) from the firebird/ directory to some other location (e.g. into an UNUSED/ directory in firebird/). The JDBC driver, called Jaybird, is a separate download from https://firebirdsql.org/en/jdbc-driver/ . This should be unzipped to a convenient location (e.g. d:\\jaybird). There's no need to add Jaybird to the classpath of the javac.exe compiler, but calls to java.exe must include the location of its JAR and associated DLL. For example, run.bat in the Base Tests/ folder calls java.exe like so: java - cp \"%LO%\\program\\classes\\*;%LO%\\URE\\java\\*; ..\\Utils;D:\\jna\\jna-4.1.0.jar; D:\\jna\\jna-platform-4.1.0.jar; D:\\jaybird\\jaybird-full-2.2.10.jar;.\" - Djava . library . path = \"D:\\jaybird\" %* The information in bold allows Jdbc.connectToFB() to find the JDBC driver at run rime: // in the Jdbc class public static Connection connectToFB ( String filePath ) { Connection conn = null ; try { Class . forName ( \"org.firebirdsql.jdbc.FBDriver\" ); conn = DriverManager . getConnection ( \"jdbc:firebirdsql:embedded:\" + filePath , \"sysdba\" , \"masterkey\" ); } catch ( ClassNotFoundException e ) { System . out . println ( \"Failed to load JDBC-Firebird driver\" ); } catch ( SQLException e ) { System . out . println ( e ); } return conn ; } // end of connectToFB() Note that the DriverManager.getConnection() call requires the system admin's default login and password, \"sysdba\" and \"masterkey\". Using Firebird Interactively: isql \u00b6 It's useful to be able to examine a database without writing Java code. Firebird offers isql.exe for that purpose, but it's not included in the embedded Firebird download. The 'simplest' way of adding it is to download the zipped version of the full firebird system (called \"Classic, Superclassic & Superserver\"), and unzip only isql.exe which is in the bin/ directory. Copy isql.exe to the embedded firebird directory on your machine (e.g. into d:\\firebird), and make a copy of the fbembed.dll file in that folder, renaming it to fbclient.dll. The isql manual is online at https://firebirdsql.org/manual/isql.html . isql also has built-in help, as shown in Figure 5. Figure 5. Using help inside isql.exe.","title":"Chapter 38. Treating an ODB File as a Zipped Folder"},{"location":"38-ODB_as_Zip.html#chapter-38-treating-an-odb-file-as-a-zipped-folder","text":"Topics Extracting a Database from an ODB File; Querying an Extracted HSQLDB Database; Querying an Extracted Firebird Database Example folders: \"Base Tests\" and \"Utils\" An ODB document can be manipulated as a zipped folder, using tools such as 7-zip ( https://7-zip.org/ ). This means that it's possible to use Java zip classes (in the java.util.zip package) to extract a database from the ODB file. The advantage of this technique is that the resulting HSQLDB or Firebird database can be accessed through Java's JDBC without using the sdbc, sdbcx, or sdb modules in the Office API. The Office download includes a copy of the HSQLDB database engine (stored in \\program\\classes\\hsqldb.jar) so there's no need to download any software for manipulating HyperSQL databases through JDBC. However, Firebird programming requires Firebird's embedded engine and its JDBC driver, called Jaybird. I'll discuss the details of how to run HSQLDB and Firebird databases after explaining how to extract them from ODB documents. EmbeddedQuery.java shows all the top-level stages: // in EmbeddedQuery.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run EmbeddedQuery <fnm>\" ); return ; } ArrayList < String > dbFnms = Base . extractEmbedded ( args [ 0 ] ); if ( dbFnms == null ) return ; System . out . println ( \"Is this a Firebird embedded database? \" + Jdbc . isFirebirdEmbedded ( dbFnms )); System . out . println ( \"Is this an HSQLDB embedded database? \" + Jdbc . isHSQLEmbedded ( dbFnms )); Connection conn = null ; try { conn = Jdbc . connectToDB ( dbFnms ); if ( conn == null ) return ; ArrayList < String > tableNames = Jdbc . getTablesNames ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); ResultSet rs = Jdbc . executeQuery ( \"SELECT * FROM \\\"\" + tableNames . get ( 0 ) + \"\\\"\" , conn ); DBTablePrinter . printResultSet ( rs ); conn . close (); } catch ( SQLException e ) { System . out . println ( e ); } // FileIO.deleteFiles(dbFnms); } // end of main()","title":"Chapter 38. Treating an ODB File as a Zipped Folder"},{"location":"38-ODB_as_Zip.html#1-extracting-a-database-from-an-odb-file","text":"Base.extractEmbedded() first determines if the ODB file contains an embedded HSQLDB or Firebird database since the unzipping steps are slightly different for each one. // in the Base class // globals public static final int HSQLDB = 1 ; public static final int FIREBIRD = 2 ; public static final String HSQL_EMBEDDED = \"sdbc:embedded:hsqldb\" ; public static final String FIREBIRD_EMBEDDED = \"sdbc:embedded:firebird\" ; public static ArrayList < String > extractEmbedded ( String fnm ) { String embedFnm = getEmbeddedFnm ( fnm ); if ( embedFnm == null ) { System . out . println ( fnm + \" is not an embedded HSQL/Firebird database\" ); return null ; } else if ( embedFnm . equals ( HSQL_EMBEDDED )) { System . out . println ( fnm + \" is an embedded HSQL database\" ); return unzipFiles ( fnm , HSQLDB ); } else if ( embedFnm . equals ( FIREBIRD_EMBEDDED )) { System . out . println ( fnm + \" is an embedded Firebird database\" ); return unzipFiles ( fnm , FIREBIRD ); } else { System . out . println ( fnm + \" holds an unknown embedded db: \" + embedFnm ); return null ; } } // end of extractEmbedded() In earlier chapters I retrieved the database type by examining the connection properties of the driver, but I don't want to use that technique here since it requires the Office API. One alternative is to look for information inside the ODB document. If an ODB file is opened as a zipped folder, the top-level always contains a content.xml file and a database/ folder, as in Figure 1. Figure 1. Inside an ODB Document. content.xml stores information about the database type inside its element. The \"xlink:href\" attribute is assigned \"sdbc:embedded.hsqldb\" for an embedded HSQLDB database, and \"sdbc:embedded:firebird\" for embedded Firebird. The \"xlink:href\" attribute inside content.xml for the liangTable.odb document is shown in Figure 2, which indicates that it's an embedded HSQLDB database. Figure 2. Part of content.xml for liangTables.odb. Incidentally, I used a Notepad++ plugin called XMLTools to format the XML in Figure 2, which makes it much easier to read. Base.getEmbeddedFnm() unzips content.xml so the \"xlink:href\" attribute of the element can be extracted: // in the Base class // globals public static final String TEMP_DIR = \"baseTmp/\" ; public static String getEmbeddedFnm ( String fnm ) { FileIO . makeDirectory ( TEMP_DIR ); String contentFnm = TEMP_DIR + \"content.xml\" ; if ( unzipContent ( fnm , contentFnm )) { String embedRes = getEmbeddedResource ( contentFnm ); FileIO . deleteFile ( contentFnm ); return embedRes ; } else { System . out . println ( \"Could not find content.xml inside \" + fnm ); return null ; } } // end of getEmbeddedFnm() Base.unzipContent() extracts content.xml, storing it temporarily in the baseTmp/ subdirectory. Base.getEmbeddedResource() accesses the element inside the file, returning the string assigned to its \"xlink:href\" attribute. This value may be null if the attribute isn't present, or it may contain the URL string of an external database. Back in Base.extractEmbedded(), if the document contains an embedded database then the next step is to copy the database files from the zipped file into the baseTemp/ folder. The extraction details are similar but not quite the same for embedded HSQLDB and Firebird databases, as can be seen by looking inside the database/ folders for the two kinds of database. Figure 3 shows the contents of an HSQLDB database/ folder on the left and a Firebird database/ folder on the right. Figure 3. Contents of a HSQLDB database/ folder (a) and a Firebird database/ folder (b). A HSQLDB database consists of several files (called backup, data, log, properties, and script) while the Firebird database is just one file (firebird.fdb). The HSQLDB \"script\" file contains table definitions, and the data for non-cached tables, while the \"data\" file contains the data for cached tables. The \"backup\" file is a compressed backup of the last known consistent state of the data file. The \"log\" file contains recent changes to the database, and the \"properties\" file stores database settings. Base.unzipFiles() unzips all of the files it finds inside database/, but changes the names of the HSQLDB files so they are all called \"hsqlDatabase\" but with different extensions based on their zip names. The new names are hsqlDatabase.backup, hsqlDatabase.data, hsqlDatabase.log, hsqlDatabase.properties, and hsqlDatabase.script, which makes them easy for JDBC to load at run time. No change is made to the name of the extracted firebird.fdb file. Base.extractEmbedded() returns a list of the files it has extracted from the ODB file. Back in EmbeddedQuery.java, Jdbc.isFirebirdEmbedded() and Jdbc.isHSQLEmbedded() examine this list to determine what kind of database was retrieved.","title":"1.  Extracting a Database from an ODB File"},{"location":"38-ODB_as_Zip.html#2-querying-an-extracted-hsqldb-database","text":"There's no need to use Base inside EmbeddedQuery.java; all database manipulations can be done with JDBC, along with the help of my Jdbc.java support class. The relevant lines in EmbeddedQuery.java are: // part of EmbeddedQuery.java... Connection conn = null ; try { conn = Jdbc . connectToDB ( dbFnms ); if ( conn == null ) return ; ArrayList < String > tableNames = Jdbc . getTablesNames ( conn ); System . out . println ( \"No. of tables: \" + tableNames . size ()); System . out . println ( Arrays . toString ( tableNames . toArray ())); ResultSet rs = Jdbc . executeQuery ( \"SELECT * FROM \\\"\" + tableNames . get ( 0 ) + \"\\\"\" , conn ); // Jdbc.printResultSet(rs); DBTablePrinter . printResultSet ( rs ); // Jdbc.displayResultSet(rs); conn . close (); } I won\u2019t bother describing most of my Jdbc.java support methods (e.g. getTablesNames(), executeQuery(), printResultSet(), and displayResultSet()) since they're virtually identical to the same-named Base.java methods. The main difference is that they use JDBC's Connection, Statement, and ResultSet classes instead of sdbc's XConnection, XStatement, and XResultSet interfaces. I'm also using Hami Galip Torun's original DBTablePrinter class rather than my modified BaseTablePrinter version. Jdbc.connectToDB() uses Jdbc.isHSQLEmbedded() and Jdbc.isFirebirdEmbedded() to decide which connect methods are used for HSQLDB and Firebird. // in the Jdbc class public static Connection connectToDB ( ArrayList < String > fnms ) { if ( isHSQLEmbedded ( fnms )) return connectToHSQL ( Base . TEMP_DIR + Base . HSQL_FNM ); else if ( isFirebirdEmbedded ( fnms )) return connectToFB ( Base . TEMP_DIR + Base . FB_FNM + \".fdb\" ); else { System . out . println ( \"Unrecognized embedded database\" ); return null ; } } // end of connectToDB() I'll explain the details of connectToHSQL() here, and connectToFB() in the next section. The HSQLDB website ( https://hsqldb.org/ ) contains a lot of documentation on how to utilize JDBC, but one thing to remember is that Office's hsqldb.jar is version 1.8 of the engine. The most prominent documentation at the HSQLDB website is for the current version (v.2.3 as I write this). Fortunately, the older 1.8. documentation is still around, beginning at https://hsqldb.org/doc/1.8/guide/ , and a short JDBC example is in Appendix B at https://hsqldb.org/doc/1.8/guide/apb.html . Jdbc.connectToHSQL() is based on that example: // in the Jdbc class public static Connection connectToHSQL ( String filePath ) { Connection conn = null ; try { Class . forName ( \"org.hsqldb.jdbcDriver\" ); conn = DriverManager . getConnection ( \"jdbc:hsqldb:file:\" + filePath + \";shutdown=true\" , \"SA\" , \"\" ); // force db closure (shutdown) at connection close // otherwise data, log and lock will not be deleted } catch ( ClassNotFoundException e ) { System . out . println ( \"Failed to load JDBC-HSQLDB driver\" ); } catch ( SQLException e ) { System . out . println ( e ); } return conn ; } // end of connectToHSQL()","title":"2.  Querying an Extracted HSQLDB Database"},{"location":"38-ODB_as_Zip.html#using-hsqldb-interactively-sqltool","text":"It's useful to be able to examine a database without having to write Java code first; HSQLDB includes SqlTool for that purpose. SqlTool is explained at length in chapter 8 of the user guide for HSQLDB 1.8 at https://hsqldb.org/doc/1.8/guide/ch08.html . It's also possible to get help at runtime by calling hsqldb.jar with the \"--help\" argument: java - jar < OFFICE > \\ program \\ classes \\ hsqldb . jar -- help Figure 4 shows the help generated when the JAR file is called inside the \\program\\classes folder. Figure 4. Using SqlTool inside hsqldb.jar.","title":"Using HSQLDB Interactively: SqlTool"},{"location":"38-ODB_as_Zip.html#3-querying-an-extracted-firebird-database","text":"Accessing a Firebird database without passing through the Office API is a bit more work than for HSQLDB since there's no JAR file inside Office containing the necessary JDBC driver. The easiest thing is to download the embedded version of Firebird from https://firebirdsql.org/en/downloads/ , making sure to grab either the 32-bit or 64- bit version for your OS. This should be unzipped to a convenient location (e.g. d:\\firebird), and the path added to Window's PATH environment variable. Bug When I added Firebird 2.5.5 to PATH this caused a problem whenever I subsequently opened embedded Firebird databases in Base! Office issued a Runtime error r6034, related to the Microsoft Visual C++ runtime library. This is triggered by the presence of a mscvcr80.dll file in the downloaded firebird/ directory which duplicates one in Windows. One solution is to move Microsoft.VC80.CRT.manifest, msvcp80.dll, and msvcr80.dll (i.e. three files) from the firebird/ directory to some other location (e.g. into an UNUSED/ directory in firebird/). The JDBC driver, called Jaybird, is a separate download from https://firebirdsql.org/en/jdbc-driver/ . This should be unzipped to a convenient location (e.g. d:\\jaybird). There's no need to add Jaybird to the classpath of the javac.exe compiler, but calls to java.exe must include the location of its JAR and associated DLL. For example, run.bat in the Base Tests/ folder calls java.exe like so: java - cp \"%LO%\\program\\classes\\*;%LO%\\URE\\java\\*; ..\\Utils;D:\\jna\\jna-4.1.0.jar; D:\\jna\\jna-platform-4.1.0.jar; D:\\jaybird\\jaybird-full-2.2.10.jar;.\" - Djava . library . path = \"D:\\jaybird\" %* The information in bold allows Jdbc.connectToFB() to find the JDBC driver at run rime: // in the Jdbc class public static Connection connectToFB ( String filePath ) { Connection conn = null ; try { Class . forName ( \"org.firebirdsql.jdbc.FBDriver\" ); conn = DriverManager . getConnection ( \"jdbc:firebirdsql:embedded:\" + filePath , \"sysdba\" , \"masterkey\" ); } catch ( ClassNotFoundException e ) { System . out . println ( \"Failed to load JDBC-Firebird driver\" ); } catch ( SQLException e ) { System . out . println ( e ); } return conn ; } // end of connectToFB() Note that the DriverManager.getConnection() call requires the system admin's default login and password, \"sysdba\" and \"masterkey\".","title":"3.  Querying an Extracted Firebird Database"},{"location":"38-ODB_as_Zip.html#using-firebird-interactively-isql","text":"It's useful to be able to examine a database without writing Java code. Firebird offers isql.exe for that purpose, but it's not included in the embedded Firebird download. The 'simplest' way of adding it is to download the zipped version of the full firebird system (called \"Classic, Superclassic & Superserver\"), and unzip only isql.exe which is in the bin/ directory. Copy isql.exe to the embedded firebird directory on your machine (e.g. into d:\\firebird), and make a copy of the fbembed.dll file in that folder, renaming it to fbclient.dll. The isql manual is online at https://firebirdsql.org/manual/isql.html . isql also has built-in help, as shown in Figure 5. Figure 5. Using help inside isql.exe.","title":"Using Firebird Interactively: isql"},{"location":"39%20Part%207%20Cross-application.html","text":"Part 7 Cross-application \u00b6","title":"Part 7 Cross-application"},{"location":"39%20Part%207%20Cross-application.html#part-7-cross-application","text":"","title":"Part 7 Cross-application"},{"location":"39-Forms_API_Overview.html","text":"Chapter 39. Forms API Overview \u00b6 Topics An Overview of the Forms API; Examining a Text-based Form; Attaching Listeners to a View Example folders: \"Forms Tests\" and \"Utils\" Forms are usually found in Writer documents, or as data entry interfaces for Base, although they can also be employed in Draw, Impress, and Calc. Although Base forms are typically employed as front-ends to databases, the same capability is available in Writer and the other Office applications. The LibreOffice \"Getting Started Guide\" (available at https://th.libreoffice.org/get-help/documentation/ ) describes the form features of Writer and Base in chapters 4 and 8. Longer examples can be found in the \"Writer Guide\" and \"Base Handbook\" documents. Chapter 15 of the \"Writer Guide\" explains how to create a form using the \"Form Controls \" and \"Form Design\" toolbars; it's essentially a matter of dragging check boxes, buttons, text fields, pull-down lists, and other controls, onto a form canvas. Properties associated with a control, such as its name, text label, and position, are set by right clicking to access a properties dialog window. An important use of Writer forms is to create editable PDF forms. This doesn't involve anything more than remembering to save the form-filled document as a PDF file when it's finished. There are several online tutorials that explain the details, such as \"Create PDF Forms with OpenOffice\" at https://foersom.com/org/HowTo/OoCreatePdfForm.html ; although it's written for OpenOffice, it can be applied to LibreOffice without change. Chapter 4 of the \"Base Handbook\" explains how to create a data input form for a library loans database, and much of the GUI interface of control toolbars, form canvas, and property dialogs is identical to that found in Writer. Even if you're only creating a text-based form, it's well worth reading the Base chapter because it goes into detail about the General, Data, and Events tab in the properties dialog. A somewhat simpler example, which is purely text-based without data sources, can be found at https://openoffice.blogs.com/forms_fromscratch.pdf . I used this article (which is titled \"Creating Forms from Scratch\") to create the scratchExample.odt file used here. 1. Why Bother Programming Forms? \u00b6 It's very easy to build a form using Office's \"Form Controls \" and \"Form Design\" toolbars. The GUI provides immediate feedback on how things will look by switching design mode on (where you're building the form) and off (to see how the form will look to a user). Nevertheless, manipulating a form from code can be useful. This chapter starts with an overview of the forms API, and then looks at how data input into an existing form can be processed using listeners. This isn't the standard way of adding behavior to forms; that capability is typically handled by macros coded in Office Basic (for example, see chapter 13 of \"Getting Started with LibreOffice\" and chapter 9 of the \"Base Handbook\"). I'll be looking at how to code form macros in Chapters 48 and 49. The next chapter, Chapter 40, will look at how a form can be constructed at run time by programmatically adding controls to a new text document. The form is linked to a local database, and table and list box controls access its tables in different ways. In addition, a variety of listeners are attached to the controls. 2. An Overview of the Forms API \u00b6 A key principle behind the forms API is the Model-View-Controller (MVC) pattern (e.g. see https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller/ ) which divides each form control in two: a model (or component) representing the control's data, and a view for its GUI. Figure 1 shows the forms MVC model in detail. Figure 1. The Form API's MVC Model. The third part of MVC, the controller, links the model and view inside an application. There might be multiple views attached to a model (i.e. different renderings of the same data), and the controller mediates between a view and the model when the user tries to change its state (for instance by typing data into a text field). The thick-edged boxes next to the Model, View and Controller rounded rectangles in Figure 1 represent the main Office services and interfaces that implement the model, view and controller. 2.1. Control Confusion \u00b6 The two uses of the word \"control\" in the API can be confusing. When the documentation refers to a control by name, such as a \"button control\" or \"text field control\", then it typically means the data and rendering parts taken as a whole. For example, \"button control\" includes the button's on-screen appearance and its state. However, when the API only talks about a \"control\" then this usually means the services and interfaces related to its appearance. If the API refers to a control's \"model\" then it means its state. Another problem with understanding the forms API is that its functionality is spread across several modules and submodules. The form module contains many services, interfaces, and seven submodules, which are listed in Table 1. Form Submodule Purpose binding collects functionality for binding form controls to external data sources component collects form control model descriptions control collects form control descriptions inspection collects services for inspecting form/components runtime collects functionality needed during a form's runtime submission collects functionality for submitting forms to external data sinks validation collects functionality to validate form components by help of external validator instances Table 1. Submodules of the Form Module. To simplify matters, I'm only going to describe two of the submodules: form.component which holds the model-related services, and form.control for the view-related services. But there's more modules to browse! Figure 2 shows the main services and interfaces used to define a button. Figure 2. Form Services and Interfaces for a Button. Four modules are mentioned in Figure 2, written in brackets inside the service rectangles. There's a CommandButton service in form.component and a second CommandButton in form.control. An examination of these services (and most other services in form.component and form.control) reveal them to be basically empty. The real 'action' is elsewhere, up in the form module's FormControlModel service, and over in Office's very large awt module, which implements its version of Java's AWT. The names of the services start to become a little unclear at this point since the words \"Control\" and \"Model\" often appear together (e.g. in FormControlModel, UnoControlButtonModel, and UnoControlModel). My advice is to remember that \"Model beats Control\" \uf04a. If a class name includes the word \"Model\", then it's probably for the model/data part of the control. If the name contains only \"Control\" then it's most likely for the rendering/appearance or listener part of the control. For example, UnoControlButtonModel is where the button's data is defined, as a lengthy collection of properties. You can quickly view its documentation with lodoc UnoControlButtonModel . UnoControlButton is for the button's GUI (see lodoc UnoControlButton ). Most of the functionality for a button is accessed through its XButton interface, which allows a listener to be attached to the button. Every model (e.g. CommandButton in form.component) inherits the FormControlModel service in the form module. This links the control into the surrounding form. 2.2. More Information on the API \u00b6 The principal documentation on the forms API is chapter 13 of the Developer's Guide available as https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . Alternatively, you can read the chapter online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Forms/Forms/ (or use loGuide Forms ). The guide's form examples are at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Forms . 3. Examining a Text-based Form \u00b6 ExamineForm.java opens a text document containing a form, and attaches button and text field listeners to every button and text field control. Figure 3 shows most of the important data structures used by a form. Figure 3. The Form Data Structures. A form is stored in a draw page associated with the document. A draw page can manage multiple forms, which can be accessed by index or by name (the default form is called \"Form\"). In some types of Office documents, it's possible to have multiple draw pages. A form contains controls, such as buttons, text fields, and tables, and also nested forms. Collectively, controls and nested forms are known as form components, and are organized into a tree hierarchy in the draw page. At the lowest level, each basic form control is represented by a control shape, a specialized kind of DrawPage shape. A data source, such as a database, may be attached to a form, which its controls can access using SQL queries. Figure 4 gives a high-level view of how ExamineForm.java \"digs down\" into a document to access each control's model and view. Figure 4. From Document to Control Model and View. The words connected by the arrows correspond (in most cases) to services in the forms API; the names in blue are the interfaces associated with those services. The \"Fig. X\" rounded rectangles refer to figures later in this chapter which give more detail about how the API links from one service to the next. Figure 4 starts with the document, and ends with references to a control's model and view services. For example, the services for a button are the CommandButton classes in the form.component and form.control modules. Figure 4 has a branch point at the DrawPage service (it's labeled with the word \"or\") since there are two ways of using the API to get from a draw page to control models. The branch on the left examines the control shapes in the DrawPage, while the branch on the right examines the form components. I've decided not to explain the the left branch, although it's documented in my Forms.java utility class. The left branch corresponds to code in the Forms.getModels2() method. Most of Figure 4 is implemented as static methods in the Forms class, which means that ExamineForm.java is fairly short: // in ExamineForm.java public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run ExamineForm <ODT file>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } ArrayList < XControlModel > models = Forms . getModels ( doc ); System . out . println ( \"No. of control models in form: \" + models . size ()); // examine each model for ( XControlModel model : models ) { System . out . println ( \" \" + Forms . getName ( model ) + \": \" + Forms . getTypeStr ( model )); // look at the control for each model XControl ctrl = Forms . getControl ( doc , model ); if ( ctrl == null ) System . out . println ( \" No control found\" ); else { // attach listener if the control is // a button or text field if ( Forms . isButton ( model )) attachButtonListener ( ctrl , model ); else if ( Forms . isTextField ( model )) attachTextFieldListeners ( ctrl ); } } System . out . println (); GUI . setVisible ( doc , true ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Forms.getModels() and Forms.getControl() will be used in most forms-based programs. Forms.getModels() returns a list of all the control models in the document. In terms of Figure 4, it moves from the Document service at the top of the figure to ControlModel near the bottom. Forms.getControl() completes the descent by retrieving the control (view) associated with a given model. If a control is a button or text field than attachButtonListener() or attachTextFieldListeners() are called. These methods are implemented in ExamineForm.java, but I'll delay explaining them until I've covered Forms.getModels() and Forms.getControl(). 3.1. From Document to DrawPages \u00b6 Every Office document supports the OfficeDocument service, and the XModel and XComponent interfaces. Using XComponent as a starting interface, it's possible to change the type to XDrawPagesSupplier (or XDrawPageSupplier), which gives access to the DrawPages (or single DrawPage) inside the document. The cast works because all Office documents support the GenericDrawingDocument service, as illustrated in Figure 5. Figure 5. Part of the GenericDrawingDocument Service Hierarchy The code that implements the cast: // in the Forms class public static XNameContainer getForms ( XComponent doc ) { XDrawPage drawPage = getDrawPage ( doc ); if ( drawPage != null ) return getForms ( drawPage ); else return null ; } // end of getForms() public static XDrawPage getDrawPage ( XComponent doc ) // return the first draw page even if there are many { XDrawPageSupplier xSuppPage = Lo . qi ( XDrawPageSupplier . class , doc ); if ( xSuppPage != null ) // this works if doc supports a single DrawPage return xSuppPage . getDrawPage (); else { // this means that the doc supports multiple DrawPages XDrawPagesSupplier xSuppPages = Lo . qi ( XDrawPagesSupplier . class , doc ); XDrawPages xPages = xSuppPages . getDrawPages (); try { System . out . println ( \"Returning first draw page\" ); return Lo . qi ( XDrawPage . class , xPages . getByIndex ( 0 )); } catch ( Exception e ) { System . out . println ( e ); return null ; } } } // end of getDrawPage() Forms.getDrawPage() only returns the first draw page in a document, even if many pages are available. 3.2. From DrawPage to Form \u00b6 The XDrawPage interface can be cast to XFormsSupplier which makes the page's forms accessible. This cast works because of the service hierarchy shown in Figure 6 which links the DrawPage service to GenericDrawPage. Figure 6. Part of the DrawPage Service Hierarchy. XFormsSupplier can supply forms as an indexed sequence (an XIndexContainer) or as an associative array using the form names as keys, returned by Forms.getForms(): // in the Forms class public static XNameContainer getForms ( XDrawPage drawPage ) // get all the forms in the page as a named container { XFormsSupplier formsSupp = Lo . qi ( XFormsSupplier . class , drawPage ); return formsSupp . getForms (); } // end of getForms() The default form in a draw page is called \"Form\" , and can be extracted by calling Forms . getForm ( doc , \"Form\" ): // in the Forms class public static XForm getForm ( XComponent doc , String formName ) // get the form called formName { XNameContainer namedForms = getForms ( doc ); // see above XNameContainer con = getFormByName ( formName , namedForms ); return Lo . qi ( XForm . class , con ); } public static XNameContainer getFormByName ( String formName , XNameContainer namedForms ) // get the form called formName { try { return Lo . qi ( XNameContainer . class , namedForms . getByName ( formName )); } catch ( Exception e ) { System . out . println ( \"Could not find form \" + formName + \": \" + e ); return null ; } } // end of getFormByName() 3.3. From Form to FormComponents \u00b6 A form is a FormComponents instance, which holds FormComponent instances (i.e. basic controls) and nested FormComponents (i.e. nested forms). Figure 7 shows a simplified service hierarchy for Form, FormComponents, and FormComponent. Figure 7. Part of the Form Service Hierarchy. Forms.getModels() collects all the FormComponent instances as a list by recursively searching from the top level form (or forms) through all the nested forms : // in the Forms class public static ArrayList < XControlModel > getModels ( XComponent doc ) { XNameContainer formNamesCon = getForms ( doc ); // see above return getModels ( formNamesCon ); } public static ArrayList < XControlModel > getModels ( XNameAccess formNamesCon ) { ArrayList < XControlModel > models = new ArrayList < XControlModel > (); String nms [] = formNamesCon . getElementNames (); for ( int i = 0 ; i < nms . length ; i ++ ) { try { XServiceInfo servInfo = Lo . qi ( XServiceInfo . class , formNamesCon . getByName ( nms [ i ] )); if ( servInfo . supportsService ( \"com.sun.star.form.FormComponents\" )) { // this means that a nested form has been found XNameAccess childCon = Lo . qi ( XNameAccess . class , servInfo ); models . addAll ( getModels ( childCon ) ); //recursively search it } else if ( servInfo . supportsService ( \"com.sun.star.form.FormComponent\" )) { XControlModel model = Lo . qi ( XControlModel . class , servInfo ); models . add ( model ); } } catch ( Exception e ) { System . out . println ( \"Could not access \" + nms [ i ] ); } } return models ; } // end of getModels() The first Forms.getModels() method extracts the top-level form (or forms) from the document as a named container, then passes it to the recursive getModels() which iterates through the container. If an element is a FormComponents instance then it's a nested form, and getModels() is called recursively to collect its controls. If the element is of type FormComponent then it's an ordinary control. 3.4. From FormComponent to Control Model \u00b6 A FormComponent instance can be cast to XControlModel: XControlModel model = Lo . qi ( XControlModel . class , servInfo ); XControlModel first appeared at the top of Figure 2 on the left \u2013 it\u2019s the interface inherited by all models. The casting is possible because every control model service (e.g. CommandButton in the form.component module) inherits both FormComponent and UnoControlModel, as depicted by Figure 8. Figure 8. Part of the Service Hierarchy for the CommandButton Model. Every model has a hierarchy similar to CommandButton's in Figure 8. For example, the text field control model hierarchy appears in Figure 9. Figure 9. Part of the Service Hierarchy for the TextField Model. Figures 8 and 9 depict two important coding features. One is that it's possible to cast between a form component and a control model, as demonstrated by Forms.getModel() shown above. The other is that a model's data is stored in its properties, and most of those are NOT in the model's service (i.e. not in CommandButton and TextField). Most model properties are in superclasses (i.e. UnoControlButtonModel in Figure 8 and UnoControlEditModel in Figure 9), which are located in the awt module. 3.5. Using a Control Model \u00b6 Returning to ExamineForm.java, the relevant bit of code is: // part of ExamineForm.java... ArrayList < XControlModel > models = Forms . getModels ( doc ); // see above System . out . println ( \"No. of control models in form: \" + models . size ()); // examine each model for ( XControlModel model : models ) { System . out . println ( \" \" + Forms . getName ( model ) + \": \" + Forms . getTypeStr ( model )); : } An XControlModel reference can be utilized in various ways, but two of the main ones are examining its subclass service type and accessing its properties. As Figures 8 and 9 indicate, most of a control's properties are in the UnoControlXXXModel service, but may come from other services which can be hard to locate. For example, \"Name\" is from UnoControlDialogElement, a superclass of UnoControlModel (which I didn't include in Figures 8 and 9). \"ClassId\" comes from FormControlModel, which is on the \"forms branch\" of the service hierarchies in the figures. The easiest thing is to print all the model's properties, by calling Props.showObjProps(): Props . showObjProps ( \"Model\" , model ); Info.showInterfaces() and Info.showServices() are similarly useful, listing all the interfaces and services for a model: Info . showInterfaces ( \"Model\" , model ); Info . showServices ( \"Model\" , model ); The Forms.getName() and Forms.getTypeStr() methods called in the code fragment above are defined as: // in the Forms class public static String getName ( XControlModel cModel ) // returns the name of the given form component { return ( String ) Props . getProperty ( cModel , \"Name\" ); } public static String getTypeStr ( XControlModel cModel ) { int id = getID ( cModel ); if ( id == - 1 ) return null ; XServiceInfo servInfo = Lo . qi ( XServiceInfo . class , cModel ); switch ( id ) { case FormComponentType . COMMANDBUTTON : return \"Command button\" ; case FormComponentType . RADIOBUTTON : return \"Radio button\" ; case FormComponentType . IMAGEBUTTON : return \"Image button\" ; case FormComponentType . CHECKBOX : return \"Check Box\" ; case FormComponentType . LISTBOX : return \"List Box\" ; case FormComponentType . COMBOBOX : return \"Combo Box\" ; case FormComponentType . GROUPBOX : return \"Group Box\" ; case FormComponentType . FIXEDTEXT : return \"Fixed Text\" ; case FormComponentType . GRIDCONTROL : return \"Grid Control\" ; case FormComponentType . FILECONTROL : return \"File Control\" ; case FormComponentType . HIDDENCONTROL : return \"Hidden Control\" ; case FormComponentType . IMAGECONTROL : return \"Image Control\" ; case FormComponentType . DATEFIELD : return \"Date Field\" ; case FormComponentType . TIMEFIELD : return \"Time Field\" ; case FormComponentType . NUMERICFIELD : return \"Numeric Field\" ; case FormComponentType . CURRENCYFIELD : return \"Currency Field\" ; case FormComponentType . PATTERNFIELD : return \"Pattern Field\" ; case FormComponentType . TEXTFIELD : // two services with this class id: // text field and formatted field if (( servInfo != null ) && servInfo . supportsService ( \"com.sun.star.form.component.FormattedField\" )) return \"Formatted Field\" ; else return \"Text Field\" ; default : System . out . println ( \"Unknown class ID: \" + id ); return null ; } } // end of getTypeStr() public static int getID ( XControlModel cModel ) { // get the ClassId property Short classId = ( Short ) Props . getProperty ( cModel , \"ClassId\" ); if ( classId == null ) { System . out . println ( \"No class ID found for form component\" ); return - 1 ; } return classId . intValue (); } // end of getID() Forms.getID returns the \"ClassId\" integer, which is checked by getTypeStr() against values in the FormComponentType enumeration, and mapped to more informative strings. Forms.getID() is utilized in a similar manner in a series of boolean isXXX() methods, such as isButton() and isTextField(): // in the Forms class public static boolean isButton ( XControlModel cModel ) { int id = getID ( cModel ); if ( id == - 1 ) return false ; else return (( id == FormComponentType . COMMANDBUTTON ) || ( id == FormComponentType . IMAGEBUTTON )); } // end of isButton() public static boolean isTextField ( XControlModel cModel ) { int id = getID ( cModel ); if ( id == - 1 ) return false ; else return (( id == FormComponentType . DATEFIELD ) || ( id == FormComponentType . TIMEFIELD ) || ( id == FormComponentType . NUMERICFIELD ) || ( id == FormComponentType . CURRENCYFIELD ) || ( id == FormComponentType . PATTERNFIELD ) || ( id == FormComponentType . TEXTFIELD )); } // end of isTextField() 3.6. From Control Model to View \u00b6 Having obtained a form's model, it's view becomes accessible, but following the MVC pattern, this requires the use of Office's controller (see Figure 1). One way to reach the controller is through a document reference (XComponent) and XModel.getCurrentController(). The resulting XController interface can be cast to XControlAccess, due to the service hierarchy shown in Figure 10. Figure 10. Part of the DrawingDocumentDrawView Service Hierarchy. These steps are implemented by GUI.getControlAccess(): // in the GUI class public static XControlAccess getControlAccess ( XComponent doc ) { return Lo . qi ( XControlAccess . class , getCurrentController ( doc )); } public static XController getCurrentController ( XComponent doc ) { XModel model = Lo . qi ( XModel . class , doc ); if ( model == null ) { System . out . println ( \"Document has no data model\" ); return null ; } return model . getCurrentController (); } Forms . getControl () employs XControlAccess . getControl () to return the model ' s view when supplied with a model : // in the Forms class public static XControl getControl ( XComponent doc , XControlModel cModel ) { XControlAccess controlAccess = GUI . getControlAccess ( doc ); // see above if ( controlAccess == null ) { System . out . println ( \"Could not obtain controls access\" ); return null ; } try { return controlAccess . getControl ( cModel ); } catch ( Exception e ) { System . out . println ( \"Could not access control: \" + e ); return null ; } } // end of getControl() 4. Attaching Listeners to a View \u00b6 XControl is an interface of the UnoControl service, which represents an abstract control. This class must be cast to a service for a real control, such as UnoControlButton or UnoControlEdit in order to call listener methods in XButton or XTextComponent. This hierarchy is illustrated by Figure 11. Figure 11. Part of the Service Hierarchy Below UnoControl. Back in ExamineForm.java, every button or text field has listeners attached to it: // part of ExamineForms.java... : // look at the control for each model XControl ctrl = Forms . getControl ( doc , model ); if ( ctrl == null ) System . out . println ( \" No control found\" ); else { // attach listener if the control is a button or text field if ( Forms . isButton ( model )) attachButtonListener ( ctrl , model ); else if ( Forms . isTextField ( model )) attachTextFieldListeners ( ctrl ); } : attachButtonListener() and attachTextFieldListener() implement the casting shown in Figure 11, starting with an XControl interface. For instance, attachButtonListener() connects an anonymous XActionListener object to a button, and sets its action command to be the button's label: // in ExamineForms.java private static void attachButtonListener ( XControl ctrl , XControlModel cModel ) { XButton xButton = Lo . qi ( XButton . class , ctrl ); // XControlModel cModel = ctrl.getModel(); xButton . setActionCommand ( Forms . getLabel ( cModel )); xButton . addActionListener ( new XActionListener () { public void disposing ( com . sun . star . lang . EventObject ev ) {} public void actionPerformed ( ActionEvent ev ) { System . out . println ( \"Pressed \\\"\" + ev . ActionCommand + \"\\\"\" ); } }); } // end of attachButtonListener() Although XActionListener and Java's ActionListener are similar, they're not the same. For one thing, its necessary to define two methods in XActionListener, actionPerformed() and disposing(). Office supports over 120 kinds of listeners! The best place to browse through them is on the documentation webpage for their common superclass, XEventListener. lodoc XEventListener should take you to XEventListener in the document module, but you want its superclass, XEventListener in the lang module. The first part of its long webpage is shown in Figure 12. Figure 12. The First Part of the XEventListener Documentation Page in the lang Module. Although the clickable images on the LibreOffice webpages make moving around the service and interface hierarchies very easy, they're not searchable. When the hierarchy is very large (as for XEventListener), and not sorted in alphabetical order, it can be time-consuming to find a particular subclass. I solved the problem by creating a text file, called XEventListenerSubclasses.txt, which lists the subclasses of XEventListener in order, and is searchable of course. You can find it in the Forms Tests/ folder for this chapter. Alternatively, almost all the listeners for controls are defined in the awt module, so you can search that module's documentation page (accessible using lodoc awt module ). attachTextFieldListeners() attaches two listeners to a text field control because XTextListener isn't triggered when the user types . My solution is to connect an XFocusListener which treats as a \"lost focus\" event when the cursor leaves the text field. The code for attachTextFieldListeners(): // in ExamineForms.java private static void attachTextFieldListeners ( XControl ctrl ) // listen for text changes and focus changes in the control { XTextComponent tc = Lo . qi ( XTextComponent . class , ctrl ); tc . addTextListener ( new XTextListener () { public void textChanged ( TextEvent ev ) { XControlModel cModel = Forms . getEventControlModel ( ev ); System . out . println ( Forms . getName ( cModel ) + \" text: \" + Props . getProperty ( cModel , \"Text\" )); } // end of textChanged() public void disposing ( EventObject ev ) {} }); XWindow tfWindow = Lo . qi ( XWindow . class , ctrl ); tfWindow . addFocusListener ( new XFocusListener () { public void focusLost ( FocusEvent ev ) { XControlModel model = Forms . getEventControlModel ( ev ); System . out . println ( \"Leaving text: \" + Props . getProperty ( model , \"Text\" )); } public void disposing ( EventObject ev ) {} // unused public void focusGained ( FocusEvent ev ) {} }); } // end of attachTextFieldListeners() Obtaining the Model \u00b6 attachButtonListener() and attachTextFieldListeners() demonstrate two ways of obtaining the control's model when an event triggers a view listener. In attachButtonListener(), an XControl reference is available, which means that XControl.getModel() could be called: XControlModel cModel = ctrl . getModel (); In fact that coding isn't used, since the model reference is available already. attachTextFieldListeners() shows another approach, which is to examine the event object that arrives at the listener's method (e.g. the FocusEvent object received by focusLost()). Forms.getEventControlModel() is defined as: // in the Forms class public static XControlModel getEventControlModel ( EventObject ev ) { XControl xControl = Lo . qi ( XControl . class , ev . Source ); return xControl . getModel (); } // end of getEventControlModel() 5. Using ExamineForm.java \u00b6 ExamineForm.java can be called with any form-based ODT file. The simplest one in the examples is form1.odt, which consists of only a text field and a button, as shown in Figure 13. Figure 13. The form1.odt Form. When the user types \"abc\" and into the text field, followed by two clicks of the \"Enter\" button, the following is printed: Text Box 1 text: a Text Box 1 text: ab Text Box 1 text: abc Leaving text: abc Leaving text: abc Pressed \"Enter\" Pressed \"Enter\" The focus lost event is reported twice because of the key press and the movement of the mouse by the user from the text field to the button.","title":"Chapter 39. Forms API Overview"},{"location":"39-Forms_API_Overview.html#chapter-39-forms-api-overview","text":"Topics An Overview of the Forms API; Examining a Text-based Form; Attaching Listeners to a View Example folders: \"Forms Tests\" and \"Utils\" Forms are usually found in Writer documents, or as data entry interfaces for Base, although they can also be employed in Draw, Impress, and Calc. Although Base forms are typically employed as front-ends to databases, the same capability is available in Writer and the other Office applications. The LibreOffice \"Getting Started Guide\" (available at https://th.libreoffice.org/get-help/documentation/ ) describes the form features of Writer and Base in chapters 4 and 8. Longer examples can be found in the \"Writer Guide\" and \"Base Handbook\" documents. Chapter 15 of the \"Writer Guide\" explains how to create a form using the \"Form Controls \" and \"Form Design\" toolbars; it's essentially a matter of dragging check boxes, buttons, text fields, pull-down lists, and other controls, onto a form canvas. Properties associated with a control, such as its name, text label, and position, are set by right clicking to access a properties dialog window. An important use of Writer forms is to create editable PDF forms. This doesn't involve anything more than remembering to save the form-filled document as a PDF file when it's finished. There are several online tutorials that explain the details, such as \"Create PDF Forms with OpenOffice\" at https://foersom.com/org/HowTo/OoCreatePdfForm.html ; although it's written for OpenOffice, it can be applied to LibreOffice without change. Chapter 4 of the \"Base Handbook\" explains how to create a data input form for a library loans database, and much of the GUI interface of control toolbars, form canvas, and property dialogs is identical to that found in Writer. Even if you're only creating a text-based form, it's well worth reading the Base chapter because it goes into detail about the General, Data, and Events tab in the properties dialog. A somewhat simpler example, which is purely text-based without data sources, can be found at https://openoffice.blogs.com/forms_fromscratch.pdf . I used this article (which is titled \"Creating Forms from Scratch\") to create the scratchExample.odt file used here.","title":"Chapter 39. Forms API Overview"},{"location":"39-Forms_API_Overview.html#1-why-bother-programming-forms","text":"It's very easy to build a form using Office's \"Form Controls \" and \"Form Design\" toolbars. The GUI provides immediate feedback on how things will look by switching design mode on (where you're building the form) and off (to see how the form will look to a user). Nevertheless, manipulating a form from code can be useful. This chapter starts with an overview of the forms API, and then looks at how data input into an existing form can be processed using listeners. This isn't the standard way of adding behavior to forms; that capability is typically handled by macros coded in Office Basic (for example, see chapter 13 of \"Getting Started with LibreOffice\" and chapter 9 of the \"Base Handbook\"). I'll be looking at how to code form macros in Chapters 48 and 49. The next chapter, Chapter 40, will look at how a form can be constructed at run time by programmatically adding controls to a new text document. The form is linked to a local database, and table and list box controls access its tables in different ways. In addition, a variety of listeners are attached to the controls.","title":"1.  Why Bother Programming Forms?"},{"location":"39-Forms_API_Overview.html#2-an-overview-of-the-forms-api","text":"A key principle behind the forms API is the Model-View-Controller (MVC) pattern (e.g. see https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller/ ) which divides each form control in two: a model (or component) representing the control's data, and a view for its GUI. Figure 1 shows the forms MVC model in detail. Figure 1. The Form API's MVC Model. The third part of MVC, the controller, links the model and view inside an application. There might be multiple views attached to a model (i.e. different renderings of the same data), and the controller mediates between a view and the model when the user tries to change its state (for instance by typing data into a text field). The thick-edged boxes next to the Model, View and Controller rounded rectangles in Figure 1 represent the main Office services and interfaces that implement the model, view and controller.","title":"2.  An Overview of the Forms API"},{"location":"39-Forms_API_Overview.html#21-control-confusion","text":"The two uses of the word \"control\" in the API can be confusing. When the documentation refers to a control by name, such as a \"button control\" or \"text field control\", then it typically means the data and rendering parts taken as a whole. For example, \"button control\" includes the button's on-screen appearance and its state. However, when the API only talks about a \"control\" then this usually means the services and interfaces related to its appearance. If the API refers to a control's \"model\" then it means its state. Another problem with understanding the forms API is that its functionality is spread across several modules and submodules. The form module contains many services, interfaces, and seven submodules, which are listed in Table 1. Form Submodule Purpose binding collects functionality for binding form controls to external data sources component collects form control model descriptions control collects form control descriptions inspection collects services for inspecting form/components runtime collects functionality needed during a form's runtime submission collects functionality for submitting forms to external data sinks validation collects functionality to validate form components by help of external validator instances Table 1. Submodules of the Form Module. To simplify matters, I'm only going to describe two of the submodules: form.component which holds the model-related services, and form.control for the view-related services. But there's more modules to browse! Figure 2 shows the main services and interfaces used to define a button. Figure 2. Form Services and Interfaces for a Button. Four modules are mentioned in Figure 2, written in brackets inside the service rectangles. There's a CommandButton service in form.component and a second CommandButton in form.control. An examination of these services (and most other services in form.component and form.control) reveal them to be basically empty. The real 'action' is elsewhere, up in the form module's FormControlModel service, and over in Office's very large awt module, which implements its version of Java's AWT. The names of the services start to become a little unclear at this point since the words \"Control\" and \"Model\" often appear together (e.g. in FormControlModel, UnoControlButtonModel, and UnoControlModel). My advice is to remember that \"Model beats Control\" \uf04a. If a class name includes the word \"Model\", then it's probably for the model/data part of the control. If the name contains only \"Control\" then it's most likely for the rendering/appearance or listener part of the control. For example, UnoControlButtonModel is where the button's data is defined, as a lengthy collection of properties. You can quickly view its documentation with lodoc UnoControlButtonModel . UnoControlButton is for the button's GUI (see lodoc UnoControlButton ). Most of the functionality for a button is accessed through its XButton interface, which allows a listener to be attached to the button. Every model (e.g. CommandButton in form.component) inherits the FormControlModel service in the form module. This links the control into the surrounding form.","title":"2.1.  Control Confusion"},{"location":"39-Forms_API_Overview.html#22-more-information-on-the-api","text":"The principal documentation on the forms API is chapter 13 of the Developer's Guide available as https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf . Alternatively, you can read the chapter online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Forms/Forms/ (or use loGuide Forms ). The guide's form examples are at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Forms .","title":"2.2.  More Information on the API"},{"location":"39-Forms_API_Overview.html#3-examining-a-text-based-form","text":"ExamineForm.java opens a text document containing a form, and attaches button and text field listeners to every button and text field control. Figure 3 shows most of the important data structures used by a form. Figure 3. The Form Data Structures. A form is stored in a draw page associated with the document. A draw page can manage multiple forms, which can be accessed by index or by name (the default form is called \"Form\"). In some types of Office documents, it's possible to have multiple draw pages. A form contains controls, such as buttons, text fields, and tables, and also nested forms. Collectively, controls and nested forms are known as form components, and are organized into a tree hierarchy in the draw page. At the lowest level, each basic form control is represented by a control shape, a specialized kind of DrawPage shape. A data source, such as a database, may be attached to a form, which its controls can access using SQL queries. Figure 4 gives a high-level view of how ExamineForm.java \"digs down\" into a document to access each control's model and view. Figure 4. From Document to Control Model and View. The words connected by the arrows correspond (in most cases) to services in the forms API; the names in blue are the interfaces associated with those services. The \"Fig. X\" rounded rectangles refer to figures later in this chapter which give more detail about how the API links from one service to the next. Figure 4 starts with the document, and ends with references to a control's model and view services. For example, the services for a button are the CommandButton classes in the form.component and form.control modules. Figure 4 has a branch point at the DrawPage service (it's labeled with the word \"or\") since there are two ways of using the API to get from a draw page to control models. The branch on the left examines the control shapes in the DrawPage, while the branch on the right examines the form components. I've decided not to explain the the left branch, although it's documented in my Forms.java utility class. The left branch corresponds to code in the Forms.getModels2() method. Most of Figure 4 is implemented as static methods in the Forms class, which means that ExamineForm.java is fairly short: // in ExamineForm.java public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run ExamineForm <ODT file>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } ArrayList < XControlModel > models = Forms . getModels ( doc ); System . out . println ( \"No. of control models in form: \" + models . size ()); // examine each model for ( XControlModel model : models ) { System . out . println ( \" \" + Forms . getName ( model ) + \": \" + Forms . getTypeStr ( model )); // look at the control for each model XControl ctrl = Forms . getControl ( doc , model ); if ( ctrl == null ) System . out . println ( \" No control found\" ); else { // attach listener if the control is // a button or text field if ( Forms . isButton ( model )) attachButtonListener ( ctrl , model ); else if ( Forms . isTextField ( model )) attachTextFieldListeners ( ctrl ); } } System . out . println (); GUI . setVisible ( doc , true ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() Forms.getModels() and Forms.getControl() will be used in most forms-based programs. Forms.getModels() returns a list of all the control models in the document. In terms of Figure 4, it moves from the Document service at the top of the figure to ControlModel near the bottom. Forms.getControl() completes the descent by retrieving the control (view) associated with a given model. If a control is a button or text field than attachButtonListener() or attachTextFieldListeners() are called. These methods are implemented in ExamineForm.java, but I'll delay explaining them until I've covered Forms.getModels() and Forms.getControl().","title":"3.  Examining a Text-based Form"},{"location":"39-Forms_API_Overview.html#31-from-document-to-drawpages","text":"Every Office document supports the OfficeDocument service, and the XModel and XComponent interfaces. Using XComponent as a starting interface, it's possible to change the type to XDrawPagesSupplier (or XDrawPageSupplier), which gives access to the DrawPages (or single DrawPage) inside the document. The cast works because all Office documents support the GenericDrawingDocument service, as illustrated in Figure 5. Figure 5. Part of the GenericDrawingDocument Service Hierarchy The code that implements the cast: // in the Forms class public static XNameContainer getForms ( XComponent doc ) { XDrawPage drawPage = getDrawPage ( doc ); if ( drawPage != null ) return getForms ( drawPage ); else return null ; } // end of getForms() public static XDrawPage getDrawPage ( XComponent doc ) // return the first draw page even if there are many { XDrawPageSupplier xSuppPage = Lo . qi ( XDrawPageSupplier . class , doc ); if ( xSuppPage != null ) // this works if doc supports a single DrawPage return xSuppPage . getDrawPage (); else { // this means that the doc supports multiple DrawPages XDrawPagesSupplier xSuppPages = Lo . qi ( XDrawPagesSupplier . class , doc ); XDrawPages xPages = xSuppPages . getDrawPages (); try { System . out . println ( \"Returning first draw page\" ); return Lo . qi ( XDrawPage . class , xPages . getByIndex ( 0 )); } catch ( Exception e ) { System . out . println ( e ); return null ; } } } // end of getDrawPage() Forms.getDrawPage() only returns the first draw page in a document, even if many pages are available.","title":"3.1.  From Document to DrawPages"},{"location":"39-Forms_API_Overview.html#32-from-drawpage-to-form","text":"The XDrawPage interface can be cast to XFormsSupplier which makes the page's forms accessible. This cast works because of the service hierarchy shown in Figure 6 which links the DrawPage service to GenericDrawPage. Figure 6. Part of the DrawPage Service Hierarchy. XFormsSupplier can supply forms as an indexed sequence (an XIndexContainer) or as an associative array using the form names as keys, returned by Forms.getForms(): // in the Forms class public static XNameContainer getForms ( XDrawPage drawPage ) // get all the forms in the page as a named container { XFormsSupplier formsSupp = Lo . qi ( XFormsSupplier . class , drawPage ); return formsSupp . getForms (); } // end of getForms() The default form in a draw page is called \"Form\" , and can be extracted by calling Forms . getForm ( doc , \"Form\" ): // in the Forms class public static XForm getForm ( XComponent doc , String formName ) // get the form called formName { XNameContainer namedForms = getForms ( doc ); // see above XNameContainer con = getFormByName ( formName , namedForms ); return Lo . qi ( XForm . class , con ); } public static XNameContainer getFormByName ( String formName , XNameContainer namedForms ) // get the form called formName { try { return Lo . qi ( XNameContainer . class , namedForms . getByName ( formName )); } catch ( Exception e ) { System . out . println ( \"Could not find form \" + formName + \": \" + e ); return null ; } } // end of getFormByName()","title":"3.2.  From DrawPage to Form"},{"location":"39-Forms_API_Overview.html#33-from-form-to-formcomponents","text":"A form is a FormComponents instance, which holds FormComponent instances (i.e. basic controls) and nested FormComponents (i.e. nested forms). Figure 7 shows a simplified service hierarchy for Form, FormComponents, and FormComponent. Figure 7. Part of the Form Service Hierarchy. Forms.getModels() collects all the FormComponent instances as a list by recursively searching from the top level form (or forms) through all the nested forms : // in the Forms class public static ArrayList < XControlModel > getModels ( XComponent doc ) { XNameContainer formNamesCon = getForms ( doc ); // see above return getModels ( formNamesCon ); } public static ArrayList < XControlModel > getModels ( XNameAccess formNamesCon ) { ArrayList < XControlModel > models = new ArrayList < XControlModel > (); String nms [] = formNamesCon . getElementNames (); for ( int i = 0 ; i < nms . length ; i ++ ) { try { XServiceInfo servInfo = Lo . qi ( XServiceInfo . class , formNamesCon . getByName ( nms [ i ] )); if ( servInfo . supportsService ( \"com.sun.star.form.FormComponents\" )) { // this means that a nested form has been found XNameAccess childCon = Lo . qi ( XNameAccess . class , servInfo ); models . addAll ( getModels ( childCon ) ); //recursively search it } else if ( servInfo . supportsService ( \"com.sun.star.form.FormComponent\" )) { XControlModel model = Lo . qi ( XControlModel . class , servInfo ); models . add ( model ); } } catch ( Exception e ) { System . out . println ( \"Could not access \" + nms [ i ] ); } } return models ; } // end of getModels() The first Forms.getModels() method extracts the top-level form (or forms) from the document as a named container, then passes it to the recursive getModels() which iterates through the container. If an element is a FormComponents instance then it's a nested form, and getModels() is called recursively to collect its controls. If the element is of type FormComponent then it's an ordinary control.","title":"3.3.  From Form to FormComponents"},{"location":"39-Forms_API_Overview.html#34-from-formcomponent-to-control-model","text":"A FormComponent instance can be cast to XControlModel: XControlModel model = Lo . qi ( XControlModel . class , servInfo ); XControlModel first appeared at the top of Figure 2 on the left \u2013 it\u2019s the interface inherited by all models. The casting is possible because every control model service (e.g. CommandButton in the form.component module) inherits both FormComponent and UnoControlModel, as depicted by Figure 8. Figure 8. Part of the Service Hierarchy for the CommandButton Model. Every model has a hierarchy similar to CommandButton's in Figure 8. For example, the text field control model hierarchy appears in Figure 9. Figure 9. Part of the Service Hierarchy for the TextField Model. Figures 8 and 9 depict two important coding features. One is that it's possible to cast between a form component and a control model, as demonstrated by Forms.getModel() shown above. The other is that a model's data is stored in its properties, and most of those are NOT in the model's service (i.e. not in CommandButton and TextField). Most model properties are in superclasses (i.e. UnoControlButtonModel in Figure 8 and UnoControlEditModel in Figure 9), which are located in the awt module.","title":"3.4.  From FormComponent to Control Model"},{"location":"39-Forms_API_Overview.html#35-using-a-control-model","text":"Returning to ExamineForm.java, the relevant bit of code is: // part of ExamineForm.java... ArrayList < XControlModel > models = Forms . getModels ( doc ); // see above System . out . println ( \"No. of control models in form: \" + models . size ()); // examine each model for ( XControlModel model : models ) { System . out . println ( \" \" + Forms . getName ( model ) + \": \" + Forms . getTypeStr ( model )); : } An XControlModel reference can be utilized in various ways, but two of the main ones are examining its subclass service type and accessing its properties. As Figures 8 and 9 indicate, most of a control's properties are in the UnoControlXXXModel service, but may come from other services which can be hard to locate. For example, \"Name\" is from UnoControlDialogElement, a superclass of UnoControlModel (which I didn't include in Figures 8 and 9). \"ClassId\" comes from FormControlModel, which is on the \"forms branch\" of the service hierarchies in the figures. The easiest thing is to print all the model's properties, by calling Props.showObjProps(): Props . showObjProps ( \"Model\" , model ); Info.showInterfaces() and Info.showServices() are similarly useful, listing all the interfaces and services for a model: Info . showInterfaces ( \"Model\" , model ); Info . showServices ( \"Model\" , model ); The Forms.getName() and Forms.getTypeStr() methods called in the code fragment above are defined as: // in the Forms class public static String getName ( XControlModel cModel ) // returns the name of the given form component { return ( String ) Props . getProperty ( cModel , \"Name\" ); } public static String getTypeStr ( XControlModel cModel ) { int id = getID ( cModel ); if ( id == - 1 ) return null ; XServiceInfo servInfo = Lo . qi ( XServiceInfo . class , cModel ); switch ( id ) { case FormComponentType . COMMANDBUTTON : return \"Command button\" ; case FormComponentType . RADIOBUTTON : return \"Radio button\" ; case FormComponentType . IMAGEBUTTON : return \"Image button\" ; case FormComponentType . CHECKBOX : return \"Check Box\" ; case FormComponentType . LISTBOX : return \"List Box\" ; case FormComponentType . COMBOBOX : return \"Combo Box\" ; case FormComponentType . GROUPBOX : return \"Group Box\" ; case FormComponentType . FIXEDTEXT : return \"Fixed Text\" ; case FormComponentType . GRIDCONTROL : return \"Grid Control\" ; case FormComponentType . FILECONTROL : return \"File Control\" ; case FormComponentType . HIDDENCONTROL : return \"Hidden Control\" ; case FormComponentType . IMAGECONTROL : return \"Image Control\" ; case FormComponentType . DATEFIELD : return \"Date Field\" ; case FormComponentType . TIMEFIELD : return \"Time Field\" ; case FormComponentType . NUMERICFIELD : return \"Numeric Field\" ; case FormComponentType . CURRENCYFIELD : return \"Currency Field\" ; case FormComponentType . PATTERNFIELD : return \"Pattern Field\" ; case FormComponentType . TEXTFIELD : // two services with this class id: // text field and formatted field if (( servInfo != null ) && servInfo . supportsService ( \"com.sun.star.form.component.FormattedField\" )) return \"Formatted Field\" ; else return \"Text Field\" ; default : System . out . println ( \"Unknown class ID: \" + id ); return null ; } } // end of getTypeStr() public static int getID ( XControlModel cModel ) { // get the ClassId property Short classId = ( Short ) Props . getProperty ( cModel , \"ClassId\" ); if ( classId == null ) { System . out . println ( \"No class ID found for form component\" ); return - 1 ; } return classId . intValue (); } // end of getID() Forms.getID returns the \"ClassId\" integer, which is checked by getTypeStr() against values in the FormComponentType enumeration, and mapped to more informative strings. Forms.getID() is utilized in a similar manner in a series of boolean isXXX() methods, such as isButton() and isTextField(): // in the Forms class public static boolean isButton ( XControlModel cModel ) { int id = getID ( cModel ); if ( id == - 1 ) return false ; else return (( id == FormComponentType . COMMANDBUTTON ) || ( id == FormComponentType . IMAGEBUTTON )); } // end of isButton() public static boolean isTextField ( XControlModel cModel ) { int id = getID ( cModel ); if ( id == - 1 ) return false ; else return (( id == FormComponentType . DATEFIELD ) || ( id == FormComponentType . TIMEFIELD ) || ( id == FormComponentType . NUMERICFIELD ) || ( id == FormComponentType . CURRENCYFIELD ) || ( id == FormComponentType . PATTERNFIELD ) || ( id == FormComponentType . TEXTFIELD )); } // end of isTextField()","title":"3.5.  Using a Control Model"},{"location":"39-Forms_API_Overview.html#36-from-control-model-to-view","text":"Having obtained a form's model, it's view becomes accessible, but following the MVC pattern, this requires the use of Office's controller (see Figure 1). One way to reach the controller is through a document reference (XComponent) and XModel.getCurrentController(). The resulting XController interface can be cast to XControlAccess, due to the service hierarchy shown in Figure 10. Figure 10. Part of the DrawingDocumentDrawView Service Hierarchy. These steps are implemented by GUI.getControlAccess(): // in the GUI class public static XControlAccess getControlAccess ( XComponent doc ) { return Lo . qi ( XControlAccess . class , getCurrentController ( doc )); } public static XController getCurrentController ( XComponent doc ) { XModel model = Lo . qi ( XModel . class , doc ); if ( model == null ) { System . out . println ( \"Document has no data model\" ); return null ; } return model . getCurrentController (); } Forms . getControl () employs XControlAccess . getControl () to return the model ' s view when supplied with a model : // in the Forms class public static XControl getControl ( XComponent doc , XControlModel cModel ) { XControlAccess controlAccess = GUI . getControlAccess ( doc ); // see above if ( controlAccess == null ) { System . out . println ( \"Could not obtain controls access\" ); return null ; } try { return controlAccess . getControl ( cModel ); } catch ( Exception e ) { System . out . println ( \"Could not access control: \" + e ); return null ; } } // end of getControl()","title":"3.6.  From Control Model to View"},{"location":"39-Forms_API_Overview.html#4-attaching-listeners-to-a-view","text":"XControl is an interface of the UnoControl service, which represents an abstract control. This class must be cast to a service for a real control, such as UnoControlButton or UnoControlEdit in order to call listener methods in XButton or XTextComponent. This hierarchy is illustrated by Figure 11. Figure 11. Part of the Service Hierarchy Below UnoControl. Back in ExamineForm.java, every button or text field has listeners attached to it: // part of ExamineForms.java... : // look at the control for each model XControl ctrl = Forms . getControl ( doc , model ); if ( ctrl == null ) System . out . println ( \" No control found\" ); else { // attach listener if the control is a button or text field if ( Forms . isButton ( model )) attachButtonListener ( ctrl , model ); else if ( Forms . isTextField ( model )) attachTextFieldListeners ( ctrl ); } : attachButtonListener() and attachTextFieldListener() implement the casting shown in Figure 11, starting with an XControl interface. For instance, attachButtonListener() connects an anonymous XActionListener object to a button, and sets its action command to be the button's label: // in ExamineForms.java private static void attachButtonListener ( XControl ctrl , XControlModel cModel ) { XButton xButton = Lo . qi ( XButton . class , ctrl ); // XControlModel cModel = ctrl.getModel(); xButton . setActionCommand ( Forms . getLabel ( cModel )); xButton . addActionListener ( new XActionListener () { public void disposing ( com . sun . star . lang . EventObject ev ) {} public void actionPerformed ( ActionEvent ev ) { System . out . println ( \"Pressed \\\"\" + ev . ActionCommand + \"\\\"\" ); } }); } // end of attachButtonListener() Although XActionListener and Java's ActionListener are similar, they're not the same. For one thing, its necessary to define two methods in XActionListener, actionPerformed() and disposing(). Office supports over 120 kinds of listeners! The best place to browse through them is on the documentation webpage for their common superclass, XEventListener. lodoc XEventListener should take you to XEventListener in the document module, but you want its superclass, XEventListener in the lang module. The first part of its long webpage is shown in Figure 12. Figure 12. The First Part of the XEventListener Documentation Page in the lang Module. Although the clickable images on the LibreOffice webpages make moving around the service and interface hierarchies very easy, they're not searchable. When the hierarchy is very large (as for XEventListener), and not sorted in alphabetical order, it can be time-consuming to find a particular subclass. I solved the problem by creating a text file, called XEventListenerSubclasses.txt, which lists the subclasses of XEventListener in order, and is searchable of course. You can find it in the Forms Tests/ folder for this chapter. Alternatively, almost all the listeners for controls are defined in the awt module, so you can search that module's documentation page (accessible using lodoc awt module ). attachTextFieldListeners() attaches two listeners to a text field control because XTextListener isn't triggered when the user types . My solution is to connect an XFocusListener which treats as a \"lost focus\" event when the cursor leaves the text field. The code for attachTextFieldListeners(): // in ExamineForms.java private static void attachTextFieldListeners ( XControl ctrl ) // listen for text changes and focus changes in the control { XTextComponent tc = Lo . qi ( XTextComponent . class , ctrl ); tc . addTextListener ( new XTextListener () { public void textChanged ( TextEvent ev ) { XControlModel cModel = Forms . getEventControlModel ( ev ); System . out . println ( Forms . getName ( cModel ) + \" text: \" + Props . getProperty ( cModel , \"Text\" )); } // end of textChanged() public void disposing ( EventObject ev ) {} }); XWindow tfWindow = Lo . qi ( XWindow . class , ctrl ); tfWindow . addFocusListener ( new XFocusListener () { public void focusLost ( FocusEvent ev ) { XControlModel model = Forms . getEventControlModel ( ev ); System . out . println ( \"Leaving text: \" + Props . getProperty ( model , \"Text\" )); } public void disposing ( EventObject ev ) {} // unused public void focusGained ( FocusEvent ev ) {} }); } // end of attachTextFieldListeners()","title":"4.  Attaching Listeners to a View"},{"location":"39-Forms_API_Overview.html#obtaining-the-model","text":"attachButtonListener() and attachTextFieldListeners() demonstrate two ways of obtaining the control's model when an event triggers a view listener. In attachButtonListener(), an XControl reference is available, which means that XControl.getModel() could be called: XControlModel cModel = ctrl . getModel (); In fact that coding isn't used, since the model reference is available already. attachTextFieldListeners() shows another approach, which is to examine the event object that arrives at the listener's method (e.g. the FocusEvent object received by focusLost()). Forms.getEventControlModel() is defined as: // in the Forms class public static XControlModel getEventControlModel ( EventObject ev ) { XControl xControl = Lo . qi ( XControl . class , ev . Source ); return xControl . getModel (); } // end of getEventControlModel()","title":"Obtaining the Model"},{"location":"39-Forms_API_Overview.html#5-using-examineformjava","text":"ExamineForm.java can be called with any form-based ODT file. The simplest one in the examples is form1.odt, which consists of only a text field and a button, as shown in Figure 13. Figure 13. The form1.odt Form. When the user types \"abc\" and into the text field, followed by two clicks of the \"Enter\" button, the following is printed: Text Box 1 text: a Text Box 1 text: ab Text Box 1 text: abc Leaving text: abc Leaving text: abc Pressed \"Enter\" Pressed \"Enter\" The focus lost event is reported twice because of the key press and the movement of the mouse by the user from the text field to the button.","title":"5.  Using ExamineForm.java"},{"location":"40-Building_a_Form.html","text":"Chapter 40. Building a Form Programmatically \u00b6 Topics Creating Controls; Assigning a Data Source to a Form; Creating Data-aware Controls; Attaching Listeners Example folders: \"Forms Tests\" and \"Utils\" BuildForm.java creates a text-based form at run-time, and attaches listeners to the controls. Three of the controls (two list boxes and a grid control) are \"data aware\" which means that they obtain their data externally from a database. Figure 1 shows a screenshot of the generated document, with the controls and data sources labeled. Figure 1. The BuildForm.java Generated Document. The document contains two forms: the default \"Form\", and \"GridForm\" holding a single GridControl. \"GridForm\" employs the same database as \"Form\", but interacts with it in a different way. Table 1 summarizes which listeners are used with which controls. These are Office listeners (i.e. subclasses of XEventListener) not Java classes. Form Control Listeners CommandButton XActionListener, XMouseListener Textfield XTextListener, XFocusListener RadioButton, CheckBox XPropertyChangeListener ListBox XItemListener GridControl XSelectionChangeListener, XGridColumnListener Table 1. Controls and Associated Listeners Used by BuildForm.java. The finished form is saved in \"build.odt\", which retains the data links (since they're stored as properties of the form controls), but the listeners are discarded. The main() function of BuildForm.java creates a text document, and adds form controls by calling createForm(): // globals private static final String DB_FNM = \"liang.odb\" ; // database private XTextDocument doc ; // for use by the listeners // in BuildForm.java public BuildForm () { XComponentLoader loader = Lo . loadOffice (); doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); System . exit ( 1 ); } doc . addEventListener ( this ); // for showing disposing of document (and controls) GUI . setVisible ( doc , true ); XTextViewCursor tvc = Write . getViewCursor ( doc ); Write . append ( tvc , \"Building a Form\\n\" ); Write . endParagraph ( tvc ); createForm ( doc ); Lo . dispatchCmd ( \"SwitchControlDesignMode\" ); // switch from form design/editing mode to live mode Lo . waitEnter (); Lo . saveDoc ( doc , \"build.odt\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of BuildForm() 1. Creating Controls \u00b6 createForm() makes many calls to Forms.addControl(), and other Forms.addXXX() methods which indirectly use Forms.addControl(). For example, the call that creates the \"No automatic generation\" radio button at the top of the form is: // part of createForm() in BuildForm.java... XPropertySet props = Forms . addControl ( doc , \"Option\" , \"No automatic generation\" , \"RadioButton\" , 106 , 11 , 50 , 6 ); It returns the model's properties since additional values often need to be set after the control has been created. Forms.addControl() starts by creating the control's view, utilizing a subclass of the Shape service, called ControlShape. The relevant part of the service hierarchy is shown in Figure 2. Figure 2. The Shape and ControlShape Services. Properties in the Shape service define the position, width, and height of the control inside the form. In the call to Forms.addControl() above, the first pair of numbers, (106,11), is the intended position, while its width and height are 50 x 6. After the view has been initialized, the control's model is created by using the string passed in the method call (e.g. \"RadioButton\" in this example). The model and shape are linked together using XControlShape.setControl(). Forms.addControl() is: // in the Forms class public static XPropertySet addControl ( XComponent doc , String name , String label , String compKind , int x , int y , int width , int height ) // use the default form, \"Form\", for the control { return addControl ( doc , name , label , compKind , x , y , width , height , null ); } public static XPropertySet addControl ( XComponent doc , String name , String label , String compKind , int x , int y , int width , int height , XNameContainer parentForm ) { XPropertySet modelProps = null ; try { // create a shape to represent the control's view XControlShape cShape = Lo . createInstanceMSF ( XControlShape . class , \"com.sun.star.drawing.ControlShape\" ); // position and size of the shape cShape . setSize ( new Size ( width * 100 , height * 100 )); cShape . setPosition ( new Point ( x * 100 , y * 100 )); // adjust the anchor so that the control is tied to the page XPropertySet shapeProps = Lo . qi ( XPropertySet . class , cShape ); TextContentAnchorType eAnchorType = TextContentAnchorType . AT_PARAGRAPH ; shapeProps . setPropertyValue ( \"AnchorType\" , eAnchorType ); // create the control's model XControlModel cModel = Lo . createInstanceMSF ( XControlModel . class , \"com.sun.star.form.component.\" + compKind ); // insert the model into the form (or default to \"Form\") if ( parentForm != null ) parentForm . insertByName ( name , cModel ); // link model to the shape cShape . setControl ( cModel ); // add shape to shapes collection of the doc's draw page XDrawPage drawPage = getDrawPage ( doc ); XShapes formShape s = Lo . qi ( XShapes . class , drawPage ); formShapes . add ( cShape ); // set Name and Label properties for the model modelProps = Lo . qi ( XPropertySet . class , cModel ); modelProps . setPropertyValue ( \"Name\" , name ); if ( label != null ) modelProps . setPropertyValue ( \"Label\" , label ); } catch ( Exception e ) { System . out . println ( e ); } return modelProps ; } // end of addControl() The control is added to the form in two ways: firstly the control model is placed in the parent form with: parentForm . insertByName ( name , cModel ); then the control shape is inserted into the form's draw page: XDrawPage drawPage = getDrawPage ( doc ); XShapes formShape s = Lo . qi ( XShapes . class , drawPage ); formShapes . add ( cShape ); The Forms class contains several methods that call addControl() with fixed arguments, and set various model properties. For example, Forms.addButton() makes a CommandButton: // in the Forms class public static XPropertySet addButton ( XComponent doc , String name , String label , int x , int y , int width , int height ) { XPropertySet buttonProps = null ; try { buttonProps = addControl ( doc , name , label , \"CommandButton\" , x , y , width , height ); buttonProps . setPropertyValue ( \"HelpText\" , name ); // don't want button to be accessible by the \"tab\" key buttonProps . setPropertyValue ( \"Tabstop\" , false ); // the button should not steal focus when clicked buttonProps . setPropertyValue ( \"FocusOnClick\" , false ); } catch ( Exception e ) { System . out . println ( e ); } return buttonProps ; } // end of addButton() The \"CommandButton\" string passed to addControl() means that the model will be an instance of \"com.sun.star.form.component.CommandButton\". Another variant of addControl() is Forms.addLabelledControl() which calls addControl() twice to attach a text label to the control. For instance, the \"FIRSTNAME\" text field is created with: // part of createForm() in BuildForm.java... XPropertySet props = Forms . addLabelledControl ( doc , \"FIRSTNAME\" , \"TextField\" , 11 ); The Forms . addLabelledControl () code : // in the Forms class public static XPropertySet addLabelledControl ( XComponent doc , String label , String compKind , int y ) { return addLabelledControl ( doc , label , compKind , 2 , y , 6 ); } public static XPropertySet addLabelledControl ( XComponent doc , String label , String compKind , int x , int y , int height ) { XPropertySet ctrlProps = null ; try { // create label (fixed text) control String name = label + \"_Label\" ; XPropertySet labelProps = addControl ( doc , name , label , \"FixedText\" , x , y , 25 , 6 ); // create data field control ctrlProps = addControl ( doc , label , null , compKind , x + 26 , y , 40 , height ); // to the right ctrlProps . setPropertyValue ( \"DataField\" , label ); // add label props to the control ctrlProps . setPropertyValue ( \"LabelControl\" , labelProps ); } catch ( Exception e ) { System . out . println ( e ); } return ctrlProps ; } // end of addLabelledControl() The label is of type com.sun.star.form.component.FixedText, and linked to the text field by setting its \"DataField\" and \"LabelControl\" properties. 2. Assigning a Data Source to a Form \u00b6 The \"Form\" and \"GridForm\" forms are both 'data aware', which means they're connected to external databases. Data awareness is supported by the DataForm subclass of the Form service, which is also connected to the RowSet and ResultSet services of Base, as in Figure 3. Figure 3. Part of the DataForm Service Hierarchy. RowSet in the sdbc module supports the \"DataSourceName\", \"Command\", and \"CommandType\" properties (amongst others). \"DataSourceName\" is set to the database's URL, and \"Command\", and \"CommandType\" specify how the database will be queried by the form's controls. The \"Form\" form is attached to the \"liang.odb\" database by: // part of createForm() in BuildForm.java... XForm defForm = Forms . getForm ( doc , \"Form\" ); Forms . bindFormToTable ( defForm , FileIO . fnmToURL ( \"liang.odb\" ), \"Course\" ); The code for Forms.bindFormToTable(): // in the Forms class public static void bindFormToTable ( XForm xForm , String sourceName , String tableName ) { Props . setProperty ( xForm , \"DataSourceName\" , sourceName ); Props . setProperty ( xForm , \"Command\" , tableName ); // any table name Props . setProperty ( xForm , \"CommandType\" , CommandType . TABLE ); } // end of bindFormToTable() CommandType.TABLE permits SQL SELECT queries to be sent to the data source by the controls. The \"Command\" setting can be the name of any table in the database since the form's two list boxes (see Figure 1) send their own SELECT queries (see below). \"GridForm\" is set up by a call to Forms.bindFormToSQL() which sends a SQL query to the database to obtain a result set for filling the GridControl table. The code fragment in BuildForm.java is: // part of createForm() in BuildForm.java... XNameContainer gridCon = Forms . insertForm ( \"GridForm\" , doc ); XForm gridForm = Lo . qi ( XForm . class , gridCon ); Forms . bindFormToSQL ( gridForm , FileIO . fnmToURL ( DB_FNM ), \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); The code for Forms.bindFormToSQL(): // in the Forms class public static void bindFormToSQL ( XForm xForm , String sourceName , String cmd ) { Props . setProperty ( xForm , \"DataSourceName\" , sourceName ); Props . setProperty ( xForm , \"Command\" , cmd ); // SQL statement Props . setProperty ( xForm , \"CommandType\" , CommandType . COMMAND ); } // end of bindFormToSQL() It's not clear to me why the command type must be CommandType.COMMAND in Forms.bindFormToSQL() since the SELECT query should be processable by CommandType.TABLE, but using that type cause a run-time error. 3. Creating Data-aware Controls \u00b6 Some control models have subclasses that support data-awareness, which means they can access the form's data source using SELECT queries. The different types are shown in Table 2. Control Models Type of Access GridControl Fill a table (grid) with data DatabaseListBox, Fill a list with data DatabaseComboBox DatabaseTextField, Fill a text field DatabaseDateField, DatabaseTimeField, DatabaseNumericField, DatabasePatternField, DatabaseFormattedField, DatabaseCurrencyField DatabaseRadioButton, Specify whether a box is selected DatabaseCheckBox or not. DatabaseImageControl Read an image Table 2. Data-aware Control Models. The service hierarchy for these control models is similar to the hierarchy for DatabaseListBox shown in Figure 4 (except for GridControl which I'll get to shortly). Figure 4. Part of the Service Hierarchy for DatabaseListBox. Figure 4 should be compared with the service hierarchy for an non-data-aware model, such as CommandButton in Figure 8 of Chapter 39. The model is initialized by setting properties using the database associated with the parent form. Exactly which properties should be set depends on the model, but DatabaseListBox and DatabaseComboBox are fairly straightforward. \"ListSourceType\" is set to ListSourceType.SQL, and \"ListSource\" assigned a string array containing a SQL command. The command should be a SELECT query which returns a single column result set. The two DatabaseListBoxs in BuildForm.java (see Figure 1) are initialized by calling Forms.addDatabaseList() like so: // part of createForm() in BuildForm.java... Forms . addDatabaseList ( doc , \"CourseNames\" , \"SELECT \\\"title\\\" FROM \\\"Course\\\"\" , 90 , 90 , 20 , 6 ); Forms . addDatabaseList ( doc , \"StudNames\" , \"SELECT \\\"lastName\\\" FROM \\\"Student\\\"\" , 140 , 90 , 20 , 6 ); Forms.addDatabaseList() is: // in the Forms class public static XPropertySet addDatabaseList ( XComponent doc , String name , String sqlCmd , int x , int y , int width , int height ) { XPropertySet listProps = null ; try { listProps = addControl ( doc , name , null , \"DatabaseListBox\" , x , y , width , height ); // listProps.setPropertyValue(\"DefaultSelection\", // new short[]{0}); // hangs listProps . setPropertyValue ( \"Dropdown\" , true ); listProps . setPropertyValue ( \"MultiSelection\" , false ); listProps . setPropertyValue ( \"BoundColumn\" , ( short ) 0 ); // data-aware properties listProps . setPropertyValue ( \"ListSourceType\" , ListSourceType . SQL ); listProps . setPropertyValue ( \"ListSource\" , new String [] { sqlCmd }); } catch ( Exception e ) { System . out . println ( e ); } return listProps ; } // end of addDatabaseList() The DatabaseListBox control is created by calling Forms.addControl(), and then the model's properties are configured. Setting the list's default selection to be its first value causes Office to hang, so I've commented out that line in addDatabaseList() above. This means that the list boxes appear to be empty until the user clicks on them. 4. Initializing the GridControl \u00b6 The GridControl is created by calling Forms.addControl() with \"GridControl\" as the model string. Also, since this is the only control not inside the \"Form\" default form, it's necessary to include a reference to the nameContainer for \"GridForm\": // part of createForm() in BuildForm.java... // add \"GridForm\" to document XNameContainer gridCon = Forms . insertForm ( \"GridForm\" , doc ); XForm gridForm = Lo . qi ( XForm . class , gridCon ); // \"GridForm\" uses an SQL query as its data source Forms . bindFormToSQL ( gridForm , FileIO . fnmToURL ( DB_FNM ), \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); // create grid control inside \"GridForm\" props = Forms . addControl ( doc , \"SalesTable\" , null , \"GridControl\" , 2 , 100 , 100 , 40 , gridCon ); \"GridForm\"s query generates a result set with two columns consisting of first and last names from the Student table. For this information to be displayed by the grid, two of the grid's columns must be attached to the two result set columns. This is done by calling Forms.createGridColumn() twice: // part of createForm() in BuildForm.java... // get grid control's model XControlModel gridModel = Lo . qi ( XControlModel . class , props ); // connect grid control's columns to result set Forms . createGridColumn ( gridModel , \"firstName\" , \"TextField\" , 25 ); Forms . createGridColumn ( gridModel , \"lastName\" , \"TextField\" , 25 ); The main service for a grid control model is GridControl in the form.components module. Part of its hierarchy is shown in Figure 5. Figure 5. Part of the GridControl Service Hierarchy. If Figure 5's hierarchy is compared to those for other models, such as CommandButton in Figure 8 of Chapter 39, there are some differences. GridControl inherits the UnoControlModel service, but not through UnoControlGridModel in the awt module. A search for such a service returns an entire awt.grid sub-module for grid services, interfaces, and classes, but these aren't utilized by the form's grid control. The consequence is that GridControl is initialized in a different way from other models, and listener code becomes a little harder to implement (as we'll see in section 6). Forms.createGridColumn() employs the XGridColumnFactory interface to link a grid column to a result set column: // in the Forms class public static void createGridColumn ( XControlModel gridModel , String dataField , String colKind , int width ) { try { // column container and factory XIndexContainer colContainer = Lo . qi ( XIndexContainer . class , gridModel ); XGridColumnFactory colFactory = Lo . qi ( XGridColumnFactory . class , gridModel ); // create the column XPropertySet colProps = colFactory . createColumn ( colKind ); colProps . setPropertyValue ( \"DataField\" , dataField ); // connect column to this result set column colProps . setPropertyValue ( \"Label\" , dataField ); colProps . setPropertyValue ( \"Name\" , dataField ); if ( width > 0 ) colProps . setPropertyValue ( \"Width\" , new Integer ( width * 10 )); // add properties column to container colContainer . insertByIndex ( colContainer . getCount (), colProps ); } catch ( Exception e ) { System . out . println ( e ); } } // end of createGridColumn() 5. Attaching Listeners \u00b6 Table 1 shows that nine Office listeners are used with the controls. To reduce coding, BuildForm implements their methods: // in BuildForm.java public class BuildForm implements XEventListener , XActionListener , XPropertyChangeListener , XTextListener , XFocusListener , XItemListener , XMouseListener , XSelectionChangeListener , XGridColumnListener { : // methods for creating the controls ... : // methods for attaching listeners to the controls ... // listener methods for ... // XEventListener public void disposing ( EventObject ev ) { String implName = Info . getImplementationName ( ev . Source ); System . out . println ( \"Disposing: \" + implName ); } // XActionListener public void actionPerformed ( ActionEvent ev ) // called when a button has been pressed { System . out . println ( \"Pressed \\\"\" + ev . ActionCommand + \"\\\"\" ); } : // many more listener methods } // end of BuildForm class The listener methods are fairly simple, except for the XSelectionChangeListener attached to the grid control. A button control is attached to a listener like so: // part of createForm() in BuildForm.java... XPropertySet props = Forms . addButton ( doc , \"first\" , \"<<\" , 2 , 63 , 8 ); listenToButton ( props ); The code in listenToButton() is depicted by Figure 6. All the other \"listener attacher\" functions in BuildForm.java work in a similar way. Figure 6. Attaching a Listener to a Button Control. The property set passed to listenToButton() is cast to XControlModel, and then converted into a view using Forms.getControl(). The control is cast to an interface (such as XButton or XTextComponent) which offers an addXXXListener() method. The listenToButton() method is: // in BuildForm.java public void listenToButton ( XPropertySet props ) { XControlModel cModel = Lo . qi ( XControlModel . class , props ); XControl control = Forms . getControl ( doc , cModel ); XButton xButton = Lo . qi ( XButton . class , control ); xButton . setActionCommand ( Forms . getName ( cModel )); xButton . addActionListener ( this ); // use BuildForms as the listener } // end of listenToButton() 6. Listening for Grid Control Selection Changes \u00b6 Grid selection changes occur when the user clicks on a cell in the table, as in Figure 7. Figure 7. Grid Control Selection Change. Figure 8 shows the grid model and control hierarchy. Figure 8. Attaching a Listener to a Grid Control. The grid model inherits UnoControlModel via FormControlModel. On the control side, GridControl in the form.control module inherits UnoControl directly. GridControl supports two listener interfaces \u2013 XSelectionSupplier and XGridControl. Their attachment is handled by listenToGrid(), which is called after the control has been initialized by createForm(): // in createForm() in BuildForm.java... props = Forms . addControl ( doc , \"SalesTable\" , null , \"GridControl\" , 2 , 100 , 100 , 40 , gridCon ); XControlModel gridModel = Lo . qi ( XControlModel . class , props ); Forms . createGridColumn ( gridModel , \"firstName\" , \"TextField\" , 25 ); Forms . createGridColumn ( gridModel , \"lastName\" , \"TextField\" , 25 ); listenToGrid ( gridModel ); listenToGrid() is defined as: // in BuildForm.java public void listenToGrid ( XControlModel gridModel ) { XControl control = Forms . getControl ( doc , gridModel ); XGridControl gc = Lo . qi ( XGridControl . class , control ); gc . addGridControlListener ( this ); XSelectionSupplier gridSelection = Lo . qi ( XSelectionSupplier . class , gc ); gridSelection . addSelectionChangeListener ( this ); } // end of listenToGrid() There's no point using XGridControlListener in this example because its columnChanged() method is only triggered when the data in a column changes, which never occurs. However, XSelectionChangeListener.selectionChanged() is sent an event whenever the user's selection changes, which is what we're interested in reporting. 7. Using the Result Set \u00b6 The XGridControl interface for GridControl doesn't offer all the methods I need for announcing selection changes. XGridControl inherits XGrid and XGridFieldDataSupplier. XGrid can retrieve the currently selected column, while XGridFieldDataSupplier provides access to the data, but neither of them offer a way to find the currently selected row. That requires the result set for the table, which can only be examined by starting from the form level. Getting to the result set requires a number of casts, the first being from the event object arriving at the listener to the model that sent it. Forms.getEventControlModel() does that job: // in the Forms class public static XControlModel getEventControlModel ( EventObject ev ) { XControl xControl = Lo . qi ( XControl . class , ev . Source ); return xControl . getModel (); } Another conversion step is from control model to the parent form, which is carried out by Forms.getFormName(): // in the Forms class public static String getFormName ( XControlModel cModel ) { XChild xChild = Lo . qi ( XChild . class , cModel ); XNamed xNamed = Lo . qi ( XNamed . class , xChild . getParent ()); return xNamed . getName (); } selectionChanged() utilizes getEventControlModel() and getFormName() to convert an event object to a form. Finally, XForm is cast to a result set using the hierarchy in Figure 3. // in BuildForm.java public void selectionChanged ( EventObject ev ) { XControlModel cModel = Forms . getEventControlModel ( ev ); XGridControl gc = Lo . qi ( XGridControl . class , ev . Source ); System . out . println ( \"Grid \" + Forms . getName ( cModel ) + \" column: \" + gc . getCurrentColumnPosition ()); String formName = Forms . getFormName ( cModel ); XForm gForm = Forms . getForm ( doc , formName ); XResultSet rs = Lo . qi ( XResultSet . class , gForm ); try { System . out . println ( \" row: \" + rs . getRow ()); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of selectionChanged() selectionChanged() jumps through these hoops in order to print the currently selected column and row in the table. The selected column is obtained by calling XGridControl.getCurrentColumnPosition(), and the current row comes from XResultSet.getRow(). 8. Some Bugs \u00b6 My first version of BuildForm.java had a few problems which caused it to hang. The most serious occurred when I tried to include an image button in the form. The relevant lines in createForm() in BuildForm.java were: // in createForm() in BuildForm.java... props = Forms . addControl ( doc , \"Smiley\" , null , \"ImageButton\" , 90 , 80 , 10 , 10 ); props . setPropertyValue ( \"ImageURL\" , FileIO . fnmToURL ( \"smiley.png\" )); The button would sometimes appear at the correct position, but cause Office to hang when pressed, and sometimes the button wouldn't appear at all. After failing to find an answer online, I commented out the above lines. If anyone knows of a solution please contact me. A more minor issue is the initial lack of text in the DatabaseListBoxs. In the original Forms.addDatabaseList(), the list text was set with: listProps . setPropertyValue ( \"DefaultSelection\" , new short [] { 0 }); This line caused Office to hang, and once again I 'solved' the problem by commenting out the code. The unfortunate side-effect is that now the list box's text is blank until the user clicks on the list.","title":"Chapter 40. Building a Form Programmatically"},{"location":"40-Building_a_Form.html#chapter-40-building-a-form-programmatically","text":"Topics Creating Controls; Assigning a Data Source to a Form; Creating Data-aware Controls; Attaching Listeners Example folders: \"Forms Tests\" and \"Utils\" BuildForm.java creates a text-based form at run-time, and attaches listeners to the controls. Three of the controls (two list boxes and a grid control) are \"data aware\" which means that they obtain their data externally from a database. Figure 1 shows a screenshot of the generated document, with the controls and data sources labeled. Figure 1. The BuildForm.java Generated Document. The document contains two forms: the default \"Form\", and \"GridForm\" holding a single GridControl. \"GridForm\" employs the same database as \"Form\", but interacts with it in a different way. Table 1 summarizes which listeners are used with which controls. These are Office listeners (i.e. subclasses of XEventListener) not Java classes. Form Control Listeners CommandButton XActionListener, XMouseListener Textfield XTextListener, XFocusListener RadioButton, CheckBox XPropertyChangeListener ListBox XItemListener GridControl XSelectionChangeListener, XGridColumnListener Table 1. Controls and Associated Listeners Used by BuildForm.java. The finished form is saved in \"build.odt\", which retains the data links (since they're stored as properties of the form controls), but the listeners are discarded. The main() function of BuildForm.java creates a text document, and adds form controls by calling createForm(): // globals private static final String DB_FNM = \"liang.odb\" ; // database private XTextDocument doc ; // for use by the listeners // in BuildForm.java public BuildForm () { XComponentLoader loader = Lo . loadOffice (); doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); System . exit ( 1 ); } doc . addEventListener ( this ); // for showing disposing of document (and controls) GUI . setVisible ( doc , true ); XTextViewCursor tvc = Write . getViewCursor ( doc ); Write . append ( tvc , \"Building a Form\\n\" ); Write . endParagraph ( tvc ); createForm ( doc ); Lo . dispatchCmd ( \"SwitchControlDesignMode\" ); // switch from form design/editing mode to live mode Lo . waitEnter (); Lo . saveDoc ( doc , \"build.odt\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of BuildForm()","title":"Chapter 40. Building a Form Programmatically"},{"location":"40-Building_a_Form.html#1-creating-controls","text":"createForm() makes many calls to Forms.addControl(), and other Forms.addXXX() methods which indirectly use Forms.addControl(). For example, the call that creates the \"No automatic generation\" radio button at the top of the form is: // part of createForm() in BuildForm.java... XPropertySet props = Forms . addControl ( doc , \"Option\" , \"No automatic generation\" , \"RadioButton\" , 106 , 11 , 50 , 6 ); It returns the model's properties since additional values often need to be set after the control has been created. Forms.addControl() starts by creating the control's view, utilizing a subclass of the Shape service, called ControlShape. The relevant part of the service hierarchy is shown in Figure 2. Figure 2. The Shape and ControlShape Services. Properties in the Shape service define the position, width, and height of the control inside the form. In the call to Forms.addControl() above, the first pair of numbers, (106,11), is the intended position, while its width and height are 50 x 6. After the view has been initialized, the control's model is created by using the string passed in the method call (e.g. \"RadioButton\" in this example). The model and shape are linked together using XControlShape.setControl(). Forms.addControl() is: // in the Forms class public static XPropertySet addControl ( XComponent doc , String name , String label , String compKind , int x , int y , int width , int height ) // use the default form, \"Form\", for the control { return addControl ( doc , name , label , compKind , x , y , width , height , null ); } public static XPropertySet addControl ( XComponent doc , String name , String label , String compKind , int x , int y , int width , int height , XNameContainer parentForm ) { XPropertySet modelProps = null ; try { // create a shape to represent the control's view XControlShape cShape = Lo . createInstanceMSF ( XControlShape . class , \"com.sun.star.drawing.ControlShape\" ); // position and size of the shape cShape . setSize ( new Size ( width * 100 , height * 100 )); cShape . setPosition ( new Point ( x * 100 , y * 100 )); // adjust the anchor so that the control is tied to the page XPropertySet shapeProps = Lo . qi ( XPropertySet . class , cShape ); TextContentAnchorType eAnchorType = TextContentAnchorType . AT_PARAGRAPH ; shapeProps . setPropertyValue ( \"AnchorType\" , eAnchorType ); // create the control's model XControlModel cModel = Lo . createInstanceMSF ( XControlModel . class , \"com.sun.star.form.component.\" + compKind ); // insert the model into the form (or default to \"Form\") if ( parentForm != null ) parentForm . insertByName ( name , cModel ); // link model to the shape cShape . setControl ( cModel ); // add shape to shapes collection of the doc's draw page XDrawPage drawPage = getDrawPage ( doc ); XShapes formShape s = Lo . qi ( XShapes . class , drawPage ); formShapes . add ( cShape ); // set Name and Label properties for the model modelProps = Lo . qi ( XPropertySet . class , cModel ); modelProps . setPropertyValue ( \"Name\" , name ); if ( label != null ) modelProps . setPropertyValue ( \"Label\" , label ); } catch ( Exception e ) { System . out . println ( e ); } return modelProps ; } // end of addControl() The control is added to the form in two ways: firstly the control model is placed in the parent form with: parentForm . insertByName ( name , cModel ); then the control shape is inserted into the form's draw page: XDrawPage drawPage = getDrawPage ( doc ); XShapes formShape s = Lo . qi ( XShapes . class , drawPage ); formShapes . add ( cShape ); The Forms class contains several methods that call addControl() with fixed arguments, and set various model properties. For example, Forms.addButton() makes a CommandButton: // in the Forms class public static XPropertySet addButton ( XComponent doc , String name , String label , int x , int y , int width , int height ) { XPropertySet buttonProps = null ; try { buttonProps = addControl ( doc , name , label , \"CommandButton\" , x , y , width , height ); buttonProps . setPropertyValue ( \"HelpText\" , name ); // don't want button to be accessible by the \"tab\" key buttonProps . setPropertyValue ( \"Tabstop\" , false ); // the button should not steal focus when clicked buttonProps . setPropertyValue ( \"FocusOnClick\" , false ); } catch ( Exception e ) { System . out . println ( e ); } return buttonProps ; } // end of addButton() The \"CommandButton\" string passed to addControl() means that the model will be an instance of \"com.sun.star.form.component.CommandButton\". Another variant of addControl() is Forms.addLabelledControl() which calls addControl() twice to attach a text label to the control. For instance, the \"FIRSTNAME\" text field is created with: // part of createForm() in BuildForm.java... XPropertySet props = Forms . addLabelledControl ( doc , \"FIRSTNAME\" , \"TextField\" , 11 ); The Forms . addLabelledControl () code : // in the Forms class public static XPropertySet addLabelledControl ( XComponent doc , String label , String compKind , int y ) { return addLabelledControl ( doc , label , compKind , 2 , y , 6 ); } public static XPropertySet addLabelledControl ( XComponent doc , String label , String compKind , int x , int y , int height ) { XPropertySet ctrlProps = null ; try { // create label (fixed text) control String name = label + \"_Label\" ; XPropertySet labelProps = addControl ( doc , name , label , \"FixedText\" , x , y , 25 , 6 ); // create data field control ctrlProps = addControl ( doc , label , null , compKind , x + 26 , y , 40 , height ); // to the right ctrlProps . setPropertyValue ( \"DataField\" , label ); // add label props to the control ctrlProps . setPropertyValue ( \"LabelControl\" , labelProps ); } catch ( Exception e ) { System . out . println ( e ); } return ctrlProps ; } // end of addLabelledControl() The label is of type com.sun.star.form.component.FixedText, and linked to the text field by setting its \"DataField\" and \"LabelControl\" properties.","title":"1.  Creating Controls"},{"location":"40-Building_a_Form.html#2-assigning-a-data-source-to-a-form","text":"The \"Form\" and \"GridForm\" forms are both 'data aware', which means they're connected to external databases. Data awareness is supported by the DataForm subclass of the Form service, which is also connected to the RowSet and ResultSet services of Base, as in Figure 3. Figure 3. Part of the DataForm Service Hierarchy. RowSet in the sdbc module supports the \"DataSourceName\", \"Command\", and \"CommandType\" properties (amongst others). \"DataSourceName\" is set to the database's URL, and \"Command\", and \"CommandType\" specify how the database will be queried by the form's controls. The \"Form\" form is attached to the \"liang.odb\" database by: // part of createForm() in BuildForm.java... XForm defForm = Forms . getForm ( doc , \"Form\" ); Forms . bindFormToTable ( defForm , FileIO . fnmToURL ( \"liang.odb\" ), \"Course\" ); The code for Forms.bindFormToTable(): // in the Forms class public static void bindFormToTable ( XForm xForm , String sourceName , String tableName ) { Props . setProperty ( xForm , \"DataSourceName\" , sourceName ); Props . setProperty ( xForm , \"Command\" , tableName ); // any table name Props . setProperty ( xForm , \"CommandType\" , CommandType . TABLE ); } // end of bindFormToTable() CommandType.TABLE permits SQL SELECT queries to be sent to the data source by the controls. The \"Command\" setting can be the name of any table in the database since the form's two list boxes (see Figure 1) send their own SELECT queries (see below). \"GridForm\" is set up by a call to Forms.bindFormToSQL() which sends a SQL query to the database to obtain a result set for filling the GridControl table. The code fragment in BuildForm.java is: // part of createForm() in BuildForm.java... XNameContainer gridCon = Forms . insertForm ( \"GridForm\" , doc ); XForm gridForm = Lo . qi ( XForm . class , gridCon ); Forms . bindFormToSQL ( gridForm , FileIO . fnmToURL ( DB_FNM ), \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); The code for Forms.bindFormToSQL(): // in the Forms class public static void bindFormToSQL ( XForm xForm , String sourceName , String cmd ) { Props . setProperty ( xForm , \"DataSourceName\" , sourceName ); Props . setProperty ( xForm , \"Command\" , cmd ); // SQL statement Props . setProperty ( xForm , \"CommandType\" , CommandType . COMMAND ); } // end of bindFormToSQL() It's not clear to me why the command type must be CommandType.COMMAND in Forms.bindFormToSQL() since the SELECT query should be processable by CommandType.TABLE, but using that type cause a run-time error.","title":"2.  Assigning a Data Source to a Form"},{"location":"40-Building_a_Form.html#3-creating-data-aware-controls","text":"Some control models have subclasses that support data-awareness, which means they can access the form's data source using SELECT queries. The different types are shown in Table 2. Control Models Type of Access GridControl Fill a table (grid) with data DatabaseListBox, Fill a list with data DatabaseComboBox DatabaseTextField, Fill a text field DatabaseDateField, DatabaseTimeField, DatabaseNumericField, DatabasePatternField, DatabaseFormattedField, DatabaseCurrencyField DatabaseRadioButton, Specify whether a box is selected DatabaseCheckBox or not. DatabaseImageControl Read an image Table 2. Data-aware Control Models. The service hierarchy for these control models is similar to the hierarchy for DatabaseListBox shown in Figure 4 (except for GridControl which I'll get to shortly). Figure 4. Part of the Service Hierarchy for DatabaseListBox. Figure 4 should be compared with the service hierarchy for an non-data-aware model, such as CommandButton in Figure 8 of Chapter 39. The model is initialized by setting properties using the database associated with the parent form. Exactly which properties should be set depends on the model, but DatabaseListBox and DatabaseComboBox are fairly straightforward. \"ListSourceType\" is set to ListSourceType.SQL, and \"ListSource\" assigned a string array containing a SQL command. The command should be a SELECT query which returns a single column result set. The two DatabaseListBoxs in BuildForm.java (see Figure 1) are initialized by calling Forms.addDatabaseList() like so: // part of createForm() in BuildForm.java... Forms . addDatabaseList ( doc , \"CourseNames\" , \"SELECT \\\"title\\\" FROM \\\"Course\\\"\" , 90 , 90 , 20 , 6 ); Forms . addDatabaseList ( doc , \"StudNames\" , \"SELECT \\\"lastName\\\" FROM \\\"Student\\\"\" , 140 , 90 , 20 , 6 ); Forms.addDatabaseList() is: // in the Forms class public static XPropertySet addDatabaseList ( XComponent doc , String name , String sqlCmd , int x , int y , int width , int height ) { XPropertySet listProps = null ; try { listProps = addControl ( doc , name , null , \"DatabaseListBox\" , x , y , width , height ); // listProps.setPropertyValue(\"DefaultSelection\", // new short[]{0}); // hangs listProps . setPropertyValue ( \"Dropdown\" , true ); listProps . setPropertyValue ( \"MultiSelection\" , false ); listProps . setPropertyValue ( \"BoundColumn\" , ( short ) 0 ); // data-aware properties listProps . setPropertyValue ( \"ListSourceType\" , ListSourceType . SQL ); listProps . setPropertyValue ( \"ListSource\" , new String [] { sqlCmd }); } catch ( Exception e ) { System . out . println ( e ); } return listProps ; } // end of addDatabaseList() The DatabaseListBox control is created by calling Forms.addControl(), and then the model's properties are configured. Setting the list's default selection to be its first value causes Office to hang, so I've commented out that line in addDatabaseList() above. This means that the list boxes appear to be empty until the user clicks on them.","title":"3.  Creating Data-aware Controls"},{"location":"40-Building_a_Form.html#4-initializing-the-gridcontrol","text":"The GridControl is created by calling Forms.addControl() with \"GridControl\" as the model string. Also, since this is the only control not inside the \"Form\" default form, it's necessary to include a reference to the nameContainer for \"GridForm\": // part of createForm() in BuildForm.java... // add \"GridForm\" to document XNameContainer gridCon = Forms . insertForm ( \"GridForm\" , doc ); XForm gridForm = Lo . qi ( XForm . class , gridCon ); // \"GridForm\" uses an SQL query as its data source Forms . bindFormToSQL ( gridForm , FileIO . fnmToURL ( DB_FNM ), \"SELECT \\\"firstName\\\", \\\"lastName\\\" FROM \\\"Student\\\"\" ); // create grid control inside \"GridForm\" props = Forms . addControl ( doc , \"SalesTable\" , null , \"GridControl\" , 2 , 100 , 100 , 40 , gridCon ); \"GridForm\"s query generates a result set with two columns consisting of first and last names from the Student table. For this information to be displayed by the grid, two of the grid's columns must be attached to the two result set columns. This is done by calling Forms.createGridColumn() twice: // part of createForm() in BuildForm.java... // get grid control's model XControlModel gridModel = Lo . qi ( XControlModel . class , props ); // connect grid control's columns to result set Forms . createGridColumn ( gridModel , \"firstName\" , \"TextField\" , 25 ); Forms . createGridColumn ( gridModel , \"lastName\" , \"TextField\" , 25 ); The main service for a grid control model is GridControl in the form.components module. Part of its hierarchy is shown in Figure 5. Figure 5. Part of the GridControl Service Hierarchy. If Figure 5's hierarchy is compared to those for other models, such as CommandButton in Figure 8 of Chapter 39, there are some differences. GridControl inherits the UnoControlModel service, but not through UnoControlGridModel in the awt module. A search for such a service returns an entire awt.grid sub-module for grid services, interfaces, and classes, but these aren't utilized by the form's grid control. The consequence is that GridControl is initialized in a different way from other models, and listener code becomes a little harder to implement (as we'll see in section 6). Forms.createGridColumn() employs the XGridColumnFactory interface to link a grid column to a result set column: // in the Forms class public static void createGridColumn ( XControlModel gridModel , String dataField , String colKind , int width ) { try { // column container and factory XIndexContainer colContainer = Lo . qi ( XIndexContainer . class , gridModel ); XGridColumnFactory colFactory = Lo . qi ( XGridColumnFactory . class , gridModel ); // create the column XPropertySet colProps = colFactory . createColumn ( colKind ); colProps . setPropertyValue ( \"DataField\" , dataField ); // connect column to this result set column colProps . setPropertyValue ( \"Label\" , dataField ); colProps . setPropertyValue ( \"Name\" , dataField ); if ( width > 0 ) colProps . setPropertyValue ( \"Width\" , new Integer ( width * 10 )); // add properties column to container colContainer . insertByIndex ( colContainer . getCount (), colProps ); } catch ( Exception e ) { System . out . println ( e ); } } // end of createGridColumn()","title":"4.  Initializing the GridControl"},{"location":"40-Building_a_Form.html#5-attaching-listeners","text":"Table 1 shows that nine Office listeners are used with the controls. To reduce coding, BuildForm implements their methods: // in BuildForm.java public class BuildForm implements XEventListener , XActionListener , XPropertyChangeListener , XTextListener , XFocusListener , XItemListener , XMouseListener , XSelectionChangeListener , XGridColumnListener { : // methods for creating the controls ... : // methods for attaching listeners to the controls ... // listener methods for ... // XEventListener public void disposing ( EventObject ev ) { String implName = Info . getImplementationName ( ev . Source ); System . out . println ( \"Disposing: \" + implName ); } // XActionListener public void actionPerformed ( ActionEvent ev ) // called when a button has been pressed { System . out . println ( \"Pressed \\\"\" + ev . ActionCommand + \"\\\"\" ); } : // many more listener methods } // end of BuildForm class The listener methods are fairly simple, except for the XSelectionChangeListener attached to the grid control. A button control is attached to a listener like so: // part of createForm() in BuildForm.java... XPropertySet props = Forms . addButton ( doc , \"first\" , \"<<\" , 2 , 63 , 8 ); listenToButton ( props ); The code in listenToButton() is depicted by Figure 6. All the other \"listener attacher\" functions in BuildForm.java work in a similar way. Figure 6. Attaching a Listener to a Button Control. The property set passed to listenToButton() is cast to XControlModel, and then converted into a view using Forms.getControl(). The control is cast to an interface (such as XButton or XTextComponent) which offers an addXXXListener() method. The listenToButton() method is: // in BuildForm.java public void listenToButton ( XPropertySet props ) { XControlModel cModel = Lo . qi ( XControlModel . class , props ); XControl control = Forms . getControl ( doc , cModel ); XButton xButton = Lo . qi ( XButton . class , control ); xButton . setActionCommand ( Forms . getName ( cModel )); xButton . addActionListener ( this ); // use BuildForms as the listener } // end of listenToButton()","title":"5.  Attaching Listeners"},{"location":"40-Building_a_Form.html#6-listening-for-grid-control-selection-changes","text":"Grid selection changes occur when the user clicks on a cell in the table, as in Figure 7. Figure 7. Grid Control Selection Change. Figure 8 shows the grid model and control hierarchy. Figure 8. Attaching a Listener to a Grid Control. The grid model inherits UnoControlModel via FormControlModel. On the control side, GridControl in the form.control module inherits UnoControl directly. GridControl supports two listener interfaces \u2013 XSelectionSupplier and XGridControl. Their attachment is handled by listenToGrid(), which is called after the control has been initialized by createForm(): // in createForm() in BuildForm.java... props = Forms . addControl ( doc , \"SalesTable\" , null , \"GridControl\" , 2 , 100 , 100 , 40 , gridCon ); XControlModel gridModel = Lo . qi ( XControlModel . class , props ); Forms . createGridColumn ( gridModel , \"firstName\" , \"TextField\" , 25 ); Forms . createGridColumn ( gridModel , \"lastName\" , \"TextField\" , 25 ); listenToGrid ( gridModel ); listenToGrid() is defined as: // in BuildForm.java public void listenToGrid ( XControlModel gridModel ) { XControl control = Forms . getControl ( doc , gridModel ); XGridControl gc = Lo . qi ( XGridControl . class , control ); gc . addGridControlListener ( this ); XSelectionSupplier gridSelection = Lo . qi ( XSelectionSupplier . class , gc ); gridSelection . addSelectionChangeListener ( this ); } // end of listenToGrid() There's no point using XGridControlListener in this example because its columnChanged() method is only triggered when the data in a column changes, which never occurs. However, XSelectionChangeListener.selectionChanged() is sent an event whenever the user's selection changes, which is what we're interested in reporting.","title":"6.  Listening for Grid Control Selection Changes"},{"location":"40-Building_a_Form.html#7-using-the-result-set","text":"The XGridControl interface for GridControl doesn't offer all the methods I need for announcing selection changes. XGridControl inherits XGrid and XGridFieldDataSupplier. XGrid can retrieve the currently selected column, while XGridFieldDataSupplier provides access to the data, but neither of them offer a way to find the currently selected row. That requires the result set for the table, which can only be examined by starting from the form level. Getting to the result set requires a number of casts, the first being from the event object arriving at the listener to the model that sent it. Forms.getEventControlModel() does that job: // in the Forms class public static XControlModel getEventControlModel ( EventObject ev ) { XControl xControl = Lo . qi ( XControl . class , ev . Source ); return xControl . getModel (); } Another conversion step is from control model to the parent form, which is carried out by Forms.getFormName(): // in the Forms class public static String getFormName ( XControlModel cModel ) { XChild xChild = Lo . qi ( XChild . class , cModel ); XNamed xNamed = Lo . qi ( XNamed . class , xChild . getParent ()); return xNamed . getName (); } selectionChanged() utilizes getEventControlModel() and getFormName() to convert an event object to a form. Finally, XForm is cast to a result set using the hierarchy in Figure 3. // in BuildForm.java public void selectionChanged ( EventObject ev ) { XControlModel cModel = Forms . getEventControlModel ( ev ); XGridControl gc = Lo . qi ( XGridControl . class , ev . Source ); System . out . println ( \"Grid \" + Forms . getName ( cModel ) + \" column: \" + gc . getCurrentColumnPosition ()); String formName = Forms . getFormName ( cModel ); XForm gForm = Forms . getForm ( doc , formName ); XResultSet rs = Lo . qi ( XResultSet . class , gForm ); try { System . out . println ( \" row: \" + rs . getRow ()); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of selectionChanged() selectionChanged() jumps through these hoops in order to print the currently selected column and row in the table. The selected column is obtained by calling XGridControl.getCurrentColumnPosition(), and the current row comes from XResultSet.getRow().","title":"7.  Using the Result Set"},{"location":"40-Building_a_Form.html#8-some-bugs","text":"My first version of BuildForm.java had a few problems which caused it to hang. The most serious occurred when I tried to include an image button in the form. The relevant lines in createForm() in BuildForm.java were: // in createForm() in BuildForm.java... props = Forms . addControl ( doc , \"Smiley\" , null , \"ImageButton\" , 90 , 80 , 10 , 10 ); props . setPropertyValue ( \"ImageURL\" , FileIO . fnmToURL ( \"smiley.png\" )); The button would sometimes appear at the correct position, but cause Office to hang when pressed, and sometimes the button wouldn't appear at all. After failing to find an answer online, I commented out the above lines. If anyone knows of a solution please contact me. A more minor issue is the initial lack of text in the DatabaseListBoxs. In the original Forms.addDatabaseList(), the list text was set with: listProps . setPropertyValue ( \"DefaultSelection\" , new short [] { 0 }); This line caused Office to hang, and once again I 'solved' the problem by commenting out the code. The unfortunate side-effect is that now the list box's text is blank until the user clicks on the list.","title":"8.  Some Bugs"},{"location":"41-Printing.html","text":"Chapter 41. Printing \u00b6 Topics The Java Print Service (JPS); Printing in Office Writer, Impress, Calc; Viewing a Document's Print Properties; Specialized Printing: Writer, Impress, Calc; Hacking the GUI; Command Prompt Printing Example folders: \"Printing Tests\" and \"Utils\" Java's Print Service (JPS) and Office's printing APIs nicely compliment each other. For example, since Java 1.4 (February 2002), JPS has included printer discovery based on document types and printer attributes. but Office's API lacks such capabilities. JPS cannot easily print much beyond text and images; binary data can be sent to a printer, but it's left to the device to interpret and render it, which is only possible in high-end printers, not ordinary inkjets and laser printers. In contrast, Office can print a very wide range of document formats, including ODF, Microsoft, and PDF files. This chapter starts by describing JPS's PrintService, which I'll use later to select a printer for the Office API. Then there's an overview of the printing capabilities of the Office API, with examples of how to print Writer, Impress, and Calc files. The bad news is that Office's printing API has a few bugs and missing features. By 'missing' I mean parts of Office's printing GUI with no equivalents in the API. Also, buggy features in the API, such as the printing of multiple pages/sheet and slide handouts, work flawlessly in the GUI. I'll finish with a short discussion of command line printing in Windows. The OS has several print utilities that are a little hard to find and use. Also, Office can be started from the command line in order to print documents. 1. The Java Print Service (JPS) \u00b6 Java 1.4 saw the introduction of the Java Print service (JPS) API which allows a printer to be selected based on document types and attributes such as color output, paper sizes, and double-sided printing. JPS printing passes through four stages: Selection of a print service (i.e. a printer or print driver), represented by a PrintService instance. The programmer can supply document types and printer attributes to limit the search. Creation of a Doc object for the document that's to be printed. Creation of a print job combining the Doc object and print request attributes. A listener can be attached to monitor what's happening during the printing. The printing is started, and performed asynchronously. Document types are encoded as DocFlavor objects which contain data source details (e.g. whether the document comes from an input stream or a URL), and a MIME type (e.g. image/gif, application/pdf). A common misconception about DocFlavor is that it means that Java can print that kind of document. A DocFlavor is used to check whether a printer supports a document type, and the answer may be \"no\". The following code locates print services that support GIF documents sent from a file: // stage 1: find print services for GIF files DocFlavor gifFlavor = DocFlavor . INPUT_STREAM . GIF ; PrintService [] services = PrintServiceLookup . lookupPrintServices ( gifFlavor , null ); The matching print services are returned in a PrintService[] array. lookupPrintServices()'s second argument (which is null here) could be a set of print request attributes (PRAs). There are four kinds of print attributes. The first two are requests sent from a program to the printer, which may be accepted or rejected: Print request attributes (PRA) ask for particular printing features, such as two- sided output, or a paper size. Doc attributes (DA) supply information about a document, such as its page size, use of color, or page ranges for printing. The two other attributes types are used by the printer service to convey information about the printer and job back to the program. Print service attributes (PSA) give information about the print service, such as the printer's make and model or whether it is currently accepting jobs. Print job attributes (PJA) give information about the status of a particular print job, such as whether it has successfully finished. The following code fragment looks for printer services that can print on both sides of A4 paper: // stage 1 example using attributes AttributeSet attrs = new HashAttributeSet (); attrs . add ( MediaSizeName . ISO_A4 ); attrs . add ( Sides . DUPLEX ); PrintService [] services = PrintServiceLookup . lookupPrintServices ( null , attrs ); AttributeSet is an interface and HashAttributeSet an implementation which supports the four kinds of attributes. The easiest way to find out about particular attribute is via the Attribute interface documentation at https://docs.oracle.com/javase/8/docs/api/index.html?java/util/jar/Attributes.html , which lists the attribute subclasses, such as MediaSizeName and Sides used in the example above. The next fragment creates a Doc object for a GIF file, a stage 2 task in JPS printing: // stage 2 : create a Doc object for a GIF file FileInputStream in = new FileInputStream ( fileName ); Doc doc = new SimpleDoc ( in , gifFlavor , null ); The third argument of the SimpleDoc constructor can be a set of document attributes (DAs). JPS stage 3 involves the creation of a print job, and perhaps a listener: // stage 3: print job creation DocPrintJob job = service [ 0 ] . createPrintJob (); job . addPrintJobListener ( new PrintJobAdapter () {...} ); The listener will receive information about the print job's progress as print job attributes (PJAs). Stage 4 starts the printing: job . print ( doc , null ); The second argument of print() can be a set of print request attributes (PRAs). 1.1. Listing the Printers \u00b6 The ListPrinters.java example in this section focuses on JPS stage 1. It prints short details about all the available printers, fuller information about the default printer, and a list of printer names. The main() function: // in ListPrinters.java public static void main ( String [] args ) { JPrint . listServices (); // short info // JPrint.listServices(true); // full info, but slow to generate PrintService ps = PrintServiceLookup . lookupDefaultPrintService (); System . out . println ( \"Default printer \\\"\" + ps . getName () + \"\\\":\" ); JPrint . listService ( ps , true ); // full info on default printer String [] pNames = JPrint . getPrinterNames (); System . out . println ( \"Printer names (\" + pNames . length + \"):\" ); for ( String pName : pNames ) System . out . println ( \" \" + pName ); } // end of main() Most of the functionality is implemented by the JPrint.java utility class. JPrint.listServices() on one of my test machines prints the following: -------- Print services (16) ---------- 1. \"Send To OneNote 2010\" color-supported:supported printer-name:Send To OneNote 2010 queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream 2. \"Ricoh Aficio MP 2000 PCL(Black Office Room)\" color-supported:not-supported printer-name:Ricoh Aficio MP 2000 PCL(Black Office Room) queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream : : 16. \"CutePDF Writer\" color-supported:supported printer-name:CutePDF Writer queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream application/postscript The information for each printer consists of four attributes, including its name and the MIME types that it can process. For example, the Ricoh Aficio MP 2000 printer can deal with standard graphics formats and \"application/octet-stream\". This latter type means that the printer will accept binary printer data, but doesn't mean that it can correctly print it. For instance, it may be output as a mishmash of ASCII characters. The service listing methods in JPrint.java: // in the JPrint class public static void listServices ( boolean showAll ) { PrintService [] psa = PrintServiceLookup . lookupPrintServices ( null , null ); listServices ( psa , showAll ); } public static void listServices ( PrintService [] psa , boolean showAll ) { if ( psa != null && psa . length > 0 ) { System . out . println ( \"\\n-------- Print services (\" + psa . length + \") ----------\\n\" ); for ( int i = 0 ; i < psa . length ; i ++ ) { System . out . println (( i + 1 ) + \". \\\"\" + psa [ i ] . getName () + \"\\\"\" ); listService ( psa [ i ] , showAll ); } System . out . println ( \"------------------\\n\" ); } else System . out . println ( \"No print services found\" ); } // end of listServices() public static void listService ( PrintService ps , boolean showAll ) { // print basic attributes Attribute [] attrs = ps . getAttributes (). toArray (); for ( Attribute attr : attrs ) System . out . println ( \" \" + attr . getName () + \":\" + attr ); // print the supported MIME types System . out . print ( \" Supported doc types: \" ); DocFlavor [] flavors = ps . getSupportedDocFlavors (); for ( int j = 0 ; j < flavors . length ; j ++ ) { // Filter out DocFlavors that have a representation class other // than java.io.InputStream. String repclass = flavors [ j ] . getRepresentationClassName (); if ( ! repclass . equals ( \"java.io.InputStream\" )) // restrict to files continue ; System . out . print ( \" \" + flavors [ j ] . getMimeType ()); } System . out . println (); // print every printer attribute if ( showAll ) { System . out . println ( \" ----\" ); ArrayList < NamedAttribute > attrList = getAttributes ( ps ); Collections . sort ( attrList ); for ( NamedAttribute attr : attrList ) printAttr ( ps , attr . getAttribute ()); } System . out . println (); } // end of listService() The lookupPrintServices() call in listServices(): PrintServiceLookup . lookupPrintServices ( null , null ) has no DocFlavor or attribute arguments, so every printer service will be returned in the array. listServices() iterates through each PrintService object, and prints its basic attributes, the supported MIME types for files, and optionally a list of every printer attribute. The four attributes returned by PrintService.getAttributes() are the tip of a very large iceberg. Java supports a multitude of attributes as seen if you look at the Java 8 Attribute documentation at https://docs.oracle.com/javase/8/docs/api/javax/print/attribute/Attribute.html . Over 70 subclasses are listed, including PrinterName, Sides, and Chromacity. A taste of what can be printed occurs when the default printer's details are listed: // in ListPrinters.java... PrintService ps = PrintServiceLookup . lookupDefaultPrintService (); System . out . println ( \"Default printer \\\"\" + ps . getName () + \"\\\":\" ); JPrint . listService ( ps , true ); // full info The default printer for my test machine is an old laser printer. ListPrinter.java reports the following: Default printer \"HP LaserJet 1200 Series PCL 6\": color-supported:not-supported printer-name:HP LaserJet 1200 Series PCL 6 queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream ---- chromaticity: color copies-supported: null ipp-attribute-fidelity: false job-name: Java Printing media: iso-a4 media-printable-area: (4.233,4.233)->(197.951,288.459)mm orientation-requested: portrait page-ranges: 1-2147483647 printer-resolution: 60000x60000 dphi requesting-user-name: Ad sheet-collate: uncollated sides: one-sided spool-data-destination: file:/C:/Users/Ad/Desktop/LibreOffice%20Tests/Printing%20Tests/o ut.prn sun-alternate-media: null The \"chromacity\" attribute states how color and monochrome documents are mapped to each other. Probably the attribute the user really wants to examne is \"color- supported\" which shows that this printer only offers grayscales. The main drawback of printing all these attributes is the time required to collect them, sort them, and remove duplicates; each printer may take several seconds to process. 1.2. Discovering Print Services \u00b6 PrintServiceLookup.lookupPrintServices() should be called with DocFlavor and/or print request attributes to narrow down the search. Some examples can be found in Discovery.java. For instance, the following fragment looks for printers that can process JPEG files: // in Discovery.java... DocFlavor flavor = DocFlavor . INPUT_STREAM . JPEG ; PrintService [] psa = PrintServiceLookup . lookupPrintServices ( flavor , null ); System . out . println ( \"\\nServices that support \" + flavor ); String [] pNames = JPrint . getPrinterNames ( psa ); if ( pNames != null ) for ( String pName : pNames ) System . out . println ( \" \" + pName ); It's very likely that the printers listed by this search can also output PDF, Word, PowerPoint and other file formats printable from Office, since Office delivers pages to a printer rendered as images. However, if a search is made for printers that can process PDF files: DocFlavor flavor = DocFlavor . INPUT_STREAM . PDF ; PrintService [] psa = PrintServiceLookup . lookupPrintServices ( flavor , null ); then no matches are found. This means that none of the printers can process PDF by themselves. JPrint.findPrinterNames() lets printers be selected based on partial names. The following call collects all the printers whose names include \"HP\": String[] pNames = JPrint.findPrinterNames(\"HP\"); Multiple attributes can be used in a search. The following looks for all the \"HP\" printer services that support color: // in Discovery.java... AttributeSet attrs = new HashAttributeSet (); System . out . println ( \"\\nHP Services that support color:\" ); PrintService [] psa ; for ( String pName : pNames ) { // from the \"HP\" search above attrs . clear (); attrs . add ( new PrinterName ( pName , null )); // must be included attrs . add ( ColorSupported . SUPPORTED ); psa = PrintServiceLookup . lookupPrintServices ( null , attrs ); if ( psa . length > 0 ) System . out . println ( \" \" + pName ); } It's possible to look for color printers with less code: // in Discovery.java... AttributeSet attrs = new HashAttributeSet (); attrs . add ( ColorSupported . SUPPORTED ); PrintService [] psa = PrintServiceLookup . lookupPrintServices ( null , attrs ); Unfortunately the returned print services include non-color printers. It seems that the printer name must be part of the attribute set to get a correct match. DocFlavors and attributes can be combined, as in the following that looks for a printer that supports JPEG and A4 paper: // in Discovery.java... DocFlavor flavor = DocFlavor . INPUT_STREAM . JPEG ; AttributeSet attrs = new HashAttributeSet (); attrs . add ( MediaSizeName . ISO_A4 ); PrintService [] psa = PrintServiceLookup . lookupPrintServices ( flavor , attrs ); A quite different printer selection approach is to display a dialog box at run time to let the user set the search criteria. Java offers ServiceUI.printDialog() for this, which I've wrapped inside JPrint.dialogSelect(): // in the JPrint class public static PrintService dialogSelect () { GUI . setLookFeel (); PrintService psa [] = PrintServiceLookup . lookupPrintServices ( null , null ); PrintService defaultService = PrintServiceLookup . lookupDefaultPrintService (); PrintRequestAttributeSet attrs = new HashPrintRequestAttributeSet (); // none PrintService service = ServiceUI . printDialog ( null , 100 , 100 , psa , defaultService , null , attrs ); if ( service == null ) System . out . println ( \"No print service selected\" ); return service ; } // end of dialogSelect() dialogSelect() initializes ServiceUI.printDialog() with a list of printer services, the default printer, and an empty print request attribute set. In Discovery.java, JPrint.dialogSelect() is called like so: // in Discovery.java... PrintService ps = JPrint . dialogSelect (); if ( ps != null ) { System . out . println ( \"\\nYou selected \" + ps . getName ()); JPrint . listService ( ps , true ); // full info } The dialog looks like Figure 1. Figure 1. The ServiceUI.printDialog() Dialog. Pressing the \"Print\" button returns a PrintService reference; pressing \"Cancel\" returns null. 1.3. Printing Using Java \u00b6 After a print service has been selected, JPS stages 2-4 involve instantiating a Doc object, creating a print job, and starting the printing. These are managed by my JPrint.printFile(): // in the JPrint class public static void printFile ( PrintService ps , String fnm ) { if ( ps == null ) { System . out . println ( \"Print service is null\" ); return ; } DocPrintJob printJob = ps . createPrintJob (); // stage 2 try { InputStream is = new FileInputStream ( fnm ); DocFlavor flavor = getFlavor ( ps , fnm ); Doc doc = new SimpleDoc ( is , flavor , null ); // stage 3 printJob . print ( doc , null ); // stage 4 is . close (); } catch ( Exception e ) { System . out . println ( \"Unable to print \" + fnm ); System . out . println ( e ); } } // end of printFile() The user supplies a PrintService and a filename. A DocFlavor for the file is obtained by JPrint.getFlavor(): // in the JPrint class public static DocFlavor getFlavor ( PrintService ps , String fnm ) { DocFlavor flavor = getFlavorFromFnm ( fnm ); System . out . println ( \"File-based DocFlavor: \" + flavor ); if ( ! ps . isDocFlavorSupported ( flavor )) { System . out . println ( \"Not supported by printer; using autosense\" ); flavor = DocFlavor . INPUT_STREAM . AUTOSENSE ; } return flavor ; } // end of getFlavor() public static DocFlavor getFlavorFromFnm ( String fnm ) { String ext = fnm . substring ( fnm . lastIndexOf ( '.' ) + 1 ). toLowerCase (); if ( ext . equals ( \"gif\" )) return DocFlavor . INPUT_STREAM . GIF ; else if ( ext . equals ( \"jpeg\" )) return DocFlavor . INPUT_STREAM . JPEG ; else if ( ext . equals ( \"jpg\" )) return DocFlavor . INPUT_STREAM . JPEG ; else if ( ext . equals ( \"png\" )) return DocFlavor . INPUT_STREAM . PNG ; else if ( ext . equals ( \"ps\" )) return DocFlavor . INPUT_STREAM . POSTSCRIPT ; else if ( ext . equals ( \"pdf\" )) return DocFlavor . INPUT_STREAM . PDF ; else if ( ext . equals ( \"txt\" )) return DocFlavor . INPUT_STREAM . TEXT_PLAIN_HOST ; else // try to determine flavor from file content return DocFlavor . INPUT_STREAM . AUTOSENSE ; } // end of getFlavorFromFnm getFlavorFromFnm() uses the file's extension to choose a DocFlavor.INPUT_STREAM constant, which is checked by the print service in PrintService.isDocFlavorSupported(). JPrint.printFile() is utilized in my JDocPrinter.java example: // in JDocPrinter.java public static void main ( String [] args ) { if (( args . length < 1 ) || ( args . length > 2 )) { System . out . println ( \"Usage: java JDocPrinter <filename> [<(partial)printer-name>]\" ); return ; } String fnm = args [ 0 ] ; String pName = null ; if ( args . length == 2 ) { String [] pNames = JPrint . findPrinterNames ( args [ 1 ] ); if ( pNames != null ) { System . out . println ( \"Using first match: \\\"\" + pNames [ 0 ] + \"\\\"\" ); pName = pNames [ 0 ] ; } } if ( pName != null ) JPrint . print ( pName , fnm ); else { PrintService ps = JPrint . dialogSelect (); if ( ps != null ) // JPrint.printMonitorFile(ps, fnm); JPrint . printFile ( ps , fnm ); } } // end of main() JPrint.printMonitorFile() is fancier version of JPrint.printFile() which attaches a PrintJobListener to the print job. The listener's methods are triggered as the job passes through its printing states such as its delivery to the printer, completion, cancellation, or printing error. The lines in JPrint.printMonitorFile() that add the listener to the print job are: // in JPrint.printMonitorFile()... DocPrintJob printJob = ps . createPrintJob (); printJob . addPrintJobListener ( new PJWatcher ()); PJWatcher implements the PrintJobListener interface: // in the JPrint class private static class PJWatcher implements PrintJobListener { public void printDataTransferCompleted ( PrintJobEvent pje ) { System . out . println ( \" >> Data transferred to printer\" ); } public void printJobCanceled ( PrintJobEvent pje ) { System . out . println ( \" >> Print job was cancelled\" ); } public void printJobCompleted ( PrintJobEvent pje ) { System . out . println ( \" >> Print job completed successfully\" ); } public void printJobFailed ( PrintJobEvent pje ) { System . out . println ( \" >> Print job failed\" ); } public void printJobNoMoreEvents ( PrintJobEvent pje ) { System . out . println ( \" >> No more events will be delivered\" ); } public void printJobRequiresAttention ( PrintJobEvent pje ) { System . out . println ( \" >> Print job needs attention\" ); } } // end of PJWatcher class 1.4. More Information on javax.print \u00b6 Good sources of information on Java printing include the tutorial at https://docs.oracle.com/javase/tutorial/2d/printing/ which covers JPS and the older Java 2D printing API, and the JPS API user guide at https://docs.oracle.com/javase/8/docs/technotes/guides/jps/spec/JPSTOC.fm.html . Two books I've found useful: Core Java, Volume II -- Advanced Features Cay S. Horstmann; Gary Cornell Prentice Hall, 2016, 10 th ed. https://horstmann.com/corejava.html Chapter 7 includes a section on printing, including a table of attributes. Pro Java 8 Programming Terrill Brett Spell Apress, 2015, 3 rd ed. https://apress.com/9781484206423/ Chapter 11 is about printing. 2. Printing in Office \u00b6 In this section I'll employ the print service search methods in JPrint.java to find a printer for Office. The service name is passed to functions that use the Office API to send a document to the printer. Only a handful of Office methods are required to print a document; the real complexity of the API is the multitude of properties which configure how the document is output. Not surprisingly, these properties are spread across many modules since different document types (i.e. Writer, Draw, Impress, and Calc) are managed by different parts of the API. Figure 2 shows the OfficeDocument services and their print-related interfaces. The words in brackets are the modules where the services are located. The rounded rectangles refer to print property tables explained later in this chapter. Figure 2. The OfficeDocument Interface and its Print-related Interfaces. The XPrintable interface is used when printing Writer, Draw, Impress, or Calc documents since their services all inherit OfficeDocument. Writer documents can also employ XPagePrintable for printing. Note that it isn't possible to print databases using XPrintable. OfficeDocument also has XPrintJobBroadcaster and XPrintableBroadcaster interfaces for attaching listeners to a print job. However, XPrintableBroadcaster is no longer supported, having been superseded by XPrintJobBroadcaster . The tricky aspects of XPrintable, XPrintJobBroadcaster, and XPagePrintable are the properties used to configure how they work. XPrintable.getPrinter() and XPrintable.setPrinter() utilize PrintDescriptor properties, the XPrintJobListener created by XPrintJobBroadcaster uses PrintableState properties, XPrintable.print() uses PrintOptions, and XPagePrintable employs PagePrintSettings. I'll be explaining all of these in due course, with the aid of the tables referred to in Figure 2. We're not finished with properties yet. There's also several \"XXXSettings\" services which configure printing properties within a document. These are summarized by Figure 3. Figure 3. The Setting Services. The rounded rectangles refer to property tables described later in this chapter. 3. Printing any Document \u00b6 At this point you may be thinking that Office printing is rather complex. In fact, if you're happy to print a document using the default printing settings then it's fairly simple. The DocPrinter.java example illustrates this by printing any Office document supplied on its command line to the default printer or to the one named in the second command line argument. The complete code: // in DocPrinter.java public static void main ( String args [] ) { if (( args . length < 1 ) || ( args . length > 3 )) { System . out . println ( \"Usage: DocPrinter fnm [printer-name [no-of-pages]]\" ); return ; } String fnm = args [ 0 ] ; String pName = JPrint . getDefaultPrinterName (); // default if ( args . length > 1 ) { // 2 or 3 args String [] printerNames = JPrint . findPrinterNames ( args [ 1 ] ); if ( printerNames == null ) System . out . println ( \"Using default printer: \\\"\" + pName + \"\\\"\" ); else { pName = printerNames [ 0 ] ; System . out . println ( \"Using first matching printer: \\\"\" + pName + \"\\\"\" ); } } String pagesStr = \"1-\" ; // default is print all pages if ( args . length == 3 ) pagesStr = args [ 2 ] ; XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } int docType = Info . reportDocType ( doc ); XPrintable xp = Lo . qi ( XPrintable . class , doc ); if ( xp == null ) System . out . println ( \"Cannot print; XPrintable is null\" ); else if ( ! Print . isPrintable ( docType )) System . out . println ( \"Cannot print that document type\" ); else { Print . usePrinter ( xp , pName ); Print . reportPrinterProps ( xp ); Print . print ( xp , pagesStr ); } Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() An optional third command line argument is a page range, given in string form. For instance, \"2-4;6\" will print pages 2 to 4 and 6 (with the page numbering starting at 1). The printer name is obtained using methods from my JPrint.java class. The Office API takes over after the document has been loaded, and utilizes support functions in my Print.java class (note: no \"J\" in the name). The document type is printed and returned by Info.reportDocType() as one of: Lo.UNKNOWN, Lo.WRITER, Lo.BASE, Lo.CALC, Lo.DRAW, Lo.IMPRESS, or Lo.MATH. The loaded document is cast to XPrintable (see Figure 1), and Print.isPrintable() tests for those document types that can be printed using XPrintable.print(): // in the Print class public static boolean isPrintable ( int docType ) { return (( docType == Lo . WRITER ) || ( docType == Lo . CALC ) || ( docType == Lo . DRAW ) || ( docType == Lo . IMPRESS )); } Print . usePrinter () adds the printer ' s name and paper format to the XPrintable properties by calling XPrintable . setPrinter () with an array of PrintDescriptor properties ( see Figure 1 ): // in the Print.java class public static void usePrinter ( XPrintable xp , String printer ) { if ( xp == null ) { System . out . println ( \"Cannot set printer XPrintable is null\" ); return ; } System . out . println ( \"Using printer \\\"\" + printer + \"\\\"\" ); xp . setPrinter ( Props . makeProps ( \"Name\" , printer , \"PaperFormat\" , PaperFormat . A4 ) ); setListener ( xp ); } Table 1 lists the PrintDescriptor properties, or use my lodoc.bat script to access the class' documentation online (type lodoc PrinterDescriptor ). Property Description Name Name of the printer. PaperOrientation Paper orientation (com.sun.star.view.PaperOrientation: PORTRAIT, LANDSCAPE) PaperFormat Paper size formats (com.sun.star.view.PaperFormat: A3, A4, A5, B4, B5, LETTER, LEGAL, TABLOID, USER) PaperSize Paper size in 100 th mm (com.sun.star.awt.Size). IsBusy Is the printer busy? CanSetPaperOrientation Can the paper orientation be set? CanSetPaperFormat Are other paper formats supported? CanSetPaperSize Are other paper sizes supported? Table 1. Properties in com.sun.star.view.PrinterDescriptor. Print.setListener() inside Print.usePrinter() attaches an XPrintJobListener listener to the print job by casting XPrintable to XPrintJobBroadcaster (see Figure 1). // in the Print class public static void setListener ( XPrintable xp ) { if ( xp == null ) { System . out . println ( \"Cannot set listener; XPrintable is null\" ); return ; } XPrintJobBroadcaster pb = Lo . qi ( XPrintJobBroadcaster . class , xp ); if ( pb == null ) { System . out . println ( \"Cannot obtain print job broadcaster\" ); return ; } pb . addPrintJobListener ( new XPrintJobListener () { public void printJobEvent ( PrintJobEvent e ) { System . out . println ( \"Print Job status: \" + printableState ( e . State )); } public void disposing ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Disposing of print job: \" + e ); } }); } // end of setListener() XPrintJobListener.printJobEvent() is called at different stages during the job's execution, and Print.printableState() converts the retrieved PrintableState constant into a more readable string: // in the Print class public static String printableState ( PrintableState val ) { if ( val == PrintableState . JOB_STARTED ) return \"JOB_STARTED\" ; else if ( val == PrintableState . JOB_COMPLETED ) return \"JOB_COMPLETED\" ; else if ( val == PrintableState . JOB_SPOOLED ) return \"JOB_SPOOLED\" ; else if ( val == PrintableState . JOB_ABORTED ) return \"JOB_ABORTED\" ; else if ( val == PrintableState . JOB_FAILED ) return \"JOB_FAILED\" ; else if ( val == PrintableState . JOB_SPOOLING_FAILED ) return \"JOB_SPOOLING_FAILED\" ; else { System . out . println ( \"Unknown printable state\" ); return \"??\" ; } } // end of printableState() The PrintableState constants are summarized in Table 2. Enumerator Constant Description JOB_STARTED Printing/rendering has begun. JOB_COMPLETED Printing/rendering has finished; spooling has begun. JOB_SPOOLED Spooling has finished successfully. This is the \"success\" state for a print job. JOB_ABORTED Printing was aborted (e.g., by the user) during printing or spooling. JOB_FAILED The printing ran into an error. JOB_SPOOLING_FAILED The document could be printed but not spooled. Table 2. Properties in com.sun.star.view.PrintableState enum. Back in the main() function of DocPrinter.java, Print.reportPrinterProps() outputs the printer's PrintDescriptor settings (listed in Table 1). It loops through the properties array returned by XPrintable.getPrinter(): // in the Print class public static void reportPrinterProps ( XPrintable xp ) { if ( xp == null ) { System . out . println ( \"Cannot report printer props\" ); return ; } PropertyValue [] printProps = xp . getPrinter (); if ( printProps == null ) System . out . println ( \"No Printer properties found\" ); else { System . out . println ( \"Printer properties:\" ); String name ; for ( PropertyValue prop : printProps ) { name = prop . Name ; if ( name . equals ( \"PaperOrientation\" )) System . out . println ( \" \" + name + \": \" + paperOrientation (( PaperOrientation ) prop . Value )); else if ( name . equals ( \"PaperFormat\" )) System . out . println ( \" \" + name + \": \" + paperFormat (( PaperFormat ) prop . Value )); else if ( name . equals ( \"PaperSize\" )) { Size sz = ( Size ) prop . Value ; System . out . println ( \" \" + name + \": (\" + sz . Width + \", \" + sz . Height + \")\" ); } else System . out . println ( \" \" + name + \": \" + prop . Value ); } System . out . println (); } } // end of reportPrinterProps() The constants in the PaperOrientation and PaperFormat classes are mapped to more easily understood strings. Typical output from Print.reportPrinterProps() is: Printer properties: Name: FinePrint PaperOrientation: PORTRAIT PaperFormat: A4 PaperSize: (11906, 16838) IsBusy: false CanSetPaperOrientation: true CanSetPaperFormat: true CanSetPaperSize: true At last it's time to print the document. As Figure 1 indicates, the call to XPrintable.print() is configured using PrintOptions properties, which are listed in Table 3. Property Description CopyCount Number of copies to print. FileName Send the output to a file rather than to the printer. Collate Collate the printed pages (set to true or false). Sort Sort the pages (deprecated; use Collate) Pages A string that specifies pages and page ranges to print. For example, \"1-4;10\" to print the pages 1 to 4 and 10. Wait Wait for the print request to be completed. DuplexMode Set duplex constant (using com.sun.star.view.DuplexMode) PrinterName The name of the printer. Table 3. Properties in com.sun.star.view.PrintOptions. The configuration and printing is carried out by Print.print(): // in the Print class public static void print ( XPrintable xp ) { print ( xp , \"1-\" ); } // print all the pages public static void print ( XPrintable xp , String pagesStr ) { if ( xp == null ) { System . out . println ( \"Cannot print; XPrintable is null\" ); return ; } System . out . println ( \"Print range: \" + pagesStr ); System . out . println ( \"Sending document...\" ); PropertyValue [] props = Props . makeProps ( \"Pages\" , pagesStr , \"Wait\" , true ); // synchronous // see com.sun.star.view.PrintOptions xp . print ( props ); // print the document System . out . println ( \"Delivered\" ); } // end of print() Two properties are set: \"Pages\" and \"Wait\". \"Pages\" could be left out if all of the document is to printed, but \"Wait\" is necessary; it forces the print() call to wait until the job has been delivered to the driver, and so has left the Office process. If \"Wait\" wasn't included then DocPrinter could continue and perhaps close Office before it had fully transmitted the document to the printer. This would cause a crash. Note that there's no need to set the \"PrinterName\" property since its already been supplied as one of the PrintDescriptor properties. 4. Viewing a Document's Print Properties \u00b6 The previous section looked at printer-related properties stored in PrinterDescriptor (Table 1) and PrintOptions (Table 2). But the real property mother lode are those related to documents, which are stored in the many subclasses below the Settings service (see Figure 3). The ShowPrintProps.java example prints out those properties for a given input document. The relevant lines are: // in ShowPrintProps.java... int docType = Info . reportDocType ( doc ); XProperty Set docProps = Print . getDocSettings ( docType ); Props . showProps ( \"Document Settings\" , docProps ); The document type returned by Info.reportDocType() is employed by Print.getDocSettings() to decide which of the subclasses of the Settings service (once again, see Figure 3) should be instantiated: // in the Print class public static XPropertySet getDocSettings ( int docType ) { XPropertySet props = null ; if ( docType == Lo . WRITER ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.text.DocumentSettings\" ); else if ( docType == Lo . IMPRESS ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.presentation.DocumentSettings\" ); else if ( docType == Lo . DRAW ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.drawing.DocumentSettings\" ); else if ( docType == Lo . CALC ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.sheet.DocumentSettings\" ); else if ( docType == Lo . BASE ) System . out . println ( \"No document settings for a base doc\" ); else if ( docType == Lo . MATH ) System . out . println ( \"No document settings for a math doc\" ); else System . out . println ( \"Unknown document type\" ); return props ; } // end of getDocSettings() All these setting services support XPropertySet, which is returned as Print.getDocSettings()'s result. The printing-related properties defined in the Settings superclass are listed in Table 4, but it contains many more properties for different aspects of a document. For a full list, use lodoc Settings document to look at the online documentation. The Settings webpage is also a good starting point for examining its DocumentSettings subclasses. Property Description PrinterName Printer used by the document. PrinterSetup A byte array containing driver-specific data. IsPrintBooklet Put two document pages on one physical page, such that you can fold the output into a booklet. IsPrintBookletFront Only print the fronts of a booklet IsPrintBookletBack Only print the backs of a booklet PrintQuality Normal (0); Grayscale (1), Black and white (2). PrinterIndependentLayout Forbid use of printer metrics for layout. EmbedFonts Whether to embed fonts used by the document. EmbedSystemFonts Whether to embed system fonts used by the document. Table 4. Printing-related Properties in com.sun.star.document.Settings. Writer documents utilize the DocumentSettings service in the text module which doesn't contain any printing properties, but is far from empty. Again, use lodoc DocumentSettings text to visit its documentation in the text module. Instead, the print properties are inherited from the PrintSettings service in the text module, which are listed in Table 5. Use lodoc PrintSettings text to visit its documentation. Property Description PrintGraphics If true, print graphic objects. PrintTables If true, print text tables. PrintDrawings If true, print shapes. PrintLeftPages If true, print left pages. PrintRightPages If true, print right pages. PrintControls If true, then control shapes in the document (usually inside forms) are printed. PrintReversed If true, print the pages in reverse order, starting with the last page. PrintPaperFromSetup If true, use the paper tray specified for the system printer. If false, use the paper tray specified by the page style. PrintFaxName Name of the fax machine. PrintAnnotationMode Specify how notes are printed. Uses com.sun.star.text.NotePrintMode: NOT, ONLY, DOC_END, or PAGE_END). PrintProspect If true, prospect printing is used. Related to brochures (I think). PrintPageBackground Determines if the background color / background graphic of pages is printed. PrintBlackFonts Determines if characters are printed in black. PrintEmptyPages Determines if automatically inserted empty pages are printed. Table 5. Properties in com.sun.star.text.PrintSettings. Back in ShowPrintProps.java, the properties are printed with Props.showProps(). The output is quite lengthy since every setting is printed, not just the printing-related ones in my tables. Typical output when a Writer file is examined includes: : PrintAnnotationMode == 0 PrintBlackFonts == false PrintControls == true PrintDrawings == true PrintEmptyPages == false PrintFaxName == PrintGraphics == true PrintHiddenText == false PrintLeftPages == true PrintPageBackground == true PrintPaperFromSetup == false PrintProspect == false PrintProspectRTL == false PrintReversed == false PrintRightPages == true PrintSingleJobs == false PrintTables == true PrintTextPlaceholder == false PrinterIndependentLayout == 3 PrinterName == PrinterSetup == [B@1222c14 PropLineSpacingShrinksFirstLine == true ProtectForm == false RedlineProtectionKey == [B@6d8acf Rsid == 537223 : A Calc file uses the DocumentSettings service in the sheet module (use lodoc DocumentSettings sheet to examine its documentation). However, printing-related properties are stored elsewhere, in the GlobalSheetSettings and PageStyle services, which need additional code to access them as I'll explain later. An Impress file uses DocumentSettings in the presentation module (see lodoc DocumentSettings service presentation ); its printing-related properties are given in Table 6. Property Description IsPrintDrawing Enables or disables the printing of the drawing pages. IsPrintNotes Enables or disables the printing of the notes pages. IsPrintHandout Enables or disables the printing of the handout pages. IsPrintOutline Enables or disables the printing of the outline pages. IsPrintHiddenPages Enables or disables the printing of draw pages that are marked as hidden. IsPrintFitPage Enables or disables the fitting of the page to the printable area during printing. IsPrintTilePage If this is true and the paper size for printing is larger than the paper size of the printer than the content is tiled over multiple pages. Table 6. Printing-related Properties in com.sun.star.presentation.DocumentSettings. Draw documents are similar to presentations, and this is reflected in the DocumentSettings service in the drawing module (see lodoc DocumentSettings service drawing ) which offers a subset of the slide properties. The printing-related ones are listed in Table 7. Property Description IsPrintFitPage Enables or disables the fitting of the page to the printable area during printing. IsPrintTilePage If this is true and the paper size for printing is larger than the paper size of the printer than the content is tiled over multiple pages. Table 7. Printing-related Properties in com.sun.star.drawing.DocumentSettings. The drawing and presentation DocumentSettings services inherit the Settings service, and a HeaderFooterSettings service in the documents folder (see lodoc HeaderFooterSettings ), which add the properties in Table 8. Property Description IsPrintPageName Enables or disables the printing of the page name in the header or footer. IsPrintDate Enables or disables the printing of the date in the header or footer. IsPrintTime Enables or disables the printing of the current time in the header or footer. Table 8. Properties in com.sun.star.document.HeaderFooterSettings. 4.1. Additional Writer Print Properties \u00b6 As Figure 2 indicates, Writer Documents have access to an XPagePrintable interface offered by the GenericTextDocument service (see lodoc XPagePrintable ). It has a print method, XPagePrintable.printPages() which utilizes properties stored in the PagePrintSettings service (see Table 9). These relate to the document's margins and printing multiple pages on a single sheet. Property Description PageRows Number of page rows on each printed page. PageColumns Number of page columns on each printed page. LeftMargin Left margin of the printed page. RightMargin Right margin. TopMargin Top margin. BottomMargin Bottom margin. HoriMargin Margin between page rows. VertMargin Margin between page columns. IsLandscape Print in landscape format? Table 9. Properties in com.sun.star.text.PagePrintSettings. These properties are printed by casting the document to XPagePrintable: // part of ShowPrintProps.java... if ( docType == Lo . WRITER ) { XPagePrintable xpp = Lo . qi ( XPagePrintable . class , doc ); PropertyValue [] printProps = xpp . getPagePrintSettings (); Props . showProps ( \"Page print settings\" , printProps ); } Typical output is: Properties for \"Page print settings\": PageRows: 1 PageColumns: 1 LeftMargin: 0 RightMargin: 0 TopMargin: 0 BottomMargin: 0 HoriMargin: 0 VertMargin: 0 IsLandscape: false 4.2. Additional Calc Print Properties \u00b6 Figure 3 indicates that a Calc document has three sources of printing-related properties: DocumentSettings in the sheet module, GlobalSheetSettings also in the sheet module, and PageStyle in the style module. In a break with usual Office conventions, the GlobalSheetService service (see lodoc GlobalSheetSettings ) doesn\u2019t store the properties; instead they're maintained by its XGlobalSheetSettings interface (see lodoc XGlobalSheetSettings ). The printing- related properties are listed in Table 10. Property Description PrintAllSheets Specifies whether all sheets or only selected sheets are printed. PrintEmptyPages Specifies whether empty pages are printed. UsePrinterMetrics Specifies whether printer metrics are used for display. Table 10. Printing-related Properties in com.sun.star.sheet.XGlobalSheetSettings. This organization of the documentation may be an error, since the XGlobalSheetSettings properties are accessed in the usual way, by instantiating the GlobalSheetSettings service, and casting it to XPropertySet: XPropertySet globalSheetProps = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.sheet.GlobalSheetSettings\" ); Props . showProps ( \"Global Sheet Settings\" , globalSheetProps ); GlobalSheetSettings properties are applied to all sheets, so you may want to reset a changed property to its original value after a print. There's an example of using global sheet settings in PrintSheet.java later in this chapter. Another source of spreadsheet properties is the PageStyle service. I explained page styles in Chapter 22, so I refer you back there for the details. A page style is associated with a sheet, and so it's necessary to first choose a sheet to examine, and then access its \"PageStyle\" property: XSpreadsheetDocument ssDoc = Calc . getSSDoc ( doc ); XSpreadsheet sheet = Calc . getSheet ( ssDoc , 0 ); // first sheet String styleName = ( String ) Props . getProperty ( sheet , \"PageStyle\" ); System . out . println ( \"\\nPageStyle of first sheet: \" + styleName ); The page style name is used to lookup the properties for that particular style: XPropertySet props = Info . getStyleProps ( doc , \"PageStyles\" , styleName ); Props . showProps ( styleName + \" PageStyles\" , props ); Props.showProps() prints an extensive list of properties, drawn form several services in the PageStyle hierarchy. A simplified version of that hierarchy is shown in Figure 4. Figure 4. Part of the PageStyle Service Hierarchy. I'm only interested in printing-related properties in this chapter. Some come from the PageProperties service in the style module (see lodoc PageProperties style ), as listed in Table 11. Property Description Lots of border props\u2026 Lots of margin props\u2026 IsLandscape Determines if the page format is landscape. PrinterPaperTray Contains the name of a paper tray of the selected printer. Lots of header props\u2026 Lots of footer props\u2026 Lots of grid props\u2026 GridPrint Determines whether text grid lines are printed. Table 11. Printing-related Properties in com.sun.star.style.PageProperties. Many more print properties come from TablePageStyle in the sheet module (see lodoc TablePageStyle , which are given in Table 12. Property Description PrintAnnotations Enables printing of cell annotations. PrintGrid Enables printing of the cell grid. PrintHeaders Enables printing of column and row headers. PrintCharts Enables printing of charts. PrintObjects Enables printing of embedded objects. PrintDrawing Enables printing of drawing objects. PrintFormulas Enables printing of formulas instead of their results. PrintZeroValues Enables printing of zero-values. PrintDownFirst Specifies the print order for the pages within each sheet. PageScale Contains the scaling factor (in percent) for printing the sheet. ScaleToPages Contains the number of pages the sheet will use for printing. ScaleToPagesX Contains the number of horizontal pages the sheet will be printed on. ScaleToPagesY Contains the number of vertical pages the sheet will be printed on. LeftPageHeaderContent Contains the content of the header for the left pages (com.sun.star.sheet.XHeaderFooterContent). RightPageHeaderContent Contains the content of the header for the right pages (com.sun.star.sheet.XHeaderFooterContent). LeftPageFooterContent Contains the content of the footer for the left pages (com.sun.star.sheet.XHeaderFooterContent). RightPageFooterContent Contains the content of the footer for the right pages (com.sun.star.sheet.XHeaderFooterContent). Table 12. Printing-related Properties in com.sun.star.sheet.TablePageStyle. 5. Specialized Printing \u00b6 In this section I'll use some of the document properties just described to control how Writer, Impress, and Calc documents are printed. The example code is in TextPrinter.java, ImpressPrinter.java, SheetPrinter.java, and PrintSheet.java. The sad news is that although TextPrinter.java and ImpressPrinter.java successfully print their documents, the API ignores most of the changes to the properties. Perhaps even sadder (from a programming perspective) is the fact that these same documents are correctly printed if the properties are set via Office's GUI. Aside from this, the print GUI in Office offers more functionality than the API. For example, it's possible to output multiple slides and sheets on a single page through the print dialog but not with API calls. 5.1. Printing a Text Document \u00b6 TextPrinter.java sends a text document to a specified printer, with two pages printed on each sheet. After the document has been loaded, the printing is carried out by: // part of TextPrinter.java... XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); XPagePrintable xpp = Lo . qi ( XPagePrintable . class , doc ); PropertyValue [] props = xpp . getPagePrintSettings (); Props . setProp ( props , \"IsLandscape\" , true ); Props . setProp ( props , \"PageColumns\" , ( short ) 2 ); xpp . setPagePrintSettings ( props ); xpp . printPages ( new PropertyValue [ 1 ] ); // empty array of props To help understand what the code is doing, refer back to Figure 2. The document is cast to XPrintable so the printer settings can be initialized by Print.usePrinter(). Then the document is cast to XPagePrintable so its PagePrintSettings properties can be configured. That's done via XPagePrintable.setPagePrintSettings() and finally XPagePrintable.printPages() is called with an empty array. The document is printed but unfortunately the two pages/sheet and landscape settings are ignored. This bug has been known for many years, and some people have suggested an alternative implementation where the properties are passed to XPagePrintable.printPages() rather than to XPagePrintable.setPagePrintSettings(). The last two lines from above would be replaced by: xpp . printPages ( props ); Unfortunately this produces the same output in my tests. If the Writer document is printed through the Office GUI, then the print dialog looks something like Figure 5. Figure 5. The Writer application's Print Dialog. The pages/sheet settings are on the \"Page Layout\" tab, as in Figure 6. Figure 6. The \"Page Layout\" Tabbed Window in the Print Dialog. When \"Ok\" is pressed, the document is printed correctly. 5.2. Printing an Impress Document \u00b6 ImpressPrinter.java prints an Impress document to the specified printer in handout format, six slides per sheet, in black and white. A4 paper in landscape mode is utilized. After the document has been loaded, the printing is carried out by the following code: // part of ImpressPrinter.java... // set document props XPropertySet props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.presentation.DocumentSettings\" ); Props . setProperties ( props , new String [] { \"IsPrintHandout\" , \"SlidesPerHandout\" , \"IsPrintFitPage\" , \"IsPrintDate\" , \"PrintQuality\" , \"PrinterName\" }, new Object [] { true , ( short ) 6 , true , true , 2 , pName } // 2 == B&W ); Props . showProps ( \"Document Settings\" , props ); // set printer props XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); xp . setPrinter ( Props . makeProps ( \"PaperOrientation\" , PaperOrientation . LANDSCAPE , \"PaperFormat\" , PaperFormat . A4 ) ); Print . reportPrinterProps ( xp ); Print . print ( xp ); To help understand what the code is doing, refer back to Figure 2. A presentation DocumentSettings service is created, and its printing properties set. The \"PrintQuality\" and \"PrinterName\" properties are from the Settings service (see Table 4), \"IsPrintHandout\" and \"IsPrintFitPage\" are from DocumentSettings (see table 6), and \"IsPrintDate\" from HeaderFooterSettings (see Table 8). This leaves the \"SlidesPerHandout\" property, which isn't documented anywhere. I discovered it by looking at the print-out of that service's properties with: Props . showProps ( \"Document Settings\" , props ); The printer properties are set as in earlier examples, but with the addition of \"PaperOrientation\" and \"PaperFormat\" which are PrintDescriptor properties (see table 1). The document is printed but as one color slide per sheet; the handout and black and white settings are ignored. If the same Impress document is printed through the Office GUI, then the print dialog looks like Figure 7. Figure 7. The Impress application's Print Dialog. This is much closer to what I want to output, although I couldn't print the handouts in landscape mode. 5.3. Printing a Calc Document \u00b6 SheetPrinter.java prints the first sheet of a Calc document, scaled so that two pages are used in the vertical direction. Also, the paper is set to landscape mode and A4 size, and the header's central field is modified. In addition, commented-out code restricts the printed area of the sheet to be a single column. The good news is that all of these setting are correctly processed at print-time. After the document has been loaded, the printing is carried out by: // part of SheetPrinter.java... XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // first sheet String styleName = ( String ) Props . getProperty ( sheet , \"PageStyle\" ); // get the properties set for the sheet's page style XPropertySet props = Info . getStyleProps ( doc , \"PageStyles\" , styleName ); Props . setProperty ( props , \"ScaleToPagesY\" , ( short ) 2 ); // use a max of 2 pages on the y-axis Props . showProps ( styleName , props ); showTotalsHeader ( props ); /* // print only the \"E\" column XPrintAreas printAreas = Lo.qi(XPrintAreas.class, sheet); printAreas.setPrintAreas(new CellRangeAddress[] {}); // reset print areas CellRangeAddress addr = Calc.getAddress(sheet, \"E1:E111\"); printAreas.setPrintAreas(new CellRangeAddress[]{ addr }); // set area */ // set printer settings XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); PropertyValue [] printProps = Props . makeProps ( \"PaperOrientation\" , PaperOrientation . LANDSCAPE , \"PageFormat\" , PaperFormat . A4 ); xp . setPrinter ( printProps ); Print . reportPrinterProps ( xp ); Print . print ( xp ); The scaling is done by accessing the sheet's page style properties, and setting the \"ScaleToPagesY\" value. This is one of the TablePageStyle properties listed in Table 12. Headers and Footers \u00b6 The headers and footers are manipulated by showTotalsHeader(): // in SheetPrinter.java private static void showTotalsHeader ( XPropertySet props ) // change the header of the sheet { // get the right-hand header and footer XHeaderFooterContent header = Calc . getHeadFoot ( props , \"RightPageHeaderContent\" ); XHeaderFooterContent footer = Calc . getHeadFoot ( props , \"RightPageFooterContent\" ); // print details about them Calc . printHeadFoot ( \"Right Header\" , header ); Calc . printHeadFoot ( \"Right Footer\" , footer ); // modify the header center text to be \"Totals\" Calc . setHeadFoot ( header , Calc . HF_CENTER , \"Totals\" ); // turn on headers and make left and right page headers the same Props . setProperty ( props , \"HeaderIsOn\" , true ); Props . setProperty ( props , \"HeaderIsShared\" , true ); // from style.PageProperties Props . setProperty ( props , \"RightPageHeaderContent\" , header ); } // end of showTotalsHeader() A sheet may have two headers (one for the left hand page, one for the right) and two footers, which are accessed as XHeaderFooterContent objects (see lodoc XHeaderFooterContent ). XHeaderFooterContent is a collection of three XText instances representing the left, center, and right of the content area. The headers and footers are accessed via the sheet's page style properties, stored as the properties \"LeftPageHeaderContent\", \"RightPageHeaderContent\", \"LeftPageFooterContent\", and \"RightPageFooterContent\" in the TablePageStyle service (see Table 12). Calc.getHeadFoot() retrieves the page style properties, and returns the requested XHeaderFooterContent: // in the Calc class public static XHeaderFooterContent getHeadFoot ( XPropertySet props , String content ) { return Lo . qi ( XHeaderFooterContent . class , Props . getProperty ( props , content )); } Calc.printHeadFoot() prints the three text fields inside the XHeaderFooterContent object: // in the Calc class public static void printHeadFoot ( String title , XHeaderFooterContent hfc ) { XText left = hfc . getLeftText (); XText center = hfc . getCenterText (); XText right = hfc . getRightText (); System . out . println ( title + \": \\\"\" + left . getString () + \"\\\" : \\\"\" + center . getString () + \"\\\" : \\\"\" + right . getString () + \"\\\"\" ); } // end of showHeadFoot() Calc.setHeadFoot() can change the text in the left, center, or right of a XHeaderFooterContent instance: // in the Calc class public static void setHeadFoot ( XHeaderFooterContent hfc , int region , String text ) { XText xText = getRegion ( hfc , region ); if ( xText == null ) { System . out . println ( \"Could not set text\" ); return ; } XTextCursor headerCursor = xText . createTextCursor (); headerCursor . gotoStart ( false ); headerCursor . gotoEnd ( true ); headerCursor . setString ( text ); } // end of setHeadFoot() public static XText getRegion ( XHeaderFooterContent hfc , int region ) { if ( hfc == null ) { System . out . println ( \"Header/footer content is null\" ); return null ; } if ( region == HF_LEFT ) return hfc . getLeftText (); else if ( region == HF_CENTER ) return hfc . getCenterText (); else if ( region == HF_RIGHT ) return hfc . getRightText (); else { System . out . println ( \"Unknown header/footer region\" ); return null ; } } // end of getRegion() Back in SheetPrinter.java, showTotalsHeader() changes the central text field of the right header to \"Totals\". It then switches on the display of headers, makes the left and right headers the same, and inserts the modified XHeaderFooterContent instance back into the page styles: // part of showTotalsHeader() in SheetPrinter.java... Props . setProperty ( props , \"HeaderIsOn\" , true ); Props . setProperty ( props , \"HeaderIsShared\" , true ); // from style.PageProperties Props . setProperty ( props , \"RightPageHeaderContent\" , header ); Print Areas \u00b6 A sheet is usually manipulated via the XSpreadsheet interface in the Spreadsheet service. However, Spreadsheet supports a number of other interfaces, including XPrintAreas for specifying printable areas within a sheet. This interface is illustrated in Figure 8. Figure 8. The Spreadsheet XPrintAreas Interface. Aside from defining printable areas, XPrintAreas also has methods for setting which rows and/or columns are repeated if a sheet spans several pages. The commented out code in SheetPrinter.java does two things: it cancels any existing print areas, and specifies that only the \"E\" column will be printed: // part of SheetPrinter.java... XPrintAreas printAreas = Lo . qi ( XPrintAreas . class , sheet ); printAreas . setPrintAreas ( new CellRangeAddress [] {}); // cancel print areas CellRangeAddress addr = Calc . getAddress ( sheet , \"E1:E111\" ); printAreas . setPrintAreas ( new CellRangeAddress [] { addr }); // set area to be the \"E\" column 5.4. Printing a Single Sheet \u00b6 My thanks to user \"villeroy\" on the OpenOffice forums for suggesting this example: how is a single sheet of a multi-sheet spreadsheet printed? One part of the solution is to set the \"PrintAllSheets\" property to false in the GlobalSheetSettings service (see Table 10). The other is to make the current sheet explicitly active in the XSpreadsheetView interface, which is equivalent to bringing the sheet to the foreground in the Calc application. The PrintSheet.java example shows how to do this for a spreadsheet of three sheets, where only \"Sheet2\" is printed: // in PrintSheet.java public static void main ( String args [] ) { // hardwired spreadsheet and printer choice String fnm = \"tables.ods\" ; String pName = \"FinePrint\" ; // load the spreadsheet XComponentLoader loader = Lo . loadOffice (); XComponent cDoc = Lo . openReadOnlyDoc ( fnm , loader ); XSpreadsheetDocument doc = Calc . getSSDoc ( cDoc ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } // what are the sheets called? String [] sheetNms = Calc . getSheetNames ( doc ); System . out . println ( \"Names of sheets (\" + sheetNms . length + \"):\" ); for ( String sheetNm : sheetNms ) System . out . println ( \" \" + sheetNm ); // make \"Sheet2\" active XSpreadsheet sheet = Calc . getSheet ( doc , \"Sheet2\" ); Calc . setActiveSheet ( doc , sheet ); // set Global Sheet settings // changes are remembered XPropertySet gsProps = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.sheet.GlobalSheetSettings\" ); Props . setProperty ( gsProps , \"PrintAllSheets\" , false ); System . out . println (); Props . showProps ( \"Global Sheet Settings\" , gsProps ); // set printer settings XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); PropertyValue [] printProps = Props . makeProps ( \"PaperOrientation\" , PaperOrientation . LANDSCAPE , \"PageFormat\" , PaperFormat . A4 ); xp . setPrinter ( printProps ); Print . print ( xp ); // reset global settings Props . setProperty ( gsProps , \"PrintAllSheets\" , true ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() One issue with changing GlobalSheet settings is that they are remembered after Office has closed, and will be used by default during future prints. In that case, it's a good idea to reset the \"PrintAllSheets\" to true after the Print.print() call. 6. A Bad Idea: Hacking the GUI \u00b6 A recurring observation of the last few sections is that printer dialogs inside Office are less buggy and more feature-rich than the API. In previous chapters, I've sometimes resorted to using Office's GUI by sending dispatch messages, and key presses to the window. I decided not to follow that approach here since it's too unreliable. Getting to the print dialog is straightforward. The document window is made visible, and an \".uno:Print\" dispatch opens the print dialog: GUI.setVisible(doc, true); Lo.delay(1000); // give the Office window time to appear Lo.dispatchCmd(\"Print\"); Lo.delay(500); // give the Print dialog time to appear The first problem is that the print dialog uses tabbed windows, and the window that's foremost can vary. Usually it's the \"General\" window (e.g. see Figure 5), but if the user has previously clicked the \"Ok\" button in another tabbed window (such as the \"Page Layout\" window in Figure 6) then that window will be foremost when the print dialog is next invoked. This means that my code cannot be sure which tabbed window is active after the \"Print\" dispatch. There's also the issue of moving around the tabbed windows and their fields. This can be implemented using Java's Robot class to send TAB and CTRL-TAB characters, as in: private static void ctrlTab () // send a CTRL-TAB character combination { try { Robot robot = new Robot (); robot . keyPress ( KeyEvent . VK_CONTROL ); robot . keyPress ( KeyEvent . VK_TAB ); robot . delay ( 100 ); robot . keyRelease ( KeyEvent . VK_TAB ); robot . keyRelease ( KeyEvent . VK_CONTROL ); } catch ( AWTException e ) { System . out . println ( e ); } } // end of ctrlTab() The difficulty is knowing how many TABs and CTRL-TABs are needed, which depends on the tab ordering of each window. Even if my code somehow managed to get to the correct field in the correct tabbed window, there's still the problem of entering data and 'pressing' the \"Ok\" button afterwards. On balance, I decided not to bother implementing this 'solution'. 7. Command Prompt Printing \u00b6 Another approach to printing documents, which avoids the use of Java, is to utilize command line utilities. There's no shortage of command line printing tools in Linux and the Mac OS, based around the CUPS printing system ( https://cups.org/ ), and plenty of sites explaining how to use lp, lpq, lpstat and others (e.g. https://computerhope.com/unix/ulp.htm , https://eecs.utk.edu/resources/it/kb/printing/linux-command-line/ ). Perhaps less well known are the printing utilities in Windows, listed in Table 13. VBScript Purpose Prnmngr.vbs Printer management. Adds, deletes, and lists printers or printer connections, in addition to setting and displaying the default printer. Used by printersList.bat Prncnfg.vbs Configures or displays configuration information about a printer. Used by printerStatus.bat Prnjobs.vbs Pauses, resumes, cancels, and lists print jobs. Used by printerJobs.bat Prnqctl.vbs Printer queue management. Prints a test page, pauses or resumes a printer, and clears a printer queue. Used by printerClean.bat Prndrvr.vbs Adds, deletes, and lists printer drivers. Prnport.vbs Printer port management. Pubprn.vbs Publish a printer to Active Directory. Table 13. Windows 7's VBScript Printing Utilities. The utilities are Visual Basic scripts, located in the C:\\Windows\\System32\\Printing_Admin_Scripts\\en-US folder which isn't a standard part of Window's PATH environment variable. One way of finding documentation on these tools is by starting \"Windows Help\" and then following the links to the commands reference section. This will eventually take you to Microsoft's TechNet website. A slightly easier alternative is the TechRepublic article \"How to take advantage of the hidden VBScript print utilities in Windows 10\" by Greg Shultz at https://techrepublic.com/article/how-to-take-advantage-of-the-hidden-vbscript-print-utilities-in-windows-10/ . In my \"Printing Tests\" examples folder, there are four Batch files (printersList.bat, printerStatus.bat, printerJobs.bat, and printerClean.bat) which use these VBScripts in simple ways. printersList.bat lists the names of all the print services visible to Windows, and also the name of the default printer. For example: > printersList Printer name Send To OneNote 2010 Printer name Ricoh Aficio MP 2000 PCL(Black Office Room) Printer name PrinterShare Printer name Print to Evernote Printer name Microsoft XPS Document Writer Printer name HPLJM806 (HP LaserJet M806) Printer name HP LaserJet9040DN PCL 6(Office) Printer name HP LaserJet M806 PCL 6 Printer name HP LaserJet 1200 Series PCL 6 Printer name Foxit PhantomPDF Printer Printer name FinePrint Printer name Fax The default printer is FinePrint These names can be used as printer name arguments in my earlier Java programs. printerStatus.bat reports the status of a printer: > printerStatus \"HP LaserJet 1200 Series PCL 6\" Printer status Idle Extended printer status Unknown printerJobs.bat lists all the print jobs currently on a printer's queue: > printerJobs \"HP LaserJet 1200 Series PCL 6\" Number of print jobs enumerated 0 printerClean.bat deletes all the jobs on a printer queue: > printerClean \"HP LaserJet 1200 Series PCL 6\" Microsoft (R) Windows Script Host Version 5.8 Copyright (C) Microsoft Corporation. All rights reserved. Success Purge Printer HP LaserJet 1200 Series PCL 6 Notably missing from the VBScripts is a way to print a document, perhaps because Windows already has an awesome \"print\" command: > print /? Prints a text file. PRINT [/D:device] [[drive:][path]filename[...]] /D:device Specifies a print device. An alternative is \"printui\" which starts Window's printui.dll ( https://technet.microsoft.com/en-us/library/ee624057(v=ws.11).aspx ). However, I'd not recommend \"print\" or \"printui\" since Office is a much better command line printing tool. If you open a command prompt in the Office directory (e.g. in C:\\Program Files\\LibreOffice 5), you can get a list of its command line options by typing: > soffice.exe \u2013h Figure 9 shows the top half of a long window. Figure 9. Some of Office Command Line Arguments. Another information source is the \"Starting the LibreOffice Software With Parameters\" webpage at https://help.libreoffice.org/Common/Starting_the_Software_With_Parameters/ . The relevant parameters for printing are \"-p\" and \"--pt\", which can be seen near the bottom of Figure 9. \"-p\" prints a file to the default printer, while \"--pt\" (note the two '- 's) sends the document to the named printer. A suitable name can be obtained from the printersList.bat script. I've utilized these parameters in a loprint.bat script in the \"Printing Tests\" folder. If loprint is called with no arguments, then Figure 9's help window is displayed. If a filename argument is supplied then the document is sent to the default printer using the '-p' parameter. Two arguments are assumed to be a printer name and filename, and are processed by \"--pt\". For example: > loprint \"HP LaserJet 1200 Series PCL 6\" cover.odg prints the cover.odg Draw file to the HP laserjet.","title":"Chapter 41. Printing"},{"location":"41-Printing.html#chapter-41-printing","text":"Topics The Java Print Service (JPS); Printing in Office Writer, Impress, Calc; Viewing a Document's Print Properties; Specialized Printing: Writer, Impress, Calc; Hacking the GUI; Command Prompt Printing Example folders: \"Printing Tests\" and \"Utils\" Java's Print Service (JPS) and Office's printing APIs nicely compliment each other. For example, since Java 1.4 (February 2002), JPS has included printer discovery based on document types and printer attributes. but Office's API lacks such capabilities. JPS cannot easily print much beyond text and images; binary data can be sent to a printer, but it's left to the device to interpret and render it, which is only possible in high-end printers, not ordinary inkjets and laser printers. In contrast, Office can print a very wide range of document formats, including ODF, Microsoft, and PDF files. This chapter starts by describing JPS's PrintService, which I'll use later to select a printer for the Office API. Then there's an overview of the printing capabilities of the Office API, with examples of how to print Writer, Impress, and Calc files. The bad news is that Office's printing API has a few bugs and missing features. By 'missing' I mean parts of Office's printing GUI with no equivalents in the API. Also, buggy features in the API, such as the printing of multiple pages/sheet and slide handouts, work flawlessly in the GUI. I'll finish with a short discussion of command line printing in Windows. The OS has several print utilities that are a little hard to find and use. Also, Office can be started from the command line in order to print documents.","title":"Chapter 41. Printing"},{"location":"41-Printing.html#1-the-java-print-service-jps","text":"Java 1.4 saw the introduction of the Java Print service (JPS) API which allows a printer to be selected based on document types and attributes such as color output, paper sizes, and double-sided printing. JPS printing passes through four stages: Selection of a print service (i.e. a printer or print driver), represented by a PrintService instance. The programmer can supply document types and printer attributes to limit the search. Creation of a Doc object for the document that's to be printed. Creation of a print job combining the Doc object and print request attributes. A listener can be attached to monitor what's happening during the printing. The printing is started, and performed asynchronously. Document types are encoded as DocFlavor objects which contain data source details (e.g. whether the document comes from an input stream or a URL), and a MIME type (e.g. image/gif, application/pdf). A common misconception about DocFlavor is that it means that Java can print that kind of document. A DocFlavor is used to check whether a printer supports a document type, and the answer may be \"no\". The following code locates print services that support GIF documents sent from a file: // stage 1: find print services for GIF files DocFlavor gifFlavor = DocFlavor . INPUT_STREAM . GIF ; PrintService [] services = PrintServiceLookup . lookupPrintServices ( gifFlavor , null ); The matching print services are returned in a PrintService[] array. lookupPrintServices()'s second argument (which is null here) could be a set of print request attributes (PRAs). There are four kinds of print attributes. The first two are requests sent from a program to the printer, which may be accepted or rejected: Print request attributes (PRA) ask for particular printing features, such as two- sided output, or a paper size. Doc attributes (DA) supply information about a document, such as its page size, use of color, or page ranges for printing. The two other attributes types are used by the printer service to convey information about the printer and job back to the program. Print service attributes (PSA) give information about the print service, such as the printer's make and model or whether it is currently accepting jobs. Print job attributes (PJA) give information about the status of a particular print job, such as whether it has successfully finished. The following code fragment looks for printer services that can print on both sides of A4 paper: // stage 1 example using attributes AttributeSet attrs = new HashAttributeSet (); attrs . add ( MediaSizeName . ISO_A4 ); attrs . add ( Sides . DUPLEX ); PrintService [] services = PrintServiceLookup . lookupPrintServices ( null , attrs ); AttributeSet is an interface and HashAttributeSet an implementation which supports the four kinds of attributes. The easiest way to find out about particular attribute is via the Attribute interface documentation at https://docs.oracle.com/javase/8/docs/api/index.html?java/util/jar/Attributes.html , which lists the attribute subclasses, such as MediaSizeName and Sides used in the example above. The next fragment creates a Doc object for a GIF file, a stage 2 task in JPS printing: // stage 2 : create a Doc object for a GIF file FileInputStream in = new FileInputStream ( fileName ); Doc doc = new SimpleDoc ( in , gifFlavor , null ); The third argument of the SimpleDoc constructor can be a set of document attributes (DAs). JPS stage 3 involves the creation of a print job, and perhaps a listener: // stage 3: print job creation DocPrintJob job = service [ 0 ] . createPrintJob (); job . addPrintJobListener ( new PrintJobAdapter () {...} ); The listener will receive information about the print job's progress as print job attributes (PJAs). Stage 4 starts the printing: job . print ( doc , null ); The second argument of print() can be a set of print request attributes (PRAs).","title":"1.  The Java Print Service (JPS)"},{"location":"41-Printing.html#11-listing-the-printers","text":"The ListPrinters.java example in this section focuses on JPS stage 1. It prints short details about all the available printers, fuller information about the default printer, and a list of printer names. The main() function: // in ListPrinters.java public static void main ( String [] args ) { JPrint . listServices (); // short info // JPrint.listServices(true); // full info, but slow to generate PrintService ps = PrintServiceLookup . lookupDefaultPrintService (); System . out . println ( \"Default printer \\\"\" + ps . getName () + \"\\\":\" ); JPrint . listService ( ps , true ); // full info on default printer String [] pNames = JPrint . getPrinterNames (); System . out . println ( \"Printer names (\" + pNames . length + \"):\" ); for ( String pName : pNames ) System . out . println ( \" \" + pName ); } // end of main() Most of the functionality is implemented by the JPrint.java utility class. JPrint.listServices() on one of my test machines prints the following: -------- Print services (16) ---------- 1. \"Send To OneNote 2010\" color-supported:supported printer-name:Send To OneNote 2010 queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream 2. \"Ricoh Aficio MP 2000 PCL(Black Office Room)\" color-supported:not-supported printer-name:Ricoh Aficio MP 2000 PCL(Black Office Room) queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream : : 16. \"CutePDF Writer\" color-supported:supported printer-name:CutePDF Writer queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream application/postscript The information for each printer consists of four attributes, including its name and the MIME types that it can process. For example, the Ricoh Aficio MP 2000 printer can deal with standard graphics formats and \"application/octet-stream\". This latter type means that the printer will accept binary printer data, but doesn't mean that it can correctly print it. For instance, it may be output as a mishmash of ASCII characters. The service listing methods in JPrint.java: // in the JPrint class public static void listServices ( boolean showAll ) { PrintService [] psa = PrintServiceLookup . lookupPrintServices ( null , null ); listServices ( psa , showAll ); } public static void listServices ( PrintService [] psa , boolean showAll ) { if ( psa != null && psa . length > 0 ) { System . out . println ( \"\\n-------- Print services (\" + psa . length + \") ----------\\n\" ); for ( int i = 0 ; i < psa . length ; i ++ ) { System . out . println (( i + 1 ) + \". \\\"\" + psa [ i ] . getName () + \"\\\"\" ); listService ( psa [ i ] , showAll ); } System . out . println ( \"------------------\\n\" ); } else System . out . println ( \"No print services found\" ); } // end of listServices() public static void listService ( PrintService ps , boolean showAll ) { // print basic attributes Attribute [] attrs = ps . getAttributes (). toArray (); for ( Attribute attr : attrs ) System . out . println ( \" \" + attr . getName () + \":\" + attr ); // print the supported MIME types System . out . print ( \" Supported doc types: \" ); DocFlavor [] flavors = ps . getSupportedDocFlavors (); for ( int j = 0 ; j < flavors . length ; j ++ ) { // Filter out DocFlavors that have a representation class other // than java.io.InputStream. String repclass = flavors [ j ] . getRepresentationClassName (); if ( ! repclass . equals ( \"java.io.InputStream\" )) // restrict to files continue ; System . out . print ( \" \" + flavors [ j ] . getMimeType ()); } System . out . println (); // print every printer attribute if ( showAll ) { System . out . println ( \" ----\" ); ArrayList < NamedAttribute > attrList = getAttributes ( ps ); Collections . sort ( attrList ); for ( NamedAttribute attr : attrList ) printAttr ( ps , attr . getAttribute ()); } System . out . println (); } // end of listService() The lookupPrintServices() call in listServices(): PrintServiceLookup . lookupPrintServices ( null , null ) has no DocFlavor or attribute arguments, so every printer service will be returned in the array. listServices() iterates through each PrintService object, and prints its basic attributes, the supported MIME types for files, and optionally a list of every printer attribute. The four attributes returned by PrintService.getAttributes() are the tip of a very large iceberg. Java supports a multitude of attributes as seen if you look at the Java 8 Attribute documentation at https://docs.oracle.com/javase/8/docs/api/javax/print/attribute/Attribute.html . Over 70 subclasses are listed, including PrinterName, Sides, and Chromacity. A taste of what can be printed occurs when the default printer's details are listed: // in ListPrinters.java... PrintService ps = PrintServiceLookup . lookupDefaultPrintService (); System . out . println ( \"Default printer \\\"\" + ps . getName () + \"\\\":\" ); JPrint . listService ( ps , true ); // full info The default printer for my test machine is an old laser printer. ListPrinter.java reports the following: Default printer \"HP LaserJet 1200 Series PCL 6\": color-supported:not-supported printer-name:HP LaserJet 1200 Series PCL 6 queued-job-count:0 printer-is-accepting-jobs:accepting-jobs Supported doc types: image/gif image/jpeg image/png application/octet-stream ---- chromaticity: color copies-supported: null ipp-attribute-fidelity: false job-name: Java Printing media: iso-a4 media-printable-area: (4.233,4.233)->(197.951,288.459)mm orientation-requested: portrait page-ranges: 1-2147483647 printer-resolution: 60000x60000 dphi requesting-user-name: Ad sheet-collate: uncollated sides: one-sided spool-data-destination: file:/C:/Users/Ad/Desktop/LibreOffice%20Tests/Printing%20Tests/o ut.prn sun-alternate-media: null The \"chromacity\" attribute states how color and monochrome documents are mapped to each other. Probably the attribute the user really wants to examne is \"color- supported\" which shows that this printer only offers grayscales. The main drawback of printing all these attributes is the time required to collect them, sort them, and remove duplicates; each printer may take several seconds to process.","title":"1.1.  Listing the Printers"},{"location":"41-Printing.html#12-discovering-print-services","text":"PrintServiceLookup.lookupPrintServices() should be called with DocFlavor and/or print request attributes to narrow down the search. Some examples can be found in Discovery.java. For instance, the following fragment looks for printers that can process JPEG files: // in Discovery.java... DocFlavor flavor = DocFlavor . INPUT_STREAM . JPEG ; PrintService [] psa = PrintServiceLookup . lookupPrintServices ( flavor , null ); System . out . println ( \"\\nServices that support \" + flavor ); String [] pNames = JPrint . getPrinterNames ( psa ); if ( pNames != null ) for ( String pName : pNames ) System . out . println ( \" \" + pName ); It's very likely that the printers listed by this search can also output PDF, Word, PowerPoint and other file formats printable from Office, since Office delivers pages to a printer rendered as images. However, if a search is made for printers that can process PDF files: DocFlavor flavor = DocFlavor . INPUT_STREAM . PDF ; PrintService [] psa = PrintServiceLookup . lookupPrintServices ( flavor , null ); then no matches are found. This means that none of the printers can process PDF by themselves. JPrint.findPrinterNames() lets printers be selected based on partial names. The following call collects all the printers whose names include \"HP\": String[] pNames = JPrint.findPrinterNames(\"HP\"); Multiple attributes can be used in a search. The following looks for all the \"HP\" printer services that support color: // in Discovery.java... AttributeSet attrs = new HashAttributeSet (); System . out . println ( \"\\nHP Services that support color:\" ); PrintService [] psa ; for ( String pName : pNames ) { // from the \"HP\" search above attrs . clear (); attrs . add ( new PrinterName ( pName , null )); // must be included attrs . add ( ColorSupported . SUPPORTED ); psa = PrintServiceLookup . lookupPrintServices ( null , attrs ); if ( psa . length > 0 ) System . out . println ( \" \" + pName ); } It's possible to look for color printers with less code: // in Discovery.java... AttributeSet attrs = new HashAttributeSet (); attrs . add ( ColorSupported . SUPPORTED ); PrintService [] psa = PrintServiceLookup . lookupPrintServices ( null , attrs ); Unfortunately the returned print services include non-color printers. It seems that the printer name must be part of the attribute set to get a correct match. DocFlavors and attributes can be combined, as in the following that looks for a printer that supports JPEG and A4 paper: // in Discovery.java... DocFlavor flavor = DocFlavor . INPUT_STREAM . JPEG ; AttributeSet attrs = new HashAttributeSet (); attrs . add ( MediaSizeName . ISO_A4 ); PrintService [] psa = PrintServiceLookup . lookupPrintServices ( flavor , attrs ); A quite different printer selection approach is to display a dialog box at run time to let the user set the search criteria. Java offers ServiceUI.printDialog() for this, which I've wrapped inside JPrint.dialogSelect(): // in the JPrint class public static PrintService dialogSelect () { GUI . setLookFeel (); PrintService psa [] = PrintServiceLookup . lookupPrintServices ( null , null ); PrintService defaultService = PrintServiceLookup . lookupDefaultPrintService (); PrintRequestAttributeSet attrs = new HashPrintRequestAttributeSet (); // none PrintService service = ServiceUI . printDialog ( null , 100 , 100 , psa , defaultService , null , attrs ); if ( service == null ) System . out . println ( \"No print service selected\" ); return service ; } // end of dialogSelect() dialogSelect() initializes ServiceUI.printDialog() with a list of printer services, the default printer, and an empty print request attribute set. In Discovery.java, JPrint.dialogSelect() is called like so: // in Discovery.java... PrintService ps = JPrint . dialogSelect (); if ( ps != null ) { System . out . println ( \"\\nYou selected \" + ps . getName ()); JPrint . listService ( ps , true ); // full info } The dialog looks like Figure 1. Figure 1. The ServiceUI.printDialog() Dialog. Pressing the \"Print\" button returns a PrintService reference; pressing \"Cancel\" returns null.","title":"1.2.  Discovering Print Services"},{"location":"41-Printing.html#13-printing-using-java","text":"After a print service has been selected, JPS stages 2-4 involve instantiating a Doc object, creating a print job, and starting the printing. These are managed by my JPrint.printFile(): // in the JPrint class public static void printFile ( PrintService ps , String fnm ) { if ( ps == null ) { System . out . println ( \"Print service is null\" ); return ; } DocPrintJob printJob = ps . createPrintJob (); // stage 2 try { InputStream is = new FileInputStream ( fnm ); DocFlavor flavor = getFlavor ( ps , fnm ); Doc doc = new SimpleDoc ( is , flavor , null ); // stage 3 printJob . print ( doc , null ); // stage 4 is . close (); } catch ( Exception e ) { System . out . println ( \"Unable to print \" + fnm ); System . out . println ( e ); } } // end of printFile() The user supplies a PrintService and a filename. A DocFlavor for the file is obtained by JPrint.getFlavor(): // in the JPrint class public static DocFlavor getFlavor ( PrintService ps , String fnm ) { DocFlavor flavor = getFlavorFromFnm ( fnm ); System . out . println ( \"File-based DocFlavor: \" + flavor ); if ( ! ps . isDocFlavorSupported ( flavor )) { System . out . println ( \"Not supported by printer; using autosense\" ); flavor = DocFlavor . INPUT_STREAM . AUTOSENSE ; } return flavor ; } // end of getFlavor() public static DocFlavor getFlavorFromFnm ( String fnm ) { String ext = fnm . substring ( fnm . lastIndexOf ( '.' ) + 1 ). toLowerCase (); if ( ext . equals ( \"gif\" )) return DocFlavor . INPUT_STREAM . GIF ; else if ( ext . equals ( \"jpeg\" )) return DocFlavor . INPUT_STREAM . JPEG ; else if ( ext . equals ( \"jpg\" )) return DocFlavor . INPUT_STREAM . JPEG ; else if ( ext . equals ( \"png\" )) return DocFlavor . INPUT_STREAM . PNG ; else if ( ext . equals ( \"ps\" )) return DocFlavor . INPUT_STREAM . POSTSCRIPT ; else if ( ext . equals ( \"pdf\" )) return DocFlavor . INPUT_STREAM . PDF ; else if ( ext . equals ( \"txt\" )) return DocFlavor . INPUT_STREAM . TEXT_PLAIN_HOST ; else // try to determine flavor from file content return DocFlavor . INPUT_STREAM . AUTOSENSE ; } // end of getFlavorFromFnm getFlavorFromFnm() uses the file's extension to choose a DocFlavor.INPUT_STREAM constant, which is checked by the print service in PrintService.isDocFlavorSupported(). JPrint.printFile() is utilized in my JDocPrinter.java example: // in JDocPrinter.java public static void main ( String [] args ) { if (( args . length < 1 ) || ( args . length > 2 )) { System . out . println ( \"Usage: java JDocPrinter <filename> [<(partial)printer-name>]\" ); return ; } String fnm = args [ 0 ] ; String pName = null ; if ( args . length == 2 ) { String [] pNames = JPrint . findPrinterNames ( args [ 1 ] ); if ( pNames != null ) { System . out . println ( \"Using first match: \\\"\" + pNames [ 0 ] + \"\\\"\" ); pName = pNames [ 0 ] ; } } if ( pName != null ) JPrint . print ( pName , fnm ); else { PrintService ps = JPrint . dialogSelect (); if ( ps != null ) // JPrint.printMonitorFile(ps, fnm); JPrint . printFile ( ps , fnm ); } } // end of main() JPrint.printMonitorFile() is fancier version of JPrint.printFile() which attaches a PrintJobListener to the print job. The listener's methods are triggered as the job passes through its printing states such as its delivery to the printer, completion, cancellation, or printing error. The lines in JPrint.printMonitorFile() that add the listener to the print job are: // in JPrint.printMonitorFile()... DocPrintJob printJob = ps . createPrintJob (); printJob . addPrintJobListener ( new PJWatcher ()); PJWatcher implements the PrintJobListener interface: // in the JPrint class private static class PJWatcher implements PrintJobListener { public void printDataTransferCompleted ( PrintJobEvent pje ) { System . out . println ( \" >> Data transferred to printer\" ); } public void printJobCanceled ( PrintJobEvent pje ) { System . out . println ( \" >> Print job was cancelled\" ); } public void printJobCompleted ( PrintJobEvent pje ) { System . out . println ( \" >> Print job completed successfully\" ); } public void printJobFailed ( PrintJobEvent pje ) { System . out . println ( \" >> Print job failed\" ); } public void printJobNoMoreEvents ( PrintJobEvent pje ) { System . out . println ( \" >> No more events will be delivered\" ); } public void printJobRequiresAttention ( PrintJobEvent pje ) { System . out . println ( \" >> Print job needs attention\" ); } } // end of PJWatcher class","title":"1.3.  Printing Using Java"},{"location":"41-Printing.html#14-more-information-on-javaxprint","text":"Good sources of information on Java printing include the tutorial at https://docs.oracle.com/javase/tutorial/2d/printing/ which covers JPS and the older Java 2D printing API, and the JPS API user guide at https://docs.oracle.com/javase/8/docs/technotes/guides/jps/spec/JPSTOC.fm.html . Two books I've found useful: Core Java, Volume II -- Advanced Features Cay S. Horstmann; Gary Cornell Prentice Hall, 2016, 10 th ed. https://horstmann.com/corejava.html Chapter 7 includes a section on printing, including a table of attributes. Pro Java 8 Programming Terrill Brett Spell Apress, 2015, 3 rd ed. https://apress.com/9781484206423/ Chapter 11 is about printing.","title":"1.4.  More Information on javax.print"},{"location":"41-Printing.html#2-printing-in-office","text":"In this section I'll employ the print service search methods in JPrint.java to find a printer for Office. The service name is passed to functions that use the Office API to send a document to the printer. Only a handful of Office methods are required to print a document; the real complexity of the API is the multitude of properties which configure how the document is output. Not surprisingly, these properties are spread across many modules since different document types (i.e. Writer, Draw, Impress, and Calc) are managed by different parts of the API. Figure 2 shows the OfficeDocument services and their print-related interfaces. The words in brackets are the modules where the services are located. The rounded rectangles refer to print property tables explained later in this chapter. Figure 2. The OfficeDocument Interface and its Print-related Interfaces. The XPrintable interface is used when printing Writer, Draw, Impress, or Calc documents since their services all inherit OfficeDocument. Writer documents can also employ XPagePrintable for printing. Note that it isn't possible to print databases using XPrintable. OfficeDocument also has XPrintJobBroadcaster and XPrintableBroadcaster interfaces for attaching listeners to a print job. However, XPrintableBroadcaster is no longer supported, having been superseded by XPrintJobBroadcaster . The tricky aspects of XPrintable, XPrintJobBroadcaster, and XPagePrintable are the properties used to configure how they work. XPrintable.getPrinter() and XPrintable.setPrinter() utilize PrintDescriptor properties, the XPrintJobListener created by XPrintJobBroadcaster uses PrintableState properties, XPrintable.print() uses PrintOptions, and XPagePrintable employs PagePrintSettings. I'll be explaining all of these in due course, with the aid of the tables referred to in Figure 2. We're not finished with properties yet. There's also several \"XXXSettings\" services which configure printing properties within a document. These are summarized by Figure 3. Figure 3. The Setting Services. The rounded rectangles refer to property tables described later in this chapter.","title":"2.  Printing in Office"},{"location":"41-Printing.html#3-printing-any-document","text":"At this point you may be thinking that Office printing is rather complex. In fact, if you're happy to print a document using the default printing settings then it's fairly simple. The DocPrinter.java example illustrates this by printing any Office document supplied on its command line to the default printer or to the one named in the second command line argument. The complete code: // in DocPrinter.java public static void main ( String args [] ) { if (( args . length < 1 ) || ( args . length > 3 )) { System . out . println ( \"Usage: DocPrinter fnm [printer-name [no-of-pages]]\" ); return ; } String fnm = args [ 0 ] ; String pName = JPrint . getDefaultPrinterName (); // default if ( args . length > 1 ) { // 2 or 3 args String [] printerNames = JPrint . findPrinterNames ( args [ 1 ] ); if ( printerNames == null ) System . out . println ( \"Using default printer: \\\"\" + pName + \"\\\"\" ); else { pName = printerNames [ 0 ] ; System . out . println ( \"Using first matching printer: \\\"\" + pName + \"\\\"\" ); } } String pagesStr = \"1-\" ; // default is print all pages if ( args . length == 3 ) pagesStr = args [ 2 ] ; XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } int docType = Info . reportDocType ( doc ); XPrintable xp = Lo . qi ( XPrintable . class , doc ); if ( xp == null ) System . out . println ( \"Cannot print; XPrintable is null\" ); else if ( ! Print . isPrintable ( docType )) System . out . println ( \"Cannot print that document type\" ); else { Print . usePrinter ( xp , pName ); Print . reportPrinterProps ( xp ); Print . print ( xp , pagesStr ); } Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() An optional third command line argument is a page range, given in string form. For instance, \"2-4;6\" will print pages 2 to 4 and 6 (with the page numbering starting at 1). The printer name is obtained using methods from my JPrint.java class. The Office API takes over after the document has been loaded, and utilizes support functions in my Print.java class (note: no \"J\" in the name). The document type is printed and returned by Info.reportDocType() as one of: Lo.UNKNOWN, Lo.WRITER, Lo.BASE, Lo.CALC, Lo.DRAW, Lo.IMPRESS, or Lo.MATH. The loaded document is cast to XPrintable (see Figure 1), and Print.isPrintable() tests for those document types that can be printed using XPrintable.print(): // in the Print class public static boolean isPrintable ( int docType ) { return (( docType == Lo . WRITER ) || ( docType == Lo . CALC ) || ( docType == Lo . DRAW ) || ( docType == Lo . IMPRESS )); } Print . usePrinter () adds the printer ' s name and paper format to the XPrintable properties by calling XPrintable . setPrinter () with an array of PrintDescriptor properties ( see Figure 1 ): // in the Print.java class public static void usePrinter ( XPrintable xp , String printer ) { if ( xp == null ) { System . out . println ( \"Cannot set printer XPrintable is null\" ); return ; } System . out . println ( \"Using printer \\\"\" + printer + \"\\\"\" ); xp . setPrinter ( Props . makeProps ( \"Name\" , printer , \"PaperFormat\" , PaperFormat . A4 ) ); setListener ( xp ); } Table 1 lists the PrintDescriptor properties, or use my lodoc.bat script to access the class' documentation online (type lodoc PrinterDescriptor ). Property Description Name Name of the printer. PaperOrientation Paper orientation (com.sun.star.view.PaperOrientation: PORTRAIT, LANDSCAPE) PaperFormat Paper size formats (com.sun.star.view.PaperFormat: A3, A4, A5, B4, B5, LETTER, LEGAL, TABLOID, USER) PaperSize Paper size in 100 th mm (com.sun.star.awt.Size). IsBusy Is the printer busy? CanSetPaperOrientation Can the paper orientation be set? CanSetPaperFormat Are other paper formats supported? CanSetPaperSize Are other paper sizes supported? Table 1. Properties in com.sun.star.view.PrinterDescriptor. Print.setListener() inside Print.usePrinter() attaches an XPrintJobListener listener to the print job by casting XPrintable to XPrintJobBroadcaster (see Figure 1). // in the Print class public static void setListener ( XPrintable xp ) { if ( xp == null ) { System . out . println ( \"Cannot set listener; XPrintable is null\" ); return ; } XPrintJobBroadcaster pb = Lo . qi ( XPrintJobBroadcaster . class , xp ); if ( pb == null ) { System . out . println ( \"Cannot obtain print job broadcaster\" ); return ; } pb . addPrintJobListener ( new XPrintJobListener () { public void printJobEvent ( PrintJobEvent e ) { System . out . println ( \"Print Job status: \" + printableState ( e . State )); } public void disposing ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Disposing of print job: \" + e ); } }); } // end of setListener() XPrintJobListener.printJobEvent() is called at different stages during the job's execution, and Print.printableState() converts the retrieved PrintableState constant into a more readable string: // in the Print class public static String printableState ( PrintableState val ) { if ( val == PrintableState . JOB_STARTED ) return \"JOB_STARTED\" ; else if ( val == PrintableState . JOB_COMPLETED ) return \"JOB_COMPLETED\" ; else if ( val == PrintableState . JOB_SPOOLED ) return \"JOB_SPOOLED\" ; else if ( val == PrintableState . JOB_ABORTED ) return \"JOB_ABORTED\" ; else if ( val == PrintableState . JOB_FAILED ) return \"JOB_FAILED\" ; else if ( val == PrintableState . JOB_SPOOLING_FAILED ) return \"JOB_SPOOLING_FAILED\" ; else { System . out . println ( \"Unknown printable state\" ); return \"??\" ; } } // end of printableState() The PrintableState constants are summarized in Table 2. Enumerator Constant Description JOB_STARTED Printing/rendering has begun. JOB_COMPLETED Printing/rendering has finished; spooling has begun. JOB_SPOOLED Spooling has finished successfully. This is the \"success\" state for a print job. JOB_ABORTED Printing was aborted (e.g., by the user) during printing or spooling. JOB_FAILED The printing ran into an error. JOB_SPOOLING_FAILED The document could be printed but not spooled. Table 2. Properties in com.sun.star.view.PrintableState enum. Back in the main() function of DocPrinter.java, Print.reportPrinterProps() outputs the printer's PrintDescriptor settings (listed in Table 1). It loops through the properties array returned by XPrintable.getPrinter(): // in the Print class public static void reportPrinterProps ( XPrintable xp ) { if ( xp == null ) { System . out . println ( \"Cannot report printer props\" ); return ; } PropertyValue [] printProps = xp . getPrinter (); if ( printProps == null ) System . out . println ( \"No Printer properties found\" ); else { System . out . println ( \"Printer properties:\" ); String name ; for ( PropertyValue prop : printProps ) { name = prop . Name ; if ( name . equals ( \"PaperOrientation\" )) System . out . println ( \" \" + name + \": \" + paperOrientation (( PaperOrientation ) prop . Value )); else if ( name . equals ( \"PaperFormat\" )) System . out . println ( \" \" + name + \": \" + paperFormat (( PaperFormat ) prop . Value )); else if ( name . equals ( \"PaperSize\" )) { Size sz = ( Size ) prop . Value ; System . out . println ( \" \" + name + \": (\" + sz . Width + \", \" + sz . Height + \")\" ); } else System . out . println ( \" \" + name + \": \" + prop . Value ); } System . out . println (); } } // end of reportPrinterProps() The constants in the PaperOrientation and PaperFormat classes are mapped to more easily understood strings. Typical output from Print.reportPrinterProps() is: Printer properties: Name: FinePrint PaperOrientation: PORTRAIT PaperFormat: A4 PaperSize: (11906, 16838) IsBusy: false CanSetPaperOrientation: true CanSetPaperFormat: true CanSetPaperSize: true At last it's time to print the document. As Figure 1 indicates, the call to XPrintable.print() is configured using PrintOptions properties, which are listed in Table 3. Property Description CopyCount Number of copies to print. FileName Send the output to a file rather than to the printer. Collate Collate the printed pages (set to true or false). Sort Sort the pages (deprecated; use Collate) Pages A string that specifies pages and page ranges to print. For example, \"1-4;10\" to print the pages 1 to 4 and 10. Wait Wait for the print request to be completed. DuplexMode Set duplex constant (using com.sun.star.view.DuplexMode) PrinterName The name of the printer. Table 3. Properties in com.sun.star.view.PrintOptions. The configuration and printing is carried out by Print.print(): // in the Print class public static void print ( XPrintable xp ) { print ( xp , \"1-\" ); } // print all the pages public static void print ( XPrintable xp , String pagesStr ) { if ( xp == null ) { System . out . println ( \"Cannot print; XPrintable is null\" ); return ; } System . out . println ( \"Print range: \" + pagesStr ); System . out . println ( \"Sending document...\" ); PropertyValue [] props = Props . makeProps ( \"Pages\" , pagesStr , \"Wait\" , true ); // synchronous // see com.sun.star.view.PrintOptions xp . print ( props ); // print the document System . out . println ( \"Delivered\" ); } // end of print() Two properties are set: \"Pages\" and \"Wait\". \"Pages\" could be left out if all of the document is to printed, but \"Wait\" is necessary; it forces the print() call to wait until the job has been delivered to the driver, and so has left the Office process. If \"Wait\" wasn't included then DocPrinter could continue and perhaps close Office before it had fully transmitted the document to the printer. This would cause a crash. Note that there's no need to set the \"PrinterName\" property since its already been supplied as one of the PrintDescriptor properties.","title":"3.  Printing any Document"},{"location":"41-Printing.html#4-viewing-a-documents-print-properties","text":"The previous section looked at printer-related properties stored in PrinterDescriptor (Table 1) and PrintOptions (Table 2). But the real property mother lode are those related to documents, which are stored in the many subclasses below the Settings service (see Figure 3). The ShowPrintProps.java example prints out those properties for a given input document. The relevant lines are: // in ShowPrintProps.java... int docType = Info . reportDocType ( doc ); XProperty Set docProps = Print . getDocSettings ( docType ); Props . showProps ( \"Document Settings\" , docProps ); The document type returned by Info.reportDocType() is employed by Print.getDocSettings() to decide which of the subclasses of the Settings service (once again, see Figure 3) should be instantiated: // in the Print class public static XPropertySet getDocSettings ( int docType ) { XPropertySet props = null ; if ( docType == Lo . WRITER ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.text.DocumentSettings\" ); else if ( docType == Lo . IMPRESS ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.presentation.DocumentSettings\" ); else if ( docType == Lo . DRAW ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.drawing.DocumentSettings\" ); else if ( docType == Lo . CALC ) props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.sheet.DocumentSettings\" ); else if ( docType == Lo . BASE ) System . out . println ( \"No document settings for a base doc\" ); else if ( docType == Lo . MATH ) System . out . println ( \"No document settings for a math doc\" ); else System . out . println ( \"Unknown document type\" ); return props ; } // end of getDocSettings() All these setting services support XPropertySet, which is returned as Print.getDocSettings()'s result. The printing-related properties defined in the Settings superclass are listed in Table 4, but it contains many more properties for different aspects of a document. For a full list, use lodoc Settings document to look at the online documentation. The Settings webpage is also a good starting point for examining its DocumentSettings subclasses. Property Description PrinterName Printer used by the document. PrinterSetup A byte array containing driver-specific data. IsPrintBooklet Put two document pages on one physical page, such that you can fold the output into a booklet. IsPrintBookletFront Only print the fronts of a booklet IsPrintBookletBack Only print the backs of a booklet PrintQuality Normal (0); Grayscale (1), Black and white (2). PrinterIndependentLayout Forbid use of printer metrics for layout. EmbedFonts Whether to embed fonts used by the document. EmbedSystemFonts Whether to embed system fonts used by the document. Table 4. Printing-related Properties in com.sun.star.document.Settings. Writer documents utilize the DocumentSettings service in the text module which doesn't contain any printing properties, but is far from empty. Again, use lodoc DocumentSettings text to visit its documentation in the text module. Instead, the print properties are inherited from the PrintSettings service in the text module, which are listed in Table 5. Use lodoc PrintSettings text to visit its documentation. Property Description PrintGraphics If true, print graphic objects. PrintTables If true, print text tables. PrintDrawings If true, print shapes. PrintLeftPages If true, print left pages. PrintRightPages If true, print right pages. PrintControls If true, then control shapes in the document (usually inside forms) are printed. PrintReversed If true, print the pages in reverse order, starting with the last page. PrintPaperFromSetup If true, use the paper tray specified for the system printer. If false, use the paper tray specified by the page style. PrintFaxName Name of the fax machine. PrintAnnotationMode Specify how notes are printed. Uses com.sun.star.text.NotePrintMode: NOT, ONLY, DOC_END, or PAGE_END). PrintProspect If true, prospect printing is used. Related to brochures (I think). PrintPageBackground Determines if the background color / background graphic of pages is printed. PrintBlackFonts Determines if characters are printed in black. PrintEmptyPages Determines if automatically inserted empty pages are printed. Table 5. Properties in com.sun.star.text.PrintSettings. Back in ShowPrintProps.java, the properties are printed with Props.showProps(). The output is quite lengthy since every setting is printed, not just the printing-related ones in my tables. Typical output when a Writer file is examined includes: : PrintAnnotationMode == 0 PrintBlackFonts == false PrintControls == true PrintDrawings == true PrintEmptyPages == false PrintFaxName == PrintGraphics == true PrintHiddenText == false PrintLeftPages == true PrintPageBackground == true PrintPaperFromSetup == false PrintProspect == false PrintProspectRTL == false PrintReversed == false PrintRightPages == true PrintSingleJobs == false PrintTables == true PrintTextPlaceholder == false PrinterIndependentLayout == 3 PrinterName == PrinterSetup == [B@1222c14 PropLineSpacingShrinksFirstLine == true ProtectForm == false RedlineProtectionKey == [B@6d8acf Rsid == 537223 : A Calc file uses the DocumentSettings service in the sheet module (use lodoc DocumentSettings sheet to examine its documentation). However, printing-related properties are stored elsewhere, in the GlobalSheetSettings and PageStyle services, which need additional code to access them as I'll explain later. An Impress file uses DocumentSettings in the presentation module (see lodoc DocumentSettings service presentation ); its printing-related properties are given in Table 6. Property Description IsPrintDrawing Enables or disables the printing of the drawing pages. IsPrintNotes Enables or disables the printing of the notes pages. IsPrintHandout Enables or disables the printing of the handout pages. IsPrintOutline Enables or disables the printing of the outline pages. IsPrintHiddenPages Enables or disables the printing of draw pages that are marked as hidden. IsPrintFitPage Enables or disables the fitting of the page to the printable area during printing. IsPrintTilePage If this is true and the paper size for printing is larger than the paper size of the printer than the content is tiled over multiple pages. Table 6. Printing-related Properties in com.sun.star.presentation.DocumentSettings. Draw documents are similar to presentations, and this is reflected in the DocumentSettings service in the drawing module (see lodoc DocumentSettings service drawing ) which offers a subset of the slide properties. The printing-related ones are listed in Table 7. Property Description IsPrintFitPage Enables or disables the fitting of the page to the printable area during printing. IsPrintTilePage If this is true and the paper size for printing is larger than the paper size of the printer than the content is tiled over multiple pages. Table 7. Printing-related Properties in com.sun.star.drawing.DocumentSettings. The drawing and presentation DocumentSettings services inherit the Settings service, and a HeaderFooterSettings service in the documents folder (see lodoc HeaderFooterSettings ), which add the properties in Table 8. Property Description IsPrintPageName Enables or disables the printing of the page name in the header or footer. IsPrintDate Enables or disables the printing of the date in the header or footer. IsPrintTime Enables or disables the printing of the current time in the header or footer. Table 8. Properties in com.sun.star.document.HeaderFooterSettings.","title":"4.  Viewing a Document's Print Properties"},{"location":"41-Printing.html#41-additional-writer-print-properties","text":"As Figure 2 indicates, Writer Documents have access to an XPagePrintable interface offered by the GenericTextDocument service (see lodoc XPagePrintable ). It has a print method, XPagePrintable.printPages() which utilizes properties stored in the PagePrintSettings service (see Table 9). These relate to the document's margins and printing multiple pages on a single sheet. Property Description PageRows Number of page rows on each printed page. PageColumns Number of page columns on each printed page. LeftMargin Left margin of the printed page. RightMargin Right margin. TopMargin Top margin. BottomMargin Bottom margin. HoriMargin Margin between page rows. VertMargin Margin between page columns. IsLandscape Print in landscape format? Table 9. Properties in com.sun.star.text.PagePrintSettings. These properties are printed by casting the document to XPagePrintable: // part of ShowPrintProps.java... if ( docType == Lo . WRITER ) { XPagePrintable xpp = Lo . qi ( XPagePrintable . class , doc ); PropertyValue [] printProps = xpp . getPagePrintSettings (); Props . showProps ( \"Page print settings\" , printProps ); } Typical output is: Properties for \"Page print settings\": PageRows: 1 PageColumns: 1 LeftMargin: 0 RightMargin: 0 TopMargin: 0 BottomMargin: 0 HoriMargin: 0 VertMargin: 0 IsLandscape: false","title":"4.1.  Additional Writer Print Properties"},{"location":"41-Printing.html#42-additional-calc-print-properties","text":"Figure 3 indicates that a Calc document has three sources of printing-related properties: DocumentSettings in the sheet module, GlobalSheetSettings also in the sheet module, and PageStyle in the style module. In a break with usual Office conventions, the GlobalSheetService service (see lodoc GlobalSheetSettings ) doesn\u2019t store the properties; instead they're maintained by its XGlobalSheetSettings interface (see lodoc XGlobalSheetSettings ). The printing- related properties are listed in Table 10. Property Description PrintAllSheets Specifies whether all sheets or only selected sheets are printed. PrintEmptyPages Specifies whether empty pages are printed. UsePrinterMetrics Specifies whether printer metrics are used for display. Table 10. Printing-related Properties in com.sun.star.sheet.XGlobalSheetSettings. This organization of the documentation may be an error, since the XGlobalSheetSettings properties are accessed in the usual way, by instantiating the GlobalSheetSettings service, and casting it to XPropertySet: XPropertySet globalSheetProps = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.sheet.GlobalSheetSettings\" ); Props . showProps ( \"Global Sheet Settings\" , globalSheetProps ); GlobalSheetSettings properties are applied to all sheets, so you may want to reset a changed property to its original value after a print. There's an example of using global sheet settings in PrintSheet.java later in this chapter. Another source of spreadsheet properties is the PageStyle service. I explained page styles in Chapter 22, so I refer you back there for the details. A page style is associated with a sheet, and so it's necessary to first choose a sheet to examine, and then access its \"PageStyle\" property: XSpreadsheetDocument ssDoc = Calc . getSSDoc ( doc ); XSpreadsheet sheet = Calc . getSheet ( ssDoc , 0 ); // first sheet String styleName = ( String ) Props . getProperty ( sheet , \"PageStyle\" ); System . out . println ( \"\\nPageStyle of first sheet: \" + styleName ); The page style name is used to lookup the properties for that particular style: XPropertySet props = Info . getStyleProps ( doc , \"PageStyles\" , styleName ); Props . showProps ( styleName + \" PageStyles\" , props ); Props.showProps() prints an extensive list of properties, drawn form several services in the PageStyle hierarchy. A simplified version of that hierarchy is shown in Figure 4. Figure 4. Part of the PageStyle Service Hierarchy. I'm only interested in printing-related properties in this chapter. Some come from the PageProperties service in the style module (see lodoc PageProperties style ), as listed in Table 11. Property Description Lots of border props\u2026 Lots of margin props\u2026 IsLandscape Determines if the page format is landscape. PrinterPaperTray Contains the name of a paper tray of the selected printer. Lots of header props\u2026 Lots of footer props\u2026 Lots of grid props\u2026 GridPrint Determines whether text grid lines are printed. Table 11. Printing-related Properties in com.sun.star.style.PageProperties. Many more print properties come from TablePageStyle in the sheet module (see lodoc TablePageStyle , which are given in Table 12. Property Description PrintAnnotations Enables printing of cell annotations. PrintGrid Enables printing of the cell grid. PrintHeaders Enables printing of column and row headers. PrintCharts Enables printing of charts. PrintObjects Enables printing of embedded objects. PrintDrawing Enables printing of drawing objects. PrintFormulas Enables printing of formulas instead of their results. PrintZeroValues Enables printing of zero-values. PrintDownFirst Specifies the print order for the pages within each sheet. PageScale Contains the scaling factor (in percent) for printing the sheet. ScaleToPages Contains the number of pages the sheet will use for printing. ScaleToPagesX Contains the number of horizontal pages the sheet will be printed on. ScaleToPagesY Contains the number of vertical pages the sheet will be printed on. LeftPageHeaderContent Contains the content of the header for the left pages (com.sun.star.sheet.XHeaderFooterContent). RightPageHeaderContent Contains the content of the header for the right pages (com.sun.star.sheet.XHeaderFooterContent). LeftPageFooterContent Contains the content of the footer for the left pages (com.sun.star.sheet.XHeaderFooterContent). RightPageFooterContent Contains the content of the footer for the right pages (com.sun.star.sheet.XHeaderFooterContent). Table 12. Printing-related Properties in com.sun.star.sheet.TablePageStyle.","title":"4.2.  Additional Calc Print Properties"},{"location":"41-Printing.html#5-specialized-printing","text":"In this section I'll use some of the document properties just described to control how Writer, Impress, and Calc documents are printed. The example code is in TextPrinter.java, ImpressPrinter.java, SheetPrinter.java, and PrintSheet.java. The sad news is that although TextPrinter.java and ImpressPrinter.java successfully print their documents, the API ignores most of the changes to the properties. Perhaps even sadder (from a programming perspective) is the fact that these same documents are correctly printed if the properties are set via Office's GUI. Aside from this, the print GUI in Office offers more functionality than the API. For example, it's possible to output multiple slides and sheets on a single page through the print dialog but not with API calls.","title":"5.  Specialized Printing"},{"location":"41-Printing.html#51-printing-a-text-document","text":"TextPrinter.java sends a text document to a specified printer, with two pages printed on each sheet. After the document has been loaded, the printing is carried out by: // part of TextPrinter.java... XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); XPagePrintable xpp = Lo . qi ( XPagePrintable . class , doc ); PropertyValue [] props = xpp . getPagePrintSettings (); Props . setProp ( props , \"IsLandscape\" , true ); Props . setProp ( props , \"PageColumns\" , ( short ) 2 ); xpp . setPagePrintSettings ( props ); xpp . printPages ( new PropertyValue [ 1 ] ); // empty array of props To help understand what the code is doing, refer back to Figure 2. The document is cast to XPrintable so the printer settings can be initialized by Print.usePrinter(). Then the document is cast to XPagePrintable so its PagePrintSettings properties can be configured. That's done via XPagePrintable.setPagePrintSettings() and finally XPagePrintable.printPages() is called with an empty array. The document is printed but unfortunately the two pages/sheet and landscape settings are ignored. This bug has been known for many years, and some people have suggested an alternative implementation where the properties are passed to XPagePrintable.printPages() rather than to XPagePrintable.setPagePrintSettings(). The last two lines from above would be replaced by: xpp . printPages ( props ); Unfortunately this produces the same output in my tests. If the Writer document is printed through the Office GUI, then the print dialog looks something like Figure 5. Figure 5. The Writer application's Print Dialog. The pages/sheet settings are on the \"Page Layout\" tab, as in Figure 6. Figure 6. The \"Page Layout\" Tabbed Window in the Print Dialog. When \"Ok\" is pressed, the document is printed correctly.","title":"5.1.  Printing a Text Document"},{"location":"41-Printing.html#52-printing-an-impress-document","text":"ImpressPrinter.java prints an Impress document to the specified printer in handout format, six slides per sheet, in black and white. A4 paper in landscape mode is utilized. After the document has been loaded, the printing is carried out by the following code: // part of ImpressPrinter.java... // set document props XPropertySet props = Lo . createInstanceMSF ( XPropertySet . class , \"com.sun.star.presentation.DocumentSettings\" ); Props . setProperties ( props , new String [] { \"IsPrintHandout\" , \"SlidesPerHandout\" , \"IsPrintFitPage\" , \"IsPrintDate\" , \"PrintQuality\" , \"PrinterName\" }, new Object [] { true , ( short ) 6 , true , true , 2 , pName } // 2 == B&W ); Props . showProps ( \"Document Settings\" , props ); // set printer props XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); xp . setPrinter ( Props . makeProps ( \"PaperOrientation\" , PaperOrientation . LANDSCAPE , \"PaperFormat\" , PaperFormat . A4 ) ); Print . reportPrinterProps ( xp ); Print . print ( xp ); To help understand what the code is doing, refer back to Figure 2. A presentation DocumentSettings service is created, and its printing properties set. The \"PrintQuality\" and \"PrinterName\" properties are from the Settings service (see Table 4), \"IsPrintHandout\" and \"IsPrintFitPage\" are from DocumentSettings (see table 6), and \"IsPrintDate\" from HeaderFooterSettings (see Table 8). This leaves the \"SlidesPerHandout\" property, which isn't documented anywhere. I discovered it by looking at the print-out of that service's properties with: Props . showProps ( \"Document Settings\" , props ); The printer properties are set as in earlier examples, but with the addition of \"PaperOrientation\" and \"PaperFormat\" which are PrintDescriptor properties (see table 1). The document is printed but as one color slide per sheet; the handout and black and white settings are ignored. If the same Impress document is printed through the Office GUI, then the print dialog looks like Figure 7. Figure 7. The Impress application's Print Dialog. This is much closer to what I want to output, although I couldn't print the handouts in landscape mode.","title":"5.2.  Printing an Impress Document"},{"location":"41-Printing.html#53-printing-a-calc-document","text":"SheetPrinter.java prints the first sheet of a Calc document, scaled so that two pages are used in the vertical direction. Also, the paper is set to landscape mode and A4 size, and the header's central field is modified. In addition, commented-out code restricts the printed area of the sheet to be a single column. The good news is that all of these setting are correctly processed at print-time. After the document has been loaded, the printing is carried out by: // part of SheetPrinter.java... XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); // first sheet String styleName = ( String ) Props . getProperty ( sheet , \"PageStyle\" ); // get the properties set for the sheet's page style XPropertySet props = Info . getStyleProps ( doc , \"PageStyles\" , styleName ); Props . setProperty ( props , \"ScaleToPagesY\" , ( short ) 2 ); // use a max of 2 pages on the y-axis Props . showProps ( styleName , props ); showTotalsHeader ( props ); /* // print only the \"E\" column XPrintAreas printAreas = Lo.qi(XPrintAreas.class, sheet); printAreas.setPrintAreas(new CellRangeAddress[] {}); // reset print areas CellRangeAddress addr = Calc.getAddress(sheet, \"E1:E111\"); printAreas.setPrintAreas(new CellRangeAddress[]{ addr }); // set area */ // set printer settings XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); PropertyValue [] printProps = Props . makeProps ( \"PaperOrientation\" , PaperOrientation . LANDSCAPE , \"PageFormat\" , PaperFormat . A4 ); xp . setPrinter ( printProps ); Print . reportPrinterProps ( xp ); Print . print ( xp ); The scaling is done by accessing the sheet's page style properties, and setting the \"ScaleToPagesY\" value. This is one of the TablePageStyle properties listed in Table 12.","title":"5.3.  Printing a Calc Document"},{"location":"41-Printing.html#headers-and-footers","text":"The headers and footers are manipulated by showTotalsHeader(): // in SheetPrinter.java private static void showTotalsHeader ( XPropertySet props ) // change the header of the sheet { // get the right-hand header and footer XHeaderFooterContent header = Calc . getHeadFoot ( props , \"RightPageHeaderContent\" ); XHeaderFooterContent footer = Calc . getHeadFoot ( props , \"RightPageFooterContent\" ); // print details about them Calc . printHeadFoot ( \"Right Header\" , header ); Calc . printHeadFoot ( \"Right Footer\" , footer ); // modify the header center text to be \"Totals\" Calc . setHeadFoot ( header , Calc . HF_CENTER , \"Totals\" ); // turn on headers and make left and right page headers the same Props . setProperty ( props , \"HeaderIsOn\" , true ); Props . setProperty ( props , \"HeaderIsShared\" , true ); // from style.PageProperties Props . setProperty ( props , \"RightPageHeaderContent\" , header ); } // end of showTotalsHeader() A sheet may have two headers (one for the left hand page, one for the right) and two footers, which are accessed as XHeaderFooterContent objects (see lodoc XHeaderFooterContent ). XHeaderFooterContent is a collection of three XText instances representing the left, center, and right of the content area. The headers and footers are accessed via the sheet's page style properties, stored as the properties \"LeftPageHeaderContent\", \"RightPageHeaderContent\", \"LeftPageFooterContent\", and \"RightPageFooterContent\" in the TablePageStyle service (see Table 12). Calc.getHeadFoot() retrieves the page style properties, and returns the requested XHeaderFooterContent: // in the Calc class public static XHeaderFooterContent getHeadFoot ( XPropertySet props , String content ) { return Lo . qi ( XHeaderFooterContent . class , Props . getProperty ( props , content )); } Calc.printHeadFoot() prints the three text fields inside the XHeaderFooterContent object: // in the Calc class public static void printHeadFoot ( String title , XHeaderFooterContent hfc ) { XText left = hfc . getLeftText (); XText center = hfc . getCenterText (); XText right = hfc . getRightText (); System . out . println ( title + \": \\\"\" + left . getString () + \"\\\" : \\\"\" + center . getString () + \"\\\" : \\\"\" + right . getString () + \"\\\"\" ); } // end of showHeadFoot() Calc.setHeadFoot() can change the text in the left, center, or right of a XHeaderFooterContent instance: // in the Calc class public static void setHeadFoot ( XHeaderFooterContent hfc , int region , String text ) { XText xText = getRegion ( hfc , region ); if ( xText == null ) { System . out . println ( \"Could not set text\" ); return ; } XTextCursor headerCursor = xText . createTextCursor (); headerCursor . gotoStart ( false ); headerCursor . gotoEnd ( true ); headerCursor . setString ( text ); } // end of setHeadFoot() public static XText getRegion ( XHeaderFooterContent hfc , int region ) { if ( hfc == null ) { System . out . println ( \"Header/footer content is null\" ); return null ; } if ( region == HF_LEFT ) return hfc . getLeftText (); else if ( region == HF_CENTER ) return hfc . getCenterText (); else if ( region == HF_RIGHT ) return hfc . getRightText (); else { System . out . println ( \"Unknown header/footer region\" ); return null ; } } // end of getRegion() Back in SheetPrinter.java, showTotalsHeader() changes the central text field of the right header to \"Totals\". It then switches on the display of headers, makes the left and right headers the same, and inserts the modified XHeaderFooterContent instance back into the page styles: // part of showTotalsHeader() in SheetPrinter.java... Props . setProperty ( props , \"HeaderIsOn\" , true ); Props . setProperty ( props , \"HeaderIsShared\" , true ); // from style.PageProperties Props . setProperty ( props , \"RightPageHeaderContent\" , header );","title":"Headers and Footers"},{"location":"41-Printing.html#print-areas","text":"A sheet is usually manipulated via the XSpreadsheet interface in the Spreadsheet service. However, Spreadsheet supports a number of other interfaces, including XPrintAreas for specifying printable areas within a sheet. This interface is illustrated in Figure 8. Figure 8. The Spreadsheet XPrintAreas Interface. Aside from defining printable areas, XPrintAreas also has methods for setting which rows and/or columns are repeated if a sheet spans several pages. The commented out code in SheetPrinter.java does two things: it cancels any existing print areas, and specifies that only the \"E\" column will be printed: // part of SheetPrinter.java... XPrintAreas printAreas = Lo . qi ( XPrintAreas . class , sheet ); printAreas . setPrintAreas ( new CellRangeAddress [] {}); // cancel print areas CellRangeAddress addr = Calc . getAddress ( sheet , \"E1:E111\" ); printAreas . setPrintAreas ( new CellRangeAddress [] { addr }); // set area to be the \"E\" column","title":"Print Areas"},{"location":"41-Printing.html#54-printing-a-single-sheet","text":"My thanks to user \"villeroy\" on the OpenOffice forums for suggesting this example: how is a single sheet of a multi-sheet spreadsheet printed? One part of the solution is to set the \"PrintAllSheets\" property to false in the GlobalSheetSettings service (see Table 10). The other is to make the current sheet explicitly active in the XSpreadsheetView interface, which is equivalent to bringing the sheet to the foreground in the Calc application. The PrintSheet.java example shows how to do this for a spreadsheet of three sheets, where only \"Sheet2\" is printed: // in PrintSheet.java public static void main ( String args [] ) { // hardwired spreadsheet and printer choice String fnm = \"tables.ods\" ; String pName = \"FinePrint\" ; // load the spreadsheet XComponentLoader loader = Lo . loadOffice (); XComponent cDoc = Lo . openReadOnlyDoc ( fnm , loader ); XSpreadsheetDocument doc = Calc . getSSDoc ( cDoc ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } // what are the sheets called? String [] sheetNms = Calc . getSheetNames ( doc ); System . out . println ( \"Names of sheets (\" + sheetNms . length + \"):\" ); for ( String sheetNm : sheetNms ) System . out . println ( \" \" + sheetNm ); // make \"Sheet2\" active XSpreadsheet sheet = Calc . getSheet ( doc , \"Sheet2\" ); Calc . setActiveSheet ( doc , sheet ); // set Global Sheet settings // changes are remembered XPropertySet gsProps = Lo . createInstanceMCF ( XPropertySet . class , \"com.sun.star.sheet.GlobalSheetSettings\" ); Props . setProperty ( gsProps , \"PrintAllSheets\" , false ); System . out . println (); Props . showProps ( \"Global Sheet Settings\" , gsProps ); // set printer settings XPrintable xp = Lo . qi ( XPrintable . class , doc ); Print . usePrinter ( xp , pName ); PropertyValue [] printProps = Props . makeProps ( \"PaperOrientation\" , PaperOrientation . LANDSCAPE , \"PageFormat\" , PaperFormat . A4 ); xp . setPrinter ( printProps ); Print . print ( xp ); // reset global settings Props . setProperty ( gsProps , \"PrintAllSheets\" , true ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() One issue with changing GlobalSheet settings is that they are remembered after Office has closed, and will be used by default during future prints. In that case, it's a good idea to reset the \"PrintAllSheets\" to true after the Print.print() call.","title":"5.4.  Printing a Single Sheet"},{"location":"41-Printing.html#6-a-bad-idea-hacking-the-gui","text":"A recurring observation of the last few sections is that printer dialogs inside Office are less buggy and more feature-rich than the API. In previous chapters, I've sometimes resorted to using Office's GUI by sending dispatch messages, and key presses to the window. I decided not to follow that approach here since it's too unreliable. Getting to the print dialog is straightforward. The document window is made visible, and an \".uno:Print\" dispatch opens the print dialog: GUI.setVisible(doc, true); Lo.delay(1000); // give the Office window time to appear Lo.dispatchCmd(\"Print\"); Lo.delay(500); // give the Print dialog time to appear The first problem is that the print dialog uses tabbed windows, and the window that's foremost can vary. Usually it's the \"General\" window (e.g. see Figure 5), but if the user has previously clicked the \"Ok\" button in another tabbed window (such as the \"Page Layout\" window in Figure 6) then that window will be foremost when the print dialog is next invoked. This means that my code cannot be sure which tabbed window is active after the \"Print\" dispatch. There's also the issue of moving around the tabbed windows and their fields. This can be implemented using Java's Robot class to send TAB and CTRL-TAB characters, as in: private static void ctrlTab () // send a CTRL-TAB character combination { try { Robot robot = new Robot (); robot . keyPress ( KeyEvent . VK_CONTROL ); robot . keyPress ( KeyEvent . VK_TAB ); robot . delay ( 100 ); robot . keyRelease ( KeyEvent . VK_TAB ); robot . keyRelease ( KeyEvent . VK_CONTROL ); } catch ( AWTException e ) { System . out . println ( e ); } } // end of ctrlTab() The difficulty is knowing how many TABs and CTRL-TABs are needed, which depends on the tab ordering of each window. Even if my code somehow managed to get to the correct field in the correct tabbed window, there's still the problem of entering data and 'pressing' the \"Ok\" button afterwards. On balance, I decided not to bother implementing this 'solution'.","title":"6.  A Bad Idea: Hacking the GUI"},{"location":"41-Printing.html#7-command-prompt-printing","text":"Another approach to printing documents, which avoids the use of Java, is to utilize command line utilities. There's no shortage of command line printing tools in Linux and the Mac OS, based around the CUPS printing system ( https://cups.org/ ), and plenty of sites explaining how to use lp, lpq, lpstat and others (e.g. https://computerhope.com/unix/ulp.htm , https://eecs.utk.edu/resources/it/kb/printing/linux-command-line/ ). Perhaps less well known are the printing utilities in Windows, listed in Table 13. VBScript Purpose Prnmngr.vbs Printer management. Adds, deletes, and lists printers or printer connections, in addition to setting and displaying the default printer. Used by printersList.bat Prncnfg.vbs Configures or displays configuration information about a printer. Used by printerStatus.bat Prnjobs.vbs Pauses, resumes, cancels, and lists print jobs. Used by printerJobs.bat Prnqctl.vbs Printer queue management. Prints a test page, pauses or resumes a printer, and clears a printer queue. Used by printerClean.bat Prndrvr.vbs Adds, deletes, and lists printer drivers. Prnport.vbs Printer port management. Pubprn.vbs Publish a printer to Active Directory. Table 13. Windows 7's VBScript Printing Utilities. The utilities are Visual Basic scripts, located in the C:\\Windows\\System32\\Printing_Admin_Scripts\\en-US folder which isn't a standard part of Window's PATH environment variable. One way of finding documentation on these tools is by starting \"Windows Help\" and then following the links to the commands reference section. This will eventually take you to Microsoft's TechNet website. A slightly easier alternative is the TechRepublic article \"How to take advantage of the hidden VBScript print utilities in Windows 10\" by Greg Shultz at https://techrepublic.com/article/how-to-take-advantage-of-the-hidden-vbscript-print-utilities-in-windows-10/ . In my \"Printing Tests\" examples folder, there are four Batch files (printersList.bat, printerStatus.bat, printerJobs.bat, and printerClean.bat) which use these VBScripts in simple ways. printersList.bat lists the names of all the print services visible to Windows, and also the name of the default printer. For example: > printersList Printer name Send To OneNote 2010 Printer name Ricoh Aficio MP 2000 PCL(Black Office Room) Printer name PrinterShare Printer name Print to Evernote Printer name Microsoft XPS Document Writer Printer name HPLJM806 (HP LaserJet M806) Printer name HP LaserJet9040DN PCL 6(Office) Printer name HP LaserJet M806 PCL 6 Printer name HP LaserJet 1200 Series PCL 6 Printer name Foxit PhantomPDF Printer Printer name FinePrint Printer name Fax The default printer is FinePrint These names can be used as printer name arguments in my earlier Java programs. printerStatus.bat reports the status of a printer: > printerStatus \"HP LaserJet 1200 Series PCL 6\" Printer status Idle Extended printer status Unknown printerJobs.bat lists all the print jobs currently on a printer's queue: > printerJobs \"HP LaserJet 1200 Series PCL 6\" Number of print jobs enumerated 0 printerClean.bat deletes all the jobs on a printer queue: > printerClean \"HP LaserJet 1200 Series PCL 6\" Microsoft (R) Windows Script Host Version 5.8 Copyright (C) Microsoft Corporation. All rights reserved. Success Purge Printer HP LaserJet 1200 Series PCL 6 Notably missing from the VBScripts is a way to print a document, perhaps because Windows already has an awesome \"print\" command: > print /? Prints a text file. PRINT [/D:device] [[drive:][path]filename[...]] /D:device Specifies a print device. An alternative is \"printui\" which starts Window's printui.dll ( https://technet.microsoft.com/en-us/library/ee624057(v=ws.11).aspx ). However, I'd not recommend \"print\" or \"printui\" since Office is a much better command line printing tool. If you open a command prompt in the Office directory (e.g. in C:\\Program Files\\LibreOffice 5), you can get a list of its command line options by typing: > soffice.exe \u2013h Figure 9 shows the top half of a long window. Figure 9. Some of Office Command Line Arguments. Another information source is the \"Starting the LibreOffice Software With Parameters\" webpage at https://help.libreoffice.org/Common/Starting_the_Software_With_Parameters/ . The relevant parameters for printing are \"-p\" and \"--pt\", which can be seen near the bottom of Figure 9. \"-p\" prints a file to the default printer, while \"--pt\" (note the two '- 's) sends the document to the named printer. A suitable name can be obtained from the printersList.bat script. I've utilized these parameters in a loprint.bat script in the \"Printing Tests\" folder. If loprint is called with no arguments, then Figure 9's help window is displayed. If a filename argument is supplied then the document is sent to the default printer using the '-p' parameter. Two arguments are assumed to be a printer name and filename, and are processed by \"--pt\". For example: > loprint \"HP LaserJet 1200 Series PCL 6\" cover.odg prints the cover.odg Draw file to the HP laserjet.","title":"7.  Command Prompt Printing"},{"location":"42-Sending_E-mail.html","text":"Chapter 42. Sending E-mail \u00b6 Topics SimpleSystemMail / SimpleCommandMail; Using the MailServiceProvider Service; Using JavaMail; The Desktop API; Thunderbird Scripting; Office Mail Merge Example folders: \"Mail Tests\" and \"Utils\" The Jargon file is a humorous collection of computer slang (online at https://catb.org/jargon/html/ ), and its entry for Zawinski's \"Law of Software Envelopment\" ( https://catb.org/jargon/html/Z/Zawinskis-Law.html ) came to mind while I was preparing this chapter. It states: \"Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can.\" Office is a reasonable example (if you replace 'read' with 'send') because, depending on how you count things, its API contains three different ways of sending e-mail. If you program in Java, the number increases to six! These approaches are summarized in Table 1, and none are without drawbacks. API Services/Classes Used Drawbacks Office API SimpleSystemMail or User must click \"Ok\" in a \"Confirm\" (coded in Java) SimpleCommandMail dialog before the e-mail is sent. MailServiceProvider Two DLLs must be repositioned in the (joint best choice) Office installation before the code will work. Firewalls may block it. MailMerge Works well, but focuses on mail merge rather than general purpose e- mail. The user must configure Office's e- mail settings in Writer before the code will work. Java only JavaMail: Session, Requires the download of the (no use of Office) Message, Transport, and javax.mail JAR. others (joint best Firewalls may block it. choice) Desktop.mail() Attachments are not supported as standard in the mailto: protocol. The e-mail client appears, and the user must press \"Send\". Process & batch file Needs a separate batch file. Tied to the Thunderbird e-mail client. The e-mail client appears, and the user must press \"Send\". Table 1. Office and Java Approaches for Sending E-mail. My aim is to write a sendMessage() function that sends a text message, optionally including a file attachment, to a specified e-mail address. The mail will be sent through an SMTP (Simple Mail Transfer Protocol) server that uses STARTTLS to encrypt the link. I've tested the code using my local departmental server, and with my Gmail account. One surprising entry in Table 1 is Office's mail merge, which typically utilizes a Writer template file and a spreadsheet (or database) to generate form letters addressed to different people. These letters can be saved to files, sent to a printer, or posted out as e-mail attachments. It's the last alternative that led me to include mail merging in this chapter. Table 1 identifies two \"joint best choice\" approaches for sending e-mail. If the mail- out is part of other Office-related tasks, such as the run-time generation of a document, then its best to use Office's MailServiceProvider service since it nicely integrates with the rest of the API. However, if you plan to write a standalone e-mail application which loads and sends ODF attachments, then JavaMail has more features ( https://java.net/projects/javamail/pages/Home/ ). I'll start this chapter by explaining the Office services for sending e-mail: SimpleSystemMail/SimpleCommandMail, and the newer MailServiceProvider. Then I'll switch to non-Office approaches, looking first at JavaMail, followed by two techniques which don't need an extra JAR file but do require the user to interact with the OSes e-mail client. I'll finish with mail merge in Office. 1. SimpleSystemMail/SimpleCommandMail \u00b6 The SimpleSystemMail and SimpleCommandMail services in the system module send e-mail using the OSes default e-mail client. They both implement the same interfaces, but SimpleSystemMail is for Windows, and SimpleCommandMail for Linux and MacOS. Figure 1 shows the services and some of their interfaces. Figure 1. The SimpleSystemMail and SimpleCommandMail Services. By utilizing the machine's e-mail client, the services don't need the programmer to enter the mail server address, its port, and a login and password, since this information is in the client's account settings (or user profile). A drawback of this approach is that the message passes through the client's GUI, and the user must press a \"Send\" button (or equivalent) to post the message. Fortunately, XSimpleMailClient lets the user interface be mostly hidden, but a \"Confirm\" dialog like the one in Figure 2 still pops up. Figure 2. The \"Confirm\" Dialog when using SimpleSystemMail/SimpleCommandMail. This dialog can be disabled via the checkbox shown in Figure 2, but that's a bad idea from a security viewpoint. SimpleSystemMail and SimpleCommandMail are utilized by sendEmailByClient() in my Mail.java utility class: // in the Mail class public static void sendEmailByClient ( String to , String subject , String body , String fnm ) { System . out . println ( \"Sending e-mail by client...\" ); try { XSimpleMailClientSupplier mcSupp = Lo . createInstanceMCF ( XSimpleMailClientSupplier . class , \"com.sun.star.system.SimpleSystemMail\" ); // windows e-mail client service if ( mcSupp == null ) { mcSupp = Lo . createInstanceMCF ( XSimpleMailClientSupplier . class , \"com.sun.star.system.SimpleCommandMail\" ); // returns null on Windows; used on Linux/Mac if ( mcSupp == null ) { System . out . println ( \"Unable to create client\" ); return ; } } XSimpleMailClient mc = mcSupp . querySimpleMailClient (); // defaults to ThunderBird on my OS XSimpleMailMessage msg = mc . createSimpleMailMessage (); msg . setRecipient ( to ); msg . setSubject ( subject ); XSimpleMailMessage2 msg2 = Lo . qi ( XSimpleMailMessage2 . class , msg ); msg2 . setBody ( body ); if ( fnm != null ) { String [] attachs = new String [ 1 ] ; attachs [ 0 ] = FileIO . getAbsolutePath ( fnm ); // attachment msg . setAttachement ( attachs ); } mc . sendSimpleMailMessage ( msg , SimpleMailClientFlags . NO_USER_INTERFACE ); // hides GUI but still displays a \"Confirm\" dialog } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of sendEmailByClient() The function first tries to instantiate the Windows SimpleSystemMail service, which returns null on a Linux/Mac platform, and then switches to SimpleCommandMail (which returns null on Windows). The resulting XSimpleMailClientSupplier instance is used to obtain a reference to the system's default e-mail client, as represented by XSimpleMailClient. An XSimpleMailMessage object is initialized with the recipient, subject line, body text, and optionally attached file. One of the quirks of the API is that the body text is added via the XSimpleMailMessage2 subclass of XSimpleMailMessage. A typical call to sendEmailByClient(): // part of LoMailer.java... Mail . sendEmailByClient ( \"xxx@xxx\" , \"Test\" , \"Body\" , \"skinner.png\" ); The default e-mail client on Windows is the application associated with the mailto protocol, as depicted in Figure 3. Figure 3. The Default E-mail Client of Windows 7. A good description of how to set up this association can be found at https://ubergizmo.com/how-to/set-default-email-client-windows/ 2. Using the MailServiceProvider Service \u00b6 The MailServiceProvider service utilizes a Python script called mailmerge.py which creates a socket-based link to the specified mail server. If that link utilizes SSL (or its successor TLS) for encrypted communication, then your code will probably crash with the error message \"No SSL support included in this Python\". This bug ( https://bugs.documentfoundation.org/show_bug.cgi?id=77354 ) is marked as \"RESOLVED NOTOURBUG\" at Office's bugzilla website which seems a bit dismissive. The problem appears to be due to the position of Office's application folders in Window's PATH environment variable. When Windows searches for two DLLs, ssleay32.dll and libeay32.dll, which implement OpenSSL, it may find incorrect versions in folders mentioned earlier in PATH. It's these incorrect DLLs that cause Python to issue the cryptic error. One solution is to copy the correct DLLs from Office's \"program\\\" folder into the \"program\\python-core-???\\lib\\\" folder (??? is a version number, such as 3.3.3), thereby ensuring they're chosen first. Another issue with switching to MailServiceProvider is that the programmer must supply more information to setup the SMTP connection, namely the address of the mail server, its port, and the login and password for accessing the server. MailServiceProvider is utilized by the Mail.sendEmail() function. Given below are examples of how it sends e-mail to my local fivedots.coe.psu.ac.th mail server and to the Gmail server at smtp.gmail.com: // part of LoMailer.java... Mail . sendEmail ( \"fivedots.coe.psu.ac.th\" , 25 , \"ad\" , password , \"xxx@xxx\" , \"Test 1\" , \"Body 1\" , \"skinner.png\" ); Mail . sendEmail ( \"smtp.gmail.com\" , 587 , \"Andrew.Davison50@gmail.com\" , password , \"xxx@xxx\" , \"Test 2\" , \"Body 2\" , \"addresses.ods\" ); The Mail.sendEmail() arguments are: the mail server address, its port, the login and password for the server, the recipient of the mail, the subject line, the body text, and an optional attachment filename. SMTP is built on top of a TCP network link, and in these security conscious days many companies and universities (including mine) use firewalls to block everything but Web links. That means I cannot use MailServiceProvider to access my Gmail account at work since its mail server is beyond my departmental firewall. However, I can access the fivedots departmental mail server. MailServiceProvider is located in the mail module, along with several interfaces. The other important service is MailMessage for constructing e-mail messages. Figure 4 shows the relationships between the services and their interfaces. Figure 4. The MailServiceProvider and MailMessage Services. An SMTP service is created via the XMailServiceProvider interface: // part of Mail.sendEmail() : XMailServiceProvider msp = Lo . createInstanceMCF ( XMailServiceProvider . class , \"com.sun.star.mail.MailServiceProvider\" ); if ( msp == null ) { System . out . println ( \"Could not create MailServiceProvider\" ); return ; } XMailService service = msp . create ( MailServiceType . SMTP ); if ( service == null ) { System . out . println ( \"Could not create SMTP MailService\" ); return ; } A listener can be attached to the service, to report on its connection status: // part of Mail.sendEmail() : service . addConnectionListener ( new XConnectionListener () { public void connected ( EventObject e ) { System . out . println ( \"Connected to server \" + getServerName ( e )); } public void disconnected ( EventObject e ) { System . out . println ( \" Disconnected\" ); } public void disposing ( EventObject e ) {} }); The connection requires address, port, protocol, login and password details, which are supplied through XCurrentContext and XAuthenticator: // in the Mail class public static void sendEmail ( String mailhost , int port , String user , String password , String to , String subject , String body , String fnm ) { : // service creation code; see above // initialize service data: context and authenticator XCurrentContext xcc = new XCurrentContext () { public Object getValueByName ( String name ) { if ( name . equals ( \"ServerName\" )) return ( Object ) mailhost ; else if ( name . equals ( \"Port\" )) return ( Object ) new Integer ( port ); else if ( name . equals ( \"ConnectionType\" )) return ( Object ) \"Ssl\" ; // or \"Insecure\"; else if ( name . equals ( \"Timeout\" )) return ( Object ) new Integer ( 60 ); System . out . println ( \"Do not recognize \\\"\" + name + \"\\\"\" ); return null ; } }; XAuthenticator auth = new XAuthenticator () { public String getUserName () { return user ; } public String getPassword () { return password ; } }; // connect to service service . connect ( xcc , auth ); System . out . println ( \"Isconnected: \" + service . isConnected ()); I've hardwired a time of 60 seconds in XCurrentContext which sets how long the code waits for a connection before giving up. MailMessage utilizes an unusual create() method, and the message's body is represented by an XTransferable instance rather than a string: // part of Mail.sendEmail() : String from = user + \"@\" + mailhost ; // person sending this e-mail XMailMessage msg = com . sun . star . mail . MailMessage . create ( Lo . getContext (), to , from , subject , new TextTransferable ( body )); The online documentation for MailMessage.create() (use lodoc MailMessage to access it) is misleading in that it doesn\u2019t mention the need for the component context, which is obtained with the Lo.getContext() call. My TextTransferable class implements the XTransferable interface, which defines how different MIME data types are transferred. XTransferable is mainly used in two ways \u2013 for packaging e-mail data (as here), and for moving data to and from the clipboard (which I'll discuss in the next chapter). TextTransferable lets Unicode text be treated as a transferable: // in the Utils/ folder public class TextTransferable implements XTransferable { private final String text ; private final String UNICODE_MIMETYPE = \"text/plain;charset=utf-16\" ; public TextTransferable ( String s ) { text = s ; } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE )) throw new UnsupportedFlavorException (); return text ; } public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = new DataFlavor ( UNICODE_MIMETYPE , \"Unicode Text\" , new Type ( String . class )); return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE ); } } // end of TextTransferable class A DataFlavor object hold three fields: the MIME type string for the data (e.g. \"text/plain\"), a 'human presentable' name for the data (which can be anything), and the corresponding Office data type. We're not finished with transferable data since an attached file must also be packaged in a similar way using Office's MailAttachment class and my FileTransferable class: // part of Mail.sendEmail() if ( fnm != null ) msg . addAttachment ( new MailAttachment ( new FileTransferable ( fnm ), fnm )); FileTransferable looks up the MIME type for its supplied file, and stores the file contents in a byte array which is returned by getTransferData(): // in the Utils/ folder public class FileTransferable implements XTransferable { private String mimeType = \"application/octet-stream\" ; // default private byte [] fileData = null ; public FileTransferable ( String fnm ) { mimeType = Info . getMIMEType ( fnm ); try { fileData = Files . readAllBytes ( Paths . get ( fnm )); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not read bytes from \" + fnm ); } } // end of FileTransferable() public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( mimeType )) throw new UnsupportedFlavorException (); return fileData ; } // end of getTransferData() public DataFlavor [] getTransferDataFlavors () { DataFlavor [] flavors = new DataFlavor [ 1 ] ; flavors [ 0 ] = new DataFlavor ( mimeType , mimeType , new Type ( byte [] . class )); return flavors ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( mimeType ); } } // end of FileTransferable class MIME type lookup is implemented by Info.getMIMEType() which uses Java's MimetypesFileTypeMap to examine a file of MIME types stored in my Utils/ folder: // in the Info class private static final String MIME_FNM = \"mime.types\" ; public static String getMIMEType ( String fnm ) { File f = new File ( fnm ); try { MimetypesFileTypeMap mftMap = new MimetypesFileTypeMap ( FileIO . getUtilsFolder () + MIME_FNM ); return mftMap . getContentType ( f ); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not find \" + MIME_FNM ); return \"application/octet-stream\" ; // better than nothing } } // end of getMIMEType() Back in Mail.sendEmail(), all that's left to do is to send the message using XSmtpService.sendMailMessage(): // part of Mail.sendEmail()... XSmtpService smtpService = Lo . qi ( XSmtpService . class , service ); smtpService . sendMailMessage ( msg ); service . disconnect (); 3. Using JavaMail \u00b6 JavaMail can send and receive e-mail via SMTP, POP3 and IMAP (its website is https://java.net/projects/javamail/pages/Home/ ). Although JavaMail is mainly intended to be a component of Java EE, it can be downloaded as a single JAR file (javax.mail.jar) as an add-on to the JDK. It's being actively developed (the current version is 1.5.6, released in mid 2016), and the website has lots of examples (see https://java.net/projects/javamail/downloads/download/javamail-samples.zip ), a FAQ, and API documentation (at https://javamail.java.net/nonav/docs/api/ ). The main textbook about JavaMail is: JavaMail API 1 st Edition Elliotte Rusty Harold O'Reilly, 2013 This started out as a chapter in Harold's \"Java Network Programming\" text, but was separated off after the 3 rd edition. Another nice resource if you want to build a GUI e-mail client using JavaMail is chapter 5 of The Art of Java by Herbert Schlidt and James Holmes, McGraw Hill, 2003. JavaMail utilizes the same approach as mailmerge.py mentioned earlier \u2013 it creates an SMTP connection using a TCP socket link to a mail server. As such it suffers from the same problem with firewalls, which means that I can't use it with my Gmail account when I'm at work. My non-Office e-mail support functions are in JMail.java, and have a similar interface to the Office versions. For instance, JMail.sendEmail() is employed to send an e-mail with JavaMail. The following two calls use the fivedots and Gmail servers: // in JMailer.java... JMail . sendEmail ( \"fivedots.coe.psu.ac.th\" , 25 , \"ad\" , password , \"xxx@xxx\" , \"Test 1\" , \"Body 1\" , \"skinner.png\" ); JMail . sendEmail ( \"smtp.gmail.com\" , 587 , \"Andrew.Davison50@gmail.com\" , password , \"xxx@xxx\" , \"Test 2\" , \"Body 2\" , \"addresses.ods\" ); They're no different from my earlier Mail.sendEmail() examples, except for the name of the support class. The arguments are: the mail server address, its port, the login and password for the server, the recipient of the mail, the subject line, the body text, and an optional attachment. JavaMail sending is based around three classes: Transport, Session, and Message. Transport specifies the underlying communication link, while Session handles the details of the communication protocol using that link. For example, secure communication is setup through properties passed to Session.getInstance(): // part of JMail.sendEmail()... Properties props = new Properties (); props . put ( \"mail.smtp.starttls.enable\" , \"true\" ); props . put ( \"mail.smtp.ssl.trust\" , \"*\" ); // no certificate needed props . put ( \"mail.smtp.timeout\" , \"60000\" ); Session session = Session . getInstance ( props ); The mail server address, port, login and password details are used to create a SMTPTransport instance (a subclass of Transport): // part of JMail.sendEmail()... URLName url = new URLName ( \"smtp\" , mailhost , port , \"\" , user , password ); Transport transport = new SMTPTransport ( session , url ); transport . connect ( mailhost , port , user , password ); JavaMail supports two kinds of listeners, one for the connection and the other for message delivery. Simple implementations are given in JMail.sendEmail(): // part of JMail.sendEmail()... : transport . addConnectionListener ( new ConnectionListener () { public void opened ( ConnectionEvent e ) { System . out . println ( \" Connection opened to: \" + e . getSource ()); } public void disconnected ( ConnectionEvent e ) { System . out . println ( \" Connection disconnected\" ); } public void closed ( ConnectionEvent e ) { System . out . println ( \" Connection closed\" ); } }); transport . addTransportListener ( new TransportListener () { public void messageDelivered ( TransportEvent e ) { System . out . println ( \" Message delivered\" ); } public void messageNotDelivered ( TransportEvent e ) { System . out . println ( \" Message not delivered\" ); } public void messagePartiallyDelivered ( TransportEvent e ) { System . out . println ( \" Message partially delivered\" ); } }); An SMTP message has fields for the recipient, subject line, body text, and an optional attached file: // part of JMail.sendEmail() : SMTPMessage msg = new SMTPMessage ( session ); msg . setReturnOption ( SMTPMessage . RETURN_HDRS ); msg . setNotifyOptions ( SMTPMessage . NOTIFY_SUCCESS | SMTPMessage . NOTIFY_FAILURE ); msg . setFrom (); // uses default msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( to )); msg . setSentDate ( new Date ()); msg . setSubject ( subject ); if ( attachFnm == null ) msg . setText ( body ); else { // add body text and file as attachments MimeBodyPart p1 = new MimeBodyPart (); p1 . setText ( body ); String mimeType = Info . getMIMEType ( attachFnm ); MimeBodyPart p2 = new MimeBodyPart (); FileDataSource fds = new FileDataSource ( attachFnm ); p2 . setDataHandler ( new DataHandler ( fds )); // add data, p2 . setFileName ( fds . getName ()); // filename, p2 . setHeader ( \"Content-Type\" , mimeType ); // MIME type // create multipart Multipart mp = new MimeMultipart (); mp . addBodyPart ( p1 ); // for body text mp . addBodyPart ( p2 ); // for the attached file msg . setContent ( mp ); } If the message contains body text and an attachment then it's necessary to add them as MimeBodyPart objects in a Multipart container. Body text on its own can be added using SMTPMessage.setText(). The MimeBodyPart holding the attachment must include the file's MIME type in its \"Content-type\" header. Once the message has been sent, the link is closed: transport . sendMessage ( msg , msg . getAllRecipients ()); transport . close (); 4. The Desktop API \u00b6 The Java equivalent of Office's SimpleSystemMail/SimpleCommandMail service is the Desktop.mail() method. It utilizes the OSes default e-mail client to post a message, which means that there's no need to download the javax.mail JAR. The delivery doesn't need to explicitly include the mail server address, port, login, and password since they're obtained from the client's settings. Desktop.mail() utilizes the mailto protocol to communicate with the client, but its specification (in RFC 2368, at https://ietf.org/rfc/rfc2368.txt ) doesn't cover attachments. There are unofficial extensions supported by some clients, but they're not part of Thunderbird (but see the next section). The mailto syntax is: \"mailto:\" recipients [ \"?\" key \"=\" value (\"&\" key \"=\" value)* ] with recipients: comma-separated e-mail addresses without spaces; Outlook needs semicolons instead of commas; key: subject, cc, bcc, body (note: there's no attachment keyword); value: URL-encoded text (e.g. space becomes %20). An example: mailto:xxx@xxx?subject=Hello&body=How%20are%20you%3F Desktop.mail() is employed by JMail.sendEmailByClient(). An example of its use: JMail.sendEmailByClient(\"xxx@xxx\", \"Hello\", \"How are you?\"); There's no way in Desktop to suppress the client's GUI, which appears on-screen, and the user must press the \"Send\" button (or equivalent) to post out the message. JMail.sendEmailByClient() is: // in the JMail class public static void sendEmailByClient ( String to , String subject , String body ) { sendEmailByClient ( to , subject , body , null ); } public static void sendEmailByClient ( String to , String subject , String body , String fnm ) { if ( ! Desktop . isDesktopSupported ()) { System . out . println ( \"Desktop mail not supported\" ); return ; } // construct \"mailto:\" string for Desktop.mail() String uriStr = String . format ( \"mailto:%s?subject=%s&body=%s\" , encodeMailto ( to ), encodeMailto ( subject ), encodeMailto ( body ) ); if ( fnm != null ) uriStr += \"&attachment=\\\"\" + FileIO . getAbsolutePath ( fnm ) + \"\\\"\" ; try { Desktop desktop = Desktop . getDesktop (); desktop . mail ( new URI ( uriStr )); } catch ( Exception e ) { System . out . println ( e ); } } // end of sendEmailByClient() public static String encodeMailto ( String str ) { try { return URLEncoder . encode ( str , \"UTF-8\" ). replace ( \"+\" , \"%20\" ); } catch ( UnsupportedEncodingException e ) { System . out . println ( \"Could not encode: \\\"\" + str + \"\\\"\" ); return null ; } } // end of encodeMailto() Following the mailto specification, the key values in the mailto string must be URL encoded. sendEmailByClient() has an attachment argument mainly because I've read that some clients, such as Outlook, can accept it. But if I try to use an attachment with Thunderbird, the call to Desktop.mail() fails. 5. Thunderbird Scripting \u00b6 The reason for my uncertainty about Thunderbird supporting attachments is that although it doesn't allow them in \"mailto\" strings, it can process attachments via its GUI, and the command line (see https://kb.mozillazine.org/Command_line_arguments_-_Thunderbird/ ). Its command line features open up another way of sending e-mail: by having Java execute Thunderbird through an external script. My Windows batch file, called TBExec.bat, applies various checks to its command line arguments, and then invokes Thunderbird using: thunderbird . exe - compose \"to='%1',subject='%2', body='%3',attachment='%CD%\\%4'\" The \"attachment\" value is an absolute file name. The Java code uses Runtime.exec() to execute the batch file, passing it three or four arguments: // in the JMail class public static void sendEmailByTB ( String to , String subject , String body , String fnm ) { String mailExec = String . format ( \"cmd /c TBExec.bat %s \\\"%s\\\" \\\"%s\\\"\" , to , subject , body ); if ( fnm != null ) // add attachment argument mailExec += \" \" + fnm ; try { Process p = Runtime . getRuntime (). exec ( mailExec ); p . waitFor (); System . out . println ( \"Sent e-mail using Thunderbird\" ); } catch ( java . lang . Exception e ) { System . out . println ( \"Unable to send Thunderbird mail: \" + e ); } } // end of sendEmailByTB() As with Desktop.mail(), there's no way to stop the Thunderbird GUI from being displayed, and the user has to press the \"Send\" button to send off the message. 6. Office Mail Merge \u00b6 Mail merge usually involves a spreadsheet of data and a form letter stored as a Writer template (an OTT file). Data from the spreadsheet replaces fields in the template, such as < Name > and < Address >, with real names and addresses, creating a series of personalized letters. Other common uses are to generate labels and envelopes. After the letters (or labels or envelopes) have been created, they can be saved to files (or to a single file), sent to a printer, or attached to e-mails. It's because of this last choice that I've included mail merging here. Figure 5 pictures the mail merge stages in more detail. Figure 5. Mail Merging using a Spreadsheet and a Writer Template. 6.1. Preparing the Mail Merge Inputs \u00b6 Mail merge configuration is most easily done using Office's GUI and wizards, and is excellently explained in chapter 11 of the Writer Guide (available from https://th.libreoffice.org/get-help/documentation/ ). A screenshot of a typical spreadsheet is shown in Figure 6. Figure 6. The addresses.ods Spreadsheet. The field names employed in the template correspond to column names in the spreadsheet (e.g. \"Title\" and \"First Name\"). Also, if the merging involves posting out of e-mails then there must be an \"E-mail\" column in the sheet; those addresses will be used as the message recipients. The spreadsheet has to be converted into a data source for the merge. This is done via Office's File, Wizards, Address Data Source menu item, as explained in the Writer Guide. The outcome is a new ODB file with the same name as the spreadsheet (addresses.odb in my case). This data source can be viewed from inside Calc by selecting the menu item View, Data Sources. The GUI display is shown in Figure 7. Figure 7. Addresses.ods with a Data Source. The \"Addresses\" data source has been opened to show its \"Addresses\" table. Both of these names will be needed later when we start programming. The next step is to add fields in the \"Addresses\" table to the Writer template. This involves dragging field names from the top row of the table over to the template, and positioning them in the text. Figure 8 shows part of the resulting template, stored in formLetter.ott. Figure 8. Part of formLetter.ott. The fields are automatically displayed in angled brackets inside gray rectangles. 6.2. Programming the Mail Merge \u00b6 The MailMerge service is located in the text module; most of its programming involves setting properties, and then calling XJob.execute(). The main services and interfaces are shown in Figure 9. Figure 9. The MailMerge Service and Interfaces. The XMailMergeBroadcaster interface is employed to attach a listener to the merging process, and XCancellable can kill the merge. If you look at the documentation for the MailMerge and DataAccessDescriptor services (e.g. use lodoc MailMerge ), you'll discover many properties in both, and that most (but not all) of the DataAccessDescriptor properties are redefined in MailMerge. The coding is summarized by the following snippet from Mail.mergeTask(): // in Mail.mergeTask() : XJob job = Lo . createInstanceMCF ( XJob . class , \"com.sun.star.text.MailMerge\" ); XPropertySet props = Lo . qi ( XPropertySet . class , job ); Props . setProperty ( props , \"DataSourceName\" , dataSourceName ); Props . setProperty ( props , \"Command\" , tableName ); : // many more properties are set... : job . execute ( new NamedValue [ 0 ] ); The MailMerge service is created as an XJob interface. Service properties are set, and then the merge is carried out by calling XJob.execute(). The NamedValue array is empty since there's no need to set any more properties using it. 6.3. Specializing the Merge \u00b6 Mail.mergeTask() is passed numerous property values. To simplify its interface, the call is hidden inside three other functions called Mail.mergeLetter(), Mail.mergePrint(), and Mail.mergeEmail(), which focus on the three different outcomes of a merge (see Figure 5). Mail.mergeLetter() takes four arguments, three of which (data source name, table name, template filename) are needed for any kind of merge: // in the Mail class public static void mergeLetter ( String dataSourceName , String tableName , String templateFnm , boolean isSingle ) { System . out . println ( \"Merging letters to files...\" ); mergeTask ( dataSourceName , tableName , templateFnm , MailMergeType . FILE , isSingle , null , false , null , null , null ); } // end of mergeLetter() The following call to Mail.mergeLetter() saves six letters as \"letter0.odt\" to \"letter5.odt\": // in MailMerge.java... private static final String DATA_SOURCE_NAME = \"Addresses\" ; private static final String TABLE_NAME = \"Addresses\" ; private static final String TEMPLATE_FNM = \"formLetter.ott\" ; Mail . mergeLetter ( DATA_SOURCE_NAME , TABLE_NAME , TEMPLATE_FNM , false ); I've defined the data source name, table name, and template filename as constants to make the call to Mail.mergeLetter() easier to read. The boolean argument specifies whether a single file should hold all the generated letters. The generated filenames are hardwired inside Mail.mergeTask() to be \"letter\" and a number. Six files are created since the spreadsheet (see Figure 6) has six rows of data. Mail.mergePrint() is passed the same first three arguments (data source name, table name, template filename), and a printer name and a boolean to signal whether multiple print jobs should be created: // in MailMerge.java... Mail . mergePrint ( DATA_SOURCE_NAME , TABLE_NAME , TEMPLATE_FNM , \"FinePrint\" , false ); This example will send a single combined print job to the \"FinePrint\" printer. The printer name can be obtained using one of the techniques explained in the previous chapter. Mail.mergePrint() calls Mail.mergeTask() with its printer name and multiple jobs boolean arguments set: // in the Mail class public static void mergePrint ( String dataSourceName , String tableName , String templateFnm , String printerName , boolean isMultipleJobs ) { System . out . println ( \"Merging letters for printing...\" ); mergeTask ( dataSourceName , tableName , templateFnm , MailMergeType . PRINTER , false , printerName , isMultipleJobs , null , null , null ); } // end of mergePrint() Mail.mergeEmail() is passed the data source name, table name, and template filename as before, and the mail server's password, e-mail subject line and body string: // in MailMerge.java... Mail . mergeEmail ( DATA_SOURCE_NAME , TABLE_NAME , TEMPLATE_FNM , password , \"Hello\" , \"Please read the attached message.\" ); Six e-mails are sent to the addresses listed in the \"E-mail\" column of the spreadsheet (see Figure 6). Each e-mail contains the subject and body text supplied in the call, and an attached copy of the personalized letter. Mail.mergeEmail() calls Mail.mergeTask(): // in the Mail class public static void mergeEmail ( String dataSourceName , String tableName , String templateFnm , String passwd , String subject , String body ) { System . out . println ( \"Merging letters for sending as e-mail...\" ); boolean isConfigured = checkMailConfig ( passwd ); System . out . println ( \"--> Mailhost is \" + ( isConfigured ? \"\" : \"NOT \" ) + \"configured\" ); if ( isConfigured ) mergeTask ( dataSourceName , tableName , templateFnm , MailMergeType . MAIL , false , null , false , passwd , subject , body ); } // end of mergeEmail() The e-mailing employs the same mailmerge.py Python script as MailServiceProvider, which means it will crash when using SSL encryption unless ssleay32.dll and libeay32.dll have been copied from Office's \"program\\\" folder into \"program\\python- core-???\\lib\\\". Please refer back to section 2 for more details. mailmerge.py attempts to open a link with the specified mail server at the given port, and usually has to supply a login and password to be allowed access. If you look back at the arguments passed to Mail.mergeEmail() you can see that the password is supplied, but what about the mail server address, its port, and a login name? The only way to specify them is via Writer's option dialog. The relevant windows are shown in Figure 10. Figure 10. Setting Writer E-mail Options. The left-hand dialog allows the mail server's address and port to be entered (fivedots.coe.psu.ac.th and 25). If secure communication is required (i.e. SSL, TLS, or STARTTLS), then the secure SSL checkbox is ticked and the \"Server Authentication\" button pressed. A second dialog opens, shown on the right in Figure 10, which lets you enter a login and password for accessing the server. It's good practice not to enter a password since the data is stored as plain text in \"registrymodifications.xcu\" in Office's user configuration directory (often the folder \\(APPDATA\\) \\LibreOffice\\??\\user). It's safer to pass the password to Mail.mergeTask() at run time, as I've done in Mail.mergeEmail(). mergeEmail() calls Mail.checkMailConfig() to check if the mail server address, port number, username, and password can be found in \"registrymodifications.xcu\". If the first three aren't present then checkMailConfig() returns false and the merge is aborted. If the password is found, then a stern warning message is printed, but merging continues. checkMailConfig() calls Info.getRegItemProp() which uses XPath to search through \"registrymodifications.xcu\" for the specified property names and values. 6.4. mergeTask(): Implementing Mail Merging \u00b6 mergeTask() is an expanded version of the code snippet given above which creates an XJob instance, sets properties in the MailMerge service, and calls XJob.execute(). The properties settings are spread across if-tests which determine if the task involves file creation, printing, or e-mail. Also, a listener is attached to the merge process. The mergeTask() code: // in the Mail class public static void mergeTask ( String dataSourceName , String tableName , String templateFnm , short outputType , boolean isSingle , // for FILE String printerName , boolean isMultipleJobs , // for PRINTER String passwd , String subject , String body ) // for MAIL { XJob job = Lo . createInstanceMCF ( XJob . class , \"com.sun.star.text.MailMerge\" ); if ( job == null ) { System . out . println ( \"Could not create MailMerge service\" ); return ; } XPropertySet props = Lo . qi ( XPropertySet . class , job ); // standard task properties Props . setProperty ( props , \"DataSourceName\" , dataSourceName ); Props . setProperty ( props , \"Command\" , tableName ); Props . setProperty ( props , \"CommandType\" , CommandType . TABLE ); Props . setProperty ( props , \"DocumentURL\" , FileIO . fnmToURL ( templateFnm )); // vary properties based on output type Props . setProperty ( props , \"OutputType\" , outputType ); if ( outputType == MailMergeType . FILE ) { Props . setProperty ( props , \"SaveAsSingleFile\" , isSingle ); Props . setProperty ( props , \"FileNamePrefix\" , \"letter\" ); // hardwired filename } else if ( outputType == MailMergeType . PRINTER ) { Props . setProperty ( props , \"SinglePrintJobs\" , isMultipleJobs ); // true means one print job for each letter PropertyValue [] pProps = Props . makeProps ( \"PrinterName\" , printerName , \"Wait\" , true ); // synchronous printing // from com.sun.star.view.PrintOptions Props . setProperty ( props , \"PrintOptions\" , pProps ); } else if ( outputType == MailMergeType . MAIL ) { if ( passwd != null ) Props . setProperty ( props , \"OutServerPassword\" , passwd ); Props . setProperty ( props , \"AddressFromColumn\" , \"E-mail\" ); // hardwired column name Props . setProperty ( props , \"Subject\" , subject ); Props . setProperty ( props , \"MailBody\" , body ); Props . setProperty ( props , \"SendAsAttachment\" , true ); Props . setProperty ( props , \"AttachmentName\" , \"letter.pdf\" ); // hardwired filename and type Props . setProperty ( props , \"AttachmentFilter\" , \"writer_pdf_Export\" ); } // monitor task's execution XMailMergeBroadcaster xmmb = Lo . qi ( XMailMergeBroadcaster . class , job ); xmmb . addMailMergeEventListener ( new XMailMergeListener () { int count = 0 ; long start = System . currentTimeMillis (); public void notifyMailMergeEvent ( MailMergeEvent e ) { count ++ ; XModel model = e . Model ; // Props.showProps(\"Mail merge event\", model.getArgs()); long currTime = System . currentTimeMillis (); System . out . println ( \" Letter \" + count + \": \" + ( currTime - start ) + \"ms\" ); start = currTime ; } }); try { job . execute ( new NamedValue [ 0 ] ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not start executing task: \" + e ); } } // end of mergeTask() There are four properties that are always set: Props . setProperty ( props , \"DataSourceName\" , dataSourceName ); Props . setProperty ( props , \"Command\" , tableName ); Props . setProperty ( props , \"CommandType\" , CommandType . TABLE ); Props . setProperty ( props , \"DocumentURL\" , FileIO . fnmToURL ( templateFnm )); These specify the use of a spreadsheet table, the data source name, and the template filename (as a URI). The other properties are divided up based on the MailMergeType constants FILE, PRINT, and MAIL (see lodoc MailMergeType ). I've hardwired certain properties to reduce the number of arguments that need to be passed to Mail.mergeLetter(), Mail.mergePrint(), and Mail.mergeEmail(). The listener implements the XMailMergeListener interface, and is attached through XMailMergeBroadcaster. notifyMailMergeEvent() is called each time a new letter is created. For my addresses.ods spreadsheet, it's triggered six times since there are six rows of data (see Figure 6). notifyMailMergeEvent() prints only timing information for each letter task, but more details could be obtained by accessing the event's model. 6.5. Mail Merge Reliability \u00b6 Office's mail merge wizard, which implements the \"Office API\" parts of Figure 5, and so corresponds to my Mail.mergeTask()function, has a long history of crashing. Mail.mergeTask() has always worked fine in my tests, except that it displays a \"LibreOffice has stopped working\" error dialog after terminating. However, no zombie Office processes are left over, so the dialog can be safely ignored and closed.","title":"Chapter 42. Sending E-mail"},{"location":"42-Sending_E-mail.html#chapter-42-sending-e-mail","text":"Topics SimpleSystemMail / SimpleCommandMail; Using the MailServiceProvider Service; Using JavaMail; The Desktop API; Thunderbird Scripting; Office Mail Merge Example folders: \"Mail Tests\" and \"Utils\" The Jargon file is a humorous collection of computer slang (online at https://catb.org/jargon/html/ ), and its entry for Zawinski's \"Law of Software Envelopment\" ( https://catb.org/jargon/html/Z/Zawinskis-Law.html ) came to mind while I was preparing this chapter. It states: \"Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can.\" Office is a reasonable example (if you replace 'read' with 'send') because, depending on how you count things, its API contains three different ways of sending e-mail. If you program in Java, the number increases to six! These approaches are summarized in Table 1, and none are without drawbacks. API Services/Classes Used Drawbacks Office API SimpleSystemMail or User must click \"Ok\" in a \"Confirm\" (coded in Java) SimpleCommandMail dialog before the e-mail is sent. MailServiceProvider Two DLLs must be repositioned in the (joint best choice) Office installation before the code will work. Firewalls may block it. MailMerge Works well, but focuses on mail merge rather than general purpose e- mail. The user must configure Office's e- mail settings in Writer before the code will work. Java only JavaMail: Session, Requires the download of the (no use of Office) Message, Transport, and javax.mail JAR. others (joint best Firewalls may block it. choice) Desktop.mail() Attachments are not supported as standard in the mailto: protocol. The e-mail client appears, and the user must press \"Send\". Process & batch file Needs a separate batch file. Tied to the Thunderbird e-mail client. The e-mail client appears, and the user must press \"Send\". Table 1. Office and Java Approaches for Sending E-mail. My aim is to write a sendMessage() function that sends a text message, optionally including a file attachment, to a specified e-mail address. The mail will be sent through an SMTP (Simple Mail Transfer Protocol) server that uses STARTTLS to encrypt the link. I've tested the code using my local departmental server, and with my Gmail account. One surprising entry in Table 1 is Office's mail merge, which typically utilizes a Writer template file and a spreadsheet (or database) to generate form letters addressed to different people. These letters can be saved to files, sent to a printer, or posted out as e-mail attachments. It's the last alternative that led me to include mail merging in this chapter. Table 1 identifies two \"joint best choice\" approaches for sending e-mail. If the mail- out is part of other Office-related tasks, such as the run-time generation of a document, then its best to use Office's MailServiceProvider service since it nicely integrates with the rest of the API. However, if you plan to write a standalone e-mail application which loads and sends ODF attachments, then JavaMail has more features ( https://java.net/projects/javamail/pages/Home/ ). I'll start this chapter by explaining the Office services for sending e-mail: SimpleSystemMail/SimpleCommandMail, and the newer MailServiceProvider. Then I'll switch to non-Office approaches, looking first at JavaMail, followed by two techniques which don't need an extra JAR file but do require the user to interact with the OSes e-mail client. I'll finish with mail merge in Office.","title":"Chapter 42. Sending E-mail"},{"location":"42-Sending_E-mail.html#1-simplesystemmailsimplecommandmail","text":"The SimpleSystemMail and SimpleCommandMail services in the system module send e-mail using the OSes default e-mail client. They both implement the same interfaces, but SimpleSystemMail is for Windows, and SimpleCommandMail for Linux and MacOS. Figure 1 shows the services and some of their interfaces. Figure 1. The SimpleSystemMail and SimpleCommandMail Services. By utilizing the machine's e-mail client, the services don't need the programmer to enter the mail server address, its port, and a login and password, since this information is in the client's account settings (or user profile). A drawback of this approach is that the message passes through the client's GUI, and the user must press a \"Send\" button (or equivalent) to post the message. Fortunately, XSimpleMailClient lets the user interface be mostly hidden, but a \"Confirm\" dialog like the one in Figure 2 still pops up. Figure 2. The \"Confirm\" Dialog when using SimpleSystemMail/SimpleCommandMail. This dialog can be disabled via the checkbox shown in Figure 2, but that's a bad idea from a security viewpoint. SimpleSystemMail and SimpleCommandMail are utilized by sendEmailByClient() in my Mail.java utility class: // in the Mail class public static void sendEmailByClient ( String to , String subject , String body , String fnm ) { System . out . println ( \"Sending e-mail by client...\" ); try { XSimpleMailClientSupplier mcSupp = Lo . createInstanceMCF ( XSimpleMailClientSupplier . class , \"com.sun.star.system.SimpleSystemMail\" ); // windows e-mail client service if ( mcSupp == null ) { mcSupp = Lo . createInstanceMCF ( XSimpleMailClientSupplier . class , \"com.sun.star.system.SimpleCommandMail\" ); // returns null on Windows; used on Linux/Mac if ( mcSupp == null ) { System . out . println ( \"Unable to create client\" ); return ; } } XSimpleMailClient mc = mcSupp . querySimpleMailClient (); // defaults to ThunderBird on my OS XSimpleMailMessage msg = mc . createSimpleMailMessage (); msg . setRecipient ( to ); msg . setSubject ( subject ); XSimpleMailMessage2 msg2 = Lo . qi ( XSimpleMailMessage2 . class , msg ); msg2 . setBody ( body ); if ( fnm != null ) { String [] attachs = new String [ 1 ] ; attachs [ 0 ] = FileIO . getAbsolutePath ( fnm ); // attachment msg . setAttachement ( attachs ); } mc . sendSimpleMailMessage ( msg , SimpleMailClientFlags . NO_USER_INTERFACE ); // hides GUI but still displays a \"Confirm\" dialog } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of sendEmailByClient() The function first tries to instantiate the Windows SimpleSystemMail service, which returns null on a Linux/Mac platform, and then switches to SimpleCommandMail (which returns null on Windows). The resulting XSimpleMailClientSupplier instance is used to obtain a reference to the system's default e-mail client, as represented by XSimpleMailClient. An XSimpleMailMessage object is initialized with the recipient, subject line, body text, and optionally attached file. One of the quirks of the API is that the body text is added via the XSimpleMailMessage2 subclass of XSimpleMailMessage. A typical call to sendEmailByClient(): // part of LoMailer.java... Mail . sendEmailByClient ( \"xxx@xxx\" , \"Test\" , \"Body\" , \"skinner.png\" ); The default e-mail client on Windows is the application associated with the mailto protocol, as depicted in Figure 3. Figure 3. The Default E-mail Client of Windows 7. A good description of how to set up this association can be found at https://ubergizmo.com/how-to/set-default-email-client-windows/","title":"1.  SimpleSystemMail/SimpleCommandMail"},{"location":"42-Sending_E-mail.html#2-using-the-mailserviceprovider-service","text":"The MailServiceProvider service utilizes a Python script called mailmerge.py which creates a socket-based link to the specified mail server. If that link utilizes SSL (or its successor TLS) for encrypted communication, then your code will probably crash with the error message \"No SSL support included in this Python\". This bug ( https://bugs.documentfoundation.org/show_bug.cgi?id=77354 ) is marked as \"RESOLVED NOTOURBUG\" at Office's bugzilla website which seems a bit dismissive. The problem appears to be due to the position of Office's application folders in Window's PATH environment variable. When Windows searches for two DLLs, ssleay32.dll and libeay32.dll, which implement OpenSSL, it may find incorrect versions in folders mentioned earlier in PATH. It's these incorrect DLLs that cause Python to issue the cryptic error. One solution is to copy the correct DLLs from Office's \"program\\\" folder into the \"program\\python-core-???\\lib\\\" folder (??? is a version number, such as 3.3.3), thereby ensuring they're chosen first. Another issue with switching to MailServiceProvider is that the programmer must supply more information to setup the SMTP connection, namely the address of the mail server, its port, and the login and password for accessing the server. MailServiceProvider is utilized by the Mail.sendEmail() function. Given below are examples of how it sends e-mail to my local fivedots.coe.psu.ac.th mail server and to the Gmail server at smtp.gmail.com: // part of LoMailer.java... Mail . sendEmail ( \"fivedots.coe.psu.ac.th\" , 25 , \"ad\" , password , \"xxx@xxx\" , \"Test 1\" , \"Body 1\" , \"skinner.png\" ); Mail . sendEmail ( \"smtp.gmail.com\" , 587 , \"Andrew.Davison50@gmail.com\" , password , \"xxx@xxx\" , \"Test 2\" , \"Body 2\" , \"addresses.ods\" ); The Mail.sendEmail() arguments are: the mail server address, its port, the login and password for the server, the recipient of the mail, the subject line, the body text, and an optional attachment filename. SMTP is built on top of a TCP network link, and in these security conscious days many companies and universities (including mine) use firewalls to block everything but Web links. That means I cannot use MailServiceProvider to access my Gmail account at work since its mail server is beyond my departmental firewall. However, I can access the fivedots departmental mail server. MailServiceProvider is located in the mail module, along with several interfaces. The other important service is MailMessage for constructing e-mail messages. Figure 4 shows the relationships between the services and their interfaces. Figure 4. The MailServiceProvider and MailMessage Services. An SMTP service is created via the XMailServiceProvider interface: // part of Mail.sendEmail() : XMailServiceProvider msp = Lo . createInstanceMCF ( XMailServiceProvider . class , \"com.sun.star.mail.MailServiceProvider\" ); if ( msp == null ) { System . out . println ( \"Could not create MailServiceProvider\" ); return ; } XMailService service = msp . create ( MailServiceType . SMTP ); if ( service == null ) { System . out . println ( \"Could not create SMTP MailService\" ); return ; } A listener can be attached to the service, to report on its connection status: // part of Mail.sendEmail() : service . addConnectionListener ( new XConnectionListener () { public void connected ( EventObject e ) { System . out . println ( \"Connected to server \" + getServerName ( e )); } public void disconnected ( EventObject e ) { System . out . println ( \" Disconnected\" ); } public void disposing ( EventObject e ) {} }); The connection requires address, port, protocol, login and password details, which are supplied through XCurrentContext and XAuthenticator: // in the Mail class public static void sendEmail ( String mailhost , int port , String user , String password , String to , String subject , String body , String fnm ) { : // service creation code; see above // initialize service data: context and authenticator XCurrentContext xcc = new XCurrentContext () { public Object getValueByName ( String name ) { if ( name . equals ( \"ServerName\" )) return ( Object ) mailhost ; else if ( name . equals ( \"Port\" )) return ( Object ) new Integer ( port ); else if ( name . equals ( \"ConnectionType\" )) return ( Object ) \"Ssl\" ; // or \"Insecure\"; else if ( name . equals ( \"Timeout\" )) return ( Object ) new Integer ( 60 ); System . out . println ( \"Do not recognize \\\"\" + name + \"\\\"\" ); return null ; } }; XAuthenticator auth = new XAuthenticator () { public String getUserName () { return user ; } public String getPassword () { return password ; } }; // connect to service service . connect ( xcc , auth ); System . out . println ( \"Isconnected: \" + service . isConnected ()); I've hardwired a time of 60 seconds in XCurrentContext which sets how long the code waits for a connection before giving up. MailMessage utilizes an unusual create() method, and the message's body is represented by an XTransferable instance rather than a string: // part of Mail.sendEmail() : String from = user + \"@\" + mailhost ; // person sending this e-mail XMailMessage msg = com . sun . star . mail . MailMessage . create ( Lo . getContext (), to , from , subject , new TextTransferable ( body )); The online documentation for MailMessage.create() (use lodoc MailMessage to access it) is misleading in that it doesn\u2019t mention the need for the component context, which is obtained with the Lo.getContext() call. My TextTransferable class implements the XTransferable interface, which defines how different MIME data types are transferred. XTransferable is mainly used in two ways \u2013 for packaging e-mail data (as here), and for moving data to and from the clipboard (which I'll discuss in the next chapter). TextTransferable lets Unicode text be treated as a transferable: // in the Utils/ folder public class TextTransferable implements XTransferable { private final String text ; private final String UNICODE_MIMETYPE = \"text/plain;charset=utf-16\" ; public TextTransferable ( String s ) { text = s ; } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE )) throw new UnsupportedFlavorException (); return text ; } public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = new DataFlavor ( UNICODE_MIMETYPE , \"Unicode Text\" , new Type ( String . class )); return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE ); } } // end of TextTransferable class A DataFlavor object hold three fields: the MIME type string for the data (e.g. \"text/plain\"), a 'human presentable' name for the data (which can be anything), and the corresponding Office data type. We're not finished with transferable data since an attached file must also be packaged in a similar way using Office's MailAttachment class and my FileTransferable class: // part of Mail.sendEmail() if ( fnm != null ) msg . addAttachment ( new MailAttachment ( new FileTransferable ( fnm ), fnm )); FileTransferable looks up the MIME type for its supplied file, and stores the file contents in a byte array which is returned by getTransferData(): // in the Utils/ folder public class FileTransferable implements XTransferable { private String mimeType = \"application/octet-stream\" ; // default private byte [] fileData = null ; public FileTransferable ( String fnm ) { mimeType = Info . getMIMEType ( fnm ); try { fileData = Files . readAllBytes ( Paths . get ( fnm )); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not read bytes from \" + fnm ); } } // end of FileTransferable() public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( mimeType )) throw new UnsupportedFlavorException (); return fileData ; } // end of getTransferData() public DataFlavor [] getTransferDataFlavors () { DataFlavor [] flavors = new DataFlavor [ 1 ] ; flavors [ 0 ] = new DataFlavor ( mimeType , mimeType , new Type ( byte [] . class )); return flavors ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( mimeType ); } } // end of FileTransferable class MIME type lookup is implemented by Info.getMIMEType() which uses Java's MimetypesFileTypeMap to examine a file of MIME types stored in my Utils/ folder: // in the Info class private static final String MIME_FNM = \"mime.types\" ; public static String getMIMEType ( String fnm ) { File f = new File ( fnm ); try { MimetypesFileTypeMap mftMap = new MimetypesFileTypeMap ( FileIO . getUtilsFolder () + MIME_FNM ); return mftMap . getContentType ( f ); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not find \" + MIME_FNM ); return \"application/octet-stream\" ; // better than nothing } } // end of getMIMEType() Back in Mail.sendEmail(), all that's left to do is to send the message using XSmtpService.sendMailMessage(): // part of Mail.sendEmail()... XSmtpService smtpService = Lo . qi ( XSmtpService . class , service ); smtpService . sendMailMessage ( msg ); service . disconnect ();","title":"2.  Using the MailServiceProvider Service"},{"location":"42-Sending_E-mail.html#3-using-javamail","text":"JavaMail can send and receive e-mail via SMTP, POP3 and IMAP (its website is https://java.net/projects/javamail/pages/Home/ ). Although JavaMail is mainly intended to be a component of Java EE, it can be downloaded as a single JAR file (javax.mail.jar) as an add-on to the JDK. It's being actively developed (the current version is 1.5.6, released in mid 2016), and the website has lots of examples (see https://java.net/projects/javamail/downloads/download/javamail-samples.zip ), a FAQ, and API documentation (at https://javamail.java.net/nonav/docs/api/ ). The main textbook about JavaMail is: JavaMail API 1 st Edition Elliotte Rusty Harold O'Reilly, 2013 This started out as a chapter in Harold's \"Java Network Programming\" text, but was separated off after the 3 rd edition. Another nice resource if you want to build a GUI e-mail client using JavaMail is chapter 5 of The Art of Java by Herbert Schlidt and James Holmes, McGraw Hill, 2003. JavaMail utilizes the same approach as mailmerge.py mentioned earlier \u2013 it creates an SMTP connection using a TCP socket link to a mail server. As such it suffers from the same problem with firewalls, which means that I can't use it with my Gmail account when I'm at work. My non-Office e-mail support functions are in JMail.java, and have a similar interface to the Office versions. For instance, JMail.sendEmail() is employed to send an e-mail with JavaMail. The following two calls use the fivedots and Gmail servers: // in JMailer.java... JMail . sendEmail ( \"fivedots.coe.psu.ac.th\" , 25 , \"ad\" , password , \"xxx@xxx\" , \"Test 1\" , \"Body 1\" , \"skinner.png\" ); JMail . sendEmail ( \"smtp.gmail.com\" , 587 , \"Andrew.Davison50@gmail.com\" , password , \"xxx@xxx\" , \"Test 2\" , \"Body 2\" , \"addresses.ods\" ); They're no different from my earlier Mail.sendEmail() examples, except for the name of the support class. The arguments are: the mail server address, its port, the login and password for the server, the recipient of the mail, the subject line, the body text, and an optional attachment. JavaMail sending is based around three classes: Transport, Session, and Message. Transport specifies the underlying communication link, while Session handles the details of the communication protocol using that link. For example, secure communication is setup through properties passed to Session.getInstance(): // part of JMail.sendEmail()... Properties props = new Properties (); props . put ( \"mail.smtp.starttls.enable\" , \"true\" ); props . put ( \"mail.smtp.ssl.trust\" , \"*\" ); // no certificate needed props . put ( \"mail.smtp.timeout\" , \"60000\" ); Session session = Session . getInstance ( props ); The mail server address, port, login and password details are used to create a SMTPTransport instance (a subclass of Transport): // part of JMail.sendEmail()... URLName url = new URLName ( \"smtp\" , mailhost , port , \"\" , user , password ); Transport transport = new SMTPTransport ( session , url ); transport . connect ( mailhost , port , user , password ); JavaMail supports two kinds of listeners, one for the connection and the other for message delivery. Simple implementations are given in JMail.sendEmail(): // part of JMail.sendEmail()... : transport . addConnectionListener ( new ConnectionListener () { public void opened ( ConnectionEvent e ) { System . out . println ( \" Connection opened to: \" + e . getSource ()); } public void disconnected ( ConnectionEvent e ) { System . out . println ( \" Connection disconnected\" ); } public void closed ( ConnectionEvent e ) { System . out . println ( \" Connection closed\" ); } }); transport . addTransportListener ( new TransportListener () { public void messageDelivered ( TransportEvent e ) { System . out . println ( \" Message delivered\" ); } public void messageNotDelivered ( TransportEvent e ) { System . out . println ( \" Message not delivered\" ); } public void messagePartiallyDelivered ( TransportEvent e ) { System . out . println ( \" Message partially delivered\" ); } }); An SMTP message has fields for the recipient, subject line, body text, and an optional attached file: // part of JMail.sendEmail() : SMTPMessage msg = new SMTPMessage ( session ); msg . setReturnOption ( SMTPMessage . RETURN_HDRS ); msg . setNotifyOptions ( SMTPMessage . NOTIFY_SUCCESS | SMTPMessage . NOTIFY_FAILURE ); msg . setFrom (); // uses default msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( to )); msg . setSentDate ( new Date ()); msg . setSubject ( subject ); if ( attachFnm == null ) msg . setText ( body ); else { // add body text and file as attachments MimeBodyPart p1 = new MimeBodyPart (); p1 . setText ( body ); String mimeType = Info . getMIMEType ( attachFnm ); MimeBodyPart p2 = new MimeBodyPart (); FileDataSource fds = new FileDataSource ( attachFnm ); p2 . setDataHandler ( new DataHandler ( fds )); // add data, p2 . setFileName ( fds . getName ()); // filename, p2 . setHeader ( \"Content-Type\" , mimeType ); // MIME type // create multipart Multipart mp = new MimeMultipart (); mp . addBodyPart ( p1 ); // for body text mp . addBodyPart ( p2 ); // for the attached file msg . setContent ( mp ); } If the message contains body text and an attachment then it's necessary to add them as MimeBodyPart objects in a Multipart container. Body text on its own can be added using SMTPMessage.setText(). The MimeBodyPart holding the attachment must include the file's MIME type in its \"Content-type\" header. Once the message has been sent, the link is closed: transport . sendMessage ( msg , msg . getAllRecipients ()); transport . close ();","title":"3.  Using JavaMail"},{"location":"42-Sending_E-mail.html#4-the-desktop-api","text":"The Java equivalent of Office's SimpleSystemMail/SimpleCommandMail service is the Desktop.mail() method. It utilizes the OSes default e-mail client to post a message, which means that there's no need to download the javax.mail JAR. The delivery doesn't need to explicitly include the mail server address, port, login, and password since they're obtained from the client's settings. Desktop.mail() utilizes the mailto protocol to communicate with the client, but its specification (in RFC 2368, at https://ietf.org/rfc/rfc2368.txt ) doesn't cover attachments. There are unofficial extensions supported by some clients, but they're not part of Thunderbird (but see the next section). The mailto syntax is: \"mailto:\" recipients [ \"?\" key \"=\" value (\"&\" key \"=\" value)* ] with recipients: comma-separated e-mail addresses without spaces; Outlook needs semicolons instead of commas; key: subject, cc, bcc, body (note: there's no attachment keyword); value: URL-encoded text (e.g. space becomes %20). An example: mailto:xxx@xxx?subject=Hello&body=How%20are%20you%3F Desktop.mail() is employed by JMail.sendEmailByClient(). An example of its use: JMail.sendEmailByClient(\"xxx@xxx\", \"Hello\", \"How are you?\"); There's no way in Desktop to suppress the client's GUI, which appears on-screen, and the user must press the \"Send\" button (or equivalent) to post out the message. JMail.sendEmailByClient() is: // in the JMail class public static void sendEmailByClient ( String to , String subject , String body ) { sendEmailByClient ( to , subject , body , null ); } public static void sendEmailByClient ( String to , String subject , String body , String fnm ) { if ( ! Desktop . isDesktopSupported ()) { System . out . println ( \"Desktop mail not supported\" ); return ; } // construct \"mailto:\" string for Desktop.mail() String uriStr = String . format ( \"mailto:%s?subject=%s&body=%s\" , encodeMailto ( to ), encodeMailto ( subject ), encodeMailto ( body ) ); if ( fnm != null ) uriStr += \"&attachment=\\\"\" + FileIO . getAbsolutePath ( fnm ) + \"\\\"\" ; try { Desktop desktop = Desktop . getDesktop (); desktop . mail ( new URI ( uriStr )); } catch ( Exception e ) { System . out . println ( e ); } } // end of sendEmailByClient() public static String encodeMailto ( String str ) { try { return URLEncoder . encode ( str , \"UTF-8\" ). replace ( \"+\" , \"%20\" ); } catch ( UnsupportedEncodingException e ) { System . out . println ( \"Could not encode: \\\"\" + str + \"\\\"\" ); return null ; } } // end of encodeMailto() Following the mailto specification, the key values in the mailto string must be URL encoded. sendEmailByClient() has an attachment argument mainly because I've read that some clients, such as Outlook, can accept it. But if I try to use an attachment with Thunderbird, the call to Desktop.mail() fails.","title":"4.  The Desktop API"},{"location":"42-Sending_E-mail.html#5-thunderbird-scripting","text":"The reason for my uncertainty about Thunderbird supporting attachments is that although it doesn't allow them in \"mailto\" strings, it can process attachments via its GUI, and the command line (see https://kb.mozillazine.org/Command_line_arguments_-_Thunderbird/ ). Its command line features open up another way of sending e-mail: by having Java execute Thunderbird through an external script. My Windows batch file, called TBExec.bat, applies various checks to its command line arguments, and then invokes Thunderbird using: thunderbird . exe - compose \"to='%1',subject='%2', body='%3',attachment='%CD%\\%4'\" The \"attachment\" value is an absolute file name. The Java code uses Runtime.exec() to execute the batch file, passing it three or four arguments: // in the JMail class public static void sendEmailByTB ( String to , String subject , String body , String fnm ) { String mailExec = String . format ( \"cmd /c TBExec.bat %s \\\"%s\\\" \\\"%s\\\"\" , to , subject , body ); if ( fnm != null ) // add attachment argument mailExec += \" \" + fnm ; try { Process p = Runtime . getRuntime (). exec ( mailExec ); p . waitFor (); System . out . println ( \"Sent e-mail using Thunderbird\" ); } catch ( java . lang . Exception e ) { System . out . println ( \"Unable to send Thunderbird mail: \" + e ); } } // end of sendEmailByTB() As with Desktop.mail(), there's no way to stop the Thunderbird GUI from being displayed, and the user has to press the \"Send\" button to send off the message.","title":"5.  Thunderbird Scripting"},{"location":"42-Sending_E-mail.html#6-office-mail-merge","text":"Mail merge usually involves a spreadsheet of data and a form letter stored as a Writer template (an OTT file). Data from the spreadsheet replaces fields in the template, such as < Name > and < Address >, with real names and addresses, creating a series of personalized letters. Other common uses are to generate labels and envelopes. After the letters (or labels or envelopes) have been created, they can be saved to files (or to a single file), sent to a printer, or attached to e-mails. It's because of this last choice that I've included mail merging here. Figure 5 pictures the mail merge stages in more detail. Figure 5. Mail Merging using a Spreadsheet and a Writer Template.","title":"6.  Office Mail Merge"},{"location":"42-Sending_E-mail.html#61-preparing-the-mail-merge-inputs","text":"Mail merge configuration is most easily done using Office's GUI and wizards, and is excellently explained in chapter 11 of the Writer Guide (available from https://th.libreoffice.org/get-help/documentation/ ). A screenshot of a typical spreadsheet is shown in Figure 6. Figure 6. The addresses.ods Spreadsheet. The field names employed in the template correspond to column names in the spreadsheet (e.g. \"Title\" and \"First Name\"). Also, if the merging involves posting out of e-mails then there must be an \"E-mail\" column in the sheet; those addresses will be used as the message recipients. The spreadsheet has to be converted into a data source for the merge. This is done via Office's File, Wizards, Address Data Source menu item, as explained in the Writer Guide. The outcome is a new ODB file with the same name as the spreadsheet (addresses.odb in my case). This data source can be viewed from inside Calc by selecting the menu item View, Data Sources. The GUI display is shown in Figure 7. Figure 7. Addresses.ods with a Data Source. The \"Addresses\" data source has been opened to show its \"Addresses\" table. Both of these names will be needed later when we start programming. The next step is to add fields in the \"Addresses\" table to the Writer template. This involves dragging field names from the top row of the table over to the template, and positioning them in the text. Figure 8 shows part of the resulting template, stored in formLetter.ott. Figure 8. Part of formLetter.ott. The fields are automatically displayed in angled brackets inside gray rectangles.","title":"6.1.  Preparing the Mail Merge Inputs"},{"location":"42-Sending_E-mail.html#62-programming-the-mail-merge","text":"The MailMerge service is located in the text module; most of its programming involves setting properties, and then calling XJob.execute(). The main services and interfaces are shown in Figure 9. Figure 9. The MailMerge Service and Interfaces. The XMailMergeBroadcaster interface is employed to attach a listener to the merging process, and XCancellable can kill the merge. If you look at the documentation for the MailMerge and DataAccessDescriptor services (e.g. use lodoc MailMerge ), you'll discover many properties in both, and that most (but not all) of the DataAccessDescriptor properties are redefined in MailMerge. The coding is summarized by the following snippet from Mail.mergeTask(): // in Mail.mergeTask() : XJob job = Lo . createInstanceMCF ( XJob . class , \"com.sun.star.text.MailMerge\" ); XPropertySet props = Lo . qi ( XPropertySet . class , job ); Props . setProperty ( props , \"DataSourceName\" , dataSourceName ); Props . setProperty ( props , \"Command\" , tableName ); : // many more properties are set... : job . execute ( new NamedValue [ 0 ] ); The MailMerge service is created as an XJob interface. Service properties are set, and then the merge is carried out by calling XJob.execute(). The NamedValue array is empty since there's no need to set any more properties using it.","title":"6.2.  Programming the Mail Merge"},{"location":"42-Sending_E-mail.html#63-specializing-the-merge","text":"Mail.mergeTask() is passed numerous property values. To simplify its interface, the call is hidden inside three other functions called Mail.mergeLetter(), Mail.mergePrint(), and Mail.mergeEmail(), which focus on the three different outcomes of a merge (see Figure 5). Mail.mergeLetter() takes four arguments, three of which (data source name, table name, template filename) are needed for any kind of merge: // in the Mail class public static void mergeLetter ( String dataSourceName , String tableName , String templateFnm , boolean isSingle ) { System . out . println ( \"Merging letters to files...\" ); mergeTask ( dataSourceName , tableName , templateFnm , MailMergeType . FILE , isSingle , null , false , null , null , null ); } // end of mergeLetter() The following call to Mail.mergeLetter() saves six letters as \"letter0.odt\" to \"letter5.odt\": // in MailMerge.java... private static final String DATA_SOURCE_NAME = \"Addresses\" ; private static final String TABLE_NAME = \"Addresses\" ; private static final String TEMPLATE_FNM = \"formLetter.ott\" ; Mail . mergeLetter ( DATA_SOURCE_NAME , TABLE_NAME , TEMPLATE_FNM , false ); I've defined the data source name, table name, and template filename as constants to make the call to Mail.mergeLetter() easier to read. The boolean argument specifies whether a single file should hold all the generated letters. The generated filenames are hardwired inside Mail.mergeTask() to be \"letter\" and a number. Six files are created since the spreadsheet (see Figure 6) has six rows of data. Mail.mergePrint() is passed the same first three arguments (data source name, table name, template filename), and a printer name and a boolean to signal whether multiple print jobs should be created: // in MailMerge.java... Mail . mergePrint ( DATA_SOURCE_NAME , TABLE_NAME , TEMPLATE_FNM , \"FinePrint\" , false ); This example will send a single combined print job to the \"FinePrint\" printer. The printer name can be obtained using one of the techniques explained in the previous chapter. Mail.mergePrint() calls Mail.mergeTask() with its printer name and multiple jobs boolean arguments set: // in the Mail class public static void mergePrint ( String dataSourceName , String tableName , String templateFnm , String printerName , boolean isMultipleJobs ) { System . out . println ( \"Merging letters for printing...\" ); mergeTask ( dataSourceName , tableName , templateFnm , MailMergeType . PRINTER , false , printerName , isMultipleJobs , null , null , null ); } // end of mergePrint() Mail.mergeEmail() is passed the data source name, table name, and template filename as before, and the mail server's password, e-mail subject line and body string: // in MailMerge.java... Mail . mergeEmail ( DATA_SOURCE_NAME , TABLE_NAME , TEMPLATE_FNM , password , \"Hello\" , \"Please read the attached message.\" ); Six e-mails are sent to the addresses listed in the \"E-mail\" column of the spreadsheet (see Figure 6). Each e-mail contains the subject and body text supplied in the call, and an attached copy of the personalized letter. Mail.mergeEmail() calls Mail.mergeTask(): // in the Mail class public static void mergeEmail ( String dataSourceName , String tableName , String templateFnm , String passwd , String subject , String body ) { System . out . println ( \"Merging letters for sending as e-mail...\" ); boolean isConfigured = checkMailConfig ( passwd ); System . out . println ( \"--> Mailhost is \" + ( isConfigured ? \"\" : \"NOT \" ) + \"configured\" ); if ( isConfigured ) mergeTask ( dataSourceName , tableName , templateFnm , MailMergeType . MAIL , false , null , false , passwd , subject , body ); } // end of mergeEmail() The e-mailing employs the same mailmerge.py Python script as MailServiceProvider, which means it will crash when using SSL encryption unless ssleay32.dll and libeay32.dll have been copied from Office's \"program\\\" folder into \"program\\python- core-???\\lib\\\". Please refer back to section 2 for more details. mailmerge.py attempts to open a link with the specified mail server at the given port, and usually has to supply a login and password to be allowed access. If you look back at the arguments passed to Mail.mergeEmail() you can see that the password is supplied, but what about the mail server address, its port, and a login name? The only way to specify them is via Writer's option dialog. The relevant windows are shown in Figure 10. Figure 10. Setting Writer E-mail Options. The left-hand dialog allows the mail server's address and port to be entered (fivedots.coe.psu.ac.th and 25). If secure communication is required (i.e. SSL, TLS, or STARTTLS), then the secure SSL checkbox is ticked and the \"Server Authentication\" button pressed. A second dialog opens, shown on the right in Figure 10, which lets you enter a login and password for accessing the server. It's good practice not to enter a password since the data is stored as plain text in \"registrymodifications.xcu\" in Office's user configuration directory (often the folder \\(APPDATA\\) \\LibreOffice\\??\\user). It's safer to pass the password to Mail.mergeTask() at run time, as I've done in Mail.mergeEmail(). mergeEmail() calls Mail.checkMailConfig() to check if the mail server address, port number, username, and password can be found in \"registrymodifications.xcu\". If the first three aren't present then checkMailConfig() returns false and the merge is aborted. If the password is found, then a stern warning message is printed, but merging continues. checkMailConfig() calls Info.getRegItemProp() which uses XPath to search through \"registrymodifications.xcu\" for the specified property names and values.","title":"6.3.  Specializing the Merge"},{"location":"42-Sending_E-mail.html#64-mergetask-implementing-mail-merging","text":"mergeTask() is an expanded version of the code snippet given above which creates an XJob instance, sets properties in the MailMerge service, and calls XJob.execute(). The properties settings are spread across if-tests which determine if the task involves file creation, printing, or e-mail. Also, a listener is attached to the merge process. The mergeTask() code: // in the Mail class public static void mergeTask ( String dataSourceName , String tableName , String templateFnm , short outputType , boolean isSingle , // for FILE String printerName , boolean isMultipleJobs , // for PRINTER String passwd , String subject , String body ) // for MAIL { XJob job = Lo . createInstanceMCF ( XJob . class , \"com.sun.star.text.MailMerge\" ); if ( job == null ) { System . out . println ( \"Could not create MailMerge service\" ); return ; } XPropertySet props = Lo . qi ( XPropertySet . class , job ); // standard task properties Props . setProperty ( props , \"DataSourceName\" , dataSourceName ); Props . setProperty ( props , \"Command\" , tableName ); Props . setProperty ( props , \"CommandType\" , CommandType . TABLE ); Props . setProperty ( props , \"DocumentURL\" , FileIO . fnmToURL ( templateFnm )); // vary properties based on output type Props . setProperty ( props , \"OutputType\" , outputType ); if ( outputType == MailMergeType . FILE ) { Props . setProperty ( props , \"SaveAsSingleFile\" , isSingle ); Props . setProperty ( props , \"FileNamePrefix\" , \"letter\" ); // hardwired filename } else if ( outputType == MailMergeType . PRINTER ) { Props . setProperty ( props , \"SinglePrintJobs\" , isMultipleJobs ); // true means one print job for each letter PropertyValue [] pProps = Props . makeProps ( \"PrinterName\" , printerName , \"Wait\" , true ); // synchronous printing // from com.sun.star.view.PrintOptions Props . setProperty ( props , \"PrintOptions\" , pProps ); } else if ( outputType == MailMergeType . MAIL ) { if ( passwd != null ) Props . setProperty ( props , \"OutServerPassword\" , passwd ); Props . setProperty ( props , \"AddressFromColumn\" , \"E-mail\" ); // hardwired column name Props . setProperty ( props , \"Subject\" , subject ); Props . setProperty ( props , \"MailBody\" , body ); Props . setProperty ( props , \"SendAsAttachment\" , true ); Props . setProperty ( props , \"AttachmentName\" , \"letter.pdf\" ); // hardwired filename and type Props . setProperty ( props , \"AttachmentFilter\" , \"writer_pdf_Export\" ); } // monitor task's execution XMailMergeBroadcaster xmmb = Lo . qi ( XMailMergeBroadcaster . class , job ); xmmb . addMailMergeEventListener ( new XMailMergeListener () { int count = 0 ; long start = System . currentTimeMillis (); public void notifyMailMergeEvent ( MailMergeEvent e ) { count ++ ; XModel model = e . Model ; // Props.showProps(\"Mail merge event\", model.getArgs()); long currTime = System . currentTimeMillis (); System . out . println ( \" Letter \" + count + \": \" + ( currTime - start ) + \"ms\" ); start = currTime ; } }); try { job . execute ( new NamedValue [ 0 ] ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not start executing task: \" + e ); } } // end of mergeTask() There are four properties that are always set: Props . setProperty ( props , \"DataSourceName\" , dataSourceName ); Props . setProperty ( props , \"Command\" , tableName ); Props . setProperty ( props , \"CommandType\" , CommandType . TABLE ); Props . setProperty ( props , \"DocumentURL\" , FileIO . fnmToURL ( templateFnm )); These specify the use of a spreadsheet table, the data source name, and the template filename (as a URI). The other properties are divided up based on the MailMergeType constants FILE, PRINT, and MAIL (see lodoc MailMergeType ). I've hardwired certain properties to reduce the number of arguments that need to be passed to Mail.mergeLetter(), Mail.mergePrint(), and Mail.mergeEmail(). The listener implements the XMailMergeListener interface, and is attached through XMailMergeBroadcaster. notifyMailMergeEvent() is called each time a new letter is created. For my addresses.ods spreadsheet, it's triggered six times since there are six rows of data (see Figure 6). notifyMailMergeEvent() prints only timing information for each letter task, but more details could be obtained by accessing the event's model.","title":"6.4.  mergeTask(): Implementing Mail Merging"},{"location":"42-Sending_E-mail.html#65-mail-merge-reliability","text":"Office's mail merge wizard, which implements the \"Office API\" parts of Figure 5, and so corresponds to my Mail.mergeTask()function, has a long history of crashing. Mail.mergeTask() has always worked fine in my tests, except that it displays a \"LibreOffice has stopped working\" error dialog after terminating. However, no zombie Office processes are left over, so the dialog can be safely ignored and closed.","title":"6.5.  Mail Merge Reliability"},{"location":"43-Using_the_Clipboard.html","text":"Chapter 43. Using the Clipboard \u00b6 Topics The Office Clipboard API: adding, retrieving, text, images; Java's Clipboard API adding, retrieving, text, images, 2D arrays; Copy and Pasting in an Office Document: Writer, Calc, Impress, Base Example folders: \"Clipboard Tests\" and \"Utils\" The clipboard has appeared a few times in previous chapters, notably in the CopySlide.java example of Chapter 17, section 4 \u2013 I used Lo.dispatchCmd(\"Copy\") to copy a slide, then a \"Paste\" dispatch to add it to the slide deck in a different position. The example in section 5 of Chapter 17 (AppendSlides.java) is even hackier since it employs \"Copy\" and \"Paste\" dispatches and JNA to click on a dialog box. The programs are \"hacky\" because they interact with the OSes windows and dialogs. The \"Copy\" dispatch asks the OS to copy the highlighted data in the currently active window into the clipboard. My code precedes the dispatch by bringing the necessary window to the front on the desktop, but there's no way for Office to force that selection to be honored. For example, in the short interval before the \"Copy\" dispatch is sent, it's possible for the user to click the mouse in a different window, making it the active window rather than the one containing the slide. Another issue with this approach is timing \u2013 a dispatchCmd() call from the Office API returns as soon as the message is passed to the OS, but that's not the same as the message being processed by the OS. The dispatch has to be routed back to the application and executed, which may take many milliseconds. For instance, changing Impress from drawing mode (the default) to slide sorter mode can sometimes take over a second, especially the first time the mode is used. In the meantime, my code will continue executing, assuming that Office is in a state that it hasn\u2019t yet reached. The only simple solution is the liberal scattering of Lo.wait() calls after dispatches to hopefully slow the API's execution enough so that the dispatches have been processed. You may be wondering why I use \"Copy\" and \"Paste\" dispatches when they're so bothersome. One reason is that there may be no other way of achieving the required result, as in the Impress examples. (However, if you don\u2019t mind using a third-party library, then Apache ODF Toolkit offers a better solution; see Chapter 51, section 4.) Another reason is that \"Copy\" automatically converts copied data into several useful formats, which would require a lot of coding to duplicate. For example, a copied block of spreadsheet cells is available through the clipboard as plain text, different types of images, in two kinds of spreadsheet exchange format, and as an ODS file! Nevertheless, it's best to avoid \"Copy\" and \"Paste\" dispatches where possible, and one alternative is Office's clipboard API. Most (but not all) dispatch-based uses of copy and paste can be replaced by the clipboard API which means that there's no need to rely on OS-level windows being active and on Lo.wait() calls. Office's clipboard API is modelled on Java's clipboard classes, and there are advantages to using the Java API instead of Office when manipulating complex data. As a consequence, I've developed two support classes, in Clip.java and JClip.java, which contain helpful functions for using the Office clipboard API and the Java version respectively. After some short examples of manipulating the clipboard using the Office API and the Java API, I'll look at four slightly longer programs that illustrate how the clipboard can be utilized with a Writer document, a spreadsheet, slides, and a database. One thing you might want to install before starting any clipboard programming is a decent clipboard viewer. It's helpful for observing the data being copied and pasted by the Office/Java code; I employ ClCl ( https://nakka.com/soft/clcl/index_eng.html ). 1. The Office Clipboard API \u00b6 Office's clipboard API is located in the clipboard sub-module inside com.sun.star.datatransfer, and utilizes several services and interfaces from its datatransfer parent. Figure 1 shows the SystemClipboard service and its main interfaces. Figure 1. The SystemClipboard Services and Interfaces. If you browse the clipboard module, several classes, such as ClipboardManager, XClipboardManager, and XClipboardFactory, suggest the possibility of creating local clipboards that aren't accessible OS-wide like the system clipboard. Unfortunately, I was unable to figure out how to create one, which parallels the problem that Java programmers have creating local clipboards using the Java API. Programming details about using the clipboard in Office can be found in chapter 6 of the Development Guide in the section \"Common Application Features\". The guide can be downloaded from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf , or the relevant section begins online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Common_Application_Features/ (or use loGuide \"Common Application Features\" ). My Clip.getClip() support method illustrates how to get a reference to the system clipboard: // in the Clip class //global private static XSystemClipboard cb = null ; // used to store clipboard ref, so only one is created // by the methods here public static XSystemClipboard getClip () { if ( cb == null ) { cb = SystemClipboard . create ( Lo . getContext ()); /* cb.addClipboardListener( new XClipboardListener() { public void disposing(EventObject e) { } public void changedContents(ClipboardEvent e) { System.out.println(\">>Clipboard has been updated\"); } }); */ } return cb ; } // end of getClip() A call to SystemClipboard.create() with the current context instantiates the XSystemClipboard interface. It's possible to attach a XClipboardListener at this stage, which will be triggered whenever the clipboard is updated. I didn't find that capability useful in my examples, so commented it out. The Clip class stores the clipboard reference as a static variable so multiple calls to Clip.getClip() reuse the same reference. 1.1. Adding Data to the Clipboard \u00b6 Data is added to and retrieved from the clipboard using XClipboard.setContents() and XClipboard.getContents(), with the data represented by objects implementing the XTransferable interface. My utilities include three concrete transferable classes: TextTransferable, ImageTransferable, and FileTransferable, which I'll explain shortly. The Clip class offers an addContents() method for adding transferable data to the clipboard: // in the Clip class private static final int MAX_TRIES = 3 ; public static boolean addContents ( XTransferable trf ) { int i = 0 ; while ( i < MAX_TRIES ) { try { getClip (). setContents ( trf , null ); return true ; } catch ( IllegalStateException e ) { System . out . println ( \"Problem accessing clipboard...\" ); Lo . wait ( 50 ); } i ++ ; } System . out . println ( \"Unable to add contents\" ); return false ; } // end of addContents() The function attempts to add the transferable data to the clipboard three times before returning false. I've coded addContents() like this so that it matches the addContents() function in the JClip class. One difference between the Office and Java clipboard APIs is that the Java version of setContents() can raise an exception, and quite often fails when first asked to write something large to the clipboard (see the next section). However, repeating the request, after a short wait, succeeds. It felt prudent to use the same defensive programming in the Office API even though the Office documentation makes no mention of setContents() being able to raise an exception. In other words, Clip.addContents() is a prime example of paranoid programming. The clipboard remembers ownership, which is changed when data is added by a different user or process. This can be employed at the programming level by attaching an XClipboardOwner listener to the clipboard when XClipboard.setContents() adds data. The listener will be triggered when data which changes the ownership is copied to the clipboard. The following code fragment illustrates the technique: // add data to the clipboard, and monitor ownership // XSystemClipboard cb = ... cb . setContents ( data , new XClipboardOwner () { public void lostOwnership ( XClipboard board , XTransferable contents ) { System . out . println ( \"Ownership is lost\" ); } }); The lostOwnership() method is called with the clipboard reference and the tranferable data just overwritten by the new owner. I didn't use this feature in my addContents() function. 1.2. Retrieving Data from the Clipboard \u00b6 XClipboard.getContents() copies data from the clipboard as an XTransferable instance. One of the surprising, and useful, features of clipboard data is that it can usually be manipulated in several different forms, such as plain text or a bitmap. This means that the XTransferable extraction must state the required data format, which is encoded as a DataFlavor object. The following code fragment illustrates the idea: // XSystemClipboard cb = ... XTransferable trf = cb . getContents (); // get transferable DataFlavor df = // dataflavor for type of data required data = trf . getTransferData ( df ); A DataFlavor object is a mapping between a mime type string and an Office type. The following example maps the \"text/plain\" mime type to Office's String class: DataFlavor df = new DataFlavor ( \"text/plain;charset=utf-16\" , \"Unicode Text\" , new Type ( String . class )) The second argument of the DataFlavor constructor is a 'human representable' string for the mime type. 1.3. Adding and Retrieving Text \u00b6 My TextTransferable class implements the XTransferable interface for storing Unicode data. It defines three methods from XTransferable: getTransferData(): this returns the data for a specified DataFlavor getTransferDataFlavors(): this returns an array of DataFlavors representing the data formats supported by this transferable isDataFlavorSupported(): this returns true or false depending of if the supplied DataFlavor is amongst those supported by the transferable The TextTransferable class: // in the Utils/ folder public class TextTransferable implements XTransferable { private final String UNICODE_MIMETYPE = \"text/plain;charset=utf-16\" ; private String text ; public TextTransferable ( String s ) { text = s ; } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException // return the data matching the df DataFlavor { if ( ! df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE )) throw new UnsupportedFlavorException (); return text ; } public DataFlavor [] getTransferDataFlavors () // return an array of all the dataflavors supported { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = new DataFlavor ( UNICODE_MIMETYPE , \"Unicode Text\" , new Type ( String . class )); return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) // is the df DataFlavor supported by this transferable? { return df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE ); } } // end of TextTransferable class TextTransferable supports only the Unicode data format; its flavor maps the \"text/plain;charset=utf-16\" mime type string to the String class. The Clip support class has setText() and getText() methods for simplifying the use of TextTransferable: // in the Clip class public static boolean setText ( String str ) { return addContents ( new TextTransferable ( str )); } public static String getText () { return ( String ) getData ( \"text/plain;charset=utf-16\" ); } The setText () method uses the TextTransferable constructor to convert a string into a transferable that is placed on the clipboard by my addContents () method from above . getText () passes a mime type string to Clip . getData (), which copies the transferable from the clipboard , and uses the mime type to decide which kind of data format to use for the returned data : // in the Clip class public static Object getData ( String mimeStr ) { XTransferable trf = getClip (). getContents (); if ( trf == null ) { System . out . println ( \"No transferable found\" ); return null ; } try { DataFlavor df = findFlavor ( trf , mimeStr ); if ( df != null ) return trf . getTransferData ( df ); else System . out . println ( \"Mime \\\"\" + mimeStr + \"\\\" not found\" ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not read clipboard: \" + e ); } return null ; } // end of getData() Clip.findFlavor() searches through the flavors associated with the transferable looking for the mime type string supplied by the user: // in the Clip class public static DataFlavor findFlavor ( XTransferable trf , String mimeStr ) { DataFlavor [] dfs = trf . getTransferDataFlavors (); for ( int i = 0 ; i < dfs . length ; i ++ ) { if ( dfs [ i ] . MimeType . startsWith ( mimeStr )) { return dfs [ i ] ; } } System . out . println ( \"Clip does not support mime: \" + mimeStr ); return null ; } // end of findFlavor() The CPTests.java file shows an example of how to add and retrieve text from the clipboard: // part of CPTests.java... Lo . loadOffice (); : Clip . setText ( Lo . getTimeStamp ()); System . out . println ( \"Added text to clipboard\" ); System . out . println ( \"Read clipboard: \" + Clip . getText ()); : Lo . closeOffice (); 1.3. Adding and Retrieving an Image \u00b6 My ImageTransferable class implements XTransferable so a BufferedImage can be stored on the clipboard. It defines the same three methods as TextTransferable, but its data flavor maps the mime type \"application/x-openoffice- bitmap;windows_formatname=\"Bitmap\"\" to a byte array. // in the Utils/ folder public class ImageTransferable implements XTransferable { private static final String BITMAP_CLIP = \"application/x-openoffice-bitmap;windows_formatname=\\\"Bitmap\\\"\" ; private byte [] imBytes ; public ImageTransferable ( BufferedImage im ) { imBytes = Images . im2bytes ( im ); } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( BITMAP_CLIP )) throw new UnsupportedFlavorException (); return imBytes ; } // end of getTransferData() public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = new DataFlavor ( BITMAP_CLIP , \"Bitmap\" , new Type ( byte [] . class )); return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( BITMAP_CLIP ); } } // end of ImageTransferable class My choice of mapping to a byte array may seem a bit strange, since it would make more sense to associate the \"bitmap\" string with a BufferedImage. Unfortunately, Office only supports String (used in TextTransferable) and byte[] (used here). This contrasts with the greater flexibility of Java's clipboard API which allows any serializable type to be used in a flavor. This will motivate my use of Java to transfer 2D arrays to and from the clipboard, as described in section 2.3. I hide the use of ImageTransferable inside two Clip.java methods, setImage() and getImage(): // in the Clip class public static boolean setImage ( BufferedImage im ) { return addContents ( new ImageTransferable ( im )); } public static BufferedImage getImage () { XTransferable trf = getClip (). getContents (); if ( trf == null ) { System . out . println ( \"No transferable found\" ); return null ; } DataFlavor df = findImageFlavor ( trf ); if ( df == null ) return null ; try { return Images . bytes2im ( ( byte [] ) trf . getTransferData ( df ) ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not retrieve image: \" + e ); return null ; } } // end of getImage() getImage() transforms the byte array returned by ImageTransferable.getTransferData() into a BufferedImage. Clip.findImageFlavor() does a slightly more sophisticated lookup than the earlier findFlavor(), searching for a suitable flavor for an image mime type. The CPTests.java file shows how to add and retrieve an image from the clipboard: // part of CPTests.java... Lo . loadOffice (); : BufferedImage im = Images . loadImage ( \"skinner.png\" ); System . out . println ( \"Image (w,h): \" + im . getWidth () + \", \" + im . getHeight ()); Clip . setImage ( im ); System . out . println ( \"Added image to clipboard\" ); BufferedImage imCopy = Clip . getImage (); if ( imCopy != null ) System . out . println ( \"Image (w,h): \" + imCopy . getWidth () + \", \" + imCopy . getHeight ()); : Lo . closeOffice (); 1.4. Adding and Retrieving an Image from a File \u00b6 FileTransferable is the third transferable class in my utilities; a filename is passed to the constructor, and the contents of the file are stored on the clipboard: // in the Utils/ folder public class FileTransferable implements XTransferable { private String mimeType = \"application/octet-stream\" ; // good default private byte [] fileData = null ; public FileTransferable ( String fnm ) { mimeType = Info . getMIMEType ( fnm ); try { fileData = Files . readAllBytes ( Paths . get ( fnm )); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not read bytes from \" + fnm ); } } // end of FileTransferable() public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( mimeType )) throw new UnsupportedFlavorException (); return fileData ; } // end of getTransferData() public DataFlavor [] getTransferDataFlavors () { DataFlavor [] flavors = new DataFlavor [ 1 ] ; flavors [ 0 ] = new DataFlavor ( mimeType , mimeType , new Type ( byte [] . class )); return flavors ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( mimeType ); } } // end of FileTransferable class Java's Files.readAllBytes() reads in the file's contents as a bytes array. The transferable also stores the mime type string for the data, which it obtains by calling Info.getMIMEType(). The Clip class has setFile() and getFile() for using FileTransferable: // in the Clip class public static boolean setFile ( String fnm ) { return addContents ( new FileTransferable ( fnm )); } public static byte [] getFile ( String fnm ) { String mimeStr = Info . getMIMEType ( fnm ); return ( byte [] ) getData ( mimeStr ); } getFile() shows why it's necessary to store the the data's mime type in the transferable \u2013 it's used as an argument to Clip.getData() to extract the byte array from the clipboard in the correct data format. CPTests.java shows how to add and retrieve the contents of a file from the clipboard: // part of CPTests.java... Lo . loadOffice (); : Clip . setFile ( \"skinner.jpg\" ); System . out . println ( \"Added file to clipboard\" ); byte [] imData = Clip . getFile ( fnm ); System . out . println ( \"Image byte length: \" + imData . length ); BufferedImage imCopy = Clip . getImage (); if ( imCopy != null ) System . out . println ( \"Image (w,h): \" + imCopy . getWidth () + \", \" + imCopy . getHeight ()); : Lo . closeOffice (); It's possible to read the file's contents from the clipboard in two ways. Clip.getFile() returns it as a byte array, while Clip.getImage() attempts to convert it to a BufferedImage. 2. Java's Clipboard API \u00b6 Office's clipboard API is closely related to Java's clipboard API, so I had high hopes of not needing Java's API in this chapter. However, Java's ability to pass serializable objects to the clipboard is very useful when copying and pasting spreadsheet cells and database result sets. It's natural to encode them both as 2D arrays which, because they're serializable, can be more easily manipulated with Java than Office. In the end, I coded a JClip.java support class (note the \"J\") which duplicates a lot of the code in Clip.java, but using Java classes for the clipboard, transferables, and flavors rather than the Office ones. It's easy to get the two APIs confused, so Table 1 shows their main correspondences. Office Java SystemClipboard.create() Toolkit.getDefaultToolkit(). getSystemClipboard() XSystemClipboard inherits Clipboard; XClipboard, and others (see Fig. 1); getContents() never fails (?); getContents() can fail; Can handle serializable objects; Can handle String or byte[] More methods XClipboardListener FlavorListener XClipboardOwner ClipboardOwner XTransferable Transferable DataFlavor DataFlavor; many predefined constants TextTransferable (my class) StringSelection (in the JDK) Table 1. Corresponding Clipboard Services, Interfaces, and Classes in the Office and Java APIs. The JClip class uses a similar approach to the Clip class for creating a clipboard reference: // in the JClip class private static Clipboard cb = null ; // used to store clipboard ref, so only one is created // by the methods here public static Clipboard getClip () { if ( cb == null ) { cb = Toolkit . getDefaultToolkit (). getSystemClipboard (); /* cb.addFlavorListener( new FlavorListener() { public void flavorsChanged(FlavorEvent e) { System.out.println(\">>Flavor change detected\"); } }); */ } return cb ; } The reference is stored in a static variable so the same instance is used when getClip() is called more than once. The Java version of Office's XClipboardListener is FlavorListener, but is triggered only when the type of flavor changes on the clipboard not when the contents change. JClip.java contains an addContents() method: // in the JClip class private static final int MAX_TRIES = 3 ; public static boolean addContents ( Transferable trf ) { int i = 0 ; while ( i < MAX_TRIES ) { try { getClip (). setContents ( trf , null ); return true ; } catch ( IllegalStateException e ) { System . out . println ( \"Problem accessing clipboard...\" ); Lo . wait ( 50 ); } i ++ ; } System . out . println ( \"Unable to add contents\" ); return false ; } // end of addContents() Java's Clipboard.setContents() can throw an IllegalStateException. However, exceptions occur infrequently, and my solution of retrying the method three times, after a short wait, deals with the problem. 2.1. Adding and Retrieving Text \u00b6 Java's API includes several predefined flavors, including one for strings (DataFlavor.stringFlavor), and a Transferable class for strings called StringSelection, which makes it unnecessary to code a TextTransferable class. The JClip support class has setText() and getText() methods: // in the JClip class public static boolean setText ( String str ) { return addContents ( new StringSelection ( str )); } public static String getText () { Transferable trf = getClip (). getContents ( null ); try { if ( trf != null && trf . isDataFlavorSupported ( DataFlavor . stringFlavor )) return ( String ) trf . getTransferData ( DataFlavor . stringFlavor ); } catch ( UnsupportedFlavorException e ) { System . out . println ( e ); } catch ( IOException e ) { System . out . println ( e ); } return null ; } // end of getText() JCPTests.java shows how to add and retrieve text from the clipboard: // part of JCPTests.java... JClip . setText ( Lo . getTimeStamp ()); System . out . println ( \"Added text to clipboard\" ); System . out . println ( \"Read clipboard: \" + JClip . getText ()); Unlike the Office examples, there's no need to start with a Lo.loadOffice() and end with Lo.closeOffice(). 2.2. Adding and Retrieving an Image \u00b6 Java's API has a predefined flavor for images (DataFlavor.imageFlavor), but no Transferable class. My JImageTransferable is comparable with the earlier ImageTransferable class that used the Office API, but returns a BufferedImage from getTransferData() instead of a byte array: // in the Utils/ folder public class JImageTransferable implements Transferable { private Image im ; public JImageTransferable ( Image im ) { this . im = im ; } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException , IOException { if ( df . equals ( DataFlavor . imageFlavor ) && im != null ) return im ; else throw new UnsupportedFlavorException ( df ); } public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = DataFlavor . imageFlavor ; return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { DataFlavor [] dfs = getTransferDataFlavors (); for ( int i = 0 ; i < dfs . length ; i ++ ) { if ( df . equals ( dfs [ i ] )) return true ; } return false ; } } // end of JImageTransferable class The JClip support class has setImage () and getImage () methods : // in the JClip class public static boolean setImage ( BufferedImage im ) { return addContents ( new JImageTransferable ( im )); } public static BufferedImage getImage () { Transferable trf = getClip (). getContents ( null ); if ( trf != null && trf . isDataFlavorSupported ( DataFlavor . imageFlavor )) { try { return ( BufferedImage ) trf . getTransferData ( DataFlavor . imageFlavor ); } catch ( Exception e ) { System . out . println ( e ); } } return null ; } // end of getImage() JClip.getImage() is simpler than the version in the Clip class since it doesn't have to convert a byte array to a BufferedImage. JCPTests.java shows how to add and retrieve an image from the clipboard: // part of JCPTests.java... BufferedImage im = Images . loadImage ( \"skinner.png\" ); System . out . println ( \"Image (w,h): \" + im . getWidth () + \", \" + im . getHeight ()); JClip . setImage ( im ); System . out . println ( \"Added image to clipboard\" ); BufferedImage imCopy = JClip . getImage (); if ( imCopy != null ) System . out . println ( \"Image (w,h): \" + imCopy . getWidth () + \", \" + imCopy . getHeight ()); It's no different from the example in CPTest.java, except for the use of JClip. 2.3. Adding and Retrieving a 2D Array \u00b6 As I mentioned above, I'm using the Java API because of the simplicity of copying 2D arrays to and from the clipboard. JArrayTransferable is an implementation of Transferable that stores a 2D array of objects on the clipboard: // in the Utils/ folder public class JArrayTransferable implements Transferable { private Object [][] vals ; private DataFlavor arrDF ; public JArrayTransferable ( Object [][] vals ) { this . vals = vals ; arrDF = new DataFlavor ( Object [][] . class , \"2D Object Array\" ); } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException , IOException { if ( df . equals ( arrDF ) && vals != null ) return vals ; else throw new UnsupportedFlavorException ( df ); } public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = arrDF ; return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { DataFlavor [] dfs = getTransferDataFlavors (); for ( int i = 0 ; i < dfs . length ; i ++ ) { if ( df . equals ( dfs [ i ] )) return true ; } return false ; } } // end of JArrayTransferable class JArrayTransferable defines a flavor for the array type: DataFlavor arrDF = new DataFlavor ( Object [][] . class , \"2D Object Array\" ); The string argument is a 'human presentable name' rather than a mime type, since there's no good mime type match. In JClip.java, the set and get methods for an array are: // in the JClip class private static final DataFlavor ARRAY_DF = new DataFlavor ( Object [][] . class , \"2D Object Array\" ); public static boolean setArray ( Object [][] vals ) { return addContents ( new JArrayTransferable ( vals )); } public static Object [][] getArray () { Transferable trf = getClip (). getContents ( null ); if ( trf != null && trf . isDataFlavorSupported ( ARRAY_DF )) { try { return ( Object [][] ) trf . getTransferData ( ARRAY_DF ); } catch ( Exception e ) { System . out . println ( e ); } } return null ; } // end of getArray() JCPTests.java shows how to store and retrieve an array: // part of JCPTests.java... Object [][] marks = {{ 50 , 60 , 55 , 67 , 70 }, { 62 , 65 , 70 , 70 , 81 }, { 72 , 66 , 77 , 80 , 69 } }; // no generics used JClip . setArray ( marks ); System . out . println ( \"Added 2D array to clipboard\" ); Object [][] arr = JClip . getArray (); I'll be using JClip.setArray() and JClip.getArray() later in this chapter for clipboard copying of spreadsheet cells and database query results (sections 5 and 7). 2.4. More Details on the Java Clipboard API \u00b6 If you'd like a slower, more detailed, explanation of Java's clipboard features, two good sources are: Pro Java 8 Programming Terrill Brett Spell Apress, 2015, 3 rd ed. https://apress.com/9781484206423/ Chapter 9 is about the clipboard. Core Java, Volume II -- Advanced Features Cay S. Horstmann; Gary Cornell Prentice Hall, 2016, 10 th ed. https://horstmann.com/corejava.html Chapter 7 includes a clipboard section. 3. Copy and Pasting in an Office Document \u00b6 The next four sections look at copying from and pasting to Office documents using the clipboard. The techniques can be divided into two groups: those that use the clipboard without requiring the copy selection to be visible in a window, and those that do need a visible window. The latter 'Visible' group utilize \"Copy\" and \"Paste\" dispatches, and suffer from the problems I mentioned at the start of the chapter (i.e. selecting an active window and timing). A problem I haven't mentioned before is how to programmatically select data, which turns out to be different for each document type. I'll look at how to use these techniques with four kinds of documents: Writer, Calc, Impress, and Base, as summarized in Table 2. Document Invisible Visible Copy-and-Paste Approach Writer Copy/Paste: Copy: XTextViewCursor (CopyPasteText.java) text Paste: RTF, HTML, ODT Calc Copy/Paste: Copy: XCellRange (CopyPasteCalc.java) 2D array Paste: SYLK, ODS Impress none Copy: XDrawView (CopySlide.java) Paste: bitmap, PNG, Base Copy/Paste: none CopyResultSet.java) 2D array Table 2. Copy-and-Paste Techniques Applied to Office Documents. The 'Visible' column shows the advantage and disadvantage of the approach. The advantage is that pasting can use a range of data formats. For example, a selected grid of cells from a spreadsheet can be saved as a Microsoft SYLK file (an ASCII format for exchanging spreadsheet tables between applications) or as an ODS file. The disadvantage is that copying involves a different interface for data selection in each document type. For example, text copying employs a text cursor (the XTextViewCursor interface), while the spreadsheet uses cell ranges (XCellRange). The underlying reason is that each document has a different \"view\" service for how it's drawn in a window, as illustrated by Figure 2. Figure 2. Different View Services in Office. The display of a Writer document is managed by TextDocumentView, while a slide presentation can use any one of PresentationView, HandoutView, NotesView, OutlineView, and PreviewView. Most of these services implement selection using the XSelectionSupplier.select() method, but the data that is passed to the select() call depends on the document type. 4. Copy and Pasting in a Writer Document \u00b6 The CopyPasteText.java example copies a sentence from the start of a document to the clipboard, then pastes it back at the end. The program does this in two ways \u2013 the 'invisible' approach uses the Clip.java support functions without making Office visible, and the 'visible' approach which visibly selects the sentence so a \"Copy\" dispatch can copy it to the clipboard. A subsequent \"Paste\" dispatch places the sentence at the end of the document, as before, but it's also possible to manipulate the clip in formats other than just text. The main() function of CopyPasteText.java loads startStory.doc, then calls either useClipUtils() or useDispatches(): // in CopyPasteText.java private static final String FNM = \"storyStart.doc\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + FNM ); Lo . closeOffice (); return ; } useClipUtils ( doc , 4 ); // invisible approach // useDispatches(doc, 4); // visible Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() useClipUtils() is passed a reference to the document and an integer used to select a sentence: // in CopyPasteText.java private static void useClipUtils ( XTextDocument doc , int n ) { XSentenceCursor senCursor = Write . getSentenceCursor ( doc ); senCursor . gotoStart ( false ); // start of text; no selection gotoSentence ( senCursor , n ); // copy to clipboard Clip . setText ( senCursor . getString ()); System . out . println ( \"Copied \\\"\" + senCursor . getString () + \"\\\"\" ); Lo . wait ( 2000 ); XTextCursor cursor = Write . getCursor ( doc ); cursor . gotoEnd ( false ); // go to end of doc // paste into doc Write . append ( cursor , Clip . getText ()); GUI . setVisible ( doc , true ); // so we can see change Lo . waitEnter (); } // end of useClipUtils() private static void gotoSentence ( XSentenceCursor senCursor , int n ) { do { senCursor . gotoEndOfSentence ( true ); // select all of sentence n -- ; } while (( n > 0 ) && senCursor . gotoNextSentence ( false )); } // end of gotoSentence() Sentence selection in gotoSentence() is done with XSentenceCursor, which was previously used in Chapter 5, section 6. The text covered by the cursor is copied to the clipboard by Clip.setText() in useClipUtils(). useClipUtils() ends with a call to GUI.setVisible() so the user can see that the sentence has been pasted at the end of the document. Visible Cut-and-Paste of Text \u00b6 The hardest part about the 'visible' technique is data selection, which involves two kinds of cursors: XSentenceCursor for moving through the document a sentence at a time, and XTextViewCursor which represents the visible cursor in the Writer window. View cursors are used to visibly select text in Writer documents rather than the XSelectionSupplier interface shown in Figure 2. Figure 3 shows how XTextViewCursor is related to the TextDocumentView service. Figure 3. The TextDocumentView Service and XTextViewCursor. Obtaining an XTextViewCursor involves some casting, which I've hidden inside Writer.getViewCursor(): // the Writer class public static XTextViewCursor getViewCursor ( XTextDocument textDoc ) { XModel model = Lo . qi ( XModel . class , textDoc ); XController xController = model . getCurrentController (); // the controller gives us the TextViewCursor XTextViewCursorSupplier supplier = Lo . qi ( XTextViewCursorSupplier . class , xController ); return supplier . getViewCursor (); } // end of getViewCursor() The text document is cast to an XModel interface, which allows its corresponding controller to be obtained. At that point we're positioned on the far right of Figure 2 in XController. The second Lo.qi() cast is the big step, since it travels along the service hierarchy all the way to the left and top of Figure 2. It stops at the TextDocumentView service, and converts XController into XTextViewCursorSupplier, one of the interfaces in Figure 3. The final line of Write.getViewCursor() calls XTextViewCursorSupplier.getViewCursor() to obtain the cursor. useDispatches() calls Writer.getViewCursor() to get a view cursor, and Write.getSentenceCursor() for a sentence cursor: // in CopyPasteText.java private static void useDispatches ( XTextDocument doc , int n ) { GUI . setVisible ( doc , true ); // *must* be made visible Lo . wait ( 2000 ); // give Office time to appear XTextViewCursor tvc = Write . getViewCursor ( doc ); XSentenceCursor senCursor = Write . getSentenceCursor ( doc ); senCursor . gotoStart ( false ); // go to start of text; no selection gotoSentence ( senCursor , n ); // move the text view cursor to highlight the current paragraph tvc . gotoRange ( senCursor . getStart (), false ); tvc . gotoRange ( senCursor . getEnd (), true ); Lo . dispatchCmd ( \"Copy\" ); Clip . listFlavors (); // save copied text as RTF & HTML FileIO . saveString ( \"storyFrag.rtf\" , Clip . getRTF ()); FileIO . saveString ( \"storyFrag.html\" , Clip . getHTML ()); // save embedded text fragment as ODT FileIO . saveBytes ( \"storyFrag.odt\" , Clip . getEmbedSource ()); Lo . wait ( 2000 ); tvc . gotoEnd ( false ); // go to end of doc Lo . dispatchCmd ( \"Paste\" ); Lo . waitEnter (); } // end of useDispatches() The sentence cursor is moved as before, by calling gotoSentence(), but it doesn't highlight the text in the window. XTextViewCursor is needed for this, by being assigned the start and end positions of XSentenceCursor. The result is illustrated in Figure 4. Figure 4. The Highlighted Sentence in the Writer window. After the copy, the XTextViewCursor is moved to the end of the document and a \"Paste\" dispatch adds the copied data back. Just after the \"Copy\" dispatch, Clip.listFlavors() prints out the flavors (data types) that have been copied to the clipboard. The output is: No of flavors: 6 1. application/x-openoffice-embed-source-xml;windows_formatname=\"Star Embed Source (XML)\" 2. text/richtext 3. text/html 4. text/plain;charset=utf-16 5. application/x-openoffice-link;windows_formatname=\"Link\" 6. application/x-openoffice-objectdescriptor-xml; windows_formatname=\"Star Object Descriptor (XML)\";classname=\"8BC\u2026\" Plain text is listed as flavor no. 4, but the data is also available in HTML and RTF formats. Flavor no. 1 (\"application/x-openoffice-embed-source-xml\") is ODF (Open Document Format), which in this case is an ODT file. Clip.listFlavors() prints this information by getting a copy of the current transferable off the clipboard, and calling its getTransferDataFlavors() method to obtain favor data: // in the Clip class public static void listFlavors () { XTransferable trf = getClip (). getContents (); if ( trf == null ) System . out . println ( \"No transferable found\" ); else listFlavors ( trf ); } // end of listFlavors() public static void listFlavors ( XTransferable trf ) { DataFlavor [] dfs = trf . getTransferDataFlavors (); System . out . println ( \"No of flavors: \" + dfs . length ); for ( int i = 0 ; i < dfs . length ; i ++ ) System . out . println (( i + 1 ) + \". \" + dfs [ i ] . MimeType ); System . out . println (); } // end of listFlavors() The ClCl clipboard viewer ( https://nakka.com/soft/clcl/index_eng.html ) is a more graphical way of viewing this information. For example, the copied text is displayed as in Figure 5. Figure 5. The ClCl View of the Writer Text. The different formats are listed below the \"Clipboard\" node on the left of Figure 5, and the data in a particular format is displayed by clicking on the format name, as in Figure 6 for \"Star Embed Source (XML)\". Figure 6. The ClCl \"Star Embed Source (XML)\" View of the Writer Text. The advantage of using Clip.listFlavors() is that it displays the Office mime type strings, which are used to select data from the transferable. These strings are employed by the Clip.getXXX() methods: // in the Clip class public static String getHTML () { byte [] data = ( byte [] ) getData ( \"text/html\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getHTML() public static String getRTF () // text format used by MS { byte [] data = ( byte [] ) getData ( \"text/richtext\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getRTF() public static byte [] getEmbedSource () // fragment in binary ODF { return ( byte [] ) getData ( \"application/x-openoffice-embed-source-xml; windows_formatname=\\\"Star Embed Source (XML)\\\"\" ); } // end of getEmbedSource() Recall that I'm using the Office API, so Clip.getData() must return either a string or a byte array. These Clip.getXXX() methods are called in useDispatches() in CopyPasteText.java, and the data is saved to a file using FileIO.saveString() or FileIO.saveBytes(). 5. Copy and Pasting in a Calc Document \u00b6 CopyPasteCalc.java copies the data in a block of spreadsheet cells to empty cells at the bottom of the sheet. The main() function is similar to the Writer example: // in CopyPasteCalc.java private static final String FNM = \"Addresses.ods\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + FNM ); Lo . closeOffice (); return ; } useClipUtils ( doc ); // invisible approach // useDispatches(doc); // visible Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() useClipUtils() employs Clip support functions so the Calc window can remain hidden, while useDispatches() needs the window to be visible so that \"Copy\" and \"Paste\" dispatches can work. useClipUtils() utilizes the SheetCellRange service which is inherited by the Spreadsheet service (see Chapter 19, section 4, Figure 5). A block of cells is selected by calling Calc.getCellRange() which returns an XCellRange instance. The data covered by that range is extracted as a 2D array by Calc.getCellRangeArray(), and stored on the clipboard by JClip.setArray(): // in CopyPasteCalc.java private static void useClipUtils ( XSpreadsheetDocument doc ) { XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCellRange cellRange = Calc . getCellRange ( sheet , 0 , 2 , 6 , 2 ); //row 3 Object [][] data = Calc . getCellRangeArray ( cellRange ); JClip . setArray ( data ); // copy array to clipboard Lo . wait ( 2000 ); XCellRange toCellRange = Calc . getCellRange ( sheet , 0 , 8 , 6 , 8 ); //row 9 Object [][] cbData = JClip . getArray (); // paste in array Calc . setCellRangeArray ( toCellRange , cbData ); GUI . setVisible ( doc , true ); // so can see the paste Lo . waitEnter (); } // end of useClipUtils() Calc.getCellRangeArray() wraps the XCellRangeData interface, which was explained in Chapter 20, section 2.3: // in the Calc class public static Object [][] getCellRangeArray ( XCellRange cellRange ) { XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); return crData . getDataArray (); } The process of pasting the cell range back into the sheet requires another call to Calc.getCellRange() to select a new block of cells. Then the clip data as an array is inserted with Calc.setCellRangeArray(). Visible Cut-and-Paste of Cells \u00b6 The 'visible' technique also uses XCellRange, but as an argument to XSelectionSupplier.select() so the cells are highlighted in the Calc window. The useDispatches() method is: // in CopyPasteCalc.java private static void useDispatches ( XSpreadsheetDocument doc ) { GUI . setVisible ( doc , true ); // Office *must* be visible XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCellRange cellRange = Calc . getCellRange ( sheet , 0 , 2 , 6 , 2 ); // row 3 XSelectionSupplier selSupp = GUI . getSelectionSupplier ( doc ); selSupp . select ( cellRange ); Lo . dispatchCmd ( \"Copy\" ); Clip . listFlavors (); Lo . wait ( 2000 ); // save embedded cells as ODS FileIO . saveBytes ( \"AddressesFrag.ods\" , Clip . getEmbedSource ()); // save cells as SYLK file FileIO . saveString ( \"AddressesFrag.slk\" , Clip . getSylk ()); XCellRange toCellRange = Calc . getCellRange ( sheet , 0 , 8 , 6 , 8 ); // row 9 // GUI dialog asks about insertion if range is too small // and data repeats if range is too big selSupp . select ( toCellRange ); Lo . dispatchCmd ( \"Paste\" ); Lo . waitEnter (); } // end of useDispatches() The selection of cell ranges is done twice in useDispatches() \u2013 a cell range is required for the block of cells being copied, and another range is necessary for the empty cell block where the data will be pasted. Figure 7 shows the cells being selected, just prior to their copying. Figure 7. The Highlighted Cells in the Calc Window. The flavors list printed by Clip.listFlavors() is longer than the one for text: No of flavors: 14 1. application/x-openoffice-embed-source-xml;windows_formatname=\"Star Embed Source (XML)\" 2. application/x-openoffice-objectdescriptor-xml; windows_formatname=\"Star Object Descriptor (XML)\";classname=\"47BB\u2026\" 3. application/x-openoffice-gdimetafile; windows_formatname=\"GDIMetaFile\" 4. application/x-openoffice-emf;windows_formatname=\"Image EMF\" 5. application/x-openoffice-wmf;windows_formatname=\"Image WMF\" 6. image/png 7. application/x-openoffice-bitmap;windows_formatname=\"Bitmap\" 8. image/bmp 9. text/html 10. application/x-openoffice-sylk;windows_formatname=\"Sylk\" 11. application/x-openoffice-link;windows_formatname=\"Link\" 12. application/x-openoffice-dif;windows_formatname=\"DIF\" 13. text/plain;charset=utf-16 14. text/richtext The additions are mostly graphic types, but \"Sylk\" and \"DIF\" are ASCII-based formats for exchanging spreadsheets between applications. The corresponding ClCl display is shown in Figure 8. Figure 8. The ClCl View of the Calc Cells. Flavors numbers 1 and 10 in the list above allow the data to be saved as an ODS file and as a SYLK file. Clip.getEmbedSource() is called in useDispatches() to return the byte array holding the ODS data, and Clip.getSylk() returns the SYLK text. The code for Clip.getSylk(): // in the Clip class public static String getSylk () // text-based spreadsheet format used by MS { byte [] data = ( byte [] ) getData ( \"application/x-openoffice-sylk;windows_formatname=\\\"Sylk\\\"\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getSylk() 5. Copy and Pasting in an Impress Document \u00b6 Table 2 shows that the Office API has no 'invisible' way of copying a slide, so I have to use \"Copy\" and \"Paste\" dispatches to a visible Impress window. I went through two examples using this technique in Chapter 17, section 4 (\"Rearranging a Slide Deck\") and section 5 (\"Appending Slide Decks Together\"). Both require Impress to be in slide sorter mode so Draw.gotoPage() can select a slide. The CopySlide.java example in this section is a simplified version of the deck rearranger: the slide is copied without being pasted back. Instead, the contents of the clipboard are saved in various formats. The main() function loads a slide deck and calls copySave() to do the hard work: // in CopySlide.java private static final String FNM = \"algs.odp\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open the file: \" + FNM ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . wait ( 2000 ); copySave ( doc , 3 ); // save copy of 4th slide Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() copySave() switches Office to slide sorter mode, goes to the specified slide, which highlights it in the window. The \"Copy\" dispatch copies that slide to the clipboard. // in CopySlide.java private static void copySave ( XComponent doc , int fromIdx ) { XController ctrl = GUI . getCurrentController ( doc ); Lo . dispatchCmd ( \"DiaMode\" ); // Switch to slide sorter view Lo . delay ( 5000 ); // give Office plenty of time to do it XDrawPage fromSlide = Draw . getSlide ( doc , fromIdx ); Draw . gotoPage ( ctrl , fromSlide ); // select this slide Lo . dispatchCmd ( \"Copy\" ); System . out . println ( \"Copied slide no. \" + ( fromIdx + 1 )); Clip . listFlavors (); // save embedded slide as ODP; FileIO . saveBytes ( \"slide\" + ( fromIdx + 1 ) + \".odp\" , Clip . getEmbedSource ()); // save slide as XML ('flat' ODP) FileIO . saveString ( \"slide\" + ( fromIdx + 1 ) + \".fodp\" , Clip . getXMLDraw ()); // save slide as PNG image Images . saveImage ( Clip . getImage (), \"slide\" + ( fromIdx + 1 ) + \".png\" ); // for another approach see Slide2Image.java in Draw Tests/ // save slide as a Bitmap FileIO . saveBytes ( \"slide\" + ( fromIdx + 1 ) + \".bmp\" , Clip . getBitmap ()); Lo . dispatchCmd ( \"DrawingMode\" ); } // end of copySave() Clip.listFlavors() reports the data types that can be copied from the clipboard: No of flavors: 9 1. application/x-openoffice-objectdescriptor-xml; windows_formatname=\"Star Object Descriptor (XML)\";classname=\"9176\u2026\" 2. application/x-openoffice-embed-source-xml; windows_formatname=\"Star Embed Source (XML)\" 3. application/x-openoffice-drawing; windows_formatname=\"Drawing Format\" 4. application/x-openoffice-gdimetafile; windows_formatname=\"GDIMetaFile\" 5. application/x-openoffice-emf;windows_formatname=\"Image EMF\" 6. application/x-openoffice-wmf;windows_formatname=\"Image WMF\" 7. image/png 8. application/x-openoffice-bitmap;windows_formatname=\"Bitmap\" 9. image/bmp One of the new mime types is flavor no. 3, \"application/x-openoffice-drawing\", which encodes an ODP file in XML. The clipboard display in ClCl is shown in Figure 9. Figure 9. The ClCl View of the Impress Slide. The code at the end of copySave() reads and saves the clipboard data in four ways. Clip.getXMLDraw() retrieves the XML for the ODP file: // in the Clip class public static String getXMLDraw () // a 'flat' XML version of the draw/slide copy { byte [] data = ( byte [] ) getData ( \"application/x-openoffice-drawing; windows_formatname=\\\"Drawing Format\\\"\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getXMLDraw() The text is saved to a file with the extension \"fodp\", indicating that it holds a 'flat' XML version of the ODP document. This file can be opened in Office by double clicking upon it. copySave() also saves the slide as PNG and bitmap images. A better way to export an image is explained in Chapter 17, section 6 (\"Saving a Slide as an Image\"); it's better because it doesn't require the Office window to be visible. 6. Copy and Pasting in Base Data \u00b6 Table 2 states that the Office API has no 'visible' way of copying a database, although I suspect it may have. I've spent a long time trying to coax DefaultViewController (see Figure 2), the view service for Base, into action. Since it supports the XSelectionSupplier interface, it should be able to select things for copying. Another of its tantalizing interfaces is XDatabaseDocumentUI which seems to offer the ability to open a table window, but I couldn\u2019t get that to work either. The closest I've got is described in Chapter 35, section 3 (\"Debugging Database Code\") with Base.showTables() which opens all the databases' tables using a \"DBTableOpen\" dispatch. It's interesting to investigate what I'm losing in terms of data formats by not utilizing a \"Copy\" dispatch. It's possible to find out by manually copying a database table from Base, then using ClCl to look at the clipboard. The result is shown in Figure 10. Figure 10. The ClCl View of a Copied Database Table. It appears that the copied table could be saved in RTF and HTML formats. The \"SBA-DATAFORMAT' entry refers to the mime type \"application/x-openoffice-sba- dataexchange;windows_formatname=\\\"SBA-DATAFORMAT\\\"\", but I've no idea what SBA stands for. An online acronym finder site ( https://acronymfinder.com/ ) suggests \"Susan B. Anthony\", but I doubt it. The Invisible Cut-and-Paste of Data \u00b6 I've described the 'invisible' approach for databases previously, in Chapter 36, section 3 (\"Copying Data From Base To Calc\"), which converts a Base table into a spreadsheet. SQL is used to generate a result set spanning the table, then Base.getResultSetArr() converts the set into a 2D array of Objects. The array is written into a new spreadsheet using XCellRangeData.setDataArray(). The same approach is used in CopyResultSet.java in this section, except that the array is copied to the clipboard with JClip.setArray(): // in CopyResultSet.java private static final String FNM = \"liangTables.odb\" ; public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( FNM , loader ); if ( dbDoc == null ) { System . out . println ( \"Could not open database \" + FNM ); Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XResultSet rs = Base . executeQuery ( \"SELECT * FROM \\\"Course\\\"\" , conn ); // BaseTablePrinter.printResultSet(rs); // rs.beforeFirst(); // fails if ResultSet is TYPE_FORWARD_ONLY, // which is the default Object [][] rsArr = Base . getResultSetArr ( rs ); Base . printResultSetArr ( rsArr ); JClip . setArray ( rsArr ); // Clip.listFlavors(); JClip . listFlavors (); System . out . println ( \"Saving array from clipboard\" ); FileIO . saveArray ( \"queryResults.txt\" , JClip . getArray ()); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() As with previous examples, listFlavors() displays the flavors available to Office. The Clip.java function reports no flavors since the serialized 2D array added to the clipboard isn't an Office mime type. It's necessary to call the JClip.java version of the function, which prints: No of flavors: 1 1. application/x-java-serialized-object; class=\"[[Ljava.lang.Object;\" The corresponding ClCl display is shown in Figure 11. Figure 11. The ClCl View of the ResultSet Data. When I was debugging the code, I initially printed the result set using BaseTablePrinter.printResultSet(). Unfortunately, this would make the subsequent call to Base.getResultSetArr() return an array containing only the column headers and no data. BaseTablePrinter.printResultSet() moves the result set cursor through the results, then returns after having moved the cursor to the end of the data. Base.getResultSetArr() assumes the cursor is at the start of the data, and moves it forward until it reaches the end of the data. This means that when it's passed a cursor already at the end of the table, it generates no array data. One solution is to reset the cursor to the start, using: rs . beforeFirst (); but this usually fails because most result sets use the default TYPE_FORWARD_ONLY setting which restricts the cursor to only moving forward. My solution is to extract the 2D array with Base.getResultSetArr(), and print the array with Base.printResultSetArr(). Typical output is: Result set array size: 5 x 5 courseId, subjectId, courseNumber, title, numOfCredits -------------------------------------------------------------- 11111, CSCI, 1301, Introduction to Java I, 4 11112, CSCI, 1302, Introduction to Java II, 3 11113, CSCI, 3720, Database Systems, 3 11114, CoE , 3721, Algorithms, 3 It's not as pretty as BaseTablePrinter.printResultSet(), but avoids the cursor problem. The array data retrieved from the clipboard is stored as text by calling FileIO.saveArray(). The resulting queryResults.txt file contains: courseId subjectId courseNumber title numOfCredits 11111 CSCI 1301 Introduction to Java I 4 11112 CSCI 1302 Introduction to Java II 3 11113 CSCI 3720 Database Systems 3 11114 CoE 3721 Algorithms 3","title":"Chapter 43. Using the Clipboard"},{"location":"43-Using_the_Clipboard.html#chapter-43-using-the-clipboard","text":"Topics The Office Clipboard API: adding, retrieving, text, images; Java's Clipboard API adding, retrieving, text, images, 2D arrays; Copy and Pasting in an Office Document: Writer, Calc, Impress, Base Example folders: \"Clipboard Tests\" and \"Utils\" The clipboard has appeared a few times in previous chapters, notably in the CopySlide.java example of Chapter 17, section 4 \u2013 I used Lo.dispatchCmd(\"Copy\") to copy a slide, then a \"Paste\" dispatch to add it to the slide deck in a different position. The example in section 5 of Chapter 17 (AppendSlides.java) is even hackier since it employs \"Copy\" and \"Paste\" dispatches and JNA to click on a dialog box. The programs are \"hacky\" because they interact with the OSes windows and dialogs. The \"Copy\" dispatch asks the OS to copy the highlighted data in the currently active window into the clipboard. My code precedes the dispatch by bringing the necessary window to the front on the desktop, but there's no way for Office to force that selection to be honored. For example, in the short interval before the \"Copy\" dispatch is sent, it's possible for the user to click the mouse in a different window, making it the active window rather than the one containing the slide. Another issue with this approach is timing \u2013 a dispatchCmd() call from the Office API returns as soon as the message is passed to the OS, but that's not the same as the message being processed by the OS. The dispatch has to be routed back to the application and executed, which may take many milliseconds. For instance, changing Impress from drawing mode (the default) to slide sorter mode can sometimes take over a second, especially the first time the mode is used. In the meantime, my code will continue executing, assuming that Office is in a state that it hasn\u2019t yet reached. The only simple solution is the liberal scattering of Lo.wait() calls after dispatches to hopefully slow the API's execution enough so that the dispatches have been processed. You may be wondering why I use \"Copy\" and \"Paste\" dispatches when they're so bothersome. One reason is that there may be no other way of achieving the required result, as in the Impress examples. (However, if you don\u2019t mind using a third-party library, then Apache ODF Toolkit offers a better solution; see Chapter 51, section 4.) Another reason is that \"Copy\" automatically converts copied data into several useful formats, which would require a lot of coding to duplicate. For example, a copied block of spreadsheet cells is available through the clipboard as plain text, different types of images, in two kinds of spreadsheet exchange format, and as an ODS file! Nevertheless, it's best to avoid \"Copy\" and \"Paste\" dispatches where possible, and one alternative is Office's clipboard API. Most (but not all) dispatch-based uses of copy and paste can be replaced by the clipboard API which means that there's no need to rely on OS-level windows being active and on Lo.wait() calls. Office's clipboard API is modelled on Java's clipboard classes, and there are advantages to using the Java API instead of Office when manipulating complex data. As a consequence, I've developed two support classes, in Clip.java and JClip.java, which contain helpful functions for using the Office clipboard API and the Java version respectively. After some short examples of manipulating the clipboard using the Office API and the Java API, I'll look at four slightly longer programs that illustrate how the clipboard can be utilized with a Writer document, a spreadsheet, slides, and a database. One thing you might want to install before starting any clipboard programming is a decent clipboard viewer. It's helpful for observing the data being copied and pasted by the Office/Java code; I employ ClCl ( https://nakka.com/soft/clcl/index_eng.html ).","title":"Chapter 43. Using the Clipboard"},{"location":"43-Using_the_Clipboard.html#1-the-office-clipboard-api","text":"Office's clipboard API is located in the clipboard sub-module inside com.sun.star.datatransfer, and utilizes several services and interfaces from its datatransfer parent. Figure 1 shows the SystemClipboard service and its main interfaces. Figure 1. The SystemClipboard Services and Interfaces. If you browse the clipboard module, several classes, such as ClipboardManager, XClipboardManager, and XClipboardFactory, suggest the possibility of creating local clipboards that aren't accessible OS-wide like the system clipboard. Unfortunately, I was unable to figure out how to create one, which parallels the problem that Java programmers have creating local clipboards using the Java API. Programming details about using the clipboard in Office can be found in chapter 6 of the Development Guide in the section \"Common Application Features\". The guide can be downloaded from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf , or the relevant section begins online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Common_Application_Features/ (or use loGuide \"Common Application Features\" ). My Clip.getClip() support method illustrates how to get a reference to the system clipboard: // in the Clip class //global private static XSystemClipboard cb = null ; // used to store clipboard ref, so only one is created // by the methods here public static XSystemClipboard getClip () { if ( cb == null ) { cb = SystemClipboard . create ( Lo . getContext ()); /* cb.addClipboardListener( new XClipboardListener() { public void disposing(EventObject e) { } public void changedContents(ClipboardEvent e) { System.out.println(\">>Clipboard has been updated\"); } }); */ } return cb ; } // end of getClip() A call to SystemClipboard.create() with the current context instantiates the XSystemClipboard interface. It's possible to attach a XClipboardListener at this stage, which will be triggered whenever the clipboard is updated. I didn't find that capability useful in my examples, so commented it out. The Clip class stores the clipboard reference as a static variable so multiple calls to Clip.getClip() reuse the same reference.","title":"1.  The Office Clipboard API"},{"location":"43-Using_the_Clipboard.html#11-adding-data-to-the-clipboard","text":"Data is added to and retrieved from the clipboard using XClipboard.setContents() and XClipboard.getContents(), with the data represented by objects implementing the XTransferable interface. My utilities include three concrete transferable classes: TextTransferable, ImageTransferable, and FileTransferable, which I'll explain shortly. The Clip class offers an addContents() method for adding transferable data to the clipboard: // in the Clip class private static final int MAX_TRIES = 3 ; public static boolean addContents ( XTransferable trf ) { int i = 0 ; while ( i < MAX_TRIES ) { try { getClip (). setContents ( trf , null ); return true ; } catch ( IllegalStateException e ) { System . out . println ( \"Problem accessing clipboard...\" ); Lo . wait ( 50 ); } i ++ ; } System . out . println ( \"Unable to add contents\" ); return false ; } // end of addContents() The function attempts to add the transferable data to the clipboard three times before returning false. I've coded addContents() like this so that it matches the addContents() function in the JClip class. One difference between the Office and Java clipboard APIs is that the Java version of setContents() can raise an exception, and quite often fails when first asked to write something large to the clipboard (see the next section). However, repeating the request, after a short wait, succeeds. It felt prudent to use the same defensive programming in the Office API even though the Office documentation makes no mention of setContents() being able to raise an exception. In other words, Clip.addContents() is a prime example of paranoid programming. The clipboard remembers ownership, which is changed when data is added by a different user or process. This can be employed at the programming level by attaching an XClipboardOwner listener to the clipboard when XClipboard.setContents() adds data. The listener will be triggered when data which changes the ownership is copied to the clipboard. The following code fragment illustrates the technique: // add data to the clipboard, and monitor ownership // XSystemClipboard cb = ... cb . setContents ( data , new XClipboardOwner () { public void lostOwnership ( XClipboard board , XTransferable contents ) { System . out . println ( \"Ownership is lost\" ); } }); The lostOwnership() method is called with the clipboard reference and the tranferable data just overwritten by the new owner. I didn't use this feature in my addContents() function.","title":"1.1.  Adding Data to the Clipboard"},{"location":"43-Using_the_Clipboard.html#12-retrieving-data-from-the-clipboard","text":"XClipboard.getContents() copies data from the clipboard as an XTransferable instance. One of the surprising, and useful, features of clipboard data is that it can usually be manipulated in several different forms, such as plain text or a bitmap. This means that the XTransferable extraction must state the required data format, which is encoded as a DataFlavor object. The following code fragment illustrates the idea: // XSystemClipboard cb = ... XTransferable trf = cb . getContents (); // get transferable DataFlavor df = // dataflavor for type of data required data = trf . getTransferData ( df ); A DataFlavor object is a mapping between a mime type string and an Office type. The following example maps the \"text/plain\" mime type to Office's String class: DataFlavor df = new DataFlavor ( \"text/plain;charset=utf-16\" , \"Unicode Text\" , new Type ( String . class )) The second argument of the DataFlavor constructor is a 'human representable' string for the mime type.","title":"1.2.  Retrieving Data from the Clipboard"},{"location":"43-Using_the_Clipboard.html#13-adding-and-retrieving-text","text":"My TextTransferable class implements the XTransferable interface for storing Unicode data. It defines three methods from XTransferable: getTransferData(): this returns the data for a specified DataFlavor getTransferDataFlavors(): this returns an array of DataFlavors representing the data formats supported by this transferable isDataFlavorSupported(): this returns true or false depending of if the supplied DataFlavor is amongst those supported by the transferable The TextTransferable class: // in the Utils/ folder public class TextTransferable implements XTransferable { private final String UNICODE_MIMETYPE = \"text/plain;charset=utf-16\" ; private String text ; public TextTransferable ( String s ) { text = s ; } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException // return the data matching the df DataFlavor { if ( ! df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE )) throw new UnsupportedFlavorException (); return text ; } public DataFlavor [] getTransferDataFlavors () // return an array of all the dataflavors supported { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = new DataFlavor ( UNICODE_MIMETYPE , \"Unicode Text\" , new Type ( String . class )); return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) // is the df DataFlavor supported by this transferable? { return df . MimeType . equalsIgnoreCase ( UNICODE_MIMETYPE ); } } // end of TextTransferable class TextTransferable supports only the Unicode data format; its flavor maps the \"text/plain;charset=utf-16\" mime type string to the String class. The Clip support class has setText() and getText() methods for simplifying the use of TextTransferable: // in the Clip class public static boolean setText ( String str ) { return addContents ( new TextTransferable ( str )); } public static String getText () { return ( String ) getData ( \"text/plain;charset=utf-16\" ); } The setText () method uses the TextTransferable constructor to convert a string into a transferable that is placed on the clipboard by my addContents () method from above . getText () passes a mime type string to Clip . getData (), which copies the transferable from the clipboard , and uses the mime type to decide which kind of data format to use for the returned data : // in the Clip class public static Object getData ( String mimeStr ) { XTransferable trf = getClip (). getContents (); if ( trf == null ) { System . out . println ( \"No transferable found\" ); return null ; } try { DataFlavor df = findFlavor ( trf , mimeStr ); if ( df != null ) return trf . getTransferData ( df ); else System . out . println ( \"Mime \\\"\" + mimeStr + \"\\\" not found\" ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not read clipboard: \" + e ); } return null ; } // end of getData() Clip.findFlavor() searches through the flavors associated with the transferable looking for the mime type string supplied by the user: // in the Clip class public static DataFlavor findFlavor ( XTransferable trf , String mimeStr ) { DataFlavor [] dfs = trf . getTransferDataFlavors (); for ( int i = 0 ; i < dfs . length ; i ++ ) { if ( dfs [ i ] . MimeType . startsWith ( mimeStr )) { return dfs [ i ] ; } } System . out . println ( \"Clip does not support mime: \" + mimeStr ); return null ; } // end of findFlavor() The CPTests.java file shows an example of how to add and retrieve text from the clipboard: // part of CPTests.java... Lo . loadOffice (); : Clip . setText ( Lo . getTimeStamp ()); System . out . println ( \"Added text to clipboard\" ); System . out . println ( \"Read clipboard: \" + Clip . getText ()); : Lo . closeOffice ();","title":"1.3.  Adding and Retrieving Text"},{"location":"43-Using_the_Clipboard.html#13-adding-and-retrieving-an-image","text":"My ImageTransferable class implements XTransferable so a BufferedImage can be stored on the clipboard. It defines the same three methods as TextTransferable, but its data flavor maps the mime type \"application/x-openoffice- bitmap;windows_formatname=\"Bitmap\"\" to a byte array. // in the Utils/ folder public class ImageTransferable implements XTransferable { private static final String BITMAP_CLIP = \"application/x-openoffice-bitmap;windows_formatname=\\\"Bitmap\\\"\" ; private byte [] imBytes ; public ImageTransferable ( BufferedImage im ) { imBytes = Images . im2bytes ( im ); } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( BITMAP_CLIP )) throw new UnsupportedFlavorException (); return imBytes ; } // end of getTransferData() public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = new DataFlavor ( BITMAP_CLIP , \"Bitmap\" , new Type ( byte [] . class )); return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( BITMAP_CLIP ); } } // end of ImageTransferable class My choice of mapping to a byte array may seem a bit strange, since it would make more sense to associate the \"bitmap\" string with a BufferedImage. Unfortunately, Office only supports String (used in TextTransferable) and byte[] (used here). This contrasts with the greater flexibility of Java's clipboard API which allows any serializable type to be used in a flavor. This will motivate my use of Java to transfer 2D arrays to and from the clipboard, as described in section 2.3. I hide the use of ImageTransferable inside two Clip.java methods, setImage() and getImage(): // in the Clip class public static boolean setImage ( BufferedImage im ) { return addContents ( new ImageTransferable ( im )); } public static BufferedImage getImage () { XTransferable trf = getClip (). getContents (); if ( trf == null ) { System . out . println ( \"No transferable found\" ); return null ; } DataFlavor df = findImageFlavor ( trf ); if ( df == null ) return null ; try { return Images . bytes2im ( ( byte [] ) trf . getTransferData ( df ) ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not retrieve image: \" + e ); return null ; } } // end of getImage() getImage() transforms the byte array returned by ImageTransferable.getTransferData() into a BufferedImage. Clip.findImageFlavor() does a slightly more sophisticated lookup than the earlier findFlavor(), searching for a suitable flavor for an image mime type. The CPTests.java file shows how to add and retrieve an image from the clipboard: // part of CPTests.java... Lo . loadOffice (); : BufferedImage im = Images . loadImage ( \"skinner.png\" ); System . out . println ( \"Image (w,h): \" + im . getWidth () + \", \" + im . getHeight ()); Clip . setImage ( im ); System . out . println ( \"Added image to clipboard\" ); BufferedImage imCopy = Clip . getImage (); if ( imCopy != null ) System . out . println ( \"Image (w,h): \" + imCopy . getWidth () + \", \" + imCopy . getHeight ()); : Lo . closeOffice ();","title":"1.3.  Adding and Retrieving an Image"},{"location":"43-Using_the_Clipboard.html#14-adding-and-retrieving-an-image-from-a-file","text":"FileTransferable is the third transferable class in my utilities; a filename is passed to the constructor, and the contents of the file are stored on the clipboard: // in the Utils/ folder public class FileTransferable implements XTransferable { private String mimeType = \"application/octet-stream\" ; // good default private byte [] fileData = null ; public FileTransferable ( String fnm ) { mimeType = Info . getMIMEType ( fnm ); try { fileData = Files . readAllBytes ( Paths . get ( fnm )); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not read bytes from \" + fnm ); } } // end of FileTransferable() public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException { if ( ! df . MimeType . equalsIgnoreCase ( mimeType )) throw new UnsupportedFlavorException (); return fileData ; } // end of getTransferData() public DataFlavor [] getTransferDataFlavors () { DataFlavor [] flavors = new DataFlavor [ 1 ] ; flavors [ 0 ] = new DataFlavor ( mimeType , mimeType , new Type ( byte [] . class )); return flavors ; } public boolean isDataFlavorSupported ( DataFlavor df ) { return df . MimeType . equalsIgnoreCase ( mimeType ); } } // end of FileTransferable class Java's Files.readAllBytes() reads in the file's contents as a bytes array. The transferable also stores the mime type string for the data, which it obtains by calling Info.getMIMEType(). The Clip class has setFile() and getFile() for using FileTransferable: // in the Clip class public static boolean setFile ( String fnm ) { return addContents ( new FileTransferable ( fnm )); } public static byte [] getFile ( String fnm ) { String mimeStr = Info . getMIMEType ( fnm ); return ( byte [] ) getData ( mimeStr ); } getFile() shows why it's necessary to store the the data's mime type in the transferable \u2013 it's used as an argument to Clip.getData() to extract the byte array from the clipboard in the correct data format. CPTests.java shows how to add and retrieve the contents of a file from the clipboard: // part of CPTests.java... Lo . loadOffice (); : Clip . setFile ( \"skinner.jpg\" ); System . out . println ( \"Added file to clipboard\" ); byte [] imData = Clip . getFile ( fnm ); System . out . println ( \"Image byte length: \" + imData . length ); BufferedImage imCopy = Clip . getImage (); if ( imCopy != null ) System . out . println ( \"Image (w,h): \" + imCopy . getWidth () + \", \" + imCopy . getHeight ()); : Lo . closeOffice (); It's possible to read the file's contents from the clipboard in two ways. Clip.getFile() returns it as a byte array, while Clip.getImage() attempts to convert it to a BufferedImage.","title":"1.4.  Adding and Retrieving an Image from a File"},{"location":"43-Using_the_Clipboard.html#2-javas-clipboard-api","text":"Office's clipboard API is closely related to Java's clipboard API, so I had high hopes of not needing Java's API in this chapter. However, Java's ability to pass serializable objects to the clipboard is very useful when copying and pasting spreadsheet cells and database result sets. It's natural to encode them both as 2D arrays which, because they're serializable, can be more easily manipulated with Java than Office. In the end, I coded a JClip.java support class (note the \"J\") which duplicates a lot of the code in Clip.java, but using Java classes for the clipboard, transferables, and flavors rather than the Office ones. It's easy to get the two APIs confused, so Table 1 shows their main correspondences. Office Java SystemClipboard.create() Toolkit.getDefaultToolkit(). getSystemClipboard() XSystemClipboard inherits Clipboard; XClipboard, and others (see Fig. 1); getContents() never fails (?); getContents() can fail; Can handle serializable objects; Can handle String or byte[] More methods XClipboardListener FlavorListener XClipboardOwner ClipboardOwner XTransferable Transferable DataFlavor DataFlavor; many predefined constants TextTransferable (my class) StringSelection (in the JDK) Table 1. Corresponding Clipboard Services, Interfaces, and Classes in the Office and Java APIs. The JClip class uses a similar approach to the Clip class for creating a clipboard reference: // in the JClip class private static Clipboard cb = null ; // used to store clipboard ref, so only one is created // by the methods here public static Clipboard getClip () { if ( cb == null ) { cb = Toolkit . getDefaultToolkit (). getSystemClipboard (); /* cb.addFlavorListener( new FlavorListener() { public void flavorsChanged(FlavorEvent e) { System.out.println(\">>Flavor change detected\"); } }); */ } return cb ; } The reference is stored in a static variable so the same instance is used when getClip() is called more than once. The Java version of Office's XClipboardListener is FlavorListener, but is triggered only when the type of flavor changes on the clipboard not when the contents change. JClip.java contains an addContents() method: // in the JClip class private static final int MAX_TRIES = 3 ; public static boolean addContents ( Transferable trf ) { int i = 0 ; while ( i < MAX_TRIES ) { try { getClip (). setContents ( trf , null ); return true ; } catch ( IllegalStateException e ) { System . out . println ( \"Problem accessing clipboard...\" ); Lo . wait ( 50 ); } i ++ ; } System . out . println ( \"Unable to add contents\" ); return false ; } // end of addContents() Java's Clipboard.setContents() can throw an IllegalStateException. However, exceptions occur infrequently, and my solution of retrying the method three times, after a short wait, deals with the problem.","title":"2.  Java's Clipboard API"},{"location":"43-Using_the_Clipboard.html#21-adding-and-retrieving-text","text":"Java's API includes several predefined flavors, including one for strings (DataFlavor.stringFlavor), and a Transferable class for strings called StringSelection, which makes it unnecessary to code a TextTransferable class. The JClip support class has setText() and getText() methods: // in the JClip class public static boolean setText ( String str ) { return addContents ( new StringSelection ( str )); } public static String getText () { Transferable trf = getClip (). getContents ( null ); try { if ( trf != null && trf . isDataFlavorSupported ( DataFlavor . stringFlavor )) return ( String ) trf . getTransferData ( DataFlavor . stringFlavor ); } catch ( UnsupportedFlavorException e ) { System . out . println ( e ); } catch ( IOException e ) { System . out . println ( e ); } return null ; } // end of getText() JCPTests.java shows how to add and retrieve text from the clipboard: // part of JCPTests.java... JClip . setText ( Lo . getTimeStamp ()); System . out . println ( \"Added text to clipboard\" ); System . out . println ( \"Read clipboard: \" + JClip . getText ()); Unlike the Office examples, there's no need to start with a Lo.loadOffice() and end with Lo.closeOffice().","title":"2.1.  Adding and Retrieving Text"},{"location":"43-Using_the_Clipboard.html#22-adding-and-retrieving-an-image","text":"Java's API has a predefined flavor for images (DataFlavor.imageFlavor), but no Transferable class. My JImageTransferable is comparable with the earlier ImageTransferable class that used the Office API, but returns a BufferedImage from getTransferData() instead of a byte array: // in the Utils/ folder public class JImageTransferable implements Transferable { private Image im ; public JImageTransferable ( Image im ) { this . im = im ; } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException , IOException { if ( df . equals ( DataFlavor . imageFlavor ) && im != null ) return im ; else throw new UnsupportedFlavorException ( df ); } public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = DataFlavor . imageFlavor ; return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { DataFlavor [] dfs = getTransferDataFlavors (); for ( int i = 0 ; i < dfs . length ; i ++ ) { if ( df . equals ( dfs [ i ] )) return true ; } return false ; } } // end of JImageTransferable class The JClip support class has setImage () and getImage () methods : // in the JClip class public static boolean setImage ( BufferedImage im ) { return addContents ( new JImageTransferable ( im )); } public static BufferedImage getImage () { Transferable trf = getClip (). getContents ( null ); if ( trf != null && trf . isDataFlavorSupported ( DataFlavor . imageFlavor )) { try { return ( BufferedImage ) trf . getTransferData ( DataFlavor . imageFlavor ); } catch ( Exception e ) { System . out . println ( e ); } } return null ; } // end of getImage() JClip.getImage() is simpler than the version in the Clip class since it doesn't have to convert a byte array to a BufferedImage. JCPTests.java shows how to add and retrieve an image from the clipboard: // part of JCPTests.java... BufferedImage im = Images . loadImage ( \"skinner.png\" ); System . out . println ( \"Image (w,h): \" + im . getWidth () + \", \" + im . getHeight ()); JClip . setImage ( im ); System . out . println ( \"Added image to clipboard\" ); BufferedImage imCopy = JClip . getImage (); if ( imCopy != null ) System . out . println ( \"Image (w,h): \" + imCopy . getWidth () + \", \" + imCopy . getHeight ()); It's no different from the example in CPTest.java, except for the use of JClip.","title":"2.2.  Adding and Retrieving an Image"},{"location":"43-Using_the_Clipboard.html#23-adding-and-retrieving-a-2d-array","text":"As I mentioned above, I'm using the Java API because of the simplicity of copying 2D arrays to and from the clipboard. JArrayTransferable is an implementation of Transferable that stores a 2D array of objects on the clipboard: // in the Utils/ folder public class JArrayTransferable implements Transferable { private Object [][] vals ; private DataFlavor arrDF ; public JArrayTransferable ( Object [][] vals ) { this . vals = vals ; arrDF = new DataFlavor ( Object [][] . class , \"2D Object Array\" ); } public Object getTransferData ( DataFlavor df ) throws UnsupportedFlavorException , IOException { if ( df . equals ( arrDF ) && vals != null ) return vals ; else throw new UnsupportedFlavorException ( df ); } public DataFlavor [] getTransferDataFlavors () { DataFlavor [] dfs = new DataFlavor [ 1 ] ; dfs [ 0 ] = arrDF ; return dfs ; } public boolean isDataFlavorSupported ( DataFlavor df ) { DataFlavor [] dfs = getTransferDataFlavors (); for ( int i = 0 ; i < dfs . length ; i ++ ) { if ( df . equals ( dfs [ i ] )) return true ; } return false ; } } // end of JArrayTransferable class JArrayTransferable defines a flavor for the array type: DataFlavor arrDF = new DataFlavor ( Object [][] . class , \"2D Object Array\" ); The string argument is a 'human presentable name' rather than a mime type, since there's no good mime type match. In JClip.java, the set and get methods for an array are: // in the JClip class private static final DataFlavor ARRAY_DF = new DataFlavor ( Object [][] . class , \"2D Object Array\" ); public static boolean setArray ( Object [][] vals ) { return addContents ( new JArrayTransferable ( vals )); } public static Object [][] getArray () { Transferable trf = getClip (). getContents ( null ); if ( trf != null && trf . isDataFlavorSupported ( ARRAY_DF )) { try { return ( Object [][] ) trf . getTransferData ( ARRAY_DF ); } catch ( Exception e ) { System . out . println ( e ); } } return null ; } // end of getArray() JCPTests.java shows how to store and retrieve an array: // part of JCPTests.java... Object [][] marks = {{ 50 , 60 , 55 , 67 , 70 }, { 62 , 65 , 70 , 70 , 81 }, { 72 , 66 , 77 , 80 , 69 } }; // no generics used JClip . setArray ( marks ); System . out . println ( \"Added 2D array to clipboard\" ); Object [][] arr = JClip . getArray (); I'll be using JClip.setArray() and JClip.getArray() later in this chapter for clipboard copying of spreadsheet cells and database query results (sections 5 and 7).","title":"2.3.  Adding and Retrieving a 2D Array"},{"location":"43-Using_the_Clipboard.html#24-more-details-on-the-java-clipboard-api","text":"If you'd like a slower, more detailed, explanation of Java's clipboard features, two good sources are: Pro Java 8 Programming Terrill Brett Spell Apress, 2015, 3 rd ed. https://apress.com/9781484206423/ Chapter 9 is about the clipboard. Core Java, Volume II -- Advanced Features Cay S. Horstmann; Gary Cornell Prentice Hall, 2016, 10 th ed. https://horstmann.com/corejava.html Chapter 7 includes a clipboard section.","title":"2.4.  More Details on the Java Clipboard API"},{"location":"43-Using_the_Clipboard.html#3-copy-and-pasting-in-an-office-document","text":"The next four sections look at copying from and pasting to Office documents using the clipboard. The techniques can be divided into two groups: those that use the clipboard without requiring the copy selection to be visible in a window, and those that do need a visible window. The latter 'Visible' group utilize \"Copy\" and \"Paste\" dispatches, and suffer from the problems I mentioned at the start of the chapter (i.e. selecting an active window and timing). A problem I haven't mentioned before is how to programmatically select data, which turns out to be different for each document type. I'll look at how to use these techniques with four kinds of documents: Writer, Calc, Impress, and Base, as summarized in Table 2. Document Invisible Visible Copy-and-Paste Approach Writer Copy/Paste: Copy: XTextViewCursor (CopyPasteText.java) text Paste: RTF, HTML, ODT Calc Copy/Paste: Copy: XCellRange (CopyPasteCalc.java) 2D array Paste: SYLK, ODS Impress none Copy: XDrawView (CopySlide.java) Paste: bitmap, PNG, Base Copy/Paste: none CopyResultSet.java) 2D array Table 2. Copy-and-Paste Techniques Applied to Office Documents. The 'Visible' column shows the advantage and disadvantage of the approach. The advantage is that pasting can use a range of data formats. For example, a selected grid of cells from a spreadsheet can be saved as a Microsoft SYLK file (an ASCII format for exchanging spreadsheet tables between applications) or as an ODS file. The disadvantage is that copying involves a different interface for data selection in each document type. For example, text copying employs a text cursor (the XTextViewCursor interface), while the spreadsheet uses cell ranges (XCellRange). The underlying reason is that each document has a different \"view\" service for how it's drawn in a window, as illustrated by Figure 2. Figure 2. Different View Services in Office. The display of a Writer document is managed by TextDocumentView, while a slide presentation can use any one of PresentationView, HandoutView, NotesView, OutlineView, and PreviewView. Most of these services implement selection using the XSelectionSupplier.select() method, but the data that is passed to the select() call depends on the document type.","title":"3.  Copy and Pasting in an Office Document"},{"location":"43-Using_the_Clipboard.html#4-copy-and-pasting-in-a-writer-document","text":"The CopyPasteText.java example copies a sentence from the start of a document to the clipboard, then pastes it back at the end. The program does this in two ways \u2013 the 'invisible' approach uses the Clip.java support functions without making Office visible, and the 'visible' approach which visibly selects the sentence so a \"Copy\" dispatch can copy it to the clipboard. A subsequent \"Paste\" dispatch places the sentence at the end of the document, as before, but it's also possible to manipulate the clip in formats other than just text. The main() function of CopyPasteText.java loads startStory.doc, then calls either useClipUtils() or useDispatches(): // in CopyPasteText.java private static final String FNM = \"storyStart.doc\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + FNM ); Lo . closeOffice (); return ; } useClipUtils ( doc , 4 ); // invisible approach // useDispatches(doc, 4); // visible Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() useClipUtils() is passed a reference to the document and an integer used to select a sentence: // in CopyPasteText.java private static void useClipUtils ( XTextDocument doc , int n ) { XSentenceCursor senCursor = Write . getSentenceCursor ( doc ); senCursor . gotoStart ( false ); // start of text; no selection gotoSentence ( senCursor , n ); // copy to clipboard Clip . setText ( senCursor . getString ()); System . out . println ( \"Copied \\\"\" + senCursor . getString () + \"\\\"\" ); Lo . wait ( 2000 ); XTextCursor cursor = Write . getCursor ( doc ); cursor . gotoEnd ( false ); // go to end of doc // paste into doc Write . append ( cursor , Clip . getText ()); GUI . setVisible ( doc , true ); // so we can see change Lo . waitEnter (); } // end of useClipUtils() private static void gotoSentence ( XSentenceCursor senCursor , int n ) { do { senCursor . gotoEndOfSentence ( true ); // select all of sentence n -- ; } while (( n > 0 ) && senCursor . gotoNextSentence ( false )); } // end of gotoSentence() Sentence selection in gotoSentence() is done with XSentenceCursor, which was previously used in Chapter 5, section 6. The text covered by the cursor is copied to the clipboard by Clip.setText() in useClipUtils(). useClipUtils() ends with a call to GUI.setVisible() so the user can see that the sentence has been pasted at the end of the document.","title":"4.  Copy and Pasting in a Writer Document"},{"location":"43-Using_the_Clipboard.html#visible-cut-and-paste-of-text","text":"The hardest part about the 'visible' technique is data selection, which involves two kinds of cursors: XSentenceCursor for moving through the document a sentence at a time, and XTextViewCursor which represents the visible cursor in the Writer window. View cursors are used to visibly select text in Writer documents rather than the XSelectionSupplier interface shown in Figure 2. Figure 3 shows how XTextViewCursor is related to the TextDocumentView service. Figure 3. The TextDocumentView Service and XTextViewCursor. Obtaining an XTextViewCursor involves some casting, which I've hidden inside Writer.getViewCursor(): // the Writer class public static XTextViewCursor getViewCursor ( XTextDocument textDoc ) { XModel model = Lo . qi ( XModel . class , textDoc ); XController xController = model . getCurrentController (); // the controller gives us the TextViewCursor XTextViewCursorSupplier supplier = Lo . qi ( XTextViewCursorSupplier . class , xController ); return supplier . getViewCursor (); } // end of getViewCursor() The text document is cast to an XModel interface, which allows its corresponding controller to be obtained. At that point we're positioned on the far right of Figure 2 in XController. The second Lo.qi() cast is the big step, since it travels along the service hierarchy all the way to the left and top of Figure 2. It stops at the TextDocumentView service, and converts XController into XTextViewCursorSupplier, one of the interfaces in Figure 3. The final line of Write.getViewCursor() calls XTextViewCursorSupplier.getViewCursor() to obtain the cursor. useDispatches() calls Writer.getViewCursor() to get a view cursor, and Write.getSentenceCursor() for a sentence cursor: // in CopyPasteText.java private static void useDispatches ( XTextDocument doc , int n ) { GUI . setVisible ( doc , true ); // *must* be made visible Lo . wait ( 2000 ); // give Office time to appear XTextViewCursor tvc = Write . getViewCursor ( doc ); XSentenceCursor senCursor = Write . getSentenceCursor ( doc ); senCursor . gotoStart ( false ); // go to start of text; no selection gotoSentence ( senCursor , n ); // move the text view cursor to highlight the current paragraph tvc . gotoRange ( senCursor . getStart (), false ); tvc . gotoRange ( senCursor . getEnd (), true ); Lo . dispatchCmd ( \"Copy\" ); Clip . listFlavors (); // save copied text as RTF & HTML FileIO . saveString ( \"storyFrag.rtf\" , Clip . getRTF ()); FileIO . saveString ( \"storyFrag.html\" , Clip . getHTML ()); // save embedded text fragment as ODT FileIO . saveBytes ( \"storyFrag.odt\" , Clip . getEmbedSource ()); Lo . wait ( 2000 ); tvc . gotoEnd ( false ); // go to end of doc Lo . dispatchCmd ( \"Paste\" ); Lo . waitEnter (); } // end of useDispatches() The sentence cursor is moved as before, by calling gotoSentence(), but it doesn't highlight the text in the window. XTextViewCursor is needed for this, by being assigned the start and end positions of XSentenceCursor. The result is illustrated in Figure 4. Figure 4. The Highlighted Sentence in the Writer window. After the copy, the XTextViewCursor is moved to the end of the document and a \"Paste\" dispatch adds the copied data back. Just after the \"Copy\" dispatch, Clip.listFlavors() prints out the flavors (data types) that have been copied to the clipboard. The output is: No of flavors: 6 1. application/x-openoffice-embed-source-xml;windows_formatname=\"Star Embed Source (XML)\" 2. text/richtext 3. text/html 4. text/plain;charset=utf-16 5. application/x-openoffice-link;windows_formatname=\"Link\" 6. application/x-openoffice-objectdescriptor-xml; windows_formatname=\"Star Object Descriptor (XML)\";classname=\"8BC\u2026\" Plain text is listed as flavor no. 4, but the data is also available in HTML and RTF formats. Flavor no. 1 (\"application/x-openoffice-embed-source-xml\") is ODF (Open Document Format), which in this case is an ODT file. Clip.listFlavors() prints this information by getting a copy of the current transferable off the clipboard, and calling its getTransferDataFlavors() method to obtain favor data: // in the Clip class public static void listFlavors () { XTransferable trf = getClip (). getContents (); if ( trf == null ) System . out . println ( \"No transferable found\" ); else listFlavors ( trf ); } // end of listFlavors() public static void listFlavors ( XTransferable trf ) { DataFlavor [] dfs = trf . getTransferDataFlavors (); System . out . println ( \"No of flavors: \" + dfs . length ); for ( int i = 0 ; i < dfs . length ; i ++ ) System . out . println (( i + 1 ) + \". \" + dfs [ i ] . MimeType ); System . out . println (); } // end of listFlavors() The ClCl clipboard viewer ( https://nakka.com/soft/clcl/index_eng.html ) is a more graphical way of viewing this information. For example, the copied text is displayed as in Figure 5. Figure 5. The ClCl View of the Writer Text. The different formats are listed below the \"Clipboard\" node on the left of Figure 5, and the data in a particular format is displayed by clicking on the format name, as in Figure 6 for \"Star Embed Source (XML)\". Figure 6. The ClCl \"Star Embed Source (XML)\" View of the Writer Text. The advantage of using Clip.listFlavors() is that it displays the Office mime type strings, which are used to select data from the transferable. These strings are employed by the Clip.getXXX() methods: // in the Clip class public static String getHTML () { byte [] data = ( byte [] ) getData ( \"text/html\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getHTML() public static String getRTF () // text format used by MS { byte [] data = ( byte [] ) getData ( \"text/richtext\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getRTF() public static byte [] getEmbedSource () // fragment in binary ODF { return ( byte [] ) getData ( \"application/x-openoffice-embed-source-xml; windows_formatname=\\\"Star Embed Source (XML)\\\"\" ); } // end of getEmbedSource() Recall that I'm using the Office API, so Clip.getData() must return either a string or a byte array. These Clip.getXXX() methods are called in useDispatches() in CopyPasteText.java, and the data is saved to a file using FileIO.saveString() or FileIO.saveBytes().","title":"Visible Cut-and-Paste of Text"},{"location":"43-Using_the_Clipboard.html#5-copy-and-pasting-in-a-calc-document","text":"CopyPasteCalc.java copies the data in a block of spreadsheet cells to empty cells at the bottom of the sheet. The main() function is similar to the Writer example: // in CopyPasteCalc.java private static final String FNM = \"Addresses.ods\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + FNM ); Lo . closeOffice (); return ; } useClipUtils ( doc ); // invisible approach // useDispatches(doc); // visible Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() useClipUtils() employs Clip support functions so the Calc window can remain hidden, while useDispatches() needs the window to be visible so that \"Copy\" and \"Paste\" dispatches can work. useClipUtils() utilizes the SheetCellRange service which is inherited by the Spreadsheet service (see Chapter 19, section 4, Figure 5). A block of cells is selected by calling Calc.getCellRange() which returns an XCellRange instance. The data covered by that range is extracted as a 2D array by Calc.getCellRangeArray(), and stored on the clipboard by JClip.setArray(): // in CopyPasteCalc.java private static void useClipUtils ( XSpreadsheetDocument doc ) { XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCellRange cellRange = Calc . getCellRange ( sheet , 0 , 2 , 6 , 2 ); //row 3 Object [][] data = Calc . getCellRangeArray ( cellRange ); JClip . setArray ( data ); // copy array to clipboard Lo . wait ( 2000 ); XCellRange toCellRange = Calc . getCellRange ( sheet , 0 , 8 , 6 , 8 ); //row 9 Object [][] cbData = JClip . getArray (); // paste in array Calc . setCellRangeArray ( toCellRange , cbData ); GUI . setVisible ( doc , true ); // so can see the paste Lo . waitEnter (); } // end of useClipUtils() Calc.getCellRangeArray() wraps the XCellRangeData interface, which was explained in Chapter 20, section 2.3: // in the Calc class public static Object [][] getCellRangeArray ( XCellRange cellRange ) { XCellRangeData crData = Lo . qi ( XCellRangeData . class , cellRange ); return crData . getDataArray (); } The process of pasting the cell range back into the sheet requires another call to Calc.getCellRange() to select a new block of cells. Then the clip data as an array is inserted with Calc.setCellRangeArray().","title":"5.  Copy and Pasting in a Calc Document"},{"location":"43-Using_the_Clipboard.html#visible-cut-and-paste-of-cells","text":"The 'visible' technique also uses XCellRange, but as an argument to XSelectionSupplier.select() so the cells are highlighted in the Calc window. The useDispatches() method is: // in CopyPasteCalc.java private static void useDispatches ( XSpreadsheetDocument doc ) { GUI . setVisible ( doc , true ); // Office *must* be visible XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); XCellRange cellRange = Calc . getCellRange ( sheet , 0 , 2 , 6 , 2 ); // row 3 XSelectionSupplier selSupp = GUI . getSelectionSupplier ( doc ); selSupp . select ( cellRange ); Lo . dispatchCmd ( \"Copy\" ); Clip . listFlavors (); Lo . wait ( 2000 ); // save embedded cells as ODS FileIO . saveBytes ( \"AddressesFrag.ods\" , Clip . getEmbedSource ()); // save cells as SYLK file FileIO . saveString ( \"AddressesFrag.slk\" , Clip . getSylk ()); XCellRange toCellRange = Calc . getCellRange ( sheet , 0 , 8 , 6 , 8 ); // row 9 // GUI dialog asks about insertion if range is too small // and data repeats if range is too big selSupp . select ( toCellRange ); Lo . dispatchCmd ( \"Paste\" ); Lo . waitEnter (); } // end of useDispatches() The selection of cell ranges is done twice in useDispatches() \u2013 a cell range is required for the block of cells being copied, and another range is necessary for the empty cell block where the data will be pasted. Figure 7 shows the cells being selected, just prior to their copying. Figure 7. The Highlighted Cells in the Calc Window. The flavors list printed by Clip.listFlavors() is longer than the one for text: No of flavors: 14 1. application/x-openoffice-embed-source-xml;windows_formatname=\"Star Embed Source (XML)\" 2. application/x-openoffice-objectdescriptor-xml; windows_formatname=\"Star Object Descriptor (XML)\";classname=\"47BB\u2026\" 3. application/x-openoffice-gdimetafile; windows_formatname=\"GDIMetaFile\" 4. application/x-openoffice-emf;windows_formatname=\"Image EMF\" 5. application/x-openoffice-wmf;windows_formatname=\"Image WMF\" 6. image/png 7. application/x-openoffice-bitmap;windows_formatname=\"Bitmap\" 8. image/bmp 9. text/html 10. application/x-openoffice-sylk;windows_formatname=\"Sylk\" 11. application/x-openoffice-link;windows_formatname=\"Link\" 12. application/x-openoffice-dif;windows_formatname=\"DIF\" 13. text/plain;charset=utf-16 14. text/richtext The additions are mostly graphic types, but \"Sylk\" and \"DIF\" are ASCII-based formats for exchanging spreadsheets between applications. The corresponding ClCl display is shown in Figure 8. Figure 8. The ClCl View of the Calc Cells. Flavors numbers 1 and 10 in the list above allow the data to be saved as an ODS file and as a SYLK file. Clip.getEmbedSource() is called in useDispatches() to return the byte array holding the ODS data, and Clip.getSylk() returns the SYLK text. The code for Clip.getSylk(): // in the Clip class public static String getSylk () // text-based spreadsheet format used by MS { byte [] data = ( byte [] ) getData ( \"application/x-openoffice-sylk;windows_formatname=\\\"Sylk\\\"\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getSylk()","title":"Visible Cut-and-Paste of Cells"},{"location":"43-Using_the_Clipboard.html#5-copy-and-pasting-in-an-impress-document","text":"Table 2 shows that the Office API has no 'invisible' way of copying a slide, so I have to use \"Copy\" and \"Paste\" dispatches to a visible Impress window. I went through two examples using this technique in Chapter 17, section 4 (\"Rearranging a Slide Deck\") and section 5 (\"Appending Slide Decks Together\"). Both require Impress to be in slide sorter mode so Draw.gotoPage() can select a slide. The CopySlide.java example in this section is a simplified version of the deck rearranger: the slide is copied without being pasted back. Instead, the contents of the clipboard are saved in various formats. The main() function loads a slide deck and calls copySave() to do the hard work: // in CopySlide.java private static final String FNM = \"algs.odp\" ; public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( FNM , loader ); if ( doc == null ) { System . out . println ( \"Could not open the file: \" + FNM ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . wait ( 2000 ); copySave ( doc , 3 ); // save copy of 4th slide Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() copySave() switches Office to slide sorter mode, goes to the specified slide, which highlights it in the window. The \"Copy\" dispatch copies that slide to the clipboard. // in CopySlide.java private static void copySave ( XComponent doc , int fromIdx ) { XController ctrl = GUI . getCurrentController ( doc ); Lo . dispatchCmd ( \"DiaMode\" ); // Switch to slide sorter view Lo . delay ( 5000 ); // give Office plenty of time to do it XDrawPage fromSlide = Draw . getSlide ( doc , fromIdx ); Draw . gotoPage ( ctrl , fromSlide ); // select this slide Lo . dispatchCmd ( \"Copy\" ); System . out . println ( \"Copied slide no. \" + ( fromIdx + 1 )); Clip . listFlavors (); // save embedded slide as ODP; FileIO . saveBytes ( \"slide\" + ( fromIdx + 1 ) + \".odp\" , Clip . getEmbedSource ()); // save slide as XML ('flat' ODP) FileIO . saveString ( \"slide\" + ( fromIdx + 1 ) + \".fodp\" , Clip . getXMLDraw ()); // save slide as PNG image Images . saveImage ( Clip . getImage (), \"slide\" + ( fromIdx + 1 ) + \".png\" ); // for another approach see Slide2Image.java in Draw Tests/ // save slide as a Bitmap FileIO . saveBytes ( \"slide\" + ( fromIdx + 1 ) + \".bmp\" , Clip . getBitmap ()); Lo . dispatchCmd ( \"DrawingMode\" ); } // end of copySave() Clip.listFlavors() reports the data types that can be copied from the clipboard: No of flavors: 9 1. application/x-openoffice-objectdescriptor-xml; windows_formatname=\"Star Object Descriptor (XML)\";classname=\"9176\u2026\" 2. application/x-openoffice-embed-source-xml; windows_formatname=\"Star Embed Source (XML)\" 3. application/x-openoffice-drawing; windows_formatname=\"Drawing Format\" 4. application/x-openoffice-gdimetafile; windows_formatname=\"GDIMetaFile\" 5. application/x-openoffice-emf;windows_formatname=\"Image EMF\" 6. application/x-openoffice-wmf;windows_formatname=\"Image WMF\" 7. image/png 8. application/x-openoffice-bitmap;windows_formatname=\"Bitmap\" 9. image/bmp One of the new mime types is flavor no. 3, \"application/x-openoffice-drawing\", which encodes an ODP file in XML. The clipboard display in ClCl is shown in Figure 9. Figure 9. The ClCl View of the Impress Slide. The code at the end of copySave() reads and saves the clipboard data in four ways. Clip.getXMLDraw() retrieves the XML for the ODP file: // in the Clip class public static String getXMLDraw () // a 'flat' XML version of the draw/slide copy { byte [] data = ( byte [] ) getData ( \"application/x-openoffice-drawing; windows_formatname=\\\"Drawing Format\\\"\" ); if ( data == null ) return null ; else return new String ( data ); } // end of getXMLDraw() The text is saved to a file with the extension \"fodp\", indicating that it holds a 'flat' XML version of the ODP document. This file can be opened in Office by double clicking upon it. copySave() also saves the slide as PNG and bitmap images. A better way to export an image is explained in Chapter 17, section 6 (\"Saving a Slide as an Image\"); it's better because it doesn't require the Office window to be visible.","title":"5.  Copy and Pasting in an Impress Document"},{"location":"43-Using_the_Clipboard.html#6-copy-and-pasting-in-base-data","text":"Table 2 states that the Office API has no 'visible' way of copying a database, although I suspect it may have. I've spent a long time trying to coax DefaultViewController (see Figure 2), the view service for Base, into action. Since it supports the XSelectionSupplier interface, it should be able to select things for copying. Another of its tantalizing interfaces is XDatabaseDocumentUI which seems to offer the ability to open a table window, but I couldn\u2019t get that to work either. The closest I've got is described in Chapter 35, section 3 (\"Debugging Database Code\") with Base.showTables() which opens all the databases' tables using a \"DBTableOpen\" dispatch. It's interesting to investigate what I'm losing in terms of data formats by not utilizing a \"Copy\" dispatch. It's possible to find out by manually copying a database table from Base, then using ClCl to look at the clipboard. The result is shown in Figure 10. Figure 10. The ClCl View of a Copied Database Table. It appears that the copied table could be saved in RTF and HTML formats. The \"SBA-DATAFORMAT' entry refers to the mime type \"application/x-openoffice-sba- dataexchange;windows_formatname=\\\"SBA-DATAFORMAT\\\"\", but I've no idea what SBA stands for. An online acronym finder site ( https://acronymfinder.com/ ) suggests \"Susan B. Anthony\", but I doubt it.","title":"6.  Copy and Pasting in Base Data"},{"location":"43-Using_the_Clipboard.html#the-invisible-cut-and-paste-of-data","text":"I've described the 'invisible' approach for databases previously, in Chapter 36, section 3 (\"Copying Data From Base To Calc\"), which converts a Base table into a spreadsheet. SQL is used to generate a result set spanning the table, then Base.getResultSetArr() converts the set into a 2D array of Objects. The array is written into a new spreadsheet using XCellRangeData.setDataArray(). The same approach is used in CopyResultSet.java in this section, except that the array is copied to the clipboard with JClip.setArray(): // in CopyResultSet.java private static final String FNM = \"liangTables.odb\" ; public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XOfficeDatabaseDocument dbDoc = Base . openBaseDoc ( FNM , loader ); if ( dbDoc == null ) { System . out . println ( \"Could not open database \" + FNM ); Lo . closeOffice (); return ; } XConnection conn = null ; try { XDataSource dataSource = dbDoc . getDataSource (); conn = dataSource . getConnection ( \"\" , \"\" ); // no login/password XResultSet rs = Base . executeQuery ( \"SELECT * FROM \\\"Course\\\"\" , conn ); // BaseTablePrinter.printResultSet(rs); // rs.beforeFirst(); // fails if ResultSet is TYPE_FORWARD_ONLY, // which is the default Object [][] rsArr = Base . getResultSetArr ( rs ); Base . printResultSetArr ( rsArr ); JClip . setArray ( rsArr ); // Clip.listFlavors(); JClip . listFlavors (); System . out . println ( \"Saving array from clipboard\" ); FileIO . saveArray ( \"queryResults.txt\" , JClip . getArray ()); } catch ( SQLException e ) { System . out . println ( e ); } Base . closeConnection ( conn ); Base . closeBaseDoc ( dbDoc ); Lo . closeOffice (); } // end of main() As with previous examples, listFlavors() displays the flavors available to Office. The Clip.java function reports no flavors since the serialized 2D array added to the clipboard isn't an Office mime type. It's necessary to call the JClip.java version of the function, which prints: No of flavors: 1 1. application/x-java-serialized-object; class=\"[[Ljava.lang.Object;\" The corresponding ClCl display is shown in Figure 11. Figure 11. The ClCl View of the ResultSet Data. When I was debugging the code, I initially printed the result set using BaseTablePrinter.printResultSet(). Unfortunately, this would make the subsequent call to Base.getResultSetArr() return an array containing only the column headers and no data. BaseTablePrinter.printResultSet() moves the result set cursor through the results, then returns after having moved the cursor to the end of the data. Base.getResultSetArr() assumes the cursor is at the start of the data, and moves it forward until it reaches the end of the data. This means that when it's passed a cursor already at the end of the table, it generates no array data. One solution is to reset the cursor to the start, using: rs . beforeFirst (); but this usually fails because most result sets use the default TYPE_FORWARD_ONLY setting which restricts the cursor to only moving forward. My solution is to extract the 2D array with Base.getResultSetArr(), and print the array with Base.printResultSetArr(). Typical output is: Result set array size: 5 x 5 courseId, subjectId, courseNumber, title, numOfCredits -------------------------------------------------------------- 11111, CSCI, 1301, Introduction to Java I, 4 11112, CSCI, 1302, Introduction to Java II, 3 11113, CSCI, 3720, Database Systems, 3 11114, CoE , 3721, Algorithms, 3 It's not as pretty as BaseTablePrinter.printResultSet(), but avoids the cursor problem. The array data retrieved from the clipboard is stored as text by calling FileIO.saveArray(). The resulting queryResults.txt file contains: courseId subjectId courseNumber title numOfCredits 11111 CSCI 1301 Introduction to Java I 4 11112 CSCI 1302 Introduction to Java II 3 11113 CSCI 3720 Database Systems 3 11114 CoE 3721 Algorithms 3","title":"The Invisible Cut-and-Paste of Data"},{"location":"44-Office_as_GUI_Comp.html","text":"Chapter 44. Office as a GUI Component \u00b6 Topics OOoBean; Wrapping OOoBean in a JPanel; Using the OBeanPanel; Using an Undecorated Office Window; Augmenting the User Interface: a New Toolbar Item; Augmenting the User Interface: a New Menu Item Example folders: \"GUI Tests\" and \"Utils\" This chapter looks at two ways to use Office as a GUI component for displaying documents in a program. The first employs Office's OOoBean class: I'll wrap it in a JPanel to utilize it as part of a Swing application. The second approach invokes Office in a separate window from the program, a technique I've used many times in earlier chapters. The difference this time is that I'll hide Office's GUI (i.e. its toolbars, menu, and sidebars), leaving only the document visible. I'll also explore two variations of this 'blank look': adding a item to a toolbar, and creating a new menu. These GUI entities aren't permanently added to Office, and are controlled and monitored by the program. 1. OOoBean \u00b6 The OOoBean class and its com.sun.star.comp.beans package aren't documented in LibreOffice, but there's an entire chapter about them in the Developer's Guide (chapter 16, \"JavaBean for Office Components\"), at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf , and https://wiki.openoffice.org/wiki/Documentation/DevGuide/JavaBean/JavaBean_for_Office_Components/ (or use loGuide JavaBean ). The chapter's example, OOoBeanViewer, wraps OOoBean in an old-style Applet (not a JApplet), and can be downloaded from https://api.libreoffice.org/examples/DevelopersGuide/examples.html#OfficeBean . Another source of information is the OOoBean code at https://github.com/LibreOffice/core/blob/master/bean/com/sun/star/comp/beans/OOoBean.java . It's also possible to decompile OOoBean 's JAR file, which you'll find in \\program\\classes\\officebean.jar. As you browse the documentation and source code, you may get the feeling that OOoBean has been abandoned. It's true that some functionality have been deprecated, but OOoBean still mostly works. Setting it up is tricky, requiring an undocumented UNO_PATH environment variable to be set when Office is invoked. Also, integrating OOoBean with Swing and my LibreOffice support classes required some work. OOoBean utilizes many parts of the Office API, since it starts Office, loads a document, and displays it on a Java Canvas. Some of that can be seen in Figure 1 which gives a simplified view of its classes and interfaces. Figure 1. Some of the OOoBean Classes and Interfaces. The classes without package prefixes are from com.sun.star.comp.beans. For example, LocalOfficeConnection invokes and connects to Office, while LocalOfficeWindow renders Office and the loaded document. LocalOfficeWindow's use of java.awt.Canvas means that the view is a heavyweight, native peer, which doesn't work well with lightweight Swing components such as drop-down menus, text fields, and buttons. One solution is to wrap the heavyweight component (i.e. the Canvas) in a JPanel, which I've done in my OOBeanPanel class described in the next section. Frame, Controller, and OfficeDocument are wrappers around com.sun.star.frame's XFrame, XController, and XModel, the three elements of Office's Frame-Controller- Model (FCM) relationship (described in Chapter 1, section 5). Figure 2 shows OOoBean's public methods, with the deprecated ones highlighted in light orange and blue. Figure 2. The Public Methods of OOoBean. Nearly half the methods are deprecated, but only one of them (releaseSystemWindow()) is required in my code, to deal with a focus switching bug. The methods marked in light blue all relate to toolbar visibility, and can be handled better by the LayoutManager service explained later. There's a table of one-line descriptions of OOoBean's methods in chapter 16 of the Developer's Guide, and online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/JavaBean/API_Overview/ (or use loGuide JavaBean \"API Overview\" ). I'll only explain the methods used in my OBeanPanel class. 2. Wrapping OOoBean in a JPanel \u00b6 OBeanPanel wraps an OOoBean instance inside a JPanel so its heavyweight canvas doesn't affect the rendering of lightweight components in the surrounding application. The class diagram for OBeanPanel in Figure 3 shows that it's a JPanel subclass, and implements Office mouse and keyboard listeners. Figure 3. The OBeanPanel Class Diagram. The key handling is necessary for coding around a keyboard focus bug. The mouse handler is included to show how to monitor mouse presses and releases in the document. OBeanPanel 's constructor sets up some JPanel attributes (its background color, dimensions, and start-up message), calls the OOoBean constructor, and adds the bean to the panel: // in the OBeanPanel class private int pWidth , pHeight ; // of panel private OOoBean oob = null ; private Font msgFont ; private FontMetrics fontMetric ; private String message ; public OBeanPanel ( int w , int h ) { pWidth = w ; pHeight = h ; setBackground ( Color . WHITE ); setPreferredSize ( new Dimension ( w , h )); setLayout ( new BorderLayout ()); // start-up and finishing message used by panel msgFont = new Font ( \"SansSerif\" , Font . BOLD , 36 ); fontMetric = getFontMetrics ( msgFont ); message = \"Waiting for Office...\" ; oob = new OOoBean (); // doesn't connect to Office; // actually an empty method add ( oob , BorderLayout . CENTER ); } // end of OBeanPanel() The surprising thing about the OOoBean() method is that its body is empty. In other words, at this stage, the bean is not connected to Office. paintComponent() draws the start-up message assigned in OBeanPanel(), which remains visible until the document is loaded and drawn over that area: // in the OBeanPanel class public void paintComponent ( Graphics g ) // display a message while OOoBean is loaded/unloaded { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ); int x = ( pWidth - fontMetric . stringWidth ( message )) / 2 ; int y = ( pHeight - fontMetric . getHeight ()) / 2 ; g2 . setColor ( Color . BLUE ); g2 . setFont ( msgFont ); g2 . drawString ( message , x , y ); } // end of paintComponent() Figure 4 shows the message before a document is loaded. Figure 4. The OBeanPanel without a Document. The buttons along the right-hand side of Figure 4 and the fields at the bottom are part of the SwingViewer.java application described later. OBeanPanel manages the large white rectangle with the \"Waiting for Office\u2026\" text. OBeanPanel.loadDoc() calls OOoBean.loadFromURL() to start Office and load and display the document: // in the OBeanPanel class //globals private XComponent doc = null ; public XComponent loadDoc ( String fnm ) { PropertyValue [] props = Props . makeProps ( \"ReadOnly\" , true ); try { String fileURL = FileIO . fnmToURL ( fnm ); oob . loadFromURL ( fileURL , props ); // real work done here! Lo . setOOoBean ( oob ); // initialize Lo class so // support classes are useable doc = getDoc (); int docType = Info . reportDocType ( doc ); if ( docType == Lo . BASE ) Lo . dispatchCmd ( getFrame (), \"DBViewTables\" , null ); // switch to tables view in Base docs XLayoutManager lm = GUI . getLayoutManager ( doc ); lm . setVisible ( false ); // hide all toolbars // add mouse click & key handlers to the doc XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); revalidate (); // needs a refresh to appear Lo . delay ( 1000 ); } catch ( java . lang . Exception e ) { System . out . println ( e ); } return doc ; } // end of loadDoc() OOoBean.loadFromURL()'s two arguments are the document's URL and a \"ReadOnly\" property since the bean is being used as a viewer. I want to keep using my support classes, which require the setting of four global variables in the Lo class. They are normally initialized by Lo.loadOffice() and Lo.openDoc(), but are copied from OOoBean by Lo.setOOoBean() in this case. // in the Lo class //globals // remote component context private static XComponentContext xcc = null ; // remote desktop UNO service private static XDesktop xDesktop = null ; // remote service managers private static XMultiComponentFactory mcFactory = null ; private static XMultiServiceFactory msFactory = null ; @SuppressWarnings ( \"deprecation\" ) public static void setOOoBean ( OOoBean oob ) { try { OfficeConnection conn = oob . getOOoConnection (); // the OfficeConnection class is deprecated if ( conn == null ) System . out . println ( \"No office connection found in OOoBean\" ); else { xcc = conn . getComponentContext (); if ( xcc == null ) System . out . println ( \"No component context in OOoBean\" ); else mcFactory = xcc . getServiceManager (); xDesktop = oob . getOOoDesktop (); msFactory = oob . getMultiServiceFactory (); } } catch ( java . lang . Exception e ) { System . out . println ( \"Couldn't init LO using OOoBean: \" + e ); } } // end of setOOoBean() The suppressed warning annotation stops the Java compiler complaining about OOoBean's deprecated OfficeConnection class. Back in OBeanPanel.loadDoc(), a reference to the loaded document is retrieved by calling OBeanPanel.getDoc(): // in the OBeanPanel class public XComponent getDoc () { XComponent doc = null ; try { XModel xModel = ( XModel ) oob . getDocument (); doc = Lo . qi ( XComponent . class , xModel ); } catch ( java . lang . Exception e ) { System . out . println ( \"OOBean document could not be accessed\" ); } return doc ; } // end of getDoc() OOoBean contains many deprecated methods that affect the visibility of Office's menu bar, standard bar, tools bar, and status bar. The preferred, and more powerful, approach is to use the LayoutManager service, which is accessed with GUI.getLayoutManager(): // in the GUI class public static XLayoutManager getLayoutManager ( XComponent doc ) { XLayoutManager lm = null ; try { XPropertySet propSet = Lo . qi ( XPropertySet . class , getFrame ( doc )); lm = Lo . qi ( XLayoutManager . class , propSet . getPropertyValue ( \"LayoutManager\" )); } catch ( Exception e ) { System . out . println ( \"Could not access layout manager\" ); } return lm ; } // end of getLayoutManager() The XLayoutManager reference is stored in the \"LayoutManager\" property of the document's frame. All the toolbars known to the layout manager can be hidden with a call to XLayoutManager.setVisible(): // part of loadDoc()... XLayoutManager lm = GUI . getLayoutManager ( doc ); lm . setVisible ( false ); // hide all toolbars loadDoc() also assigns the monitoring of the keyboard and mouse to OBeanPanel: // part of loadDoc()... XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); The mouse methods don't do much: // in the OBeanPanel class public boolean mousePressed ( com . sun . star . awt . MouseEvent e ) { System . out . println ( \"Mouse pressed (\" + e . X + \", \" + e . Y + \")\" ); return false ; // send event on, or use true not to send } public boolean mouseReleased ( com . sun . star . awt . MouseEvent e ) { System . out . println ( \"Mouse released (\" + e . X + \", \" + e . Y + \")\" ); return false ; } Unlike Java listeners, these Office handlers return a boolean to indicate whether the event should be passed on to other listeners; false means the event should be sent on, true causes it to be consumed. The key release handler is similarly short, but the key press handler deals with a keyboard focus bug: // in the OBeanPanel class public boolean keyReleased ( com . sun . star . awt . KeyEvent e ) { return false ; } @SuppressWarnings ( \"deprecation\" ) public boolean keyPressed ( com . sun . star . awt . KeyEvent e ) { if ( oob == null ) return false ; try { oob . releaseSystemWindow (); // force focus away from bean; // must suppress deprecation warning oob . aquireSystemWindow (); // Impress redisplays toolbars; remove them again XLayoutManager lm = GUI . getLayoutManager ( doc ); lm . setVisible ( false ); Lo . dispatchCmd ( \"LeftPaneImpress\" , Props . makeProps ( \"LeftPaneImpress\" , false ) ); // hide slides pane } catch ( java . lang . Exception ex ) {} return false ; } // end of keyPressed() keyPressed() calls OOoBean.releaseSystemWindow() and then OOoBean.aquireSystemWindow() to force the bean to release the keyboard focus; this allows the user to select and type text into other text fields, such as the page jump field in the SwingViewer.java example described below. I found this trick in a forum post by Martin Illguth at https://forum.openoffice.org/en/forum/viewtopic.php?f=20&t=63008 . keyPressed() also deals with a side-effect of displaying Impress slides \u2013 clicking on a slide inside the bean causes hidden toolbars and the slides pane to be made visible. Another call to the layout manager deals with the toolbars, but the slides pane, which isn't a toolbar, is hidden with a \".uno:LeftPaneImpress\" dispatch. 3. Using the OBeanPanel \u00b6 Figure 4 shows SwingViewer.java at start-up; the buttons on the right are for quickly moving through a multi-page (or multi-slide) document, and for zooming in and out on a document. The controls at the bottom show the number of pages (or slides) in the document, and allow the user to jump to a specified page/slide number. Figure 5 shows the controls in close-up. Figure 5. The Buttons and Page Controls in SwingViewer. Aside from text documents and slide decks, SwingViewer can load Draw, Calc, and Base files; Figure 6 shows a sample. Figure 6. Different Documents Displayed by SwingViewer. The SwingViewer constructor is passed the document's filename, creates an OBeanPanel in a JFrame with buttons and other controls, and loads the document: // globals private OBeanPanel officePanel ; private XComponent doc = null ; private int docType = Lo . UNKNOWN ; public SwingViewer ( String fnm ) { super ( \"SwingViewer\" ); Container c = getContentPane (); officePanel = new OBeanPanel ( 850 , 600 ); // OOoBean inside a JPanel c . add ( officePanel , BorderLayout . CENTER ); if ( officePanel . getBean () == null ) { System . out . println ( \"OOoBean not created\" ); System . exit ( 1 ); } c . add ( makeButtons (), BorderLayout . EAST ); c . add ( makePageControls (), BorderLayout . SOUTH ); addWindowListener ( new WindowAdapter () { public void windowClosing ( WindowEvent e ){ officePanel . closeDown (); System . exit ( 0 ); } }); pack (); setLocationRelativeTo ( null ); // center the window setResizable ( false ); setVisible ( true ); Lo . delay ( 200 ); // give time for the OOBean to appear doc = officePanel . loadDoc ( fnm ); docType = Info . reportDocType ( doc ); if ( doc == null ) { officePanel . closeDown (); System . exit ( 0 ); } // initialize loaded document if ( docType == Lo . WRITER ) initTextDoc (); else if ( docType == Lo . IMPRESS ) initDrawDoc (); } // end of SwingViewer() OOoBean termination is done by OBeanPanel.closeDown() in a window listener. It calls OOoBean.stopOOoConnection(), but this sometimes hangs, so it also invokes Lo.killOffice(): // in the OBeanPanel class public void closeDown () { if ( oob != null ) { System . out . println ( \"Closing connection to office\" ); oob . stopOOoConnection (); } Lo . delay ( 1000 ); // wait for close down to finish Lo . killOffice (); // make sure office processes are gone } // end of closeDown() The loading of a Writer or Impress document causes several globals to be initialized by initTextDoc() or initDrawDoc(). initTextDoc() stores the page count and creates a visible text cursor for moving through the document's pages: // in the SwingViewer class // globals private int pageCount = - 1 ; private XTextViewCursor tvCursor = null ; // for text docs private void initTextDoc () { // report the number of pages in the doc XTextDocument textDoc = Lo . qi ( XTextDocument . class , doc ); pageCount = Write . getPageCount ( textDoc ); setLastPage ( pageCount ); try { // get the document's visible cursor XController xc = officePanel . getController (); XTextViewCursorSupplier tvcSupplier = Lo . qi ( XTextViewCursorSupplier . class , xc ); tvCursor = tvcSupplier . getViewCursor (); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not access document cursor\" ); } } // end of initTextDoc() initTextDoc() calls setLastPage() to write the pageCount value into the \"Last Page\" field shown in Figure 5. initDrawDoc() also initializes the global pageCount variable, but with the number of slides in the document. However, instead of a text cursor, it create XDrawPages and XDrawView instances for moving through the slides on-screen. // globals private int pageCount = - 1 ; private XDrawView xDrawView = null ; // for slide docs private XDrawPages xDrawPages = null ; private void initDrawDoc () { try { // report the number of slides in the doc xDrawPages = Draw . getSlides ( doc ); pageCount = Draw . getSlidesCount ( doc ); setLastPage ( pageCount ); // get a slide view xDrawView = Lo . qi ( XDrawView . class , officePanel . getController ()); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not access document pages\" ); } } // end of initDrawDoc() The globals are utilized when the user presses one of SwingViewer's button. For example, clicking on the \"Up\" and \"Down\" buttons triggers calls to pageChange(): // part of SwingViewer.makeButtons() : JButton upButton = new JButton ( \"Up\" ); upButton . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ev ) { pageChange ( false ); } // isDown is false, i.e. move up }); JButton downButton = new JButton ( \"Down\" ); downButton . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ev ) { pageChange ( true ); } // isDown is true, i.e. move down }); : pageChange() uses the document's type to decide whether to change pages or slides: public void pageChange ( boolean isDown ) { if ( docType == Lo . WRITER ) textChange ( isDown ); else if ( docType == Lo . IMPRESS ) slideChange ( isDown ); } // end of pageChange() textChange() utilizes the visible text cursor, while slideChange() uses the XDrawPages and XDrawView variables. If the document isn't textual or a slide deck, then pageChange() returns without doing anything. 4. Using an Undecorated Office Window \u00b6 As I mentioned at the start, there are two ways of employing Office as a GUI component: one is to use OOoBean inside a JPanel, as just explained. The other is to have the program make Office visible on-screen, which I've done many times in earlier examples. The main difference in my OffViewer.java example is that most of Office's GUI is hidden, so the document appears in an undecorated window. Figure 7 shows the five documents from Figure 6, this time loaded by OffViewer: Figure 7. Different Documents Displayed by OffViewer. There are a few differences between SwingViewer's display and OffViewer. For instance, OffViewer uses some of Office's toolbars and tool panes, depending on the document type. The \"Find\" bar is visible underneath the Writer, Draw, and Impress documents, and the slide pane is present to the left of the current slide. The Draw, Impress, and Calc documents also include a yellow pane along their tops containing a button for enabling editing of the read-only document. I've not been able to find a way to hide that pane. The OffViewer constructor loads Office, loads the document, attaches listeners, and displays some toolbars and panes depending on the document's type: // global private XComponent doc = null ; public OffViewer ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); doc = Lo . openReadOnlyDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } // attach listeners doc . addEventListener ( this ); XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); // give window time to appear XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); // modify UI visibility ArrayList < String > showElems = new ArrayList < String > (); showElems . add ( GUI . FIND_BAR ); showElems . add ( GUI . STATUS_BAR ); GUI . showOnly ( doc , showElems ); // call dispatches *after* the window is visible Lo . dispatchCmd ( \"Sidebar\" , Props . makeProps ( \"Sidebar\" , false )); // hide sidebar // modify UI based on the document type int docType = Info . reportDocType ( doc ); if ( docType == Lo . DRAW ) Lo . dispatchCmd ( \"LeftPaneDraw\" , Props . makeProps ( \"LeftPaneDraw\" , false ) ); // hide Pages pane if ( docType == Lo . IMPRESS ) Lo . dispatchCmd ( \"LeftPaneImpress\" , Props . makeProps ( \"LeftPaneImpress\" , true ) ); // show Slides pane if ( docType == Lo . CALC ) Lo . dispatchCmd ( \"InputLineVisible\" , Props . makeProps ( \"InputLineVisible\" , false ) ); // hide formula bar if ( docType == Lo . BASE ) Lo . dispatchCmd ( \"DBViewTables\" ); // switch to tables view } // end of OffViewer() Several common toolbar resource names are defined as constants in the GUI class: // in the GUI class public static final String MENU_BAR = \"private:resource/menubar/menubar\" ; public static final String STATUS_BAR = \"private:resource/statusbar/statusbar\" ; public static final String FIND_BAR = \"private:resource/toolbar/findbar\" ; public static final String STANDARD_BAR = \"private:resource/toolbar/standardbar\" ; public static final String TOOL_BAR = \"private:resource/toolbar/toolbar\" ; A lengthy list of all the toolbars in LibreOffice is stored in TOOLBAR_NMS[] in GUI.java, and can be accessed by calling GUI.getToobarResource() with a partial string; the first matching toolbar resource name is returned. For example: GUI.getToobarResource(\"zoom\"); returns the string \"private:resource/toolbar/zoombar\". The visibility of Office's toolbars is managed by the LayoutManager service as before, but in a somewhat more complex way because OffViewer can both hide and show toolbars. GUI.showOnly() hides all the toolbars accessible to the layout manager, except for those in its showElems argument. The difficulty is that some of these visible toolbars may not currently exist, and so need to be created and then made visible. GUI.showOnly() is: // in the GUI class public static void showOnly ( XComponent doc , ArrayList < String > showElems ) // leave only the toolbars in showElems visible { XLayoutManager lm = getLayoutManager ( doc ); if ( lm == null ) System . out . println ( \"No layout manager found\" ); else { XUIElement [] uiElems = lm . getElements (); hideExcept ( lm , uiElems , showElems ); for ( String elemName : showElems ) { // these elems are not in lm lm . createElement ( elemName ); // so need to be created & shown lm . showElement ( elemName ); System . out . println ( elemName + \" made visible\" ); } } } // end of showOnly() public static void hideExcept ( XLayoutManager lm , XUIElement [] uiElems , ArrayList < String > showElems ) // hide all of uiElems toolbars, except ones in showElems; // delete any showElems toolbar strings that match { for ( XUIElement uiElem : uiElems ) { String elemName = uiElem . getResourceURL (); boolean toHide = true ; for ( int i = 0 ; i < showElems . size (); i ++ ){ if ( showElems . get ( i ). equals ( elemName )) { showElems . remove ( i ); // this elem is in lm so remove from showElems toHide = false ; // since the toolbar is already shown break ; } } if ( toHide ) { lm . hideElement ( elemName ); System . out . println ( elemName + \" hidden\" ); } } } // end of hideExcept() GUI.showOnly() hides toolbars by calling hideExcept(), which calls XLayoutManager.hideElement() on all the layout manager's toolbars except ones in the showElems list, which are meant to stay visible. If a showElems toolbar is left unhidden then its name is deleted from the list because it's not needed in the next step back in GUI.showOnly() When hideExcept() returns, showOnly() iterates through the remaining toolbars in showElems which are there because they were unknown to the layout manager.Each of these toolbars must be created (with XLayoutManager.createElement()) before being made visible by XLayoutManager.showElement(). In OffViewer, several tool panes, such as the slides pane in Impress, have to be enabled or disabled, but they're not accessible through the layout manager. Instead, I use dispatch commands which only work if the Office window is visible and active. I couldn't find any documentation about dispatch commands for UI panes, but it appears that a pane can be made visible or invisible by including its name as a property with the value true or false. For example: Lo . dispatchCmd ( \"LeftPaneImpress\" , Props . makeProps ( \"LeftPaneImpress\" , true ) ); // show Slides pane This call sends a \".uno:LeftPanelImpress\" dispatch to Office to make the slides pane visible. The easiest way to find dispatch names is to browse through the long list at https://wiki.documentfoundation.org/Development/DispatchCommands/ . It's divided into application and tool subcategories, which narrows the search a little. Also, each entry includes a \"Label value\" field which for UI elements (i.e. toolbars, panes, and menus) corresponds to its name in Office's GUI. Another approach is to search Office's source code \u2013 dispatches are defined inside \".xcu\" files, and the UI related files are mostly in the subdirectory \\officecfg\\registry\\schema\\org\\openoffice\\Office\\UI. Listening to User Input and the Window \u00b6 OffViewer implements four listeners for mouse presses, keyboard handling, window changes, and document events: public class OffViewer implements XMouseClickHandler , XKeyHandler , XWindowListener , com . sun . star . document . XEventListener { ... } The listeners are attached in the constructor for OffViewer, which implements all the methods itself: // part of OffViewer()... doc . addEventListener ( this ); XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); The event listener's disposing() method is triggered as the document is closed, and uses Lo.killOffice() to terminate Office. As with SwingViewer.java, only calling Lo.closeOffice() is insufficient, causing Office to hang. // in the OffViewer class public void disposing ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Document is closing\" ); if ( doc != null ) Lo . closeDoc ( doc ); // Lo.closeOffice(); // Office hangs, so kill it instead Lo . killOffice (); System . exit ( 0 ); } The window, mouse, and keyboard handlers print simple information: // XWindow listener methods public void windowShown ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Doc window has become visible\" ); } public void windowHidden ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Doc window has been hidden\" ); } public void windowResized ( WindowEvent e ) { System . out . println ( \"Resized to \" + e . Width + \" x \" + e . Height ); } public void windowMoved ( WindowEvent e ) { System . out . println ( \"Moved to (\" + e . X + \", \" + e . Y + \")\" ); } // XMouseClickHandler methods public boolean mousePressed ( MouseEvent e ) { System . out . println ( \"Mouse pressed (\" + e . X + \", \" + e . Y + \")\" ); return false ; // send event on, or use true not to send } public boolean mouseReleased ( MouseEvent e ) { System . out . println ( \"Mouse released (\" + e . X + \", \" + e . Y + \")\" ); return false ; } // XKeyHandler methods public boolean keyPressed ( KeyEvent e ) { System . out . println ( \"Key pressed: \" + e . KeyCode + \"/\" + e . KeyChar ); return true ; } public boolean keyReleased ( KeyEvent e ) { System . out . println ( \"Key released: \" + e . KeyCode + \"/\" + e . KeyChar ); return true ; } The mouse handlers allow their events to be used by other handlers (i.e. they return false), but the keyboard handlers consume their inputs. 5. Augmenting the User Interface: a New Toolbar Item \u00b6 TBViewer.java is a variant of OffViewer which adds a toolbar item called \"Hello\" to the \"Find\" toolbar, as shown in Figure 8 on the left. Figure 8. The \"Find\" Toolbar with the \"Hello\" Item. When the user clicks on \"Hello\", ToolbarItemListener is woken up, and its clicked() method called. clicked() displays a message box (see Figure 9). Figure 9. The Message Box that Appears when \"Hello\" is Clicked. This toolbar extension technique is similar to Office's Add-ons, which I'll be discussing in Chapter 46. However, the item isn't permanently added to the toolbar, existing only while TBViewer is executing. The TBViewer constructor: // global private XComponent doc = null ; public TBViewer ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); doc = Lo . openReadOnlyDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); // give window time to appear GUI . showOne ( doc , GUI . FIND_BAR ); Lo . dispatchCmd ( \"Sidebar\" , Props . makeProps ( \"Sidebar\" , false )); // hide sidebar GUI . addItemToToolbar ( doc , GUI . FIND_BAR , \"Hello\" , \"h.png\" ); // add an dispatch interceptor for the \"Hello\" item XDispatchProviderInterception dpi = GUI . getDPI ( doc ); if ( dpi != null ) dpi . registerDispatchProviderInterceptor ( new ItemInterceptor ( this , \"Hello\" )); } // end of TBViewer() GUI . showOne () utilizes GUI . showOnly () to leave only the \"Find\" toolbar visible : // in the GUI class public static void showOne ( XComponent doc , String showElem ) { ArrayList < String > showElems = new ArrayList < String > (); showElems . add ( showElem ); showOnly ( doc , showElems ); } // end of showOne() GUI.addItemToToolbar() creates the toolbar item: GUI.addItemToToolbar(doc, GUI.FIND_BAR, \"Hello\", \"h.png\"); Its arguments are the document, the toolbar's resource name, the item name, and the filename of an image icon. A dispatch interceptor (an ItemInterceptor object) is registered to catch clicks (dispatches) on the \"Hello\" item, and redirect them to TBViewer: XDispatchProviderInterception dpi = GUI . getDPI ( doc ); if ( dpi != null ) dpi . registerDispatchProviderInterceptor ( new ItemInterceptor ( this , \"Hello\" )); ItemInterceptor processes each click by calling ToolbarItemListener.clicked() which is implemented by TBViewer as: // in the TBViewer class public void clicked ( String itemName , URL cmdURL , PropertyValue [] props ) { GUI . showMessageBox ( \"Item Dialog\" , \"Processing the \\\"\" + itemName + \"\\\" command\" ); } // end of clicked() 5.1. Intercepting Dispatches \u00b6 ItemInterceptor implements XDispatchProviderInterceptor and XDispatch so it can both intercept dispatches and process them: public class ItemInterceptor implements XDispatchProviderInterceptor , XDispatch { private XDispatchProvider slaveDP , masterDP ; // pointers to next and previous dispatch providers in list private ToolbarItemListener viewer ; // object sent dispatch info private String itemName ; // toolbar item name private String cmd ; // toolbar item's dispatch command public ItemInterceptor ( ToolbarItemListener v , String itemName ) { viewer = v ; this . itemName = itemName ; cmd = Lo . makeUnoCmd ( itemName ); } // : more XDispatchProviderInterceptor and XDispatch methods; // : see below } // end of ItemInterceptor class The ItemInterceptor() arguments are a reference to ToolbarItemListener (which implements clicked()), and the toolbar item name (\"Hello\") which is converted into a UNO command string by Lo.makeUnoCmd(): // in the Lo class public static String makeUnoCmd ( String itemName ) // use a dummy Java class name, Foo { return \"vnd.sun.star.script:Foo/Foo.\" + itemName + \"?language=Java&location=share\" ; } The returned command string is mostly make-believe \u2013 there's no vnd.sun.star.script:Foo/Foo class, but that doesn't matter so long as the string is unique, and matches the command string in the toolbar item (which is set up by GUI.addItemToToolbar(), as shown below). Office adds the ItemInterceptor object to an interceptors list, which is doubly-linked so that each node points to the previous (master) and next (slave) list element. These are accessible through get/set master/slave methods: // in ItemInterceptor class public void setMasterDispatchProvider ( XDispatchProvider dp ) { masterDP = dp ; } public void setSlaveDispatchProvider ( XDispatchProvider dp ) { slaveDP = dp ; } public XDispatchProvider getMasterDispatchProvider () { return masterDP ; } public XDispatchProvider getSlaveDispatchProvider () { return slaveDP ; } XDispatchProviderInterceptor also requires implementations for queryDispatches() and queryDispatch(). queryDispatches() iterates through the array of dispatch descriptors passed to it, and calls queryDispatch() on each one: // in ItemInterceptor class public XDispatch [] queryDispatches ( DispatchDescriptor [] descrs ) { int count = descrs . length ; XDispatch [] xDispatch = new XDispatch [ count ] ; for ( int i = 0 ; i < count ; i ++ ) xDispatch [ i ] = queryDispatch ( descrs [ i ] . FeatureURL , descrs [ i ] . FrameName , descrs [ i ] . SearchFlags ); return xDispatch ; } // end of queryDispatches() If the dispatch passed to queryDispatch() is recognized by this interceptor then an XDispatch object is returned; otherwise the dispatch is sent to the next interceptor in the list: // in ItemInterceptor class public XDispatch queryDispatch ( URL cmdURL , String target , int srchFlags ) { if ( cmdURL . Complete . equalsIgnoreCase ( cmd )) { System . out . println ( itemName + \" seen\" ); return this ; // this will cause dispatch() to be called } if ( slaveDP != null ) return slaveDP . queryDispatch ( cmdURL , target , srchFlags ); // pass command to next interceptor in list else return null ; } // end of queryDispatch() Office processes the returned XDispatch object by calling its dispatch() method, which is implemented by ItemInterceptor: // in ItemInterceptor class // global private ToolbarItemListener viewer ; // object sent dispatch info public void dispatch ( URL cmdURL , PropertyValue [] props ) { viewer . clicked ( itemName , cmdURL , props ); } Control is passed to the listener's clicked() method, which is in TBViewer. For more information on dispatch interception, see chapter 6 of the Developer's Guide, which is also online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Dispatch_Interception (or use loGuide \"Dispatch Interception\" ). 5.2. Displaying a Message Box \u00b6 TBViewer's clicked() creates an Office message dialog (see Figure 10) by calling GUI.showMessageBox(). This dialog requires some complicated coding, and you may wonder why I didn't just use Java's dialogs. For example, as in GUI.showJMessageBox(): // in the GUI class public static void showJMessageBox ( String title , String message ) { JOptionPane . showMessageDialog ( null , message , title , JOptionPane . INFORMATION_MESSAGE ); } I did try this, and it works fine most of the time, but sometimes the dialog appears behind Office's window, and so is hidden from the user. The problem lies with the null first argument of JOptionPane.showMessageDialog() which leaves the dialog's parent window unspecified. An Office message dialog is created in two main steps, as shown in GUI.showMessageBox(): // in the GUI class public static void showMessageBox ( String title , String message ) { XToolkit xToolkit = Lo . createInstanceMCF ( XToolkit . class , \"com.sun.star.awt.Toolkit\" ); XWindow xWindow = getWindow (); if (( xToolkit == null ) || ( xWindow == null )) return ; XWindowPeer xPeer = Lo . qi ( XWindowPeer . class , xWindow ); // initialize window description WindowDescriptor desc = new WindowDescriptor (); desc . Type = WindowClass . MODALTOP ; desc . WindowServiceName = new String ( \"infobox\" ); desc . ParentIndex = - 1 ; desc . Parent = xPeer ; desc . Bounds = new Rectangle ( 0 , 0 , 300 , 200 ); desc . WindowAttributes = WindowAttribute . BORDER | WindowAttribute . MOVEABLE | WindowAttribute . CLOSEABLE ; // create message box using the description XWindowPeer descPeer = xToolkit . createWindow ( desc ); if ( descPeer != null ) { XMessageBox msgBox = Lo . qi ( XMessageBox . class , descPeer ); if ( msgBox != null ) { msgBox . setCaptionText ( title ); msgBox . setMessageText ( message ); msgBox . execute (); // show the box } } } // end of showMessageBox() A WindowDescriptor object is initialized to specify the type of window that will be created, including its parent (the Office window). The descriptor is used to create a XWindowPeer object, which is converted into an XMessageBox. 5.3. Adding \"Hello\" to the Toolbar \u00b6 GUI.addItemToToolbar() adds the \"Hello\" item to the \"Find\" toolbar: GUI . addItemToToolbar ( doc , GUI . FIND_BAR , \"Hello\" , \"h.png\" ); The code: // in the GUI class public static void addItemToToolbar ( XComponent doc , String toolbarName , String itemName , String imFnm ) { String cmd = Lo . makeUnoCmd ( itemName ); XUIConfigurationManager confMan = GUI . getUIConfigManagerDoc ( doc ); if ( confMan == null ) { System . out . println ( \"Cannot create configuration manager\" ); return ; } try { // add icon for the command XImageManager imageMan = Lo . qi ( XImageManager . class , confMan . getImageManager ()); String [] cmds = { cmd }; XGraphic [] pics = new XGraphic [ 1 ] ; pics [ 0 ] = Images . loadGraphicFile ( imFnm ); imageMan . insertImages (( short ) 0 , cmds , pics ); // add item to toolbar XIndexAccess settings = confMan . getSettings ( toolbarName , true ); XIndexContainer conSettings = Lo . qi ( XIndexContainer . class , settings ); PropertyValue [] itemProps = Props . makeBarItem ( cmd , itemName ); conSettings . insertByIndex ( 0 , itemProps ); // place first in the toolbar confMan . replaceSettings ( toolbarName , conSettings ); } catch ( java . lang . Exception e ) { System . out . println ( e ); } } // end of addItemToToolbar() It accesses the toolbar with XUIConfigurationManager. A toolbar item is created (as an array of properties), and added to the bar at the specified index position. The icon that should be drawn next to \"Hello\" on the toolbar is loaded by XImageManager. As Figure 8 shows, this image doesn't appear, although it has been loaded since it's listed in the \"Visible Buttons\" window in Figure 10. Figure 10. The \"Visible Buttons\" Window for the Toolbar. 6. Augmenting the User Interface: a New Menu Item \u00b6 MenuViewer.java is a variant of OffViewer which either adds a menu at the end of Office's menubar (see Figure 11a), or creates a new menubar for the menu (see Figure 11b). Figure 11. Adding an Item to a Menubar. The same menu is created in both cases, and is shown in pop-down form in Figure 12. Figure 12. The \"My_menu\" Menu. The menu includes a \"Hello\" item with an icon, \"Quit\" for quitting Office, and some radio button and checkbox items that do nothing. When \"Hello\" is clicked, the same Office message box appears as in Figure 10. The MenuViewer constructor creates a new menubar (see Figure 11b), but contains commented out code for adding the menu to Office's menubar (as in Figure 11a): // in MenuViewer.java // globals private XComponent doc = null ; private short id = 0 ; // used for menu IDs public MenuViewer ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); doc = Lo . openReadOnlyDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); // wait for window to appear // create new menubar GUI . showNone ( doc ); // hide all toolbars makeMenubar ( win ); /* // or modify the existing menubar GUI.showOne(doc, GUI.MENU_BAR); // hide all toolbars except the menubar setMenubar(doc); */ } // end of MenuViewer() This MenuViewer example is based on one in the \"Creating Menus\" section at the end of chapter 19, \"Graphical user Interfaces\", in the Developer's Guide; it can be found online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/GUI/Creating_Menus/ (or use loGuide \"Creating Menus\" ). The corresponding code is at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#GraphicalUserInterfaces/ , and includes the use of a context menu, which I don't consider here. 6.1. Creating a New Menubar \u00b6 makeMenubar() attaches an XMenubar instance to the Office window using XTopWindow.setMenuBar(): // in MenuViewer.java private void makeMenubar ( XWindow win ) { XTopWindow topWin = Lo . qi ( XTopWindow . class , win ); XMenuBar menubar = Lo . createInstanceMCF ( XMenuBar . class , \"com.sun.star.awt.MenuBar\" ); if ( menubar == null ) System . out . println ( \"Could not create a menu bar\" ); else { addMenu ( menubar , ( short ) 0 ); topWin . setMenuBar ( menubar ); } } // end of makeMenubar() addMenu() labels the menu, which is generated by makePopupMenu(): // in MenuViewer.java // globals private short id = 0 ; // used for menu IDs private void addMenu ( XMenuBar bar , short mPos ) { short menuID = id ; bar . insertItem ( menuID , \"My ~Menu\" , MenuItemStyle . AUTOCHECK , mPos ); id ++ ; bar . setPopupMenu ( menuID , makePopupMenu ()); // add menu to menubar } // end of addMenu() The three important menu interfaces are shown in Figure 13. Figure 13. The Menu Services and Interfaces. Although addMenu() initializes an XMenuBar instance, the interface doesn't contain any methods, inheriting its functionality from XMenu, as indicated in Figure 13. The menu methods, such as XMenu.insertItem() used by addMenu(), can be a little confusing because of their use of shorts in different ways. Every menu and menu item is assigned an ID, which is useful in listener code for identifying which item was clicked. In my code, each menu ID is initialized using a global id variable, which is incremented after each use. Every menu and item also uses a position short value which determines where the menu appears in the bar, and where an item appears in the menu. For example, addMenu() is called by makeMenubar() with a position value set to 0, which will place the menu first on the bar. The third use of short is as MenuItemStyle constants, which specify behavior for menu items acting as check and radio boxes. Creating the Menu \u00b6 The menu in Figure 12 is created by makePopupMenu(): // in MenuViewer.java // globals private static final String CMD_HELLO = \"Cmd_Hello\" ; private static final String CMD_QUIT = \"Cmd_Quit\" ; private short id = 0 ; // used for menu IDs public XPopupMenu makePopupMenu () /* Popup menu consists of: * Hello + image * three radio buttons (only one on) * a separator * two check boxes * Quit */ { XPopupMenu pum = Lo . createInstanceMCF ( XPopupMenu . class , \"com.sun.star.awt.PopupMenu\" ); if ( pum == null ) { System . out . println ( \"Could not create a menu\" ); return null ; } short mPos = 0 ; pum . insertItem ( id , \"Hello\" , ( short ) 0 , mPos ++ ); // first short is an ID for the new menu item; // the second is the style for the item, 0 means none/ordinary; // the third is the items' position on the menu pum . setItemImage ( id , Images . loadGraphicFile ( \"H.png\" ), false ); pum . setCommand ( id ++ , CMD_HELLO ); pum . insertItem ( id , \"First Radio\" , ( short ) ( MenuItemStyle . RADIOCHECK + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . enableItem ( id ++ , false ); // grayed out pum . insertItem ( id , \"Second Radio\" , ( short ) ( MenuItemStyle . RADIOCHECK + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . checkItem ( id ++ , true ); // selected pum . insertItem ( id ++ , \"Third Radio\" , ( short ) ( MenuItemStyle . RADIOCHECK + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . insertSeparator ( mPos ++ ); pum . insertItem ( id ++ , \"Check 1\" , ( short ) ( MenuItemStyle . CHECKABLE + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . insertItem ( id ++ , \"Check 2\" , ( short ) ( MenuItemStyle . CHECKABLE + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . insertItem ( id , \"Quit\" , ( short ) 0 , mPos ++ ); pum . setCommand ( id ++ , CMD_QUIT ); pum . addMenuListener ( this ); return pum ; } // end of makePopupMenu() Ordinary menu items (in my case, \"Hello\" and \"Quit\") are assigned a style value of 0. Menu items activation by the user are detected by attaching a listener to the menu. When an item is pressed, an event containing its ID is sent to the listener. Optionally items can be assigned command strings (as for the \"Hello\" and \"Quit\" items) to better distinguish them. MenuViewer.java implements XMenuListener, which requires four methods \u2013 itemSelected(), itemHighlighted(), itemActivated(), and itemDeactivated(). Only itemSelected() does anything of note: // in MenuViewer.java public void itemSelected ( MenuEvent menuEvent ) { short id = menuEvent . MenuId ; XPopupMenu pum = Lo . qi ( XPopupMenu . class , menuEvent . Source ); if ( pum == null ) System . out . println ( \"Menu item \" + id + \" selected; popupmenu is null\" ); else { String itemName = pum . getItemText ( id ); String cmd = pum . getCommand ( id ); System . out . println ( \"Menu item \\\"\" + pum . getItemText ( id ) + \"\\\" selected\" ); System . out . println ( \" is checked? \" + pum . isItemChecked ( id )); processCmd ( cmd ); } } // end of itemSelected() public void itemHighlighted ( MenuEvent menuEvent ) { // System.out.println(menuEvent.MenuId + \" highlighted\"); } public void itemDeactivated ( MenuEvent menuEvent ) { // System.out.println(menuEvent.MenuId + \" deactivated\"); } public void itemActivated ( MenuEvent menuEvent ) { // System.out.println(menuEvent.MenuId + \" activated\"); } Each MenuEvent object includes the menu item ' s ID and a reference to its menu , which are accessed at the start of itemSelected (): short id = menuEvent . MenuId ; XPopupMenu pum = Lo . qi ( XPopupMenu . class , menuEvent . Source ); itemSelected () uses the ID and menu to access details , including the menu item ' s label and command string . Item processing is handled by processCmd (): public void processCmd ( String cmd ) { if (( cmd == null ) || cmd . equals ( \"\" )) { System . out . println ( \" No command\" ); return ; } if ( cmd . equals ( CMD_HELLO )) GUI . showMessageBox ( \"Item Dialog\" , \"Processing the \\\"Hello\\\" command\" ); else if ( cmd . equals ( CMD_QUIT )) { System . out . println ( \" Quiting the Application\" ); if ( doc != null ) Lo . closeDoc ( doc ); // will trigger a call to disposing() } else System . out . println ( \" Got command: \" + cmd ); } // end of processCmd() Clicking on \"Hello\" results in a call to GUI.showMessageBox() which was used earlier in ItemViewer. Clicking on \"Quit\" causes the document to be closed by Lo.closeDoc() which in turn triggers a call to XWindowListener.disposing() which MenuViewer.java also implements: // in MenuViewer.java public void disposing ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Doc window is closing\" ); if ( doc != null ) Lo . closeDoc ( doc ); // Lo.closeOffice(); // Office hangs, so kill it instead Lo . killOffice (); System . exit ( 0 ); } 6.2. Adding to the Existing Menubar \u00b6 MenuViewer.java can be edited to add the menu to Office's menubar rather than create a new one. The end of the constructor becomes: // end of MenuViewer()... /* // create new menu bar GUI.showNone(doc); makeMenubar(win); */ // or modify the existing menubar GUI . showOne ( doc , GUI . MENU_BAR ); setMenubar ( doc ); setMenuBar() uses the layout manager to obtain a reference to Office's menubar, and calculates a unique ID for the new menu and its position on the bar: // in MenuViewer.java // globals private short id = 0 ; // used for menu IDs private void setMenubar ( XComponent doc ) { XLayoutManager lm = GUI . getLayoutManager ( doc ); XMenuBar menubar = GUI . getMenubar ( lm ); if ( menubar == null ) System . out . println ( \"Menubar not found\" ); else { short menuCount = menubar . getItemCount (); // count along the menu bar to get no. of menus short maxID = GUI . getMenuMaxID ( menubar ); // find the largest menu item ID id = ( short )( maxID + ( short ) 100 ); // hacky /* add a big number to account for the IDs used by menu items in the menu */ addMenu ( menubar , menuCount ); } } // end of setMenubar() The XMenuBar reference is retrieved from a property in the XUIElement for the bar: // in the GUI class //globals public static final String MENU_BAR = \"private:resource/menubar/menubar\" ; public static XMenuBar getMenubar ( XLayoutManager lm ) { if ( lm == null ) { System . out . println ( \"No layout manager available\" ); return null ; } XMenuBar bar = null ; try { XUIElement oMenuBar = lm . getElement ( GUI . MENU_BAR ); XPropertySet props = Lo . qi ( XPropertySet . class , oMenuBar ); bar = Lo . qi ( XMenuBar . class , props . getPropertyValue ( \"XMenuBar\" )); if ( bar == null ) System . out . println ( \"Menubar reference not found\" ); } catch ( Exception e ) { System . out . println ( \"Could not access menubar\" ); } return bar ; } // end of getMenubar() Back in setMenubar(), XMenuBar.getItemCount() returns the number of menus already on the bar, which can be used as the position of the new menu. Deciding on a unique menu ID is a little difficult since the IDs of all the items on the existing menus, including submenus, should be examined. A simpler, and faster, solution is implemented by GUI.getMenuMaxID(), which only finds the largest ID of the menus (items in the menus aren't considered): // in the GUI class public static short getMenuMaxID ( XMenuBar bar ) { if ( bar == null ) return - 1 ; short itemCount = bar . getItemCount (); System . out . println ( \"No items in menu bar: \" + itemCount ); short maxID = - 1 ; for ( short i = 0 ; i < itemCount ; i ++ ) { short id = bar . getItemId ( i ); if ( id > maxID ) maxID = id ; } return maxID ; } // end of getMenuMaxID() The drawback is that the menu with the largest ID will probably contain some items with larger IDs. setMenubar() deals with this by adding 100 to the ID returned by getMenuMaxID(), in the hope that this exceeds the largest item ID. setMenubar() finished with a call to addMenu(), the same function used by makeMenubar() from earlier; it creates the menu and adds it to the bar.","title":"Chapter 44. Office as a GUI Component"},{"location":"44-Office_as_GUI_Comp.html#chapter-44-office-as-a-gui-component","text":"Topics OOoBean; Wrapping OOoBean in a JPanel; Using the OBeanPanel; Using an Undecorated Office Window; Augmenting the User Interface: a New Toolbar Item; Augmenting the User Interface: a New Menu Item Example folders: \"GUI Tests\" and \"Utils\" This chapter looks at two ways to use Office as a GUI component for displaying documents in a program. The first employs Office's OOoBean class: I'll wrap it in a JPanel to utilize it as part of a Swing application. The second approach invokes Office in a separate window from the program, a technique I've used many times in earlier chapters. The difference this time is that I'll hide Office's GUI (i.e. its toolbars, menu, and sidebars), leaving only the document visible. I'll also explore two variations of this 'blank look': adding a item to a toolbar, and creating a new menu. These GUI entities aren't permanently added to Office, and are controlled and monitored by the program.","title":"Chapter 44. Office as a GUI Component"},{"location":"44-Office_as_GUI_Comp.html#1-ooobean","text":"The OOoBean class and its com.sun.star.comp.beans package aren't documented in LibreOffice, but there's an entire chapter about them in the Developer's Guide (chapter 16, \"JavaBean for Office Components\"), at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf , and https://wiki.openoffice.org/wiki/Documentation/DevGuide/JavaBean/JavaBean_for_Office_Components/ (or use loGuide JavaBean ). The chapter's example, OOoBeanViewer, wraps OOoBean in an old-style Applet (not a JApplet), and can be downloaded from https://api.libreoffice.org/examples/DevelopersGuide/examples.html#OfficeBean . Another source of information is the OOoBean code at https://github.com/LibreOffice/core/blob/master/bean/com/sun/star/comp/beans/OOoBean.java . It's also possible to decompile OOoBean 's JAR file, which you'll find in \\program\\classes\\officebean.jar. As you browse the documentation and source code, you may get the feeling that OOoBean has been abandoned. It's true that some functionality have been deprecated, but OOoBean still mostly works. Setting it up is tricky, requiring an undocumented UNO_PATH environment variable to be set when Office is invoked. Also, integrating OOoBean with Swing and my LibreOffice support classes required some work. OOoBean utilizes many parts of the Office API, since it starts Office, loads a document, and displays it on a Java Canvas. Some of that can be seen in Figure 1 which gives a simplified view of its classes and interfaces. Figure 1. Some of the OOoBean Classes and Interfaces. The classes without package prefixes are from com.sun.star.comp.beans. For example, LocalOfficeConnection invokes and connects to Office, while LocalOfficeWindow renders Office and the loaded document. LocalOfficeWindow's use of java.awt.Canvas means that the view is a heavyweight, native peer, which doesn't work well with lightweight Swing components such as drop-down menus, text fields, and buttons. One solution is to wrap the heavyweight component (i.e. the Canvas) in a JPanel, which I've done in my OOBeanPanel class described in the next section. Frame, Controller, and OfficeDocument are wrappers around com.sun.star.frame's XFrame, XController, and XModel, the three elements of Office's Frame-Controller- Model (FCM) relationship (described in Chapter 1, section 5). Figure 2 shows OOoBean's public methods, with the deprecated ones highlighted in light orange and blue. Figure 2. The Public Methods of OOoBean. Nearly half the methods are deprecated, but only one of them (releaseSystemWindow()) is required in my code, to deal with a focus switching bug. The methods marked in light blue all relate to toolbar visibility, and can be handled better by the LayoutManager service explained later. There's a table of one-line descriptions of OOoBean's methods in chapter 16 of the Developer's Guide, and online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/JavaBean/API_Overview/ (or use loGuide JavaBean \"API Overview\" ). I'll only explain the methods used in my OBeanPanel class.","title":"1.  OOoBean"},{"location":"44-Office_as_GUI_Comp.html#2-wrapping-ooobean-in-a-jpanel","text":"OBeanPanel wraps an OOoBean instance inside a JPanel so its heavyweight canvas doesn't affect the rendering of lightweight components in the surrounding application. The class diagram for OBeanPanel in Figure 3 shows that it's a JPanel subclass, and implements Office mouse and keyboard listeners. Figure 3. The OBeanPanel Class Diagram. The key handling is necessary for coding around a keyboard focus bug. The mouse handler is included to show how to monitor mouse presses and releases in the document. OBeanPanel 's constructor sets up some JPanel attributes (its background color, dimensions, and start-up message), calls the OOoBean constructor, and adds the bean to the panel: // in the OBeanPanel class private int pWidth , pHeight ; // of panel private OOoBean oob = null ; private Font msgFont ; private FontMetrics fontMetric ; private String message ; public OBeanPanel ( int w , int h ) { pWidth = w ; pHeight = h ; setBackground ( Color . WHITE ); setPreferredSize ( new Dimension ( w , h )); setLayout ( new BorderLayout ()); // start-up and finishing message used by panel msgFont = new Font ( \"SansSerif\" , Font . BOLD , 36 ); fontMetric = getFontMetrics ( msgFont ); message = \"Waiting for Office...\" ; oob = new OOoBean (); // doesn't connect to Office; // actually an empty method add ( oob , BorderLayout . CENTER ); } // end of OBeanPanel() The surprising thing about the OOoBean() method is that its body is empty. In other words, at this stage, the bean is not connected to Office. paintComponent() draws the start-up message assigned in OBeanPanel(), which remains visible until the document is loaded and drawn over that area: // in the OBeanPanel class public void paintComponent ( Graphics g ) // display a message while OOoBean is loaded/unloaded { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ); int x = ( pWidth - fontMetric . stringWidth ( message )) / 2 ; int y = ( pHeight - fontMetric . getHeight ()) / 2 ; g2 . setColor ( Color . BLUE ); g2 . setFont ( msgFont ); g2 . drawString ( message , x , y ); } // end of paintComponent() Figure 4 shows the message before a document is loaded. Figure 4. The OBeanPanel without a Document. The buttons along the right-hand side of Figure 4 and the fields at the bottom are part of the SwingViewer.java application described later. OBeanPanel manages the large white rectangle with the \"Waiting for Office\u2026\" text. OBeanPanel.loadDoc() calls OOoBean.loadFromURL() to start Office and load and display the document: // in the OBeanPanel class //globals private XComponent doc = null ; public XComponent loadDoc ( String fnm ) { PropertyValue [] props = Props . makeProps ( \"ReadOnly\" , true ); try { String fileURL = FileIO . fnmToURL ( fnm ); oob . loadFromURL ( fileURL , props ); // real work done here! Lo . setOOoBean ( oob ); // initialize Lo class so // support classes are useable doc = getDoc (); int docType = Info . reportDocType ( doc ); if ( docType == Lo . BASE ) Lo . dispatchCmd ( getFrame (), \"DBViewTables\" , null ); // switch to tables view in Base docs XLayoutManager lm = GUI . getLayoutManager ( doc ); lm . setVisible ( false ); // hide all toolbars // add mouse click & key handlers to the doc XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); revalidate (); // needs a refresh to appear Lo . delay ( 1000 ); } catch ( java . lang . Exception e ) { System . out . println ( e ); } return doc ; } // end of loadDoc() OOoBean.loadFromURL()'s two arguments are the document's URL and a \"ReadOnly\" property since the bean is being used as a viewer. I want to keep using my support classes, which require the setting of four global variables in the Lo class. They are normally initialized by Lo.loadOffice() and Lo.openDoc(), but are copied from OOoBean by Lo.setOOoBean() in this case. // in the Lo class //globals // remote component context private static XComponentContext xcc = null ; // remote desktop UNO service private static XDesktop xDesktop = null ; // remote service managers private static XMultiComponentFactory mcFactory = null ; private static XMultiServiceFactory msFactory = null ; @SuppressWarnings ( \"deprecation\" ) public static void setOOoBean ( OOoBean oob ) { try { OfficeConnection conn = oob . getOOoConnection (); // the OfficeConnection class is deprecated if ( conn == null ) System . out . println ( \"No office connection found in OOoBean\" ); else { xcc = conn . getComponentContext (); if ( xcc == null ) System . out . println ( \"No component context in OOoBean\" ); else mcFactory = xcc . getServiceManager (); xDesktop = oob . getOOoDesktop (); msFactory = oob . getMultiServiceFactory (); } } catch ( java . lang . Exception e ) { System . out . println ( \"Couldn't init LO using OOoBean: \" + e ); } } // end of setOOoBean() The suppressed warning annotation stops the Java compiler complaining about OOoBean's deprecated OfficeConnection class. Back in OBeanPanel.loadDoc(), a reference to the loaded document is retrieved by calling OBeanPanel.getDoc(): // in the OBeanPanel class public XComponent getDoc () { XComponent doc = null ; try { XModel xModel = ( XModel ) oob . getDocument (); doc = Lo . qi ( XComponent . class , xModel ); } catch ( java . lang . Exception e ) { System . out . println ( \"OOBean document could not be accessed\" ); } return doc ; } // end of getDoc() OOoBean contains many deprecated methods that affect the visibility of Office's menu bar, standard bar, tools bar, and status bar. The preferred, and more powerful, approach is to use the LayoutManager service, which is accessed with GUI.getLayoutManager(): // in the GUI class public static XLayoutManager getLayoutManager ( XComponent doc ) { XLayoutManager lm = null ; try { XPropertySet propSet = Lo . qi ( XPropertySet . class , getFrame ( doc )); lm = Lo . qi ( XLayoutManager . class , propSet . getPropertyValue ( \"LayoutManager\" )); } catch ( Exception e ) { System . out . println ( \"Could not access layout manager\" ); } return lm ; } // end of getLayoutManager() The XLayoutManager reference is stored in the \"LayoutManager\" property of the document's frame. All the toolbars known to the layout manager can be hidden with a call to XLayoutManager.setVisible(): // part of loadDoc()... XLayoutManager lm = GUI . getLayoutManager ( doc ); lm . setVisible ( false ); // hide all toolbars loadDoc() also assigns the monitoring of the keyboard and mouse to OBeanPanel: // part of loadDoc()... XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); The mouse methods don't do much: // in the OBeanPanel class public boolean mousePressed ( com . sun . star . awt . MouseEvent e ) { System . out . println ( \"Mouse pressed (\" + e . X + \", \" + e . Y + \")\" ); return false ; // send event on, or use true not to send } public boolean mouseReleased ( com . sun . star . awt . MouseEvent e ) { System . out . println ( \"Mouse released (\" + e . X + \", \" + e . Y + \")\" ); return false ; } Unlike Java listeners, these Office handlers return a boolean to indicate whether the event should be passed on to other listeners; false means the event should be sent on, true causes it to be consumed. The key release handler is similarly short, but the key press handler deals with a keyboard focus bug: // in the OBeanPanel class public boolean keyReleased ( com . sun . star . awt . KeyEvent e ) { return false ; } @SuppressWarnings ( \"deprecation\" ) public boolean keyPressed ( com . sun . star . awt . KeyEvent e ) { if ( oob == null ) return false ; try { oob . releaseSystemWindow (); // force focus away from bean; // must suppress deprecation warning oob . aquireSystemWindow (); // Impress redisplays toolbars; remove them again XLayoutManager lm = GUI . getLayoutManager ( doc ); lm . setVisible ( false ); Lo . dispatchCmd ( \"LeftPaneImpress\" , Props . makeProps ( \"LeftPaneImpress\" , false ) ); // hide slides pane } catch ( java . lang . Exception ex ) {} return false ; } // end of keyPressed() keyPressed() calls OOoBean.releaseSystemWindow() and then OOoBean.aquireSystemWindow() to force the bean to release the keyboard focus; this allows the user to select and type text into other text fields, such as the page jump field in the SwingViewer.java example described below. I found this trick in a forum post by Martin Illguth at https://forum.openoffice.org/en/forum/viewtopic.php?f=20&t=63008 . keyPressed() also deals with a side-effect of displaying Impress slides \u2013 clicking on a slide inside the bean causes hidden toolbars and the slides pane to be made visible. Another call to the layout manager deals with the toolbars, but the slides pane, which isn't a toolbar, is hidden with a \".uno:LeftPaneImpress\" dispatch.","title":"2.  Wrapping OOoBean in a JPanel"},{"location":"44-Office_as_GUI_Comp.html#3-using-the-obeanpanel","text":"Figure 4 shows SwingViewer.java at start-up; the buttons on the right are for quickly moving through a multi-page (or multi-slide) document, and for zooming in and out on a document. The controls at the bottom show the number of pages (or slides) in the document, and allow the user to jump to a specified page/slide number. Figure 5 shows the controls in close-up. Figure 5. The Buttons and Page Controls in SwingViewer. Aside from text documents and slide decks, SwingViewer can load Draw, Calc, and Base files; Figure 6 shows a sample. Figure 6. Different Documents Displayed by SwingViewer. The SwingViewer constructor is passed the document's filename, creates an OBeanPanel in a JFrame with buttons and other controls, and loads the document: // globals private OBeanPanel officePanel ; private XComponent doc = null ; private int docType = Lo . UNKNOWN ; public SwingViewer ( String fnm ) { super ( \"SwingViewer\" ); Container c = getContentPane (); officePanel = new OBeanPanel ( 850 , 600 ); // OOoBean inside a JPanel c . add ( officePanel , BorderLayout . CENTER ); if ( officePanel . getBean () == null ) { System . out . println ( \"OOoBean not created\" ); System . exit ( 1 ); } c . add ( makeButtons (), BorderLayout . EAST ); c . add ( makePageControls (), BorderLayout . SOUTH ); addWindowListener ( new WindowAdapter () { public void windowClosing ( WindowEvent e ){ officePanel . closeDown (); System . exit ( 0 ); } }); pack (); setLocationRelativeTo ( null ); // center the window setResizable ( false ); setVisible ( true ); Lo . delay ( 200 ); // give time for the OOBean to appear doc = officePanel . loadDoc ( fnm ); docType = Info . reportDocType ( doc ); if ( doc == null ) { officePanel . closeDown (); System . exit ( 0 ); } // initialize loaded document if ( docType == Lo . WRITER ) initTextDoc (); else if ( docType == Lo . IMPRESS ) initDrawDoc (); } // end of SwingViewer() OOoBean termination is done by OBeanPanel.closeDown() in a window listener. It calls OOoBean.stopOOoConnection(), but this sometimes hangs, so it also invokes Lo.killOffice(): // in the OBeanPanel class public void closeDown () { if ( oob != null ) { System . out . println ( \"Closing connection to office\" ); oob . stopOOoConnection (); } Lo . delay ( 1000 ); // wait for close down to finish Lo . killOffice (); // make sure office processes are gone } // end of closeDown() The loading of a Writer or Impress document causes several globals to be initialized by initTextDoc() or initDrawDoc(). initTextDoc() stores the page count and creates a visible text cursor for moving through the document's pages: // in the SwingViewer class // globals private int pageCount = - 1 ; private XTextViewCursor tvCursor = null ; // for text docs private void initTextDoc () { // report the number of pages in the doc XTextDocument textDoc = Lo . qi ( XTextDocument . class , doc ); pageCount = Write . getPageCount ( textDoc ); setLastPage ( pageCount ); try { // get the document's visible cursor XController xc = officePanel . getController (); XTextViewCursorSupplier tvcSupplier = Lo . qi ( XTextViewCursorSupplier . class , xc ); tvCursor = tvcSupplier . getViewCursor (); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not access document cursor\" ); } } // end of initTextDoc() initTextDoc() calls setLastPage() to write the pageCount value into the \"Last Page\" field shown in Figure 5. initDrawDoc() also initializes the global pageCount variable, but with the number of slides in the document. However, instead of a text cursor, it create XDrawPages and XDrawView instances for moving through the slides on-screen. // globals private int pageCount = - 1 ; private XDrawView xDrawView = null ; // for slide docs private XDrawPages xDrawPages = null ; private void initDrawDoc () { try { // report the number of slides in the doc xDrawPages = Draw . getSlides ( doc ); pageCount = Draw . getSlidesCount ( doc ); setLastPage ( pageCount ); // get a slide view xDrawView = Lo . qi ( XDrawView . class , officePanel . getController ()); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not access document pages\" ); } } // end of initDrawDoc() The globals are utilized when the user presses one of SwingViewer's button. For example, clicking on the \"Up\" and \"Down\" buttons triggers calls to pageChange(): // part of SwingViewer.makeButtons() : JButton upButton = new JButton ( \"Up\" ); upButton . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ev ) { pageChange ( false ); } // isDown is false, i.e. move up }); JButton downButton = new JButton ( \"Down\" ); downButton . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ev ) { pageChange ( true ); } // isDown is true, i.e. move down }); : pageChange() uses the document's type to decide whether to change pages or slides: public void pageChange ( boolean isDown ) { if ( docType == Lo . WRITER ) textChange ( isDown ); else if ( docType == Lo . IMPRESS ) slideChange ( isDown ); } // end of pageChange() textChange() utilizes the visible text cursor, while slideChange() uses the XDrawPages and XDrawView variables. If the document isn't textual or a slide deck, then pageChange() returns without doing anything.","title":"3.  Using the OBeanPanel"},{"location":"44-Office_as_GUI_Comp.html#4-using-an-undecorated-office-window","text":"As I mentioned at the start, there are two ways of employing Office as a GUI component: one is to use OOoBean inside a JPanel, as just explained. The other is to have the program make Office visible on-screen, which I've done many times in earlier examples. The main difference in my OffViewer.java example is that most of Office's GUI is hidden, so the document appears in an undecorated window. Figure 7 shows the five documents from Figure 6, this time loaded by OffViewer: Figure 7. Different Documents Displayed by OffViewer. There are a few differences between SwingViewer's display and OffViewer. For instance, OffViewer uses some of Office's toolbars and tool panes, depending on the document type. The \"Find\" bar is visible underneath the Writer, Draw, and Impress documents, and the slide pane is present to the left of the current slide. The Draw, Impress, and Calc documents also include a yellow pane along their tops containing a button for enabling editing of the read-only document. I've not been able to find a way to hide that pane. The OffViewer constructor loads Office, loads the document, attaches listeners, and displays some toolbars and panes depending on the document's type: // global private XComponent doc = null ; public OffViewer ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); doc = Lo . openReadOnlyDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } // attach listeners doc . addEventListener ( this ); XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); // give window time to appear XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); // modify UI visibility ArrayList < String > showElems = new ArrayList < String > (); showElems . add ( GUI . FIND_BAR ); showElems . add ( GUI . STATUS_BAR ); GUI . showOnly ( doc , showElems ); // call dispatches *after* the window is visible Lo . dispatchCmd ( \"Sidebar\" , Props . makeProps ( \"Sidebar\" , false )); // hide sidebar // modify UI based on the document type int docType = Info . reportDocType ( doc ); if ( docType == Lo . DRAW ) Lo . dispatchCmd ( \"LeftPaneDraw\" , Props . makeProps ( \"LeftPaneDraw\" , false ) ); // hide Pages pane if ( docType == Lo . IMPRESS ) Lo . dispatchCmd ( \"LeftPaneImpress\" , Props . makeProps ( \"LeftPaneImpress\" , true ) ); // show Slides pane if ( docType == Lo . CALC ) Lo . dispatchCmd ( \"InputLineVisible\" , Props . makeProps ( \"InputLineVisible\" , false ) ); // hide formula bar if ( docType == Lo . BASE ) Lo . dispatchCmd ( \"DBViewTables\" ); // switch to tables view } // end of OffViewer() Several common toolbar resource names are defined as constants in the GUI class: // in the GUI class public static final String MENU_BAR = \"private:resource/menubar/menubar\" ; public static final String STATUS_BAR = \"private:resource/statusbar/statusbar\" ; public static final String FIND_BAR = \"private:resource/toolbar/findbar\" ; public static final String STANDARD_BAR = \"private:resource/toolbar/standardbar\" ; public static final String TOOL_BAR = \"private:resource/toolbar/toolbar\" ; A lengthy list of all the toolbars in LibreOffice is stored in TOOLBAR_NMS[] in GUI.java, and can be accessed by calling GUI.getToobarResource() with a partial string; the first matching toolbar resource name is returned. For example: GUI.getToobarResource(\"zoom\"); returns the string \"private:resource/toolbar/zoombar\". The visibility of Office's toolbars is managed by the LayoutManager service as before, but in a somewhat more complex way because OffViewer can both hide and show toolbars. GUI.showOnly() hides all the toolbars accessible to the layout manager, except for those in its showElems argument. The difficulty is that some of these visible toolbars may not currently exist, and so need to be created and then made visible. GUI.showOnly() is: // in the GUI class public static void showOnly ( XComponent doc , ArrayList < String > showElems ) // leave only the toolbars in showElems visible { XLayoutManager lm = getLayoutManager ( doc ); if ( lm == null ) System . out . println ( \"No layout manager found\" ); else { XUIElement [] uiElems = lm . getElements (); hideExcept ( lm , uiElems , showElems ); for ( String elemName : showElems ) { // these elems are not in lm lm . createElement ( elemName ); // so need to be created & shown lm . showElement ( elemName ); System . out . println ( elemName + \" made visible\" ); } } } // end of showOnly() public static void hideExcept ( XLayoutManager lm , XUIElement [] uiElems , ArrayList < String > showElems ) // hide all of uiElems toolbars, except ones in showElems; // delete any showElems toolbar strings that match { for ( XUIElement uiElem : uiElems ) { String elemName = uiElem . getResourceURL (); boolean toHide = true ; for ( int i = 0 ; i < showElems . size (); i ++ ){ if ( showElems . get ( i ). equals ( elemName )) { showElems . remove ( i ); // this elem is in lm so remove from showElems toHide = false ; // since the toolbar is already shown break ; } } if ( toHide ) { lm . hideElement ( elemName ); System . out . println ( elemName + \" hidden\" ); } } } // end of hideExcept() GUI.showOnly() hides toolbars by calling hideExcept(), which calls XLayoutManager.hideElement() on all the layout manager's toolbars except ones in the showElems list, which are meant to stay visible. If a showElems toolbar is left unhidden then its name is deleted from the list because it's not needed in the next step back in GUI.showOnly() When hideExcept() returns, showOnly() iterates through the remaining toolbars in showElems which are there because they were unknown to the layout manager.Each of these toolbars must be created (with XLayoutManager.createElement()) before being made visible by XLayoutManager.showElement(). In OffViewer, several tool panes, such as the slides pane in Impress, have to be enabled or disabled, but they're not accessible through the layout manager. Instead, I use dispatch commands which only work if the Office window is visible and active. I couldn't find any documentation about dispatch commands for UI panes, but it appears that a pane can be made visible or invisible by including its name as a property with the value true or false. For example: Lo . dispatchCmd ( \"LeftPaneImpress\" , Props . makeProps ( \"LeftPaneImpress\" , true ) ); // show Slides pane This call sends a \".uno:LeftPanelImpress\" dispatch to Office to make the slides pane visible. The easiest way to find dispatch names is to browse through the long list at https://wiki.documentfoundation.org/Development/DispatchCommands/ . It's divided into application and tool subcategories, which narrows the search a little. Also, each entry includes a \"Label value\" field which for UI elements (i.e. toolbars, panes, and menus) corresponds to its name in Office's GUI. Another approach is to search Office's source code \u2013 dispatches are defined inside \".xcu\" files, and the UI related files are mostly in the subdirectory \\officecfg\\registry\\schema\\org\\openoffice\\Office\\UI.","title":"4.  Using an Undecorated Office Window"},{"location":"44-Office_as_GUI_Comp.html#listening-to-user-input-and-the-window","text":"OffViewer implements four listeners for mouse presses, keyboard handling, window changes, and document events: public class OffViewer implements XMouseClickHandler , XKeyHandler , XWindowListener , com . sun . star . document . XEventListener { ... } The listeners are attached in the constructor for OffViewer, which implements all the methods itself: // part of OffViewer()... doc . addEventListener ( this ); XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); XUserInputInterception uii = GUI . getUII ( doc ); uii . addMouseClickHandler ( this ); uii . addKeyHandler ( this ); The event listener's disposing() method is triggered as the document is closed, and uses Lo.killOffice() to terminate Office. As with SwingViewer.java, only calling Lo.closeOffice() is insufficient, causing Office to hang. // in the OffViewer class public void disposing ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Document is closing\" ); if ( doc != null ) Lo . closeDoc ( doc ); // Lo.closeOffice(); // Office hangs, so kill it instead Lo . killOffice (); System . exit ( 0 ); } The window, mouse, and keyboard handlers print simple information: // XWindow listener methods public void windowShown ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Doc window has become visible\" ); } public void windowHidden ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Doc window has been hidden\" ); } public void windowResized ( WindowEvent e ) { System . out . println ( \"Resized to \" + e . Width + \" x \" + e . Height ); } public void windowMoved ( WindowEvent e ) { System . out . println ( \"Moved to (\" + e . X + \", \" + e . Y + \")\" ); } // XMouseClickHandler methods public boolean mousePressed ( MouseEvent e ) { System . out . println ( \"Mouse pressed (\" + e . X + \", \" + e . Y + \")\" ); return false ; // send event on, or use true not to send } public boolean mouseReleased ( MouseEvent e ) { System . out . println ( \"Mouse released (\" + e . X + \", \" + e . Y + \")\" ); return false ; } // XKeyHandler methods public boolean keyPressed ( KeyEvent e ) { System . out . println ( \"Key pressed: \" + e . KeyCode + \"/\" + e . KeyChar ); return true ; } public boolean keyReleased ( KeyEvent e ) { System . out . println ( \"Key released: \" + e . KeyCode + \"/\" + e . KeyChar ); return true ; } The mouse handlers allow their events to be used by other handlers (i.e. they return false), but the keyboard handlers consume their inputs.","title":"Listening to User Input and the Window"},{"location":"44-Office_as_GUI_Comp.html#5-augmenting-the-user-interface-a-new-toolbar-item","text":"TBViewer.java is a variant of OffViewer which adds a toolbar item called \"Hello\" to the \"Find\" toolbar, as shown in Figure 8 on the left. Figure 8. The \"Find\" Toolbar with the \"Hello\" Item. When the user clicks on \"Hello\", ToolbarItemListener is woken up, and its clicked() method called. clicked() displays a message box (see Figure 9). Figure 9. The Message Box that Appears when \"Hello\" is Clicked. This toolbar extension technique is similar to Office's Add-ons, which I'll be discussing in Chapter 46. However, the item isn't permanently added to the toolbar, existing only while TBViewer is executing. The TBViewer constructor: // global private XComponent doc = null ; public TBViewer ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); doc = Lo . openReadOnlyDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); // give window time to appear GUI . showOne ( doc , GUI . FIND_BAR ); Lo . dispatchCmd ( \"Sidebar\" , Props . makeProps ( \"Sidebar\" , false )); // hide sidebar GUI . addItemToToolbar ( doc , GUI . FIND_BAR , \"Hello\" , \"h.png\" ); // add an dispatch interceptor for the \"Hello\" item XDispatchProviderInterception dpi = GUI . getDPI ( doc ); if ( dpi != null ) dpi . registerDispatchProviderInterceptor ( new ItemInterceptor ( this , \"Hello\" )); } // end of TBViewer() GUI . showOne () utilizes GUI . showOnly () to leave only the \"Find\" toolbar visible : // in the GUI class public static void showOne ( XComponent doc , String showElem ) { ArrayList < String > showElems = new ArrayList < String > (); showElems . add ( showElem ); showOnly ( doc , showElems ); } // end of showOne() GUI.addItemToToolbar() creates the toolbar item: GUI.addItemToToolbar(doc, GUI.FIND_BAR, \"Hello\", \"h.png\"); Its arguments are the document, the toolbar's resource name, the item name, and the filename of an image icon. A dispatch interceptor (an ItemInterceptor object) is registered to catch clicks (dispatches) on the \"Hello\" item, and redirect them to TBViewer: XDispatchProviderInterception dpi = GUI . getDPI ( doc ); if ( dpi != null ) dpi . registerDispatchProviderInterceptor ( new ItemInterceptor ( this , \"Hello\" )); ItemInterceptor processes each click by calling ToolbarItemListener.clicked() which is implemented by TBViewer as: // in the TBViewer class public void clicked ( String itemName , URL cmdURL , PropertyValue [] props ) { GUI . showMessageBox ( \"Item Dialog\" , \"Processing the \\\"\" + itemName + \"\\\" command\" ); } // end of clicked()","title":"5.  Augmenting the User Interface: a New Toolbar Item"},{"location":"44-Office_as_GUI_Comp.html#51-intercepting-dispatches","text":"ItemInterceptor implements XDispatchProviderInterceptor and XDispatch so it can both intercept dispatches and process them: public class ItemInterceptor implements XDispatchProviderInterceptor , XDispatch { private XDispatchProvider slaveDP , masterDP ; // pointers to next and previous dispatch providers in list private ToolbarItemListener viewer ; // object sent dispatch info private String itemName ; // toolbar item name private String cmd ; // toolbar item's dispatch command public ItemInterceptor ( ToolbarItemListener v , String itemName ) { viewer = v ; this . itemName = itemName ; cmd = Lo . makeUnoCmd ( itemName ); } // : more XDispatchProviderInterceptor and XDispatch methods; // : see below } // end of ItemInterceptor class The ItemInterceptor() arguments are a reference to ToolbarItemListener (which implements clicked()), and the toolbar item name (\"Hello\") which is converted into a UNO command string by Lo.makeUnoCmd(): // in the Lo class public static String makeUnoCmd ( String itemName ) // use a dummy Java class name, Foo { return \"vnd.sun.star.script:Foo/Foo.\" + itemName + \"?language=Java&location=share\" ; } The returned command string is mostly make-believe \u2013 there's no vnd.sun.star.script:Foo/Foo class, but that doesn't matter so long as the string is unique, and matches the command string in the toolbar item (which is set up by GUI.addItemToToolbar(), as shown below). Office adds the ItemInterceptor object to an interceptors list, which is doubly-linked so that each node points to the previous (master) and next (slave) list element. These are accessible through get/set master/slave methods: // in ItemInterceptor class public void setMasterDispatchProvider ( XDispatchProvider dp ) { masterDP = dp ; } public void setSlaveDispatchProvider ( XDispatchProvider dp ) { slaveDP = dp ; } public XDispatchProvider getMasterDispatchProvider () { return masterDP ; } public XDispatchProvider getSlaveDispatchProvider () { return slaveDP ; } XDispatchProviderInterceptor also requires implementations for queryDispatches() and queryDispatch(). queryDispatches() iterates through the array of dispatch descriptors passed to it, and calls queryDispatch() on each one: // in ItemInterceptor class public XDispatch [] queryDispatches ( DispatchDescriptor [] descrs ) { int count = descrs . length ; XDispatch [] xDispatch = new XDispatch [ count ] ; for ( int i = 0 ; i < count ; i ++ ) xDispatch [ i ] = queryDispatch ( descrs [ i ] . FeatureURL , descrs [ i ] . FrameName , descrs [ i ] . SearchFlags ); return xDispatch ; } // end of queryDispatches() If the dispatch passed to queryDispatch() is recognized by this interceptor then an XDispatch object is returned; otherwise the dispatch is sent to the next interceptor in the list: // in ItemInterceptor class public XDispatch queryDispatch ( URL cmdURL , String target , int srchFlags ) { if ( cmdURL . Complete . equalsIgnoreCase ( cmd )) { System . out . println ( itemName + \" seen\" ); return this ; // this will cause dispatch() to be called } if ( slaveDP != null ) return slaveDP . queryDispatch ( cmdURL , target , srchFlags ); // pass command to next interceptor in list else return null ; } // end of queryDispatch() Office processes the returned XDispatch object by calling its dispatch() method, which is implemented by ItemInterceptor: // in ItemInterceptor class // global private ToolbarItemListener viewer ; // object sent dispatch info public void dispatch ( URL cmdURL , PropertyValue [] props ) { viewer . clicked ( itemName , cmdURL , props ); } Control is passed to the listener's clicked() method, which is in TBViewer. For more information on dispatch interception, see chapter 6 of the Developer's Guide, which is also online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Dispatch_Interception (or use loGuide \"Dispatch Interception\" ).","title":"5.1.  Intercepting Dispatches"},{"location":"44-Office_as_GUI_Comp.html#52-displaying-a-message-box","text":"TBViewer's clicked() creates an Office message dialog (see Figure 10) by calling GUI.showMessageBox(). This dialog requires some complicated coding, and you may wonder why I didn't just use Java's dialogs. For example, as in GUI.showJMessageBox(): // in the GUI class public static void showJMessageBox ( String title , String message ) { JOptionPane . showMessageDialog ( null , message , title , JOptionPane . INFORMATION_MESSAGE ); } I did try this, and it works fine most of the time, but sometimes the dialog appears behind Office's window, and so is hidden from the user. The problem lies with the null first argument of JOptionPane.showMessageDialog() which leaves the dialog's parent window unspecified. An Office message dialog is created in two main steps, as shown in GUI.showMessageBox(): // in the GUI class public static void showMessageBox ( String title , String message ) { XToolkit xToolkit = Lo . createInstanceMCF ( XToolkit . class , \"com.sun.star.awt.Toolkit\" ); XWindow xWindow = getWindow (); if (( xToolkit == null ) || ( xWindow == null )) return ; XWindowPeer xPeer = Lo . qi ( XWindowPeer . class , xWindow ); // initialize window description WindowDescriptor desc = new WindowDescriptor (); desc . Type = WindowClass . MODALTOP ; desc . WindowServiceName = new String ( \"infobox\" ); desc . ParentIndex = - 1 ; desc . Parent = xPeer ; desc . Bounds = new Rectangle ( 0 , 0 , 300 , 200 ); desc . WindowAttributes = WindowAttribute . BORDER | WindowAttribute . MOVEABLE | WindowAttribute . CLOSEABLE ; // create message box using the description XWindowPeer descPeer = xToolkit . createWindow ( desc ); if ( descPeer != null ) { XMessageBox msgBox = Lo . qi ( XMessageBox . class , descPeer ); if ( msgBox != null ) { msgBox . setCaptionText ( title ); msgBox . setMessageText ( message ); msgBox . execute (); // show the box } } } // end of showMessageBox() A WindowDescriptor object is initialized to specify the type of window that will be created, including its parent (the Office window). The descriptor is used to create a XWindowPeer object, which is converted into an XMessageBox.","title":"5.2.  Displaying a Message Box"},{"location":"44-Office_as_GUI_Comp.html#53-adding-hello-to-the-toolbar","text":"GUI.addItemToToolbar() adds the \"Hello\" item to the \"Find\" toolbar: GUI . addItemToToolbar ( doc , GUI . FIND_BAR , \"Hello\" , \"h.png\" ); The code: // in the GUI class public static void addItemToToolbar ( XComponent doc , String toolbarName , String itemName , String imFnm ) { String cmd = Lo . makeUnoCmd ( itemName ); XUIConfigurationManager confMan = GUI . getUIConfigManagerDoc ( doc ); if ( confMan == null ) { System . out . println ( \"Cannot create configuration manager\" ); return ; } try { // add icon for the command XImageManager imageMan = Lo . qi ( XImageManager . class , confMan . getImageManager ()); String [] cmds = { cmd }; XGraphic [] pics = new XGraphic [ 1 ] ; pics [ 0 ] = Images . loadGraphicFile ( imFnm ); imageMan . insertImages (( short ) 0 , cmds , pics ); // add item to toolbar XIndexAccess settings = confMan . getSettings ( toolbarName , true ); XIndexContainer conSettings = Lo . qi ( XIndexContainer . class , settings ); PropertyValue [] itemProps = Props . makeBarItem ( cmd , itemName ); conSettings . insertByIndex ( 0 , itemProps ); // place first in the toolbar confMan . replaceSettings ( toolbarName , conSettings ); } catch ( java . lang . Exception e ) { System . out . println ( e ); } } // end of addItemToToolbar() It accesses the toolbar with XUIConfigurationManager. A toolbar item is created (as an array of properties), and added to the bar at the specified index position. The icon that should be drawn next to \"Hello\" on the toolbar is loaded by XImageManager. As Figure 8 shows, this image doesn't appear, although it has been loaded since it's listed in the \"Visible Buttons\" window in Figure 10. Figure 10. The \"Visible Buttons\" Window for the Toolbar.","title":"5.3.  Adding \"Hello\" to the Toolbar"},{"location":"44-Office_as_GUI_Comp.html#6-augmenting-the-user-interface-a-new-menu-item","text":"MenuViewer.java is a variant of OffViewer which either adds a menu at the end of Office's menubar (see Figure 11a), or creates a new menubar for the menu (see Figure 11b). Figure 11. Adding an Item to a Menubar. The same menu is created in both cases, and is shown in pop-down form in Figure 12. Figure 12. The \"My_menu\" Menu. The menu includes a \"Hello\" item with an icon, \"Quit\" for quitting Office, and some radio button and checkbox items that do nothing. When \"Hello\" is clicked, the same Office message box appears as in Figure 10. The MenuViewer constructor creates a new menubar (see Figure 11b), but contains commented out code for adding the menu to Office's menubar (as in Figure 11a): // in MenuViewer.java // globals private XComponent doc = null ; private short id = 0 ; // used for menu IDs public MenuViewer ( String fnm ) { XComponentLoader loader = Lo . loadOffice (); doc = Lo . openReadOnlyDoc ( fnm , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + fnm ); Lo . closeOffice (); return ; } XWindow win = GUI . getWindow ( doc ); win . addWindowListener ( this ); win . setVisible ( true ); Lo . delay ( 500 ); // wait for window to appear // create new menubar GUI . showNone ( doc ); // hide all toolbars makeMenubar ( win ); /* // or modify the existing menubar GUI.showOne(doc, GUI.MENU_BAR); // hide all toolbars except the menubar setMenubar(doc); */ } // end of MenuViewer() This MenuViewer example is based on one in the \"Creating Menus\" section at the end of chapter 19, \"Graphical user Interfaces\", in the Developer's Guide; it can be found online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/GUI/Creating_Menus/ (or use loGuide \"Creating Menus\" ). The corresponding code is at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#GraphicalUserInterfaces/ , and includes the use of a context menu, which I don't consider here.","title":"6.  Augmenting the User Interface: a New Menu Item"},{"location":"44-Office_as_GUI_Comp.html#61-creating-a-new-menubar","text":"makeMenubar() attaches an XMenubar instance to the Office window using XTopWindow.setMenuBar(): // in MenuViewer.java private void makeMenubar ( XWindow win ) { XTopWindow topWin = Lo . qi ( XTopWindow . class , win ); XMenuBar menubar = Lo . createInstanceMCF ( XMenuBar . class , \"com.sun.star.awt.MenuBar\" ); if ( menubar == null ) System . out . println ( \"Could not create a menu bar\" ); else { addMenu ( menubar , ( short ) 0 ); topWin . setMenuBar ( menubar ); } } // end of makeMenubar() addMenu() labels the menu, which is generated by makePopupMenu(): // in MenuViewer.java // globals private short id = 0 ; // used for menu IDs private void addMenu ( XMenuBar bar , short mPos ) { short menuID = id ; bar . insertItem ( menuID , \"My ~Menu\" , MenuItemStyle . AUTOCHECK , mPos ); id ++ ; bar . setPopupMenu ( menuID , makePopupMenu ()); // add menu to menubar } // end of addMenu() The three important menu interfaces are shown in Figure 13. Figure 13. The Menu Services and Interfaces. Although addMenu() initializes an XMenuBar instance, the interface doesn't contain any methods, inheriting its functionality from XMenu, as indicated in Figure 13. The menu methods, such as XMenu.insertItem() used by addMenu(), can be a little confusing because of their use of shorts in different ways. Every menu and menu item is assigned an ID, which is useful in listener code for identifying which item was clicked. In my code, each menu ID is initialized using a global id variable, which is incremented after each use. Every menu and item also uses a position short value which determines where the menu appears in the bar, and where an item appears in the menu. For example, addMenu() is called by makeMenubar() with a position value set to 0, which will place the menu first on the bar. The third use of short is as MenuItemStyle constants, which specify behavior for menu items acting as check and radio boxes.","title":"6.1.  Creating a New Menubar"},{"location":"44-Office_as_GUI_Comp.html#creating-the-menu","text":"The menu in Figure 12 is created by makePopupMenu(): // in MenuViewer.java // globals private static final String CMD_HELLO = \"Cmd_Hello\" ; private static final String CMD_QUIT = \"Cmd_Quit\" ; private short id = 0 ; // used for menu IDs public XPopupMenu makePopupMenu () /* Popup menu consists of: * Hello + image * three radio buttons (only one on) * a separator * two check boxes * Quit */ { XPopupMenu pum = Lo . createInstanceMCF ( XPopupMenu . class , \"com.sun.star.awt.PopupMenu\" ); if ( pum == null ) { System . out . println ( \"Could not create a menu\" ); return null ; } short mPos = 0 ; pum . insertItem ( id , \"Hello\" , ( short ) 0 , mPos ++ ); // first short is an ID for the new menu item; // the second is the style for the item, 0 means none/ordinary; // the third is the items' position on the menu pum . setItemImage ( id , Images . loadGraphicFile ( \"H.png\" ), false ); pum . setCommand ( id ++ , CMD_HELLO ); pum . insertItem ( id , \"First Radio\" , ( short ) ( MenuItemStyle . RADIOCHECK + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . enableItem ( id ++ , false ); // grayed out pum . insertItem ( id , \"Second Radio\" , ( short ) ( MenuItemStyle . RADIOCHECK + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . checkItem ( id ++ , true ); // selected pum . insertItem ( id ++ , \"Third Radio\" , ( short ) ( MenuItemStyle . RADIOCHECK + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . insertSeparator ( mPos ++ ); pum . insertItem ( id ++ , \"Check 1\" , ( short ) ( MenuItemStyle . CHECKABLE + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . insertItem ( id ++ , \"Check 2\" , ( short ) ( MenuItemStyle . CHECKABLE + MenuItemStyle . AUTOCHECK ), mPos ++ ); pum . insertItem ( id , \"Quit\" , ( short ) 0 , mPos ++ ); pum . setCommand ( id ++ , CMD_QUIT ); pum . addMenuListener ( this ); return pum ; } // end of makePopupMenu() Ordinary menu items (in my case, \"Hello\" and \"Quit\") are assigned a style value of 0. Menu items activation by the user are detected by attaching a listener to the menu. When an item is pressed, an event containing its ID is sent to the listener. Optionally items can be assigned command strings (as for the \"Hello\" and \"Quit\" items) to better distinguish them. MenuViewer.java implements XMenuListener, which requires four methods \u2013 itemSelected(), itemHighlighted(), itemActivated(), and itemDeactivated(). Only itemSelected() does anything of note: // in MenuViewer.java public void itemSelected ( MenuEvent menuEvent ) { short id = menuEvent . MenuId ; XPopupMenu pum = Lo . qi ( XPopupMenu . class , menuEvent . Source ); if ( pum == null ) System . out . println ( \"Menu item \" + id + \" selected; popupmenu is null\" ); else { String itemName = pum . getItemText ( id ); String cmd = pum . getCommand ( id ); System . out . println ( \"Menu item \\\"\" + pum . getItemText ( id ) + \"\\\" selected\" ); System . out . println ( \" is checked? \" + pum . isItemChecked ( id )); processCmd ( cmd ); } } // end of itemSelected() public void itemHighlighted ( MenuEvent menuEvent ) { // System.out.println(menuEvent.MenuId + \" highlighted\"); } public void itemDeactivated ( MenuEvent menuEvent ) { // System.out.println(menuEvent.MenuId + \" deactivated\"); } public void itemActivated ( MenuEvent menuEvent ) { // System.out.println(menuEvent.MenuId + \" activated\"); } Each MenuEvent object includes the menu item ' s ID and a reference to its menu , which are accessed at the start of itemSelected (): short id = menuEvent . MenuId ; XPopupMenu pum = Lo . qi ( XPopupMenu . class , menuEvent . Source ); itemSelected () uses the ID and menu to access details , including the menu item ' s label and command string . Item processing is handled by processCmd (): public void processCmd ( String cmd ) { if (( cmd == null ) || cmd . equals ( \"\" )) { System . out . println ( \" No command\" ); return ; } if ( cmd . equals ( CMD_HELLO )) GUI . showMessageBox ( \"Item Dialog\" , \"Processing the \\\"Hello\\\" command\" ); else if ( cmd . equals ( CMD_QUIT )) { System . out . println ( \" Quiting the Application\" ); if ( doc != null ) Lo . closeDoc ( doc ); // will trigger a call to disposing() } else System . out . println ( \" Got command: \" + cmd ); } // end of processCmd() Clicking on \"Hello\" results in a call to GUI.showMessageBox() which was used earlier in ItemViewer. Clicking on \"Quit\" causes the document to be closed by Lo.closeDoc() which in turn triggers a call to XWindowListener.disposing() which MenuViewer.java also implements: // in MenuViewer.java public void disposing ( com . sun . star . lang . EventObject e ) { System . out . println ( \"Doc window is closing\" ); if ( doc != null ) Lo . closeDoc ( doc ); // Lo.closeOffice(); // Office hangs, so kill it instead Lo . killOffice (); System . exit ( 0 ); }","title":"Creating the Menu"},{"location":"44-Office_as_GUI_Comp.html#62-adding-to-the-existing-menubar","text":"MenuViewer.java can be edited to add the menu to Office's menubar rather than create a new one. The end of the constructor becomes: // end of MenuViewer()... /* // create new menu bar GUI.showNone(doc); makeMenubar(win); */ // or modify the existing menubar GUI . showOne ( doc , GUI . MENU_BAR ); setMenubar ( doc ); setMenuBar() uses the layout manager to obtain a reference to Office's menubar, and calculates a unique ID for the new menu and its position on the bar: // in MenuViewer.java // globals private short id = 0 ; // used for menu IDs private void setMenubar ( XComponent doc ) { XLayoutManager lm = GUI . getLayoutManager ( doc ); XMenuBar menubar = GUI . getMenubar ( lm ); if ( menubar == null ) System . out . println ( \"Menubar not found\" ); else { short menuCount = menubar . getItemCount (); // count along the menu bar to get no. of menus short maxID = GUI . getMenuMaxID ( menubar ); // find the largest menu item ID id = ( short )( maxID + ( short ) 100 ); // hacky /* add a big number to account for the IDs used by menu items in the menu */ addMenu ( menubar , menuCount ); } } // end of setMenubar() The XMenuBar reference is retrieved from a property in the XUIElement for the bar: // in the GUI class //globals public static final String MENU_BAR = \"private:resource/menubar/menubar\" ; public static XMenuBar getMenubar ( XLayoutManager lm ) { if ( lm == null ) { System . out . println ( \"No layout manager available\" ); return null ; } XMenuBar bar = null ; try { XUIElement oMenuBar = lm . getElement ( GUI . MENU_BAR ); XPropertySet props = Lo . qi ( XPropertySet . class , oMenuBar ); bar = Lo . qi ( XMenuBar . class , props . getPropertyValue ( \"XMenuBar\" )); if ( bar == null ) System . out . println ( \"Menubar reference not found\" ); } catch ( Exception e ) { System . out . println ( \"Could not access menubar\" ); } return bar ; } // end of getMenubar() Back in setMenubar(), XMenuBar.getItemCount() returns the number of menus already on the bar, which can be used as the position of the new menu. Deciding on a unique menu ID is a little difficult since the IDs of all the items on the existing menus, including submenus, should be examined. A simpler, and faster, solution is implemented by GUI.getMenuMaxID(), which only finds the largest ID of the menus (items in the menus aren't considered): // in the GUI class public static short getMenuMaxID ( XMenuBar bar ) { if ( bar == null ) return - 1 ; short itemCount = bar . getItemCount (); System . out . println ( \"No items in menu bar: \" + itemCount ); short maxID = - 1 ; for ( short i = 0 ; i < itemCount ; i ++ ) { short id = bar . getItemId ( i ); if ( id > maxID ) maxID = id ; } return maxID ; } // end of getMenuMaxID() The drawback is that the menu with the largest ID will probably contain some items with larger IDs. setMenubar() deals with this by adding 100 to the ID returned by getMenuMaxID(), in the hope that this exceeds the largest item ID. setMenubar() finished with a call to addMenu(), the same function used by makeMenubar() from earlier; it creates the menu and adds it to the bar.","title":"6.2.  Adding to the Existing Menubar"},{"location":"45%20Part%208%20Extending%20LibreOffice.html","text":"Part 8 Extending LibreOffice \u00b6","title":"Part 8 Extending LibreOffice"},{"location":"45%20Part%208%20Extending%20LibreOffice.html#part-8-extending-libreoffice","text":"","title":"Part 8 Extending LibreOffice"},{"location":"45-UNO_Components.html","text":"Chapter 45. Coding UNO Components \u00b6 Topics Using the RandomSents Component; Writing IDL Definitions; Using idlc.bat; Merging Type Data into a Registry Database; Generating the Java Package and Interface; Creating a Skeleton Component; Compiling the Completed Implementation; Packaging the Component; Installing the Extension; Using a New Component in a Program Example folders: \"UNO Comps Tests\" and \"Utils\" In its simplest form, an UNO component consists of a new service and interface that's added to Office as an extension. Subsequently, the service and interface can be used in the same way as other classes in the Office API. This chapter's UNO component example implements a RandomSents service, which generates random sentences and paragraphs, optionally in all-caps. After RandomSents has been added to Office as an extension, my PoemCreator.java employs Office and RandomSents to write poetry into a Word document. UNO components extend the API, but aren't accessible to Office users via its GUI. However, in the next two chapters, I'll look at how to write extended components called add-ons and Calc add-ins. An add-on is accessible through the Office GUI, typically as a new toolbar or menu item. Calc add-ins appear as new functions for cell calculations. Other uses of components include the creation of new Chart types (Chart add-ins), Calc data pilots, database drivers, and filters for the input/output of new kinds of documents. I won\u2019t be looking at those kinds of components. Office's SDK has command line tools for creating a 'skeleton' component containing a service and interface with most of the necessary boilerplate API code. Other tools mostly automate the creation of the component's extension file and its installation into Office. How this set of tools works together to form a code generation \uf0ae compilation \uf0ae installation toolchain is somewhat confusing. Another problem is that some of the tools require changes to Window's PATH environment variable, and files and folders to be in specific locations. My solution to these issues is twelve (12!) batch files, whose names label the arrows in Figure 1. Figure 1. Toolchain for Creating a Component. Figure 1 shows a two-part toolchain, separated by the need for the programmer to finish off the skeleton code for the component's service and interface. The chain begins with the creation of an IDL file which holds a description of the component's types, data attributes, and method signatures. The IDL document is converted into registry database information (an URD file), then merged with other URD files and converted to RDB format (a binary tree data structure). The javamaker tool converts the RDB data into a Java package (i.e. a nested set of folders) containing a \".class\" file for the interface. The class is converted into Java code by the skelComp tool, which also adds boilerplate methods and data needed for the installation and calling of the component's service and interface. The domain-specific methods are left empty, which is where the programmer takes over. The Office SDK also includes a cppmaker tool, a version of the skeleton generator for C++ programmers. It's also possible to code components in Python and Office Basic. Five tools are utilized in the first part of the toolchain: idlc.bat, regmerge.bat, regview.bat, javamaker.bat, and skelComp.bat. The genCode.bat script shown in Figure 1 calls these tools in order. After the programmer has filled in the component's domain-specific methods, the code is compiled with compileOrg.bat, and converted to a JAR file with toJar.bat. An Office extension is stored as an OXT file, which is created by makeOXT.bat, and then installed by pkg.bat. extManager.bat lists Office's installed extensions. The rest of this chapter visits each of these batch scripts as I develop the RandomSents component. Information on Tools, Components, and Extensions \u00b6 Most of my batch files call Office SDK tools. For instance, idlc.bat, regmerge.bat, regview.bat, javamaker.bat, and skelComp.bat utilize Office's idlc.exe, regmerge.exe, regview.exe, javamaker.exe, and uno-skeletonmaker.exe. The best source of information on these SDK tools is at https://api.libreoffice.org/docs/tools.html , which gives a short but useful description of each one. The creation and installation of components is explained at length early in the Developer's Guide, in chapters 3 (\"Writing UNO Components\") and 4 (\"Extensions\"). The guide is available from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf , or the chapters are online starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Writing_UNO_Components/ and https://wiki.openoffice.org/wiki/Documentation/DevGuide/Extensions/Extensions/ (or use loGuide \"Writing UNO Components\" and loGuide Extensions ). The drawback with the guide (both PDF and online) is that the tools available in the current version of Office have changed slightly from when the guide was written in 2009. Two other documents worth studying are \"How to Install Extensions\" (available at https://libreoffice.org/get-help/documentation/ ), and \"Publishing Extensions for LibreOffice\" ( https://wiki.documentfoundation.org/images/1/14/Publishing_extensions.pdf ) which explains how to add an extension to LibreOffice's 'shop window' at https://extensions.libreoffice.org/ . The LibreOffice site concerned with how to code extensions is https://wiki.documentfoundation.org/Development/Extension_Development/ , which points to a large OpenOffice site ( https://wiki.openoffice.org/wiki/Extensions/ ), called the OOo Extension Project. It includes a useful list of pointers to tutorials and articles about building extensions, at https://wiki.openoffice.org/wiki/Extensions_development/ . These websites can be a little overwhelming since an extension can be so many different things: UNO components, add-ons, Calc add-ins, file filters, etc., and be implemented in so many different languages (C++, Java, Python). Since this chapter is only about components, here's a list of component examples I've found useful: The examples from chapter 3 of the Developer's Guide ( https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Component s), including an image reducer component called Thumbs; The \"MinimalComponent\" Java example in the \"UNO Components Examples\" section of https://api.libreoffice.org/examples/examples.html#Java_examples ; The Python love letter writer ( https://github.com/kunaldeo/Py-LibreOffice-Love- Letter-Writer). For those of you less fond of command line tools, there's an Eclipse plugin called LOEclipse for creating Office extensions ( https://marketplace.eclipse.org/content/loeclipse/ ), and an add-on example at https://github.com/smehrbrodt/libreoffice-starter-extension/ 1. Using the RandomSents Component \u00b6 The RandomSents UNO component consists of a single service and interface. The service is employed only to access the XRandomSents interface, which has two methods and an attribute, as depicted in Figure 2. Figure 2. The RandomSents Component's Service and Interface. getParagraph() returns a single string consisting of a specified number of sentences, while getSentences() returns the sentences in an array. The isAllCaps boolean indicates whether the text should be in all-caps. PoemCreator.java uses Office and the RandomSents component (after it's been added to Office) to write a poem into a Word file: // in PoemCreator.java import com.sun.star.uno.* ; // other imports... import org.openoffice.randomsents.XRandomSents ; public class PoemCreator { public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } Info . listExtensions (); GUI . setVisible ( doc , true ); Write . setHeader ( doc , \"Muse of the Office\" ); Write . setA4PageFormat ( doc ); Write . setPageNumbers ( doc ); XRandomSents rs = Lo . createInstanceMCF ( XRandomSents . class , \"org.openoffice.randomsents.RandomSents\" ); String [] sents = rs . getSentences ( 5 ); XTextCursor cursor = Write . getCursor ( doc ); for ( String sent : sents ) Write . appendPara ( cursor , sent + \"\\n\" ); rs . setisAllCaps ( true ); Write . appendPara ( cursor , rs . getParagraph ( 2 ) + \"\\n\" ); Write . appendPara ( cursor , Lo . getTimeStamp ()); Lo . waitEnter (); Lo . saveDoc ( doc , \"poem.doc\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of PoemCreator class The program begins and ends in a familiar way: a Writer document is created and the generated text is saved to \"poem.doc\". The RandomSents service and its interface are created using Lo.createInstanceMCF(): XRandomSents rs = Lo . createInstanceMCF ( XRandomSents . class , \"org.openoffice.randomsents.RandomSents\" ); This requires that the RandomSents component's interface be imported: import org.openoffice.randomsents.XRandomSents ; PoemCreator writes five paragraphs into the document, each one a sentence from the array returned by XRandomSents.getSentences(). After switching to all-caps (using XRandomSents.setisAllCaps()), the last paragraph is made up of two sentences by calling XRandomSents.getParagraph(). Typical output looks like Figure 3. Figure 3. A Generated Poem in poem.doc. Note that the XRandomSents isAllCaps boolean is not accessed directly, but via get/set methods, setisAllCaps() and getisAllCaps(). 2. Writing IDL Definitions \u00b6 The UNO IDL (Interface Definition Language) is used to specify the types, attributes, and methods in the service and interface of the RandomSents component. The RandomSents.idl file contains two definitions: #ifndef _org_openoffice_randomsents_RandomSents_ #define _org_openoffice_randomsents_RandomSents_ #include <com/sun/star/uno/XInterface.idl> module org { module openoffice { module randomsents { interface XRandomSents { [attribute] boolean isAllCaps; string getParagraph([in] long numSents); sequence<string> getSentences([in] long numSents); }; }; }; }; module org { module openoffice { module randomsents { service RandomSents : XRandomSents; }; }; }; #endif Both definitions start with the org.openoffice.randomsents module path. The first is for the XRandomSents interface, the second for the RandomSents service. The IDL lets a module path be almost anything, but my batch scripts assume that it begins with \"org.openoffice\", and the module name (i.e. \"randomsents\") is a lowercase version of the service name (\"RandomSents\"). The tools assume that \"org.openoffice\" corresponds to an existing \"org/\" folder in the current directory, containing an \"openoffice/\" folder. However, the directory for the module (i.e. \"randomsents/\") will be created. The IDL borrows many syntactic features from the COBRA IDL (which gives a fair indication of its age). For example: data fields are distinguished with the phrase \"[attribute]\"; an array is represented as a \"sequence\"; there is no int type, \"long\" is the IDL equivalent; method arguments can be both input (\"[in]\") and output (\"[out]\") or both (\"[inout]\"). The guide warns Java programmers to avoid \"[out]\" and \"[inout]\", which I've done. Much of chapter 3 in the Developer's Guide is concerned with explaining IDL features. An important subsection is \"Using UNOIDL to Specify New Components\", which explains how to define a service and interface; it's online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Using_UNOIDL_to_Specify_New_Components/ , or use loGuide \"Using UNOIDL\" . Details on how IDL types are mapped to Java can be found in chapter 2 of the guide, starting at the \"Type Mapping\" subsection; online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/ProUNO/Java/Type_Mappings/ , or use loGuide \"Type Mappings\" . 3. Using idlc.bat \u00b6 My idlc.bat batch file utilizes idlc.exe, one of Office's SDK tools in \\sdk\\bin. Its main purpose is to generate type data, storing it in an URD file. A little more information can be found at https://api.libreoffice.org/docs/tools.html#idlc . Unfortunately, idlc.exe can only process an IDL file if it's located in \\sdk\\bin\\, probably because its \"-I\" option can't find necessary support files when searching in other folders. Also, the path to \\program must be added to Window's PATH environment variable so idlc.exe can employ DLLs stored there. The URD file is written to \\sdk\\bin\\, which is inconvenient, so idlc.bat moves the IDL and URD files back to the original directory. A typical call to idlc.bat uses the component's service name to identify the IDL file: > idlc.bat RandomSents Output looks something like: Found \"C:\\Program Files\\LibreOffice 5\" Copying RandomSents.idl to \"C:\\Program Files\\LibreOffice 5\"\\sdk\\bin 1 file(s) copied. Compiling RandomSents with idlc... idlc: compiling 1 source files ... Compiling: RandomSents.idl idlc: returned successful idlc Version 1.1 Copying RandomSents.urd to \"C:\\Users\\Dell\\Desktop\\LibreOffice Tests\\Component Tests\\\" 1 file(s) copied. The end result is the creation of a RandomSents.urd file. idlc.bat may fail because of its need to copy files into a folder beneath C:\\Program Files\\, which requires administrative privileges. The easiest workaround is to download the elevate.exe utility from https://code.kliu.org/misc/elevate/ , which starts an administrative console so the necessary privileges are granted. The call to idlc.bat becomes: > elevate.exe -k -w idlc.bat RandomSents 4. Merging Type Data into a Registry Database \u00b6 regmerge.exe has two main roles: the merging of type data from multiple URD files, and the conversion of the URD format into RDB, a binary tree data structure using keys; RDB stands for \"Registry Database\". The regmerge call must include an \"UCR\" argument which is used to label the type descriptions in RDB (UCR stands for \"Uno Core Reflection\"). The resulting RDB file can be printed using regview.exe. My regmerge.bat and regview.bat scripts call the corresponding UNO tools in \\program, and use the component's service name to identify the URD and RDB files. For example: > regmerge.bat RandomSents merging registry \"RandomSents.urd\" under key \"UCR\" in registry \"RandomSents.rdb\". > regview.bat RandomSents Registry \"file:///C:/RandomSents.urd\": / / org / openoffice / randomsents / RandomSents Value: Type = RegValueType::BINARY Size = 158 Data = version: 1 documentation: \"\" file name: \"\" type class: service type name: \"org/openoffice/randomsents/RandomSents\" // many more lines ... The outcome of the regview.bat call is a RandomSents.rdb file, which is displayed by regview.bat. The RDB format was changed in LibreOffice 4.1, but most tools that use RDB can understand both the old and new formats. Unfortunately, regmerge.exe only generates old-style RDB, and regview cannot print the new format. That's means regview is useless for examining important registry databases in \\program, such as types.rdb and services.rdb which use the new format. The API includes a com.sun.star.registry module with an XSimpleRegistry interface for examining registry databases (i.e. RDB files). Unfortunately, it only understands the old RDB format, as illustrated by the inability of my test program, ViewRegistry.java, to display types.rdb or services.rdb (but RandomSents.rdb is readable). 5. Generating the Java Package and Interface \u00b6 javamaker.exe (and cppumaker.exe) map IDL types to Java (and C++) using data from RDB files. RandomSents.rdb cannot be mapped on its own because it refers to types, such as XInterface, which it doesn't define. javamaker also needs Office's types.rdb, located in \\program. javamaker generates two things \u2013 a Java package representing the IDL module structure, and a Java \".class\" file corresponding to the IDL interface. For example, the module structure in RandomSents.idl is: module org { module openoffice { module randomsents javamaker converts this into a Java package made up of three nested folders, as shown in Figure 4. Figure 4. The Java Package for the randomsents Module. Figure 4 shows an XRandomSents.class in the randomsents folder, which holds the compiled Java \".class\" code for the XRandomSents interface. The simplest way to examine this class is to run it through javap: > javap XRandomSents.class public interface org.openoffice.randomsents.XRandomSents extends com.sun.star.uno.XInterface { public static final com.sun.star.lib.uno.typeinfo.TypeInfo[] UNOTYPEINFO; public abstract boolean getisAllCaps(); public abstract void setisAllCaps(boolean); public abstract java.lang.String getParagraph(int); public abstract java.lang.String[] getSentences(int); } I decided to improve on this by using the CFR decompiler library ( https://benf.org/other/cfr/ ) to generate the class' full source code. javamaker.bat calls CFR to generate XRandomSents.java, which is written into the randomsents folder: package org.openoffice.randomsents ; import com.sun.star.lib.uno.typeinfo.AttributeTypeInfo ; import com.sun.star.lib.uno.typeinfo.MethodTypeInfo ; import com.sun.star.lib.uno.typeinfo.TypeInfo ; import com.sun.star.uno.XInterface ; public interface XRandomSents extends XInterface { public static final TypeInfo [] UNOTYPEINFO = new TypeInfo [] { new AttributeTypeInfo ( \"isAllCaps\" , 0 , 0 ), new MethodTypeInfo ( \"getParagraph\" , 2 , 0 ), new MethodTypeInfo ( \"getSentences\" , 3 , 0 )}; public boolean getisAllCaps (); public void setisAllCaps ( boolean var1 ); public String getParagraph ( int var1 ); public String [] getSentences ( int var1 ); } The XRandomSents interface has four methods that need implementing. Note that the isAllCaps IDL attribute has become a get and a set method. javamaker.bat is called in a similar way to the other batch scripts, by supplying the component's service name: > javamaker.bat RandomSents javamaker.bat passes javamaker.exe the package name (org.openoffice.randomsents), RandomSents.rdb, and Office's types.rdb. The script's construction of this package name employs tr.exe, a Windows version of UNIX's tr, which I obtained from the Gow UNIX tools site ( https://github.com/bmatzelle/gow/wiki/ ). 6. Creating a Skeleton Component \u00b6 The implementation of the XRandomSents interface, is greatly simplified by calling uno-skeletonmaker.exe. It generates the boilerplate code relating to how a service and interface are found and initialized at runtime. We'll meet uno-skeletonmaker.exe a few more times in the next two chapters since it can also generate code for add-ons and Calc add-ins. uno-skeletonmaker.exe suffers from the same constraints as idlc.exe \u2013 all its input data must be copied into its local directory ( \\sdk\\bin), and \" \\program\" must be added to Window's PATH environment variable so necessary DLLs can be located. As with idlc.exe, the copying of files into C:\\Program Files requires administrative privileges, which may mean calling the batch file with \"elevate.exe\". uno-skeletonmaker.exe requires a reference to the component's RDB file, Office's types.rdb, and a fully qualified Java interface name (i.e. org.openoffice.randonsents.XRandomSents). The following shows skelComp.bat's output when passed the RandomSents service name: > skelComp RandomSents Copying RandomSents.rdb to \"C:\\Program Files\\LibreOffice 5\"\\sdk\\bin 1 file(s) copied. Copying Java classes in org/ to \"C:\\Program Files\\LibreOffice 5\"\\sdk\\bin 2 File(s) copied Generating RandomSentsImpl.java Copying RandomSentsImpl.java 1 file(s) copied. Deleting copied RDB, org package, and original RandomSentsImpl.java **TIME** for you to complete RandomSentsImpl.java The skeleton Java implementation is called RandomSentsImpl.java, and its class structure is shown in Figure 5. Figure 5. Class Diagram for RandomSentsImpl.java RandomSentsImpl extends WeakBase, the base class for UNO components. It's part of the com.sun.star.lib.uno package which is documented separately from Office modules such as Writer, Calc, and Impress. Both documentation trees can be accessed from the LibreOffice API documentation page at https://api.libreoffice.org/ . The XServiceInfo interface contains three methods for retrieving the component's implementation name (i.e. \"RandomSentsImpl\") and supported services (i.e. \"org.openoffice.randomsents.RandomSents\"). These methods were generated by uno- skeletonmaker, and added to RandomSentsImpl .java. The __getComponentFactory() method in RandomSentsImpl is used by Office's service manager to create a RandomSents service and interface. __writeRegisryServiceInfo() is used by the service manager to register the component in Office at runtime. The remaining four methods in RandomSentsImpl are stubs for the functions defined in XRandomSents; our job is to implement them: // part of RandomSentsImpl.java... public boolean getisAllCaps () { return false ; } public void setisAllCaps ( boolean the_value ) { } public java / lang / String getParagraph ( int numSents ) { return new java / lang / String (); } public java / lang / String [] getSentences ( int numSents ) { return new java / lang / String [ 0 ] ; } Any Java classes employed in the stubs are fully qualified, and written using \"/\"s rather than \".\"s. This can be seen in RandomSentsImpl 's getParagraph() and getSentences(). 7. Compiling the Completed Implementation \u00b6 The completed RandomSentsImpl class is based on a Processing example at https://funprogramming.org/57-A-random-sentence-generator-writes-nonsense.html . I used that program's grammar and arrays of articles, adjectives, nouns, prepositions, and verbs. The arrays are defined at the start of the completed RandomSentsImpl.java: // globals in RandomSentsImpl.java private static final int MAX_SENTENCES = 100 ; private static String [] articles = { \"the\" , \"my\" , \"your\" , ... }; private static String [] adjs = { \"happy\" , \"rotating\" , \"red\" , ... }; private static String [] nouns = { \"forest\" , \"tree\" , \"flower\" , ... }; private static String [] preps = { \"under\" , \"in front of\" , ... }; private static String [] verbs = { \"sings\" , \"dances\" , ... }; There's a private variable to hold the current all-caps setting: private boolean isAllCaps = false ; This variable makes the all-caps get and set methods trivial: public boolean getisAllCaps () { return isAllCaps ; } public void setisAllCaps ( boolean b ) { isAllCaps = b ; } getParagraph() calls getSentences() and then converts its sentences array into a single string: public String getParagraph ( int numSents ) { String [] sents = getSentences ( numSents ); StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < sents . length ; i ++ ) sb . append ( sents [ i ] ); return sb . toString (); } // end of getParagraph() getSentences() implements the sentence grammar: < article > < adjective > < noun > < verb > < preposition > < article > < adjective > < noun > A sentence is generated by randomly selecting a word from each syntactic category, represented by the word arrays at the top of the program. getSentences() uses a loop to repeat this task until enough sentences have been created: public String [] getSentences ( int numSents ) { if ( numSents < 1 ) numSents = 1 ; else if ( numSents > MAX_SENTENCES ) numSents = MAX_SENTENCES ; String [] sents = new String [ numSents ] ; StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < numSents ; i ++ ) { sb . setLength ( 0 ); // empty builder sb . append ( capitalize ( pickWord ( articles )) + \" \" ); sb . append ( pickWord ( adjs ) + \" \" ); sb . append ( pickWord ( nouns ) + \" \" ); sb . append ( pickWord ( verbs ) + \" \" ); sb . append ( pickWord ( preps ) + \" \" ); sb . append ( pickWord ( articles ) + \" \" ); sb . append ( pickWord ( adjs ) + \" \" ); sb . append ( pickWord ( nouns ) + \". \" ); sents [ i ] = isAllCaps ? sb . toString (). toUpperCase () : sb . toString (); } return sents ; } // end of getSentences() private String pickWord ( String [] words ) { return words [ ( int )( Math . random () * words . length ) ] ; } private String capitalize ( String word ) { return word . substring ( 0 , 1 ). toUpperCase () + word . substring ( 1 ); } The compilation of RandomSentsImpl.java requires that the Office SDK and the org.openoffice.randomsents package be added to javac's classpath. This is managed by compileOrg.bat which takes the service name and filename as inputs: > compileOrg.bat RandomSents RandomSentsImpl.java 8. Packaging the Component \u00b6 The Java code for the component is zipped twice, once to form a JAR, and then to create an Office OXT (extension) file. toJar.bat starts by compiling the Java code (using compileOrg.bat), then constructs the JAR file from a manifest and the org.openoffice package. The RandomSents manifest is a one-liner, stored in ManifestRandomSents.txt: RegistrationClassName: RandomSentsImpl toJar.bat is called using the component's service name: > toJar.bat RandomSents Compiling RandomSentsImpl.java with LibreOffice SDK, JNA, Utils, and RandomSents service... Generating RandomSentsImpl.jar added manifest adding: RandomSentsImpl.class(in = 7092) (out= 3944)(deflated 44%) adding: RandomSentsImpl.java(in = 6803) (out= 2484)(deflated 63%) adding: org/(in = 0) (out= 0)(stored 0%) adding: org/openoffice/(in = 0) (out= 0)(stored 0%) adding: org/openoffice/randomsents/(in = 0) (out= 0)(stored 0%) adding: org/openoffice/randomsents/XRandomSents.class(in = 745) (out= 450)(deflated 39%) adding: org/openoffice/randomsents/XRandomSents.java(in = 901) (out= 353)(deflated 60%) The resulting JAR is called RandomSentsImpl.jar. An OXT extension file is a zipped folder which contains a manifest.xml file in a META-INF folder, a description of the extension in description.xml, the component's RDB file, and its code (a JAR file in my case). makeOXT.bat looks for a pre-existing folder with the same name as the component's service. It should already contain a manifest and description, but makeOXT.bat adds the RDB and JAR files itself. The required RandomSents folder is shown in Figure 6. Figure 6. The RandomSents Folder used by makeOXT.bat. The manifest.xml file inside META-INF consists of two attributes which give the names for RandomSents' RDB and JAR files: <manifest:manifest> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.uno-typelibrary;type=RDB\" manifest:full-path=\"RandomSents.rdb\" /> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.uno-component;type=Java\" manifest:full-path=\"RandomSentsImpl.jar\" /> </manifest:manifest> Only these names need to be changed when using this manifest for a different extension. description.xml can be fairly minimal or relatively fancy, as in my example: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <description xmlns=\"https://openoffice.org/extensions/description/2006\" xmlns:d=\"https://openoffice.org/extensions/description/2006\" xmlns:xlink=\"https://w3.org/1999/xlink\"> <identifier value=\"org.openoffice.randomsents\"/> <version value=\"0.1\"/> <display-name> <name lang=\"en\">Random Sentences</name> </display-name> <publisher> <name xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\" lang=\"en\">Andrew Davison</name> </publisher> <registration> <simple-license accept-by=\"user\" > <license-text xlink:href=\"license.txt\" lang=\"en\"/> </simple-license> </registration> <extension-description> <src lang=\"en\" xlink:href=\"package-description.txt\"/> </extension-description> <icon> <default xlink:href=\"stack.png\" /> </icon> <update-information> <src xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\"/> </update-information> <dependencies> <OpenOffice.org-minimal-version value=\"3.4\" d:name=\"OpenOffice.org 3.4\"/> </dependencies> <platform value=\"all\" /> </description> There are ten fields inside the tag: identifier: the fully qualified module name (this field is mandatory); version number (also mandatory); display-name: a short piece of text which will act as a title; publisher: this field can include a URL which can be clicked on inside the Extension manager (see Figure 8 below); registration: license text which is displayed when the component is first installed, and the user must accept or reject. Figure 6 shows the \"license.txt\" file (an MIT license) in the OXT folder. If software licenses are a mystery to you (as they were to me), a good site for helping you choose one is https://choosealicense.com/ ; extension-description: a one or two line description of the component, which may be stored in a separate file, as I've done. Figure 6 shows the \"package- description.txt\" file in the OXT folder; icon: the filename of a small image (42 x 42 pixels, PNG or JPG) which appears next to the component information in the Extensions manager (see Figure 8 below). Figure 6 shows the \"stack.png\" file in the OXT folder; update-information: a URL link to an update page; dependencies: the minimal version of Office that supports the component. I've referred to OpenOffice in this tag, which is also understood to mean LibreOffice. OpenOffice 3.4 corresponds to versions of LibreOffice up to 4.1.3, and OpenOffice 4.1 matches LibreOffice 4.2.4. Since LibreOffice 3.5, you can use the tag name \"LibreOffice-minimal-version\"; platform: a list of OSes that support the component; usually assigned \"all\" or left out (which means the same thing). A more specific example is <platform value = \"windows_x86, linux_x86, linux_x86_64, macosx_x86, macosx_x86_64, macosx_powerpc\" />. As far as I know there's no label for Windows 64 bit. The best place for more information on these fields is chapter 4 of the Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Extensions/Extensions/ , or use loGuide Extensions . Chapter 4 talks about several configuration topics I won't be covering, including update support, the options dialog, and help content. The makeOXT.bat script is called using the component's service name: > makeOxt.bat RandomSents Copying RandomSents.rdb to RandomSents\\ 1 file(s) copied. Copying RandomSentsImpl.jar to RandomSents\\ 1 file(s) copied. Zipping RandomSents\\ as RandomSents.oxt adding: description.xml (152 bytes security) (deflated 58%) adding: license.txt (152 bytes security) (deflated 41%) adding: META-INF/ (152 bytes security) (stored 0%) adding: META-INF/manifest.xml (152 bytes security) (deflated 53%) adding: package-description.txt (152 bytes security) (deflated 4%) adding: RandomSents.rdb (152 bytes security) (deflated 90%) adding: RandomSentsImpl.jar (152 bytes security) (deflated 9%) adding: stack.png (152 bytes security) (stored 0%) The previously created RDB and JAR files are copied into the RandomSents folder in Figure 6, and the folder is zipped up as RandomSents.oxt. The zipping is carried out by a Windows version of the UNIX zip tool downloaded from the Gow site ( https://github.com/bmatzelle/gow/wiki/ ). 9. Installing the Extension \u00b6 The Extension Manager can be started independently of Office by calling the unopkg tool in \\program with a \"gui\" argument; my extManager.bat script does this for you, resulting in a window something like Figure 7. Figure 7. Office's Extension Manager. My pkg.bat script utilizes unopkg.exe to remove any currently installed version of the extension before installing the one stored in the OXT file. The manager window is displayed at the end, to visually confirm that the extension has been loaded. A typical call: > pkg.bat RandomSents Attempting to remove old version of RandomSents.oxt with unopkg... ERROR: There is no such extension deployed: org.openoffice.randomsents unopkg failed. Installing RandomSents.oxt with unopkg... Extension Software License Agreement of Random Sentences: MIT License Copyright (c) 2016 Andrew Davison Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Read the complete License Agreement displayed above. Accept the License Agreement by typing \"yes\" on the console then press the Return key. Type \"no\" to decline and to abort the extension setup. [Enter \"yes\" or \"no\"]:yes unopkg done. The installation prints the license text, followed by a prompt to enter \"yes\" or \"no\"; I typed \"yes\" so the installation could progress. Figure 8 shows the Extension Manager after a successful installation of RandomSents. I've added labels to show which description.xml fields are used in the display. Figure 8. The Extension Manager with RandomSents Installed. 10. Using a New Component in a Program \u00b6 The PoemCreator.java example at the start of the chapter skipped over two important problems: how the program is compiled against a new UNO Component (e.g. RandomSent), and how the component is used at runtime. Almost every one of my Java examples from previous chapters have been compiled against the Office API located below the directory. My compile.bat script contains something like: javac - cp \"%LO%\\program\\classes\\*;.\" %* The LO variable is assigned the path to Office by code earlier in the script, and then javac looks in \\program\\classes for the JAR files that make up the API. This approach will not work when looking for the JAR that implements a new UNO component (e.g. RandomSentsImpl.jar in RandomSent.oxt). Extensions aren't stored with the API JARs, but usually in a folder below C:\\Users\\ \\AppData\\Roaming\\LibreOffice. I say \"usually\" because the location depends on the license details in the OXT description. The relevant field for RandomSent is: // part of description.xml : <registration> <simple-license accept-by=\"user\" > <license-text xlink:href=\"license.txt\" lang=\"en\"/> </simple-license> </registration> : The license will be accepted by a \"user\", which causes the extension to be installed in that user's AppData\\Roaming\\LibreOffice folder. Another licensing possibility is \"admin\", which makes the extension available to everyone using Office on this machine. These are called shared mode extensions, and stored in \\share\\extensions. In short then, how can javac.exe (and java.exe) find the JAR file for a new component when it comes time to compile (and run) a program such as PoemCreator.java? The Office API offers a PackageInformationProvider service which can access information about installed extensions. My Info.listExtensions() utilizes PackageInformationProvider to print extension details. It's called at the start of PoemCreator.java before the poetry is generated: // in PoemCreator.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } Info . listExtensions (); GUI . setVisible ( doc , true ); Write . setHeader ( doc , \"Muse of the Office\" ); : // make poetry } The ID, version, and installation location are printed for each extension: Extensions: 1. ID: org.openoffice.en.hunspell.dictionaries Version: 2011.12.05.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/dict-en 2. ID: French.linguistic.resources.from.Dicollecte.by.OlivierR Version: 5.4.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/dict-fr 3. ID: org.openoffice.languagetool.oxt Version: 3.4 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/uno_packages/cache/uno_packages/ lu4156ef34f.tmp_/LanguageTool-3.4.oxt 4. ID: org.openoffice.randomsents Version: 0.1 Loc: file:///C:/Users/Ad/AppData/Roaming/LibreOffice/4/user/ uno_packages/cache/uno_packages/ lu29529rfgd.tmp_/RandomSents.oxt 5. ID: com.sun.star.comp.Calc.NLPSolver Version: 0.9 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/nlpsolver 6. ID: spanish.es_ANY.dicts.from.rla-es Version: 0.8 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/dict-es 7. ID: com.sun.wiki-publisher Version: 1.2.0 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/wiki-publisher The list shows that Office's dictionaries and Calc NLPSolver are shared extensions, but RandomSents (no. 4) is for user \"Ad\" only. Info.listExtensions() obtains an instance of the XPackageInformationProvider interface, then calls XPackageInformationProvider.getExtensionList() to get IDs. An extension's location is obtained by calling XPackageInformationProvider.getPackageLocation() with its ID. The listExtensions() code: // in the Info class public static void listExtensions () { XPackageInformationProvider pip = getPip (); if ( pip == null ) System . out . println ( \"No package info provider found\" ); else { String [][] extsTable = pip . getExtensionList (); System . out . println ( \"\\nExtensions:\" ); String serviceName ; for ( int i = 0 ; i < extsTable . length ; i ++ ) { System . out . println (( i + 1 ) + \". ID: \" + extsTable [ i ][ 0 ] ); System . out . println ( \" Version: \" + extsTable [ i ][ 1 ] ); System . out . println ( \" Loc: \" + pip . getPackageLocation ( extsTable [ i ][ 0 ] )); System . out . println (); } } } // end of listExtensions() public static XPackageInformationProvider getPip () { return PackageInformationProvider . get ( Lo . getContext ()); } 10.1. Finding an Extension's JAR File \u00b6 FindExtJar.java is passed an extension's fully qualified module name (e.g. \"org.openoffice.randomsents\"), and uses it to find the extension's installation folder. The folder is searched for a JAR filename, and the first match is stored in \"lofindTemp.txt\". The main() function of FindExtJar.java: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run FindExtJar <ID>\" ); return ; } Lo . loadOffice (); FileIO . saveString ( \"lofindTemp.txt\" , \"\\\"xx\\\"\" ); String extDir = Info . getExtensionLoc ( args [ 0 ] ); if (( extDir == null ) || extDir . equals ( \"\" )) { System . out . println ( \"Could not find extension: \" + args [ 0 ] ); Lo . closeOffice (); return ; } // look in folder for JAR filename try { FilenameFilter filter = new FilenameFilter () { public boolean accept ( File dir , String name ) { return name . endsWith ( \".jar\" ); } }; File dir = new File ( new URI ( extDir )); String [] fnms = dir . list ( filter ); if ( fnms == null ) System . out . println ( \"No jars found\" ); else { String extPath = dir . getAbsolutePath (); String jarNm = \"\\\"\" + extPath + \"/\" + fnms [ 0 ] + \"\\\"\" ; FileIO . saveString ( \"lofindTemp.txt\" , jarNm ); } } catch ( java . lang . Exception e ) { System . out . println ( e ); } Lo . closeOffice (); } // end of main() Info.getExtensionLoc() calls XPackageInformationProvider.getPackageLocation(): // in the Info class public static String getExtensionLoc ( String id ) { XPackageInformationProvider pip = getPip (); if ( pip == null ) { System . out . println ( \"No package info provider found\" ); return null ; } else return pip . getPackageLocation ( id ); } // end of getExtensionLoc() Back in the main() function, the directory is searched for a \".jar\" file using a FileFilter object. Several things may go wrong (e.g. the module name may be wrong, or the extension might not contain a JAR file), so \"xx\" is written to \"lofindTemp.txt\" initially, to act as an error string. 10.2. Using an Extension's JAR in Batch Scripts \u00b6 With the help of FindExtJar.java, it's possible to write batch scripts that compile and run a program using an extension's JAR. Both compileExt.bat and runExt.bat are similar, so I'll only outline how compileExt.bat works. The script is called with two arguments: the extension's service name, and the Java file that needs compiling. For example: > compileExt.bat RandomSents PoemCreator.java Found \"C:\\Program Files\\LibreOffice 5\" Executing FindExtJar org.openoffice.randomsents with LibreOffice SDK, JNA, and Utils... Loading Office... Saved string to file: lofindTemp.txt Closing Office Office terminated Using RandomSents JAR: C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user\\uno_packages\\cache\\uno _packages\\lu29529rfgd.tmp_\\RandomSents.oxt/RandomSentsImpl.jar Compiling PoemCreator.java with LibreOffice SDK, JNA, Utils, and RandomSents... The output shows that Office is invoked, which happens when FindExtJar is called. The script reads in the contents of \"lofindTemp.txt\", and adds the JAR's path to javac.exe's classpath. The compileExt.bat script is: @echo off setlocal IF [%1] == [] ( echo No service name or Java file supplied EXIT /B ) IF [%2] == [] ( echo No service name or Java file supplied EXIT /B ) call lofind.bat set /p LOQ=<lofindTemp.txt SET LO=%LOQ:\"=% echo %1| tr \"[A-Z]\" \"[a-z]\" > tempComp.txt set /p PACK_NM=<tempComp.txt del tempComp.txt call run FindExtJar org.openoffice.%PACK_NM% set /p JARQ=<lofindTemp.txt IF %JARQ%==\"xx\" ( echo No JAR found EXIT /B ) SET JAR=%JARQ:\"=% echo. echo Using %1 JAR: %JAR% echo Compiling %2 with LibreOffice SDK, JNA, Utils, and %1... javac -cp \"%LO%\\program\\classes\\*;%LO%\\URE\\java\\*; ..\\Utils;D:\\jna\\jna-4.1.0.jar; D:\\jna\\jna-platform-4.1.0.jar;%JAR%;.\" %2 The path to the extension's JAR file is stored in the JAR variable. The main drawback of this approach is the need to fire up Office, albeit briefly. Office can take a while to load, especially the first time, but is fast subsequently.","title":"Chapter 45. Coding UNO Components"},{"location":"45-UNO_Components.html#chapter-45-coding-uno-components","text":"Topics Using the RandomSents Component; Writing IDL Definitions; Using idlc.bat; Merging Type Data into a Registry Database; Generating the Java Package and Interface; Creating a Skeleton Component; Compiling the Completed Implementation; Packaging the Component; Installing the Extension; Using a New Component in a Program Example folders: \"UNO Comps Tests\" and \"Utils\" In its simplest form, an UNO component consists of a new service and interface that's added to Office as an extension. Subsequently, the service and interface can be used in the same way as other classes in the Office API. This chapter's UNO component example implements a RandomSents service, which generates random sentences and paragraphs, optionally in all-caps. After RandomSents has been added to Office as an extension, my PoemCreator.java employs Office and RandomSents to write poetry into a Word document. UNO components extend the API, but aren't accessible to Office users via its GUI. However, in the next two chapters, I'll look at how to write extended components called add-ons and Calc add-ins. An add-on is accessible through the Office GUI, typically as a new toolbar or menu item. Calc add-ins appear as new functions for cell calculations. Other uses of components include the creation of new Chart types (Chart add-ins), Calc data pilots, database drivers, and filters for the input/output of new kinds of documents. I won\u2019t be looking at those kinds of components. Office's SDK has command line tools for creating a 'skeleton' component containing a service and interface with most of the necessary boilerplate API code. Other tools mostly automate the creation of the component's extension file and its installation into Office. How this set of tools works together to form a code generation \uf0ae compilation \uf0ae installation toolchain is somewhat confusing. Another problem is that some of the tools require changes to Window's PATH environment variable, and files and folders to be in specific locations. My solution to these issues is twelve (12!) batch files, whose names label the arrows in Figure 1. Figure 1. Toolchain for Creating a Component. Figure 1 shows a two-part toolchain, separated by the need for the programmer to finish off the skeleton code for the component's service and interface. The chain begins with the creation of an IDL file which holds a description of the component's types, data attributes, and method signatures. The IDL document is converted into registry database information (an URD file), then merged with other URD files and converted to RDB format (a binary tree data structure). The javamaker tool converts the RDB data into a Java package (i.e. a nested set of folders) containing a \".class\" file for the interface. The class is converted into Java code by the skelComp tool, which also adds boilerplate methods and data needed for the installation and calling of the component's service and interface. The domain-specific methods are left empty, which is where the programmer takes over. The Office SDK also includes a cppmaker tool, a version of the skeleton generator for C++ programmers. It's also possible to code components in Python and Office Basic. Five tools are utilized in the first part of the toolchain: idlc.bat, regmerge.bat, regview.bat, javamaker.bat, and skelComp.bat. The genCode.bat script shown in Figure 1 calls these tools in order. After the programmer has filled in the component's domain-specific methods, the code is compiled with compileOrg.bat, and converted to a JAR file with toJar.bat. An Office extension is stored as an OXT file, which is created by makeOXT.bat, and then installed by pkg.bat. extManager.bat lists Office's installed extensions. The rest of this chapter visits each of these batch scripts as I develop the RandomSents component.","title":"Chapter 45. Coding UNO Components"},{"location":"45-UNO_Components.html#information-on-tools-components-and-extensions","text":"Most of my batch files call Office SDK tools. For instance, idlc.bat, regmerge.bat, regview.bat, javamaker.bat, and skelComp.bat utilize Office's idlc.exe, regmerge.exe, regview.exe, javamaker.exe, and uno-skeletonmaker.exe. The best source of information on these SDK tools is at https://api.libreoffice.org/docs/tools.html , which gives a short but useful description of each one. The creation and installation of components is explained at length early in the Developer's Guide, in chapters 3 (\"Writing UNO Components\") and 4 (\"Extensions\"). The guide is available from https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf , or the chapters are online starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Writing_UNO_Components/ and https://wiki.openoffice.org/wiki/Documentation/DevGuide/Extensions/Extensions/ (or use loGuide \"Writing UNO Components\" and loGuide Extensions ). The drawback with the guide (both PDF and online) is that the tools available in the current version of Office have changed slightly from when the guide was written in 2009. Two other documents worth studying are \"How to Install Extensions\" (available at https://libreoffice.org/get-help/documentation/ ), and \"Publishing Extensions for LibreOffice\" ( https://wiki.documentfoundation.org/images/1/14/Publishing_extensions.pdf ) which explains how to add an extension to LibreOffice's 'shop window' at https://extensions.libreoffice.org/ . The LibreOffice site concerned with how to code extensions is https://wiki.documentfoundation.org/Development/Extension_Development/ , which points to a large OpenOffice site ( https://wiki.openoffice.org/wiki/Extensions/ ), called the OOo Extension Project. It includes a useful list of pointers to tutorials and articles about building extensions, at https://wiki.openoffice.org/wiki/Extensions_development/ . These websites can be a little overwhelming since an extension can be so many different things: UNO components, add-ons, Calc add-ins, file filters, etc., and be implemented in so many different languages (C++, Java, Python). Since this chapter is only about components, here's a list of component examples I've found useful: The examples from chapter 3 of the Developer's Guide ( https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Component s), including an image reducer component called Thumbs; The \"MinimalComponent\" Java example in the \"UNO Components Examples\" section of https://api.libreoffice.org/examples/examples.html#Java_examples ; The Python love letter writer ( https://github.com/kunaldeo/Py-LibreOffice-Love- Letter-Writer). For those of you less fond of command line tools, there's an Eclipse plugin called LOEclipse for creating Office extensions ( https://marketplace.eclipse.org/content/loeclipse/ ), and an add-on example at https://github.com/smehrbrodt/libreoffice-starter-extension/","title":"Information on Tools, Components, and Extensions"},{"location":"45-UNO_Components.html#1-using-the-randomsents-component","text":"The RandomSents UNO component consists of a single service and interface. The service is employed only to access the XRandomSents interface, which has two methods and an attribute, as depicted in Figure 2. Figure 2. The RandomSents Component's Service and Interface. getParagraph() returns a single string consisting of a specified number of sentences, while getSentences() returns the sentences in an array. The isAllCaps boolean indicates whether the text should be in all-caps. PoemCreator.java uses Office and the RandomSents component (after it's been added to Office) to write a poem into a Word file: // in PoemCreator.java import com.sun.star.uno.* ; // other imports... import org.openoffice.randomsents.XRandomSents ; public class PoemCreator { public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } Info . listExtensions (); GUI . setVisible ( doc , true ); Write . setHeader ( doc , \"Muse of the Office\" ); Write . setA4PageFormat ( doc ); Write . setPageNumbers ( doc ); XRandomSents rs = Lo . createInstanceMCF ( XRandomSents . class , \"org.openoffice.randomsents.RandomSents\" ); String [] sents = rs . getSentences ( 5 ); XTextCursor cursor = Write . getCursor ( doc ); for ( String sent : sents ) Write . appendPara ( cursor , sent + \"\\n\" ); rs . setisAllCaps ( true ); Write . appendPara ( cursor , rs . getParagraph ( 2 ) + \"\\n\" ); Write . appendPara ( cursor , Lo . getTimeStamp ()); Lo . waitEnter (); Lo . saveDoc ( doc , \"poem.doc\" ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of PoemCreator class The program begins and ends in a familiar way: a Writer document is created and the generated text is saved to \"poem.doc\". The RandomSents service and its interface are created using Lo.createInstanceMCF(): XRandomSents rs = Lo . createInstanceMCF ( XRandomSents . class , \"org.openoffice.randomsents.RandomSents\" ); This requires that the RandomSents component's interface be imported: import org.openoffice.randomsents.XRandomSents ; PoemCreator writes five paragraphs into the document, each one a sentence from the array returned by XRandomSents.getSentences(). After switching to all-caps (using XRandomSents.setisAllCaps()), the last paragraph is made up of two sentences by calling XRandomSents.getParagraph(). Typical output looks like Figure 3. Figure 3. A Generated Poem in poem.doc. Note that the XRandomSents isAllCaps boolean is not accessed directly, but via get/set methods, setisAllCaps() and getisAllCaps().","title":"1.  Using the RandomSents Component"},{"location":"45-UNO_Components.html#2-writing-idl-definitions","text":"The UNO IDL (Interface Definition Language) is used to specify the types, attributes, and methods in the service and interface of the RandomSents component. The RandomSents.idl file contains two definitions: #ifndef _org_openoffice_randomsents_RandomSents_ #define _org_openoffice_randomsents_RandomSents_ #include <com/sun/star/uno/XInterface.idl> module org { module openoffice { module randomsents { interface XRandomSents { [attribute] boolean isAllCaps; string getParagraph([in] long numSents); sequence<string> getSentences([in] long numSents); }; }; }; }; module org { module openoffice { module randomsents { service RandomSents : XRandomSents; }; }; }; #endif Both definitions start with the org.openoffice.randomsents module path. The first is for the XRandomSents interface, the second for the RandomSents service. The IDL lets a module path be almost anything, but my batch scripts assume that it begins with \"org.openoffice\", and the module name (i.e. \"randomsents\") is a lowercase version of the service name (\"RandomSents\"). The tools assume that \"org.openoffice\" corresponds to an existing \"org/\" folder in the current directory, containing an \"openoffice/\" folder. However, the directory for the module (i.e. \"randomsents/\") will be created. The IDL borrows many syntactic features from the COBRA IDL (which gives a fair indication of its age). For example: data fields are distinguished with the phrase \"[attribute]\"; an array is represented as a \"sequence\"; there is no int type, \"long\" is the IDL equivalent; method arguments can be both input (\"[in]\") and output (\"[out]\") or both (\"[inout]\"). The guide warns Java programmers to avoid \"[out]\" and \"[inout]\", which I've done. Much of chapter 3 in the Developer's Guide is concerned with explaining IDL features. An important subsection is \"Using UNOIDL to Specify New Components\", which explains how to define a service and interface; it's online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Using_UNOIDL_to_Specify_New_Components/ , or use loGuide \"Using UNOIDL\" . Details on how IDL types are mapped to Java can be found in chapter 2 of the guide, starting at the \"Type Mapping\" subsection; online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/ProUNO/Java/Type_Mappings/ , or use loGuide \"Type Mappings\" .","title":"2.  Writing IDL Definitions"},{"location":"45-UNO_Components.html#3-using-idlcbat","text":"My idlc.bat batch file utilizes idlc.exe, one of Office's SDK tools in \\sdk\\bin. Its main purpose is to generate type data, storing it in an URD file. A little more information can be found at https://api.libreoffice.org/docs/tools.html#idlc . Unfortunately, idlc.exe can only process an IDL file if it's located in \\sdk\\bin\\, probably because its \"-I\" option can't find necessary support files when searching in other folders. Also, the path to \\program must be added to Window's PATH environment variable so idlc.exe can employ DLLs stored there. The URD file is written to \\sdk\\bin\\, which is inconvenient, so idlc.bat moves the IDL and URD files back to the original directory. A typical call to idlc.bat uses the component's service name to identify the IDL file: > idlc.bat RandomSents Output looks something like: Found \"C:\\Program Files\\LibreOffice 5\" Copying RandomSents.idl to \"C:\\Program Files\\LibreOffice 5\"\\sdk\\bin 1 file(s) copied. Compiling RandomSents with idlc... idlc: compiling 1 source files ... Compiling: RandomSents.idl idlc: returned successful idlc Version 1.1 Copying RandomSents.urd to \"C:\\Users\\Dell\\Desktop\\LibreOffice Tests\\Component Tests\\\" 1 file(s) copied. The end result is the creation of a RandomSents.urd file. idlc.bat may fail because of its need to copy files into a folder beneath C:\\Program Files\\, which requires administrative privileges. The easiest workaround is to download the elevate.exe utility from https://code.kliu.org/misc/elevate/ , which starts an administrative console so the necessary privileges are granted. The call to idlc.bat becomes: > elevate.exe -k -w idlc.bat RandomSents","title":"3.  Using idlc.bat"},{"location":"45-UNO_Components.html#4-merging-type-data-into-a-registry-database","text":"regmerge.exe has two main roles: the merging of type data from multiple URD files, and the conversion of the URD format into RDB, a binary tree data structure using keys; RDB stands for \"Registry Database\". The regmerge call must include an \"UCR\" argument which is used to label the type descriptions in RDB (UCR stands for \"Uno Core Reflection\"). The resulting RDB file can be printed using regview.exe. My regmerge.bat and regview.bat scripts call the corresponding UNO tools in \\program, and use the component's service name to identify the URD and RDB files. For example: > regmerge.bat RandomSents merging registry \"RandomSents.urd\" under key \"UCR\" in registry \"RandomSents.rdb\". > regview.bat RandomSents Registry \"file:///C:/RandomSents.urd\": / / org / openoffice / randomsents / RandomSents Value: Type = RegValueType::BINARY Size = 158 Data = version: 1 documentation: \"\" file name: \"\" type class: service type name: \"org/openoffice/randomsents/RandomSents\" // many more lines ... The outcome of the regview.bat call is a RandomSents.rdb file, which is displayed by regview.bat. The RDB format was changed in LibreOffice 4.1, but most tools that use RDB can understand both the old and new formats. Unfortunately, regmerge.exe only generates old-style RDB, and regview cannot print the new format. That's means regview is useless for examining important registry databases in \\program, such as types.rdb and services.rdb which use the new format. The API includes a com.sun.star.registry module with an XSimpleRegistry interface for examining registry databases (i.e. RDB files). Unfortunately, it only understands the old RDB format, as illustrated by the inability of my test program, ViewRegistry.java, to display types.rdb or services.rdb (but RandomSents.rdb is readable).","title":"4.  Merging Type Data into a Registry Database"},{"location":"45-UNO_Components.html#5-generating-the-java-package-and-interface","text":"javamaker.exe (and cppumaker.exe) map IDL types to Java (and C++) using data from RDB files. RandomSents.rdb cannot be mapped on its own because it refers to types, such as XInterface, which it doesn't define. javamaker also needs Office's types.rdb, located in \\program. javamaker generates two things \u2013 a Java package representing the IDL module structure, and a Java \".class\" file corresponding to the IDL interface. For example, the module structure in RandomSents.idl is: module org { module openoffice { module randomsents javamaker converts this into a Java package made up of three nested folders, as shown in Figure 4. Figure 4. The Java Package for the randomsents Module. Figure 4 shows an XRandomSents.class in the randomsents folder, which holds the compiled Java \".class\" code for the XRandomSents interface. The simplest way to examine this class is to run it through javap: > javap XRandomSents.class public interface org.openoffice.randomsents.XRandomSents extends com.sun.star.uno.XInterface { public static final com.sun.star.lib.uno.typeinfo.TypeInfo[] UNOTYPEINFO; public abstract boolean getisAllCaps(); public abstract void setisAllCaps(boolean); public abstract java.lang.String getParagraph(int); public abstract java.lang.String[] getSentences(int); } I decided to improve on this by using the CFR decompiler library ( https://benf.org/other/cfr/ ) to generate the class' full source code. javamaker.bat calls CFR to generate XRandomSents.java, which is written into the randomsents folder: package org.openoffice.randomsents ; import com.sun.star.lib.uno.typeinfo.AttributeTypeInfo ; import com.sun.star.lib.uno.typeinfo.MethodTypeInfo ; import com.sun.star.lib.uno.typeinfo.TypeInfo ; import com.sun.star.uno.XInterface ; public interface XRandomSents extends XInterface { public static final TypeInfo [] UNOTYPEINFO = new TypeInfo [] { new AttributeTypeInfo ( \"isAllCaps\" , 0 , 0 ), new MethodTypeInfo ( \"getParagraph\" , 2 , 0 ), new MethodTypeInfo ( \"getSentences\" , 3 , 0 )}; public boolean getisAllCaps (); public void setisAllCaps ( boolean var1 ); public String getParagraph ( int var1 ); public String [] getSentences ( int var1 ); } The XRandomSents interface has four methods that need implementing. Note that the isAllCaps IDL attribute has become a get and a set method. javamaker.bat is called in a similar way to the other batch scripts, by supplying the component's service name: > javamaker.bat RandomSents javamaker.bat passes javamaker.exe the package name (org.openoffice.randomsents), RandomSents.rdb, and Office's types.rdb. The script's construction of this package name employs tr.exe, a Windows version of UNIX's tr, which I obtained from the Gow UNIX tools site ( https://github.com/bmatzelle/gow/wiki/ ).","title":"5.  Generating the Java Package and Interface"},{"location":"45-UNO_Components.html#6-creating-a-skeleton-component","text":"The implementation of the XRandomSents interface, is greatly simplified by calling uno-skeletonmaker.exe. It generates the boilerplate code relating to how a service and interface are found and initialized at runtime. We'll meet uno-skeletonmaker.exe a few more times in the next two chapters since it can also generate code for add-ons and Calc add-ins. uno-skeletonmaker.exe suffers from the same constraints as idlc.exe \u2013 all its input data must be copied into its local directory ( \\sdk\\bin), and \" \\program\" must be added to Window's PATH environment variable so necessary DLLs can be located. As with idlc.exe, the copying of files into C:\\Program Files requires administrative privileges, which may mean calling the batch file with \"elevate.exe\". uno-skeletonmaker.exe requires a reference to the component's RDB file, Office's types.rdb, and a fully qualified Java interface name (i.e. org.openoffice.randonsents.XRandomSents). The following shows skelComp.bat's output when passed the RandomSents service name: > skelComp RandomSents Copying RandomSents.rdb to \"C:\\Program Files\\LibreOffice 5\"\\sdk\\bin 1 file(s) copied. Copying Java classes in org/ to \"C:\\Program Files\\LibreOffice 5\"\\sdk\\bin 2 File(s) copied Generating RandomSentsImpl.java Copying RandomSentsImpl.java 1 file(s) copied. Deleting copied RDB, org package, and original RandomSentsImpl.java **TIME** for you to complete RandomSentsImpl.java The skeleton Java implementation is called RandomSentsImpl.java, and its class structure is shown in Figure 5. Figure 5. Class Diagram for RandomSentsImpl.java RandomSentsImpl extends WeakBase, the base class for UNO components. It's part of the com.sun.star.lib.uno package which is documented separately from Office modules such as Writer, Calc, and Impress. Both documentation trees can be accessed from the LibreOffice API documentation page at https://api.libreoffice.org/ . The XServiceInfo interface contains three methods for retrieving the component's implementation name (i.e. \"RandomSentsImpl\") and supported services (i.e. \"org.openoffice.randomsents.RandomSents\"). These methods were generated by uno- skeletonmaker, and added to RandomSentsImpl .java. The __getComponentFactory() method in RandomSentsImpl is used by Office's service manager to create a RandomSents service and interface. __writeRegisryServiceInfo() is used by the service manager to register the component in Office at runtime. The remaining four methods in RandomSentsImpl are stubs for the functions defined in XRandomSents; our job is to implement them: // part of RandomSentsImpl.java... public boolean getisAllCaps () { return false ; } public void setisAllCaps ( boolean the_value ) { } public java / lang / String getParagraph ( int numSents ) { return new java / lang / String (); } public java / lang / String [] getSentences ( int numSents ) { return new java / lang / String [ 0 ] ; } Any Java classes employed in the stubs are fully qualified, and written using \"/\"s rather than \".\"s. This can be seen in RandomSentsImpl 's getParagraph() and getSentences().","title":"6.  Creating a Skeleton Component"},{"location":"45-UNO_Components.html#7-compiling-the-completed-implementation","text":"The completed RandomSentsImpl class is based on a Processing example at https://funprogramming.org/57-A-random-sentence-generator-writes-nonsense.html . I used that program's grammar and arrays of articles, adjectives, nouns, prepositions, and verbs. The arrays are defined at the start of the completed RandomSentsImpl.java: // globals in RandomSentsImpl.java private static final int MAX_SENTENCES = 100 ; private static String [] articles = { \"the\" , \"my\" , \"your\" , ... }; private static String [] adjs = { \"happy\" , \"rotating\" , \"red\" , ... }; private static String [] nouns = { \"forest\" , \"tree\" , \"flower\" , ... }; private static String [] preps = { \"under\" , \"in front of\" , ... }; private static String [] verbs = { \"sings\" , \"dances\" , ... }; There's a private variable to hold the current all-caps setting: private boolean isAllCaps = false ; This variable makes the all-caps get and set methods trivial: public boolean getisAllCaps () { return isAllCaps ; } public void setisAllCaps ( boolean b ) { isAllCaps = b ; } getParagraph() calls getSentences() and then converts its sentences array into a single string: public String getParagraph ( int numSents ) { String [] sents = getSentences ( numSents ); StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < sents . length ; i ++ ) sb . append ( sents [ i ] ); return sb . toString (); } // end of getParagraph() getSentences() implements the sentence grammar: < article > < adjective > < noun > < verb > < preposition > < article > < adjective > < noun > A sentence is generated by randomly selecting a word from each syntactic category, represented by the word arrays at the top of the program. getSentences() uses a loop to repeat this task until enough sentences have been created: public String [] getSentences ( int numSents ) { if ( numSents < 1 ) numSents = 1 ; else if ( numSents > MAX_SENTENCES ) numSents = MAX_SENTENCES ; String [] sents = new String [ numSents ] ; StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < numSents ; i ++ ) { sb . setLength ( 0 ); // empty builder sb . append ( capitalize ( pickWord ( articles )) + \" \" ); sb . append ( pickWord ( adjs ) + \" \" ); sb . append ( pickWord ( nouns ) + \" \" ); sb . append ( pickWord ( verbs ) + \" \" ); sb . append ( pickWord ( preps ) + \" \" ); sb . append ( pickWord ( articles ) + \" \" ); sb . append ( pickWord ( adjs ) + \" \" ); sb . append ( pickWord ( nouns ) + \". \" ); sents [ i ] = isAllCaps ? sb . toString (). toUpperCase () : sb . toString (); } return sents ; } // end of getSentences() private String pickWord ( String [] words ) { return words [ ( int )( Math . random () * words . length ) ] ; } private String capitalize ( String word ) { return word . substring ( 0 , 1 ). toUpperCase () + word . substring ( 1 ); } The compilation of RandomSentsImpl.java requires that the Office SDK and the org.openoffice.randomsents package be added to javac's classpath. This is managed by compileOrg.bat which takes the service name and filename as inputs: > compileOrg.bat RandomSents RandomSentsImpl.java","title":"7.  Compiling the Completed Implementation"},{"location":"45-UNO_Components.html#8-packaging-the-component","text":"The Java code for the component is zipped twice, once to form a JAR, and then to create an Office OXT (extension) file. toJar.bat starts by compiling the Java code (using compileOrg.bat), then constructs the JAR file from a manifest and the org.openoffice package. The RandomSents manifest is a one-liner, stored in ManifestRandomSents.txt: RegistrationClassName: RandomSentsImpl toJar.bat is called using the component's service name: > toJar.bat RandomSents Compiling RandomSentsImpl.java with LibreOffice SDK, JNA, Utils, and RandomSents service... Generating RandomSentsImpl.jar added manifest adding: RandomSentsImpl.class(in = 7092) (out= 3944)(deflated 44%) adding: RandomSentsImpl.java(in = 6803) (out= 2484)(deflated 63%) adding: org/(in = 0) (out= 0)(stored 0%) adding: org/openoffice/(in = 0) (out= 0)(stored 0%) adding: org/openoffice/randomsents/(in = 0) (out= 0)(stored 0%) adding: org/openoffice/randomsents/XRandomSents.class(in = 745) (out= 450)(deflated 39%) adding: org/openoffice/randomsents/XRandomSents.java(in = 901) (out= 353)(deflated 60%) The resulting JAR is called RandomSentsImpl.jar. An OXT extension file is a zipped folder which contains a manifest.xml file in a META-INF folder, a description of the extension in description.xml, the component's RDB file, and its code (a JAR file in my case). makeOXT.bat looks for a pre-existing folder with the same name as the component's service. It should already contain a manifest and description, but makeOXT.bat adds the RDB and JAR files itself. The required RandomSents folder is shown in Figure 6. Figure 6. The RandomSents Folder used by makeOXT.bat. The manifest.xml file inside META-INF consists of two attributes which give the names for RandomSents' RDB and JAR files: <manifest:manifest> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.uno-typelibrary;type=RDB\" manifest:full-path=\"RandomSents.rdb\" /> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.uno-component;type=Java\" manifest:full-path=\"RandomSentsImpl.jar\" /> </manifest:manifest> Only these names need to be changed when using this manifest for a different extension. description.xml can be fairly minimal or relatively fancy, as in my example: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <description xmlns=\"https://openoffice.org/extensions/description/2006\" xmlns:d=\"https://openoffice.org/extensions/description/2006\" xmlns:xlink=\"https://w3.org/1999/xlink\"> <identifier value=\"org.openoffice.randomsents\"/> <version value=\"0.1\"/> <display-name> <name lang=\"en\">Random Sentences</name> </display-name> <publisher> <name xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\" lang=\"en\">Andrew Davison</name> </publisher> <registration> <simple-license accept-by=\"user\" > <license-text xlink:href=\"license.txt\" lang=\"en\"/> </simple-license> </registration> <extension-description> <src lang=\"en\" xlink:href=\"package-description.txt\"/> </extension-description> <icon> <default xlink:href=\"stack.png\" /> </icon> <update-information> <src xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\"/> </update-information> <dependencies> <OpenOffice.org-minimal-version value=\"3.4\" d:name=\"OpenOffice.org 3.4\"/> </dependencies> <platform value=\"all\" /> </description> There are ten fields inside the tag: identifier: the fully qualified module name (this field is mandatory); version number (also mandatory); display-name: a short piece of text which will act as a title; publisher: this field can include a URL which can be clicked on inside the Extension manager (see Figure 8 below); registration: license text which is displayed when the component is first installed, and the user must accept or reject. Figure 6 shows the \"license.txt\" file (an MIT license) in the OXT folder. If software licenses are a mystery to you (as they were to me), a good site for helping you choose one is https://choosealicense.com/ ; extension-description: a one or two line description of the component, which may be stored in a separate file, as I've done. Figure 6 shows the \"package- description.txt\" file in the OXT folder; icon: the filename of a small image (42 x 42 pixels, PNG or JPG) which appears next to the component information in the Extensions manager (see Figure 8 below). Figure 6 shows the \"stack.png\" file in the OXT folder; update-information: a URL link to an update page; dependencies: the minimal version of Office that supports the component. I've referred to OpenOffice in this tag, which is also understood to mean LibreOffice. OpenOffice 3.4 corresponds to versions of LibreOffice up to 4.1.3, and OpenOffice 4.1 matches LibreOffice 4.2.4. Since LibreOffice 3.5, you can use the tag name \"LibreOffice-minimal-version\"; platform: a list of OSes that support the component; usually assigned \"all\" or left out (which means the same thing). A more specific example is <platform value = \"windows_x86, linux_x86, linux_x86_64, macosx_x86, macosx_x86_64, macosx_powerpc\" />. As far as I know there's no label for Windows 64 bit. The best place for more information on these fields is chapter 4 of the Developer's Guide at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Extensions/Extensions/ , or use loGuide Extensions . Chapter 4 talks about several configuration topics I won't be covering, including update support, the options dialog, and help content. The makeOXT.bat script is called using the component's service name: > makeOxt.bat RandomSents Copying RandomSents.rdb to RandomSents\\ 1 file(s) copied. Copying RandomSentsImpl.jar to RandomSents\\ 1 file(s) copied. Zipping RandomSents\\ as RandomSents.oxt adding: description.xml (152 bytes security) (deflated 58%) adding: license.txt (152 bytes security) (deflated 41%) adding: META-INF/ (152 bytes security) (stored 0%) adding: META-INF/manifest.xml (152 bytes security) (deflated 53%) adding: package-description.txt (152 bytes security) (deflated 4%) adding: RandomSents.rdb (152 bytes security) (deflated 90%) adding: RandomSentsImpl.jar (152 bytes security) (deflated 9%) adding: stack.png (152 bytes security) (stored 0%) The previously created RDB and JAR files are copied into the RandomSents folder in Figure 6, and the folder is zipped up as RandomSents.oxt. The zipping is carried out by a Windows version of the UNIX zip tool downloaded from the Gow site ( https://github.com/bmatzelle/gow/wiki/ ).","title":"8.  Packaging the Component"},{"location":"45-UNO_Components.html#9-installing-the-extension","text":"The Extension Manager can be started independently of Office by calling the unopkg tool in \\program with a \"gui\" argument; my extManager.bat script does this for you, resulting in a window something like Figure 7. Figure 7. Office's Extension Manager. My pkg.bat script utilizes unopkg.exe to remove any currently installed version of the extension before installing the one stored in the OXT file. The manager window is displayed at the end, to visually confirm that the extension has been loaded. A typical call: > pkg.bat RandomSents Attempting to remove old version of RandomSents.oxt with unopkg... ERROR: There is no such extension deployed: org.openoffice.randomsents unopkg failed. Installing RandomSents.oxt with unopkg... Extension Software License Agreement of Random Sentences: MIT License Copyright (c) 2016 Andrew Davison Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Read the complete License Agreement displayed above. Accept the License Agreement by typing \"yes\" on the console then press the Return key. Type \"no\" to decline and to abort the extension setup. [Enter \"yes\" or \"no\"]:yes unopkg done. The installation prints the license text, followed by a prompt to enter \"yes\" or \"no\"; I typed \"yes\" so the installation could progress. Figure 8 shows the Extension Manager after a successful installation of RandomSents. I've added labels to show which description.xml fields are used in the display. Figure 8. The Extension Manager with RandomSents Installed.","title":"9.  Installing the Extension"},{"location":"45-UNO_Components.html#10-using-a-new-component-in-a-program","text":"The PoemCreator.java example at the start of the chapter skipped over two important problems: how the program is compiled against a new UNO Component (e.g. RandomSent), and how the component is used at runtime. Almost every one of my Java examples from previous chapters have been compiled against the Office API located below the directory. My compile.bat script contains something like: javac - cp \"%LO%\\program\\classes\\*;.\" %* The LO variable is assigned the path to Office by code earlier in the script, and then javac looks in \\program\\classes for the JAR files that make up the API. This approach will not work when looking for the JAR that implements a new UNO component (e.g. RandomSentsImpl.jar in RandomSent.oxt). Extensions aren't stored with the API JARs, but usually in a folder below C:\\Users\\ \\AppData\\Roaming\\LibreOffice. I say \"usually\" because the location depends on the license details in the OXT description. The relevant field for RandomSent is: // part of description.xml : <registration> <simple-license accept-by=\"user\" > <license-text xlink:href=\"license.txt\" lang=\"en\"/> </simple-license> </registration> : The license will be accepted by a \"user\", which causes the extension to be installed in that user's AppData\\Roaming\\LibreOffice folder. Another licensing possibility is \"admin\", which makes the extension available to everyone using Office on this machine. These are called shared mode extensions, and stored in \\share\\extensions. In short then, how can javac.exe (and java.exe) find the JAR file for a new component when it comes time to compile (and run) a program such as PoemCreator.java? The Office API offers a PackageInformationProvider service which can access information about installed extensions. My Info.listExtensions() utilizes PackageInformationProvider to print extension details. It's called at the start of PoemCreator.java before the poetry is generated: // in PoemCreator.java public static void main ( String args [] ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } Info . listExtensions (); GUI . setVisible ( doc , true ); Write . setHeader ( doc , \"Muse of the Office\" ); : // make poetry } The ID, version, and installation location are printed for each extension: Extensions: 1. ID: org.openoffice.en.hunspell.dictionaries Version: 2011.12.05.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/dict-en 2. ID: French.linguistic.resources.from.Dicollecte.by.OlivierR Version: 5.4.1 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/dict-fr 3. ID: org.openoffice.languagetool.oxt Version: 3.4 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/uno_packages/cache/uno_packages/ lu4156ef34f.tmp_/LanguageTool-3.4.oxt 4. ID: org.openoffice.randomsents Version: 0.1 Loc: file:///C:/Users/Ad/AppData/Roaming/LibreOffice/4/user/ uno_packages/cache/uno_packages/ lu29529rfgd.tmp_/RandomSents.oxt 5. ID: com.sun.star.comp.Calc.NLPSolver Version: 0.9 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/nlpsolver 6. ID: spanish.es_ANY.dicts.from.rla-es Version: 0.8 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/dict-es 7. ID: com.sun.wiki-publisher Version: 1.2.0 Loc: file:///C:/Program%20Files/LibreOffice%205/program/../ share/extensions/wiki-publisher The list shows that Office's dictionaries and Calc NLPSolver are shared extensions, but RandomSents (no. 4) is for user \"Ad\" only. Info.listExtensions() obtains an instance of the XPackageInformationProvider interface, then calls XPackageInformationProvider.getExtensionList() to get IDs. An extension's location is obtained by calling XPackageInformationProvider.getPackageLocation() with its ID. The listExtensions() code: // in the Info class public static void listExtensions () { XPackageInformationProvider pip = getPip (); if ( pip == null ) System . out . println ( \"No package info provider found\" ); else { String [][] extsTable = pip . getExtensionList (); System . out . println ( \"\\nExtensions:\" ); String serviceName ; for ( int i = 0 ; i < extsTable . length ; i ++ ) { System . out . println (( i + 1 ) + \". ID: \" + extsTable [ i ][ 0 ] ); System . out . println ( \" Version: \" + extsTable [ i ][ 1 ] ); System . out . println ( \" Loc: \" + pip . getPackageLocation ( extsTable [ i ][ 0 ] )); System . out . println (); } } } // end of listExtensions() public static XPackageInformationProvider getPip () { return PackageInformationProvider . get ( Lo . getContext ()); }","title":"10. Using a New Component in a Program"},{"location":"45-UNO_Components.html#101-finding-an-extensions-jar-file","text":"FindExtJar.java is passed an extension's fully qualified module name (e.g. \"org.openoffice.randomsents\"), and uses it to find the extension's installation folder. The folder is searched for a JAR filename, and the first match is stored in \"lofindTemp.txt\". The main() function of FindExtJar.java: public static void main ( String args [] ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run FindExtJar <ID>\" ); return ; } Lo . loadOffice (); FileIO . saveString ( \"lofindTemp.txt\" , \"\\\"xx\\\"\" ); String extDir = Info . getExtensionLoc ( args [ 0 ] ); if (( extDir == null ) || extDir . equals ( \"\" )) { System . out . println ( \"Could not find extension: \" + args [ 0 ] ); Lo . closeOffice (); return ; } // look in folder for JAR filename try { FilenameFilter filter = new FilenameFilter () { public boolean accept ( File dir , String name ) { return name . endsWith ( \".jar\" ); } }; File dir = new File ( new URI ( extDir )); String [] fnms = dir . list ( filter ); if ( fnms == null ) System . out . println ( \"No jars found\" ); else { String extPath = dir . getAbsolutePath (); String jarNm = \"\\\"\" + extPath + \"/\" + fnms [ 0 ] + \"\\\"\" ; FileIO . saveString ( \"lofindTemp.txt\" , jarNm ); } } catch ( java . lang . Exception e ) { System . out . println ( e ); } Lo . closeOffice (); } // end of main() Info.getExtensionLoc() calls XPackageInformationProvider.getPackageLocation(): // in the Info class public static String getExtensionLoc ( String id ) { XPackageInformationProvider pip = getPip (); if ( pip == null ) { System . out . println ( \"No package info provider found\" ); return null ; } else return pip . getPackageLocation ( id ); } // end of getExtensionLoc() Back in the main() function, the directory is searched for a \".jar\" file using a FileFilter object. Several things may go wrong (e.g. the module name may be wrong, or the extension might not contain a JAR file), so \"xx\" is written to \"lofindTemp.txt\" initially, to act as an error string.","title":"10.1. Finding an Extension's JAR File"},{"location":"45-UNO_Components.html#102-using-an-extensions-jar-in-batch-scripts","text":"With the help of FindExtJar.java, it's possible to write batch scripts that compile and run a program using an extension's JAR. Both compileExt.bat and runExt.bat are similar, so I'll only outline how compileExt.bat works. The script is called with two arguments: the extension's service name, and the Java file that needs compiling. For example: > compileExt.bat RandomSents PoemCreator.java Found \"C:\\Program Files\\LibreOffice 5\" Executing FindExtJar org.openoffice.randomsents with LibreOffice SDK, JNA, and Utils... Loading Office... Saved string to file: lofindTemp.txt Closing Office Office terminated Using RandomSents JAR: C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user\\uno_packages\\cache\\uno _packages\\lu29529rfgd.tmp_\\RandomSents.oxt/RandomSentsImpl.jar Compiling PoemCreator.java with LibreOffice SDK, JNA, Utils, and RandomSents... The output shows that Office is invoked, which happens when FindExtJar is called. The script reads in the contents of \"lofindTemp.txt\", and adds the JAR's path to javac.exe's classpath. The compileExt.bat script is: @echo off setlocal IF [%1] == [] ( echo No service name or Java file supplied EXIT /B ) IF [%2] == [] ( echo No service name or Java file supplied EXIT /B ) call lofind.bat set /p LOQ=<lofindTemp.txt SET LO=%LOQ:\"=% echo %1| tr \"[A-Z]\" \"[a-z]\" > tempComp.txt set /p PACK_NM=<tempComp.txt del tempComp.txt call run FindExtJar org.openoffice.%PACK_NM% set /p JARQ=<lofindTemp.txt IF %JARQ%==\"xx\" ( echo No JAR found EXIT /B ) SET JAR=%JARQ:\"=% echo. echo Using %1 JAR: %JAR% echo Compiling %2 with LibreOffice SDK, JNA, Utils, and %1... javac -cp \"%LO%\\program\\classes\\*;%LO%\\URE\\java\\*; ..\\Utils;D:\\jna\\jna-4.1.0.jar; D:\\jna\\jna-platform-4.1.0.jar;%JAR%;.\" %2 The path to the extension's JAR file is stored in the JAR variable. The main drawback of this approach is the need to fire up Office, albeit briefly. Office can take a while to load, especially the first time, but is fast subsequently.","title":"10.2. Using  an Extension's JAR in Batch Scripts"},{"location":"46-Addons.html","text":"Chapter 46. Add-ons \u00b6 Topics What is an Add- on?; Creating the EzHighlight Add-on; Creating a Partial Add- on Implementation; The FreeMarker-generated EzHighlightAddonImpl; Creating the Dialog; Configuring the Add-on; Building and Installing the OXT File Example folders: \"AddOn Tests\", \"Utils\" Add-ons build upon the UNO component techniques described in the last chapter to make a component accessible via an Office menu and/or toolbar item. I'll implement the EzHighlight add-on, which allows word occurrences to be highlighted in a Writer document. EzHighlight is installed in Office as an extension in the same way as an UNO component, and is listed by the Extension Manger in Figure 1. Figure 1. The EzHighlight Add-on Extension. When the Writer application is running, EzHighlight is accessible either through Office's Tools, Add-Ons menu item (see Figure 2) or as a toolbar created by View, Toolbars, Add-on 2 (see Figure 3). This 'floating' toolbar can be attached to an existing toolbar. Figure 2. The EzHighlight Add-on on the Tools Menu. Figure 3. The EzHighlighter Add-on as a Toolbar. When the user clicks on \"EzHighlight Text\", either through the menu or toolbar, the dialog shown in Figure 4 appears. Figure 4. The EzHighlighter Dialog. The user enters a word, and either types or presses the \"Highlight\" button. Every matching word in the currently loaded Writer document is redrawn in red, and the number of changes reported in the \"Count:\" field. EzHighlight also has basic help support, accessible from Office's Help menu as the \"About EzHighlight\" item (see Figure 5). Figure 5. The EzHighlight Help Menu Item. Clicking on the help item causes a simple message box to appear, as in Figure 6. Figure 6. The EzHighlight Help Message Box. 1. What is an Add-on? \u00b6 Office supports two kinds of add-on: job add-ons and ProtocolHandler add-ons. A job add-on is a component triggered by events inside Office, such as when the application is first opened or about to terminate, or when a document is loaded, printed, or closed. This chapter is about Protocol handler add-ons, which link menu and/or toolbar items to a component using Office's dispatch framework. Every GUI element is assigned a 'command URL', a unique name made of two or three parts: <protocol string>:<command string>[?<command string argument>+ ] A protocol string can be almost anything, and I'll be using the extension's ID (\"org.openoffice.ezhighlightAddon\"). There is a different command string for each GUI-triggered action, and I'll utilize two: \"EzHighlight\" and \"help\". \"EzHighlight\" is associated with the EzHighlight menu and toolbar items (Figures 2 and 3), and makes the dialog in Figure 4 appear. \"help\" is assigned to the \"About EzHighlight\" help menu item, and causes the message box in Figure 6 to be displayed. I won't be using command string arguments. When a user chooses an item in the user interface, its command URL is passed along a list of dispatch handlers until one accepts the command and processes it by creating a dispatch object. Fortunately, most of the dispatch handling behavior in an add-on can be generated automatically. The main source of information for job and ProtocolHandler add-ons is chapter 3 of the Developer's Guide (available at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf ), or online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Integrating_Components_into_OpenOffice.org and https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/AddOns/Add-Ons/ (or use loGuide \"Integrating Components\" and loGuide add-ons ). The Developer's Guide add-on example can be found at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Components 2. Creating the EzHighlight Add-on \u00b6 There's an overlap between the steps required to create an UNO component and an add-on. The main similarity is the need for an OXT file containing a JAR and a description.xml. However, there's no need for an IDL file or type database (a RDB file), but there are extra details concerning the GUI and dispatch handling. The main steps in creating an add-on are illustrated by Figure 7. Figure 7. Toolchain for Creating an Add-on. The UNO component toolchain in the previous chapter used my skelComp.bat script to generate a partial Java implementation. The script utilizes Office's uno- skeletonmaker which can also be employed to generate add-ons and Calc addins. Unfortunately, I was unable to get its add-on features to work. This was not a great loss since I'd already been thinking about replacing uno- skeletonmaker with FreeMarker, a powerful template processing library ( https://freemarker.org/ ). FreeMarker can easily duplicate all the features of uno- skeletonmaker, creating a Java class with the boilerplate code for creating a service and handling command URLs. Also, by switching to FreeMarker, I was able to add more automatic code generation, including code for a user input dialog and a debugging window. The OXT file requires three configuration files: a description of the dialog in Figure 4, Addon.xcs which defines the add-on's GUI (e.g. the menu and toolbar items in Figures 2 and 3), and ProtocolHandler.xcu which says which command URLs are processed by the add-on's dispatch handler. The toolchain in Figure 7 will be explained in more detail in the rest of this chapter. 3. Creating a Partial Add-on Implementation \u00b6 Figure 8 shows the main elements needed to use the FreeMarker template library: a FTL template file, and a program that instantiates the template by employing a collection of FreeMarker variables and their bindings. Figure 8. Using FreeMarker. The simplest FreeMarker program replaces all the FreeMarker variables in the template by their associated bindings, generating a new text file (a Java program in this case). However, FreeMarker contains additional programming features, including for-loops and if-statements, which can generate more complex blocks of text. The add-on template is stored in addonImpl.ftl, and is processed by CreateAddonImpl.java. It reads in the add-on's name, and initializes a HashMap of three FreeMarker variables called \"className\", \"extensionID, and \"cmdNames\". For example, CreateAddonImpl can be called like so: > run CreateAddonImpl EzHighlight The three variables are assigned: \"className\" : \"EzHighlightAddonImpl\" \"extensionID : \"org.openoffice.ezhighlightAddon\" \"cmdNames\" : [ \"EzHighlight\", \"help\" ] \"className\" is assigned the name of the generated Java class. \"extensionID\" contains the protocol string used by the command URLs. \"cmdNames\" holds a list of command URL names: \"EzHighlight\" is linked to the add-on's menu and toolbar items, and \"help\" is attached to the add-on's help menu item. CreateAddonImpl outputs a class called EzHighlightAddonImpl, a fully functional add-on, which displays a dialog like the one in Figure 4 and the help message in Figure 6. However, after the user has typed in the dialog or pressed the \"Ok\" button, no processing is carried out on the Office document. First I'll give an overview of the features in the generated EzHighlightAddonImpl class, then explain the additional highlighting code in a later section. 4. The FreeMarker-generated EzHighlightAddonImpl \u00b6 The template in addonImpl.ftl represents a single Java class, which extends WeakBase and implements seven interfaces: public class $ { className } extends WeakBase implements XInitialization , XServiceInfo , XDispatchProvider , XDispatch , // for the add-on XActionListener , XTopWindowListener , XKeyListener // for the dialog { // ... add-on code } WeakBase is the base class used by all components (which includes add-ons and Calc Addins). XServiceInfo and XInitialization handle the creation and initialization of the service at run time. The XDispatchProvider method, queryDispatch(), implements the dispatch handler for the add-on \u2013 it accepts the command URLs associated with the add-on: // in EzHighlightAddonInpl.java public XDispatch queryDispatch ( URL commandURL , String targetFrameName , int searchFlags ) { if ( commandURL . Protocol . compareTo ( \"org.openoffice.ezhighlightAddon:\" ) == 0 ) { if ( commandURL . Path . compareTo ( \"EzHighlight\" ) == 0 ) { System . out . println ( \"queryDispatch() for \\\"EzHighlight\\\"\" ); return this ; } if ( commandURL . Path . compareTo ( \"help\" ) == 0 ) { System . out . println ( \"queryDispatch() for \\\"help\\\"\" ); return this ; } } return null ; } // end of queryDispatch() The handler signals its acceptance of a command URL by returning a dispatch object which Office uses to process the command. EzHighlightAddonImpl also implements the XDispatch interface, so returns a reference to itself. This means that Office calls EzHighlightAddonImpl.dispatch(), passing it the command URL and other properties: // in EzHighlightAddonInpl.java public void dispatch ( URL commandURL , PropertyValue [] props ) { if ( commandURL . Protocol . compareTo ( \"org.openoffice.ezhighlightAddon:\" ) == 0 ) { if ( commandURL . Path . compareTo ( \"EzHighlight\" ) == 0 ) processCmd ( \"EzHighlight\" ); if ( commandURL . Path . compareTo ( \"help\" ) == 0 ) processCmd ( \"help\" ); } } // end of dispatch() The template-generated code inside dispatch() distinguishes between the possible command names (\"EzHighlight\" and \"help\") by calling processCmd() with different arguments. If processCmd()'s input argument is \"help\", then GUI.showMessageBox() is called to display the window shown in Figure 6, while \"EzHighlight\" triggers the dialog in Figure 4. The processCmd() code is: // in EzHighlightAddonInpl.java... // globals private XDialog dialog = null ; private Console console ; // for debugging output private int printCount = 1 ; private void processCmd ( String cmd ) { XComponent doc = Lo . addonInitialize ( xcc ); // so my utils can be used safely System . out . println ( \"Window title: \" + GUI . getTitleBar ()); System . out . println ( printCount ++ + \". dispatch() called for \\\"\" + cmd + \"\\\"\" ); if ( cmd . equals ( \"help\" )) { GUI . showMessageBox ( \"Add-on Help\" , \"Type in the text, then press return or click the Ok button.\" ); return ; } // \"EzHighlight\" is processed by the following code... console . setVisible ( true ); dialog = Dialogs . loadAddonDialog ( \"org.openoffice.ezhighlightAddon\" , \"dialogLibrary/\" + cmd + \".xdl\" ); if ( dialog == null ) { System . out . println ( \"Could not load \" + cmd + \" dialog\" ); return ; } XControl dialogControl = Dialogs . getDialogControl ( dialog ); initDialog ( dialogControl ); Dialogs . execute ( dialogControl ); console . setVisible ( false ); } // end of processCmd() Lo.addonInitialize() initializes the globals used by my Lo utility library and other support classes: // in the Lo class // globals private static XComponentContext xcc = null ; private static XDesktop xDesktop = null ; private static XMultiComponentFactory mcFactory = null ; private static XMultiServiceFactory msFactory = null ; public static XComponent addonInitialize ( XComponentContext addonXcc ) { xcc = addonXcc ; if ( xcc == null ) { System . out . println ( \"Could not access component context\" ); return null ; } mcFactory = xcc . getServiceManager (); if ( mcFactory == null ) { System . out . println ( \"Office Service Manager is unavailable\" ); return null ; } try { Object oDesktop = mcFactory . createInstanceWithContext ( \"com.sun.star.frame.Desktop\" , xcc ); xDesktop = Lo . qi ( XDesktop . class , oDesktop ); } catch ( Exception e ) { System . out . println ( \"Could not access desktop\" ); return null ; } XComponent doc = xDesktop . getCurrentComponent (); if ( doc == null ) { System . out . println ( \"Could not access document\" ); return null ; } msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); return doc ; } // end of addonInitialize() addonInitialize() returns an instance of XComponent, which refers to the document currently loaded into Office. Later this will be used to highlight the document's text. processCmd() calls Console.setVisible() before and after the processing of the \"EzHighlight\" command. The first call makes a Console debugging window visible, and the call at the end hides it. These lines should be commented out of the completed add-on, so the window doesn't appear. The dialog is handled by methods from my Dialogs support class, and by listeners set up in initDialog(). 5. Creating the Dialog \u00b6 There are two approaches for dialog creation: the easy way uses Office's dialog editor, and the hard way calls functions in my Dialogs support class to programmatically create the dialog's components. I'll use the editor in this chapter, and employ Dialogs methods in my macros in Chapter 48. The Developer's Guide has some information on the dialog editor in chapter 11, \"OpenOffice.org Basic\". The relevant sub-sections are online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Basic/Dialog_Editor/ and https://wiki.openoffice.org/wiki/Documentation/DevGuide/Basic/Creating_Dialogs/ (or use loGuide \"Dialog Editor\" and loGuide \"Creating Dialogs\" ). The editor utilizes drag-and-drop to place GUI elements in a dialog drawing area, with property windows for specializing each element. The editor is reached via Office's menu item Tools > Macros > Organize Dialogs (see Figure 9). Figure 9. Creating a new Dialog. Figure 10 shows the dialog editor window after the creation of a new dialog called \"Basic\"; the GUI controls run along the bottom of the window. Figure 10. The Dialog Editor Window for a new Dialog. The simplest useful dialog is probably the version of the \"Basic\" dialog in Figure 11, consisting of a label, text field, and \"Ok\" button. Figure 11. The \"Basic\" Dialog. A dialog can be exported as XML using the \"Export Dialog\" icon above the drawing area (the icon includes a floppy disk which will leave young programmers mystified). The resulting XDL file contains text something like: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE dlg:window PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"dialog.dtd\"> <dlg:window xmlns:dlg=\"https://openoffice.org/2000/dialog\" xmlns:script=\"https://openoffice.org/2000/script\" dlg:id=\"Basic\" dlg:left=\"52\" dlg:top=\"44\" dlg:width=\"173\" dlg:height=\"34\" dlg:closeable=\"true\" dlg:moveable=\"true\" dlg:title=\"Basic Dialog\"> <dlg:styles> <dlg:style dlg:style-id=\"0\" dlg:background-color=\"0xeeeeee\" dlg:font-height=\"10\"/> </dlg:styles> <dlg:bulletinboard> <dlg:text dlg:style-id=\"0\" dlg:id=\"Label1\" dlg:tab-index=\"0\" dlg:left=\"6\" dlg:top=\"11\" dlg:width=\"38\" dlg:height=\"8\" dlg:value=\"Enter input:\"/> <dlg:textfield dlg:id=\"TextField1\" dlg:tab-index=\"1\" dlg:left=\"41\" dlg:top=\"7\" dlg:width=\"83\" dlg:height=\"14\"/> <dlg:button dlg:id=\"CommandButton1\" dlg:tab-index=\"2\" dlg:left=\"137\" dlg:top=\"9\" dlg:width=\"28\" dlg:height=\"12\" dlg:value=\"Ok\"/> </dlg:bulletinboard> </dlg:window> The code in EzHighlightAddonInpl assumes that the dialog contains a text field called \"TextField1\" and a button called \"CommandButton1\", which is true of the XDL shown above. Of course, it's possible to add more GUI components, as in the next section. 5.1. The EzHighlight Dialog \u00b6 The dialog editor has an import icon to the left of the export icon, which can be used to load an XDL file for modification. I copied the \"Basic\" XDL file, renaming it to \"EzHighlight.xdl\", and imported it; a few changes and additions later, it looked as shown in Figure 12. Figure 12. The EzHighlight.xdl Dialog. The exported XML is: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE dlg:window PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"dialog.dtd\"> <dlg:window xmlns:dlg=\"https://openoffice.org/2000/dialog\" xmlns:script=\"https://openoffice.org/2000/script\" dlg:id=\"EzHighlight\" dlg:left=\"109\" dlg:top=\"73\" dlg:width=\"184\" dlg:height=\"44\" dlg:closeable=\"true\" dlg:moveable=\"true\" dlg:title=\"EzHighlight Text Selector\"> <dlg:styles> <dlg:style dlg:style-id=\"0\" dlg:background-color=\"0xeeeeee\"/> </dlg:styles> <dlg:bulletinboard> <dlg:text dlg:style-id=\"0\" dlg:id=\"Label1\" dlg:tab-index=\"0\" dlg:left=\"8\" dlg:top=\"11\" dlg:width=\"26\" dlg:height=\"10\" dlg:value=\"Enter text:\" dlg:align=\"right\"/> <dlg:textfield dlg:id=\"TextField1\" dlg:tab-index=\"1\" dlg:left=\"39\" dlg:top=\"9\" dlg:width=\"83\" dlg:height=\"12\"/> <dlg:textfield dlg:id=\"TextField2\" dlg:tab-index=\"2\" dlg:left=\"39\" dlg:top=\"26\" dlg:width=\"46\" dlg:height=\"12\" dlg:readonly=\"true\"/> <dlg:text dlg:style-id=\"0\" dlg:id=\"Label2\" dlg:tab-index=\"3\" dlg:left=\"8\" dlg:top=\"27\" dlg:width=\"26\" dlg:height=\"10\" dlg:value=\"Count:\" dlg:align=\"right\"/> <dlg:button dlg:id=\"CommandButton1\" dlg:tab-index=\"4\" dlg:left=\"131\" dlg:top=\"9\" dlg:width=\"46\" dlg:height=\"12\" dlg:value=\"Highlight\"/> </dlg:bulletinboard> </dlg:window> The dialog loading code in EzHighlightAddonInpl.java assumes that the dialog's filename is the same as the command URL name, as can be seen in processCmd(): // part of processCmd() in EzHighlightAddonInpl.java... dialog = Dialogs . loadAddonDialog ( \"org.openoffice.ezhighlightAddon\" , \"dialogLibrary/\" + cmd + \".xdl\" ); processCmd() also assumes that the XDL file is in a dialogLibrary/ sub-directory. I'll explain how this is part of the add-on's OXT file in a later section. Dialogs.loadAddonDialog() is defined as: // in the Dialogs class public static XDialog loadAddonDialog ( String extensionID , String dialogFnm ) { XDialogProvider dp = Lo . createInstanceMCF ( XDialogProvider . class , \"com.sun.star.awt.DialogProvider\" ); if ( dp == null ) { System . out . println ( \"Could not access the Dialog Provider\" ); return null ; } try { return dp . createDialog ( \"vnd.sun.star.extension://\" + extensionID + \"/\" + dialogFnm ); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not load the dialog: \\\"\" + dialogFnm + \"\\\": \" + e ); return null ; } } // end of loadAddonDialog() The crucial line is the call to XDialogProvider.createDialog(), which constructs the dialog name: vnd . sun . star . extension : //org.openoffice.ezhighlightAddon/ dialogLibrary / EzHighlight The dialog is loaded from the ezhighlightAddon extension. 5.2. Listening to the Dialog \u00b6 Back in processCmd(), listeners are attached to the loaded dialog, and the dialog is made visible on-screen: // in processCmd() in EzHighlightAddonInpl.java... XControl dialogControl = Dialogs . getDialogControl ( dialog ); initDialog ( dialogControl ); Dialogs . execute ( dialogControl ); Dialogs.getDialogControl() casts the XDialog into an XControl: // in the Dialogs class public static XControl getDialogControl ( XDialog dialog ) { return Lo . qi ( XControl . class , dialog ); } The initDialog() method inside EzHighlightAddonInpl.java attaches three listeners to the dialog: a window listener, an action listener for the \"CommandButton1\" button, and a key listener for the \"TextField1\" text field: // in the EzHighlightAddonInpl class // globals private XTextComponent textBox ; // the text in the dialog's text field private void initDialog ( XControl dialogControl ) { // listen to the dialog window XTopWindow topWin = Dialogs . getDialogWindow ( dialogControl ); topWin . addTopWindowListener ( this ); // Dialogs.showControlInfo(dialogControl); // set listener for Ok button XButton button = Lo . qi ( XButton . class , Dialogs . findControl ( dialogControl , \"CommandButton1\" )); button . addActionListener ( this ); // set listener for text box textBox = Lo . qi ( XTextComponent . class , Dialogs . findControl ( dialogControl , \"TextField1\" )); XWindow xTFWindow = ( XWindow ) Lo . qi ( XWindow . class , textBox ); xTFWindow . addKeyListener ( this ); xTFWindow . setFocus (); } // end of initDialog() These controls and listeners are all from Office's com.sun.star.awt module. The dialog and listeners will be invoked by Office at run time, and so should use its API, not Java's Swing. The call to Dialogs.showControlInfo() is commented out in initDialog(), but is a useful way to double-check the dialog's internal construction, and particularly the IDs of its components. showControlInfo() prints to standard output which will be displayed in the Console window. Figure 13 reports the structure of the EzHighlight.xdl dialog from Figure 12. Figure 13. The Console Window Showing Dialog Details. The dialog contains five components: two labels, two text fields, and a button. Dialogs.findControl() uses a control's name to find it inside a dialog: // in Dialogs class public static XControl findControl ( XControl dialogCtrl , String name ) { XControlContainer ctrlCon = Lo . qi ( XControlContainer . class , dialogCtrl ); return ctrlCon . getControl ( name ); } initDialog() converts the returned \"CommandButton1\" control into an XButton, and the \"TextField1\" control into an XTextComponent so that listeners can be attached to them. EzHighlightAddonInpl implements all of the listener interfaces used by the dialog: XActionListener, XTopWindowListener, and XKeyListener. XActionListener.actionPerformed() deals with button presses, XTopWindowListener.windowClosing() listens for the closing of the dialog, and XKeyListener.keyPressed() captures the user typing into the text field: // in the EzHighlightAddonInpl class // globals private XDialog dialog = null ; private XTextComponent textBox ; public void actionPerformed ( ActionEvent e ) { String info = textBox . getText (); if ( info . equals ( \"\" )) return ; System . out . println ( \"Info: \\\"\" + info + \"\\\"\" ); textBox . setText ( \"\" ); // ADD code here } // end of actionPerformed() public void windowClosing ( EventObject event ) { dialog . endExecute (); } public void keyPressed ( KeyEvent event ) { if ( event . KeyCode == Key . RETURN ) { String info = textBox . getText (); if ( info . equals ( \"\" )) return ; System . out . println ( \"Info: \\\"\" + info + \"\\\"\" ); textBox . setText ( \"\" ); // ADD code here } } // end of keyPressed() The template generated code for actionPerformed() and keyPressed() only print information to the Console window. Add-on specific functionality is added next. 6. Completing the Implementation of EzHighlightAddonInpl \u00b6 The completion of EzHighlightAddonInpl.java takes the form of new code in processCmd(), initDialog(), actionPerformed(), and keyPressed(), and a few new global variables. processCmd() converts the XComponent document returned by Lo.addonInitialize() into an XTextDocument, assuming that the currently loaded document is text-based. If it isn't then there's no point continuing: // in the EzHighlightAddonInpl class // globals private XTextDocument textDoc ; // in processCmd() : XComponent doc = Lo . addonInitialize ( xcc ); // added textDoc = Write . getTextDoc ( doc ); if ( textDoc == null ) return ; : initDialog() is extended to access the word count text field. It's only used to report the number of changes, so doesn't need a listener: // in the EzHighlightAddonInpl class // globals private XTextComponent countTextBox ; // in initDialog() : // get a reference to the count text field; added countTextBox = Lo . qi ( XTextComponent . class , Dialogs . findControl ( dialogControl , \"TextField2\" )); : actionPerformed() and keyPressed() must trigger the highlighting code, which is implemented in applyEzHighlighting(): // added to actionPerformed() : int count = applyEzHighlighting ( info ); countTextBox . setText ( \"\" + count ); // added to keyPressed() : int count = applyEzHighlighting ( info ); countTextBox . setText ( \"\" + count ); applyEzHighlighting() is passed the text entered by the user through the dialog. It uses the XReplaceable and XReplaceDescriptor interfaces to perform a search and replace through the document. This technique, and very similar code, was explained in Chapter 9. applyEzHighlighting() is: // in the EzHighlightAddonInpl class // globals private XTextDocument textDoc ; private int applyEzHighlighting ( String searchKey ) /* Matches whole words and is case sensitive. Highlights in bold and red; */ { System . out . println ( \"applyEzHighlighting(): \" + searchKey ); XReplaceable repl = Lo . qi ( XReplaceable . class , textDoc ); XReplaceDescriptor desc = repl . createReplaceDescriptor (); /* Get a XPropertyReplace object for altering the properties of the replaced text */ XPropertyReplace propReplace = Lo . qi ( XPropertyReplace . class , desc ); // Set the replaced text to bold and red PropertyValue wv = new PropertyValue ( \"CharWeight\" , - 1 , FontWeight . BOLD , PropertyState . DIRECT_VALUE ); PropertyValue cv = new PropertyValue ( \"CharColor\" , - 1 , Color . RED . getRGB (), PropertyState . DIRECT_VALUE ); PropertyValue [] props = new PropertyValue [] { cv , wv }; try { propReplace . setReplaceAttributes ( props ); // Only match whole words and be case sensitive desc . setPropertyValue ( \"SearchCaseSensitive\" , true ); desc . setPropertyValue ( \"SearchWords\" , true ); } catch ( com . sun . star . uno . Exception ex ) { System . out . println ( \"Error setting up search properties\" ); return - 1 ; } /* Replaces all instances of searchKey with new Text properties and gets the number of changed instances */ desc . setSearchString ( searchKey ); desc . setReplaceString ( searchKey ); return repl . replaceAll ( desc ); } // end of applyEzHighlighting() 7. Configuring the Add-on \u00b6 An add-on OXT file requires two configuration files not used by an UNO component: ProtocolHandler.xcu and Addon.xcs. 7.1. ProtocolHandler.xcu \u00b6 ProtocolHandler.xcu specifies which command URLs will be handled by the component. The contents of the file for EzHighlight are: <?xml version='1.0' encoding='UTF-8'?> <oor:component-data oor:name=\"ProtocolHandler\" oor:package=\"org.openoffice.Office\" xmlns:oor=\"https://openoffice.org/2001/registry\" xmlns:xs=\"https://w3.org/2001/XMLSchema\" xmlns:xsi=\"https://w3.org/2001/XMLSchema-instance\"> <node oor:name=\"HandlerSet\"> <node oor:name=\"EzHighlightAddonImpl\" oor:op=\"replace\"> <prop oor:name=\"Protocols\" oor:type=\"oor:string-list\"> <value>org.openoffice.ezhighlightAddon:*</value> </prop> </node> </node> </oor:component-data> The \"EzHighlightAddonImpl\" component will handle all command URLs that begin with the \"org.openoffice.ezhighlightAddon\" extension ID. The \"all\" is specified using the * wildcard. The component name is the name of the generated Java class. 7.2. Addon.xcs \u00b6 Addon.xcs defines the add-on's GUI elements, such as its menu and toolbar items (i.e. as seen in Figures 2, 3, and 5). Figure 14 illustrates how the file may set up to five attributes: Figure 14. The Addon.xcs GUI Elements. The \"AddonMenu\" attribute defines the look of the menu item that appears at the end of Office's Tool > Add-ons menu, as in Figure 2. The \"OfficeToolbar\" attribute specifies the appearance of the floating toolbar reached via View > Toolbars > Add-on , as in Figure 3. The \"OfficeMenubar\" attribute is used to add a menu item to Office's main menu bar, which seems a rather poor GUI design choice, so I've chosen not to use it. The OfficeHelp\" attribute creates the add-on's help menu item on Office's Help menu, as in Figure 5. The \"Images\" attribute defines the icons that appear next to the text in the menu and toolbar items. If you look back at Figures 2 and 3, you'll see that no icons appear, but this isn't for want of me trying. This feature seems to be broken, but I'll still explain how to set it up. Aside from \"Images\", the attributes have a similar structure: a menu or toolbar item with five sub-attributes: URL, Title, ImageIdentifier, Context, and Target; I'll not be using sub-menu attributes. The best explanation of Addon.xcs' structure is \"How to distribute your macros with an Addon\" by Bernard Marcelly at https://openoffice.org/documentation/HOW_TO/various_topics/Addons1_1en.pdf , which dates from 2003. \"AddonMenu\" Attribute \u00b6 The \"AddonMenu\" attribute used by the EzHighlight add-on is: <node oor:name=\"AddonMenu\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:EzHighlight</value> </prop> <prop oor:name=\"Title\" oor:type=\"xs:string\"> <value>EzHighlight Text</value> </prop> <prop oor:name=\"ImageIdentifier\" oor:type=\"xs:string\"> <value/> </prop> <prop oor:name=\"Context\" oor:type=\"xs:string\"> <value>com.sun.star.text.TextDocument</value> </prop> <prop oor:name=\"Target\" oor:type=\"xs:string\"> <value>_self</value> </prop> </node> </node> The \"URL\" attribute holds the command URL which is dispatched by Office when the menu item is clicked. The \"Title\" attribute contains the menu item's text, and \"ImageIdentifier\" can be assigned the path to a PNG or BMP file for the text's icon. \"ImageIdentifier\" is left empty here since all the images are defined in the \"Images\" attribute, explained below. The \"Context\" attribute is assigned the document service for the Office application utilizing the add-on. EzHighlight is accessible only from Writer, so \"Context\"'s value is \"com.sun.star.text.TextDocument\". Other application/service mappings are shown in Table 1. Office Application Document Service Writer com.sun.star.text.TextDocument Calc com.sun.star.sheet.SpreadsheetDocument Impress com.sun.star.presentation.PresentationDocument Draw com.sun.star.drawing.DrawingDocument Formula com.sun.star.formula.FormulaProperties Chart com.sun.star.chart.ChartDocument Bibliography com.sun.star.frame.Bibliography Table 1. Office Application/Service Mappings Used by \"Context\" If the \"Context\" field isn't assigned a value, then the add-on will be available in all of Office's applications. The \"Target\" field can be assigned four values: \"_top\", \"_parent\", \"_blank\", and \"_self\", but I've never seen any other value used but \"_self\". \"OfficeToolbar\" Attribute \u00b6 Figure 2 (EzHighlight's menu item) and Figure 3 (its toolbar item) look the same, and respond in the same way when clicked, so it's no great surprise that the \"OfficeToolbar\" attribute in Addon.xcs is almost exactly the same as \"AddonMenu\": <node oor:name=\"OfficeToolBar\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <node oor:name=\"m1\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:EzHighlight</value> </prop> <prop oor:name=\"Title\" oor:type=\"xs:string\"> <value>EzHighlight Text</value> </prop> <prop oor:name=\"ImageIdentifier\" oor:type=\"xs:string\"> <value/> </prop> <prop oor:name=\"Context\" oor:type=\"xs:string\"> <value>com.sun.star.text.TextDocument</value> </prop> <prop oor:name=\"Target\" oor:type=\"xs:string\"> <value>_self</value> </prop> </node> </node> </node> The difference is an extra attribute which allows a toolbar to hold several items. In the description above, there's one item labeled as \"m1\". The labels can be any unique string, but \"m\" followed by a number is used in most examples. \"OfficeHelp\" Attribute \u00b6 The \"OfficeHelp\" attribute is similar to \"OfficeToolbar\" and \"AddonMenu\", but dispatches a different command URL (\"org.openoffice.ezhighlightAddon:help\") and its menu item uses a different title (\"About EzHighlight\"). <node oor:name=\"OfficeHelp\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:help</value> </prop> <prop oor:name=\"Title\" oor:type=\"xs:string\"> <value xml:lang=\"en-US\">About EzHighlight</value> </prop> <prop oor:name=\"ImageIdentifier\" oor:type=\"xs:string\"> <value/> </prop> <prop oor:name=\"Context\" oor:type=\"xs:string\"> <value>com.sun.star.text.TextDocument</value> </prop> <prop oor:name=\"Target\" oor:type=\"xs:string\"> <value>_self</value> </prop> </node> </node> \"Images\" Attribute \u00b6 The \"Images\" attribute specifies the icons used by the GUI elements. An image can be either big or small (26x26 or 16x16 pixels), high contrast or normal, and loaded from a file or coded as hexadecimal text. These different combinations mean there are eight variants to choose from, each with a different property name, which are listed in Table 2. Size in Pixels Contrast Hexadecimal text File name 16x16 normal ImageSmall ImageSmallURL 16x16 high ImageSmallHC ImageSmallHCURL 26x26 normal ImageBig ImageBigURL 26x26 high ImageBigHC ImageBigHCURL Table 2. Image Property Names. The \"Images\" attribute for EzHighlight is: <node oor:name=\"Images\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:EzHighlight</value> </prop> <node oor:name=\"UserDefinedImages\"> <prop oor:name=\"ImageSmallURL\"> <value>%origin%/images/ezhighlight16.png</value> </prop> <prop oor:name=\"ImageBigURL\"> <value>%origin%/images/ezhighlight26.png</value> </prop> </node> </node> </node> The \"UserDefinedImages\" sub-attribute specifies two sizes of normal contrast image, supplied as filenames. %origin% stands for the OXT file, so the two icons are stored in the images/ subdirectory inside that zipped file. The images will be used for the menu and toolbar items associated with the \"org.openoffice.ezhighlightAddon:EzHighlight\" command URL. Unfortunately, the images don't appear, as shown in Figures 2 and 3. The hexadecimal text definition of a small image would be something like: <prop oor:name=\"ImageSmall\"> <value>89504E470D0A1A0A0000000D494844520000001000000 01008060000001FF3FF610000024F494 ... // more numbers </value> </prop> One way to obtain an image's hexadecimal text is to call my ImageHex.java program which prints it to stdout. Unfortunately, the icon still doesn't appear, even when specified in this form. 8. Building and Installing the OXT File \u00b6 Figure 7 shows the stages in building and installing the add-on as an extension. These steps are carried out by my installAddon.bat script, which assumes that the various configuration files have already been created and are in certain locations. The completed EzHighlightAddonImpl.java file is compiled, then added to EzHighlight.jar with a manifest that refers to Utils.jar: RegistrationClassName : EzHighlightAddonImpl Class - Path : Utils . jar Utils.jar contains my support classes, which may be required by the add-on at run- time. installAddon.bat will add it to the OXT file along with EzHighlight.jar. installAddon.bat assumes that the add-on configuration files are in a sub-directory with the same name as the add-on. For example, when it's processing the EzHighlight add-on, it looks for a EzHighlight/ folder with the following structure: EzHighlight | Addons.xcu | description.xml | license.txt | package-description.txt | ProtocolHandler.xcu | Utils.jar | +---dialogLibrary | EzHighlight.xdl | +---images | ezhighlight.png | ezhighlight16.png | ezhighlight26.png | \\---META-INF manifest.xml EzHighlight.jar is moved into EzHighlight/, and the folder is zipped into EzHighlight.oxt. The extension is installed into Office using the unopkg tool, in the same way as the UNO component of the last chapter. EzHighlight/ contains three configuration files: ProtocolHandler.xcu, Addons.xcu, and description.xml. description.xml plays the same role as the same-named file for UNO components. Its contents use the same XML attributes: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <description xmlns=\"https://openoffice.org/extensions/description/2006\" xmlns:d=\"https://openoffice.org/extensions/description/2006\" xmlns:xlink=\"https://w3.org/1999/xlink\"> <identifier value=\"org.openoffice.ezhighlightAddon\"/> <version value=\"0.1\"/> <display-name> <name lang=\"en\">EzHighlight Addon</name> </display-name> <publisher> <name xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\" lang=\"en\">Andrew Davison</name> </publisher> <registration> <simple-license accept-by=\"user\" > <license-text xlink:href=\"license.txt\" lang=\"en\"/> </simple-license> </registration> <extension-description> <src lang=\"en-US\" xlink:href=\"package-description.txt\"/> </extension-description> <icon> <default xlink:href=\"images/ezhighlight.png\" /> </icon> <update-information> <src xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\"/> </update-information> <dependencies> <OpenOffice.org-minimal-version value=\"3.4\" d:name=\"OpenOffice.org 3.4\"/> </dependencies> <platform value=\"all\" /> </description> The biggest difference is that the extension icon is located in the images/ subdirectory inside EzHighlight/. license.txt and package-description.txt are referenced in the description, which explains why those files are in EzHighlight/. The dialog description (EzHighlight.xdl) is stored in its own subdirectory, dialogLibrary/, to match the dialog loading code in EzHighlightAddonInpl.java: // in processCmd() dialog = Dialogs . loadAddonDialog ( \"org.openoffice.ezhighlightAddon\" , \"dialogLibrary/\" + cmd + \".xdl\" ); The images/ subdirectory contains the extension manager icon (ezhighlight.png) and two sizes of GUI icons (ezhighlight16.png and ezhighlight26.png). The GUI icons must be inside images/ to match the locations specified in the \"Images\" attribute in Addon.xcs.","title":"Chapter 46. Add-ons"},{"location":"46-Addons.html#chapter-46-add-ons","text":"Topics What is an Add- on?; Creating the EzHighlight Add-on; Creating a Partial Add- on Implementation; The FreeMarker-generated EzHighlightAddonImpl; Creating the Dialog; Configuring the Add-on; Building and Installing the OXT File Example folders: \"AddOn Tests\", \"Utils\" Add-ons build upon the UNO component techniques described in the last chapter to make a component accessible via an Office menu and/or toolbar item. I'll implement the EzHighlight add-on, which allows word occurrences to be highlighted in a Writer document. EzHighlight is installed in Office as an extension in the same way as an UNO component, and is listed by the Extension Manger in Figure 1. Figure 1. The EzHighlight Add-on Extension. When the Writer application is running, EzHighlight is accessible either through Office's Tools, Add-Ons menu item (see Figure 2) or as a toolbar created by View, Toolbars, Add-on 2 (see Figure 3). This 'floating' toolbar can be attached to an existing toolbar. Figure 2. The EzHighlight Add-on on the Tools Menu. Figure 3. The EzHighlighter Add-on as a Toolbar. When the user clicks on \"EzHighlight Text\", either through the menu or toolbar, the dialog shown in Figure 4 appears. Figure 4. The EzHighlighter Dialog. The user enters a word, and either types or presses the \"Highlight\" button. Every matching word in the currently loaded Writer document is redrawn in red, and the number of changes reported in the \"Count:\" field. EzHighlight also has basic help support, accessible from Office's Help menu as the \"About EzHighlight\" item (see Figure 5). Figure 5. The EzHighlight Help Menu Item. Clicking on the help item causes a simple message box to appear, as in Figure 6. Figure 6. The EzHighlight Help Message Box.","title":"Chapter 46. Add-ons"},{"location":"46-Addons.html#1-what-is-an-add-on","text":"Office supports two kinds of add-on: job add-ons and ProtocolHandler add-ons. A job add-on is a component triggered by events inside Office, such as when the application is first opened or about to terminate, or when a document is loaded, printed, or closed. This chapter is about Protocol handler add-ons, which link menu and/or toolbar items to a component using Office's dispatch framework. Every GUI element is assigned a 'command URL', a unique name made of two or three parts: <protocol string>:<command string>[?<command string argument>+ ] A protocol string can be almost anything, and I'll be using the extension's ID (\"org.openoffice.ezhighlightAddon\"). There is a different command string for each GUI-triggered action, and I'll utilize two: \"EzHighlight\" and \"help\". \"EzHighlight\" is associated with the EzHighlight menu and toolbar items (Figures 2 and 3), and makes the dialog in Figure 4 appear. \"help\" is assigned to the \"About EzHighlight\" help menu item, and causes the message box in Figure 6 to be displayed. I won't be using command string arguments. When a user chooses an item in the user interface, its command URL is passed along a list of dispatch handlers until one accepts the command and processes it by creating a dispatch object. Fortunately, most of the dispatch handling behavior in an add-on can be generated automatically. The main source of information for job and ProtocolHandler add-ons is chapter 3 of the Developer's Guide (available at https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf ), or online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Integrating_Components_into_OpenOffice.org and https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/AddOns/Add-Ons/ (or use loGuide \"Integrating Components\" and loGuide add-ons ). The Developer's Guide add-on example can be found at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Components","title":"1.  What is an Add-on?"},{"location":"46-Addons.html#2-creating-the-ezhighlight-add-on","text":"There's an overlap between the steps required to create an UNO component and an add-on. The main similarity is the need for an OXT file containing a JAR and a description.xml. However, there's no need for an IDL file or type database (a RDB file), but there are extra details concerning the GUI and dispatch handling. The main steps in creating an add-on are illustrated by Figure 7. Figure 7. Toolchain for Creating an Add-on. The UNO component toolchain in the previous chapter used my skelComp.bat script to generate a partial Java implementation. The script utilizes Office's uno- skeletonmaker which can also be employed to generate add-ons and Calc addins. Unfortunately, I was unable to get its add-on features to work. This was not a great loss since I'd already been thinking about replacing uno- skeletonmaker with FreeMarker, a powerful template processing library ( https://freemarker.org/ ). FreeMarker can easily duplicate all the features of uno- skeletonmaker, creating a Java class with the boilerplate code for creating a service and handling command URLs. Also, by switching to FreeMarker, I was able to add more automatic code generation, including code for a user input dialog and a debugging window. The OXT file requires three configuration files: a description of the dialog in Figure 4, Addon.xcs which defines the add-on's GUI (e.g. the menu and toolbar items in Figures 2 and 3), and ProtocolHandler.xcu which says which command URLs are processed by the add-on's dispatch handler. The toolchain in Figure 7 will be explained in more detail in the rest of this chapter.","title":"2.  Creating the EzHighlight Add-on"},{"location":"46-Addons.html#3-creating-a-partial-add-on-implementation","text":"Figure 8 shows the main elements needed to use the FreeMarker template library: a FTL template file, and a program that instantiates the template by employing a collection of FreeMarker variables and their bindings. Figure 8. Using FreeMarker. The simplest FreeMarker program replaces all the FreeMarker variables in the template by their associated bindings, generating a new text file (a Java program in this case). However, FreeMarker contains additional programming features, including for-loops and if-statements, which can generate more complex blocks of text. The add-on template is stored in addonImpl.ftl, and is processed by CreateAddonImpl.java. It reads in the add-on's name, and initializes a HashMap of three FreeMarker variables called \"className\", \"extensionID, and \"cmdNames\". For example, CreateAddonImpl can be called like so: > run CreateAddonImpl EzHighlight The three variables are assigned: \"className\" : \"EzHighlightAddonImpl\" \"extensionID : \"org.openoffice.ezhighlightAddon\" \"cmdNames\" : [ \"EzHighlight\", \"help\" ] \"className\" is assigned the name of the generated Java class. \"extensionID\" contains the protocol string used by the command URLs. \"cmdNames\" holds a list of command URL names: \"EzHighlight\" is linked to the add-on's menu and toolbar items, and \"help\" is attached to the add-on's help menu item. CreateAddonImpl outputs a class called EzHighlightAddonImpl, a fully functional add-on, which displays a dialog like the one in Figure 4 and the help message in Figure 6. However, after the user has typed in the dialog or pressed the \"Ok\" button, no processing is carried out on the Office document. First I'll give an overview of the features in the generated EzHighlightAddonImpl class, then explain the additional highlighting code in a later section.","title":"3.  Creating a Partial Add-on Implementation"},{"location":"46-Addons.html#4-the-freemarker-generated-ezhighlightaddonimpl","text":"The template in addonImpl.ftl represents a single Java class, which extends WeakBase and implements seven interfaces: public class $ { className } extends WeakBase implements XInitialization , XServiceInfo , XDispatchProvider , XDispatch , // for the add-on XActionListener , XTopWindowListener , XKeyListener // for the dialog { // ... add-on code } WeakBase is the base class used by all components (which includes add-ons and Calc Addins). XServiceInfo and XInitialization handle the creation and initialization of the service at run time. The XDispatchProvider method, queryDispatch(), implements the dispatch handler for the add-on \u2013 it accepts the command URLs associated with the add-on: // in EzHighlightAddonInpl.java public XDispatch queryDispatch ( URL commandURL , String targetFrameName , int searchFlags ) { if ( commandURL . Protocol . compareTo ( \"org.openoffice.ezhighlightAddon:\" ) == 0 ) { if ( commandURL . Path . compareTo ( \"EzHighlight\" ) == 0 ) { System . out . println ( \"queryDispatch() for \\\"EzHighlight\\\"\" ); return this ; } if ( commandURL . Path . compareTo ( \"help\" ) == 0 ) { System . out . println ( \"queryDispatch() for \\\"help\\\"\" ); return this ; } } return null ; } // end of queryDispatch() The handler signals its acceptance of a command URL by returning a dispatch object which Office uses to process the command. EzHighlightAddonImpl also implements the XDispatch interface, so returns a reference to itself. This means that Office calls EzHighlightAddonImpl.dispatch(), passing it the command URL and other properties: // in EzHighlightAddonInpl.java public void dispatch ( URL commandURL , PropertyValue [] props ) { if ( commandURL . Protocol . compareTo ( \"org.openoffice.ezhighlightAddon:\" ) == 0 ) { if ( commandURL . Path . compareTo ( \"EzHighlight\" ) == 0 ) processCmd ( \"EzHighlight\" ); if ( commandURL . Path . compareTo ( \"help\" ) == 0 ) processCmd ( \"help\" ); } } // end of dispatch() The template-generated code inside dispatch() distinguishes between the possible command names (\"EzHighlight\" and \"help\") by calling processCmd() with different arguments. If processCmd()'s input argument is \"help\", then GUI.showMessageBox() is called to display the window shown in Figure 6, while \"EzHighlight\" triggers the dialog in Figure 4. The processCmd() code is: // in EzHighlightAddonInpl.java... // globals private XDialog dialog = null ; private Console console ; // for debugging output private int printCount = 1 ; private void processCmd ( String cmd ) { XComponent doc = Lo . addonInitialize ( xcc ); // so my utils can be used safely System . out . println ( \"Window title: \" + GUI . getTitleBar ()); System . out . println ( printCount ++ + \". dispatch() called for \\\"\" + cmd + \"\\\"\" ); if ( cmd . equals ( \"help\" )) { GUI . showMessageBox ( \"Add-on Help\" , \"Type in the text, then press return or click the Ok button.\" ); return ; } // \"EzHighlight\" is processed by the following code... console . setVisible ( true ); dialog = Dialogs . loadAddonDialog ( \"org.openoffice.ezhighlightAddon\" , \"dialogLibrary/\" + cmd + \".xdl\" ); if ( dialog == null ) { System . out . println ( \"Could not load \" + cmd + \" dialog\" ); return ; } XControl dialogControl = Dialogs . getDialogControl ( dialog ); initDialog ( dialogControl ); Dialogs . execute ( dialogControl ); console . setVisible ( false ); } // end of processCmd() Lo.addonInitialize() initializes the globals used by my Lo utility library and other support classes: // in the Lo class // globals private static XComponentContext xcc = null ; private static XDesktop xDesktop = null ; private static XMultiComponentFactory mcFactory = null ; private static XMultiServiceFactory msFactory = null ; public static XComponent addonInitialize ( XComponentContext addonXcc ) { xcc = addonXcc ; if ( xcc == null ) { System . out . println ( \"Could not access component context\" ); return null ; } mcFactory = xcc . getServiceManager (); if ( mcFactory == null ) { System . out . println ( \"Office Service Manager is unavailable\" ); return null ; } try { Object oDesktop = mcFactory . createInstanceWithContext ( \"com.sun.star.frame.Desktop\" , xcc ); xDesktop = Lo . qi ( XDesktop . class , oDesktop ); } catch ( Exception e ) { System . out . println ( \"Could not access desktop\" ); return null ; } XComponent doc = xDesktop . getCurrentComponent (); if ( doc == null ) { System . out . println ( \"Could not access document\" ); return null ; } msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); return doc ; } // end of addonInitialize() addonInitialize() returns an instance of XComponent, which refers to the document currently loaded into Office. Later this will be used to highlight the document's text. processCmd() calls Console.setVisible() before and after the processing of the \"EzHighlight\" command. The first call makes a Console debugging window visible, and the call at the end hides it. These lines should be commented out of the completed add-on, so the window doesn't appear. The dialog is handled by methods from my Dialogs support class, and by listeners set up in initDialog().","title":"4.  The FreeMarker-generated EzHighlightAddonImpl"},{"location":"46-Addons.html#5-creating-the-dialog","text":"There are two approaches for dialog creation: the easy way uses Office's dialog editor, and the hard way calls functions in my Dialogs support class to programmatically create the dialog's components. I'll use the editor in this chapter, and employ Dialogs methods in my macros in Chapter 48. The Developer's Guide has some information on the dialog editor in chapter 11, \"OpenOffice.org Basic\". The relevant sub-sections are online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Basic/Dialog_Editor/ and https://wiki.openoffice.org/wiki/Documentation/DevGuide/Basic/Creating_Dialogs/ (or use loGuide \"Dialog Editor\" and loGuide \"Creating Dialogs\" ). The editor utilizes drag-and-drop to place GUI elements in a dialog drawing area, with property windows for specializing each element. The editor is reached via Office's menu item Tools > Macros > Organize Dialogs (see Figure 9). Figure 9. Creating a new Dialog. Figure 10 shows the dialog editor window after the creation of a new dialog called \"Basic\"; the GUI controls run along the bottom of the window. Figure 10. The Dialog Editor Window for a new Dialog. The simplest useful dialog is probably the version of the \"Basic\" dialog in Figure 11, consisting of a label, text field, and \"Ok\" button. Figure 11. The \"Basic\" Dialog. A dialog can be exported as XML using the \"Export Dialog\" icon above the drawing area (the icon includes a floppy disk which will leave young programmers mystified). The resulting XDL file contains text something like: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE dlg:window PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"dialog.dtd\"> <dlg:window xmlns:dlg=\"https://openoffice.org/2000/dialog\" xmlns:script=\"https://openoffice.org/2000/script\" dlg:id=\"Basic\" dlg:left=\"52\" dlg:top=\"44\" dlg:width=\"173\" dlg:height=\"34\" dlg:closeable=\"true\" dlg:moveable=\"true\" dlg:title=\"Basic Dialog\"> <dlg:styles> <dlg:style dlg:style-id=\"0\" dlg:background-color=\"0xeeeeee\" dlg:font-height=\"10\"/> </dlg:styles> <dlg:bulletinboard> <dlg:text dlg:style-id=\"0\" dlg:id=\"Label1\" dlg:tab-index=\"0\" dlg:left=\"6\" dlg:top=\"11\" dlg:width=\"38\" dlg:height=\"8\" dlg:value=\"Enter input:\"/> <dlg:textfield dlg:id=\"TextField1\" dlg:tab-index=\"1\" dlg:left=\"41\" dlg:top=\"7\" dlg:width=\"83\" dlg:height=\"14\"/> <dlg:button dlg:id=\"CommandButton1\" dlg:tab-index=\"2\" dlg:left=\"137\" dlg:top=\"9\" dlg:width=\"28\" dlg:height=\"12\" dlg:value=\"Ok\"/> </dlg:bulletinboard> </dlg:window> The code in EzHighlightAddonInpl assumes that the dialog contains a text field called \"TextField1\" and a button called \"CommandButton1\", which is true of the XDL shown above. Of course, it's possible to add more GUI components, as in the next section.","title":"5.  Creating the Dialog"},{"location":"46-Addons.html#51-the-ezhighlight-dialog","text":"The dialog editor has an import icon to the left of the export icon, which can be used to load an XDL file for modification. I copied the \"Basic\" XDL file, renaming it to \"EzHighlight.xdl\", and imported it; a few changes and additions later, it looked as shown in Figure 12. Figure 12. The EzHighlight.xdl Dialog. The exported XML is: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE dlg:window PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"dialog.dtd\"> <dlg:window xmlns:dlg=\"https://openoffice.org/2000/dialog\" xmlns:script=\"https://openoffice.org/2000/script\" dlg:id=\"EzHighlight\" dlg:left=\"109\" dlg:top=\"73\" dlg:width=\"184\" dlg:height=\"44\" dlg:closeable=\"true\" dlg:moveable=\"true\" dlg:title=\"EzHighlight Text Selector\"> <dlg:styles> <dlg:style dlg:style-id=\"0\" dlg:background-color=\"0xeeeeee\"/> </dlg:styles> <dlg:bulletinboard> <dlg:text dlg:style-id=\"0\" dlg:id=\"Label1\" dlg:tab-index=\"0\" dlg:left=\"8\" dlg:top=\"11\" dlg:width=\"26\" dlg:height=\"10\" dlg:value=\"Enter text:\" dlg:align=\"right\"/> <dlg:textfield dlg:id=\"TextField1\" dlg:tab-index=\"1\" dlg:left=\"39\" dlg:top=\"9\" dlg:width=\"83\" dlg:height=\"12\"/> <dlg:textfield dlg:id=\"TextField2\" dlg:tab-index=\"2\" dlg:left=\"39\" dlg:top=\"26\" dlg:width=\"46\" dlg:height=\"12\" dlg:readonly=\"true\"/> <dlg:text dlg:style-id=\"0\" dlg:id=\"Label2\" dlg:tab-index=\"3\" dlg:left=\"8\" dlg:top=\"27\" dlg:width=\"26\" dlg:height=\"10\" dlg:value=\"Count:\" dlg:align=\"right\"/> <dlg:button dlg:id=\"CommandButton1\" dlg:tab-index=\"4\" dlg:left=\"131\" dlg:top=\"9\" dlg:width=\"46\" dlg:height=\"12\" dlg:value=\"Highlight\"/> </dlg:bulletinboard> </dlg:window> The dialog loading code in EzHighlightAddonInpl.java assumes that the dialog's filename is the same as the command URL name, as can be seen in processCmd(): // part of processCmd() in EzHighlightAddonInpl.java... dialog = Dialogs . loadAddonDialog ( \"org.openoffice.ezhighlightAddon\" , \"dialogLibrary/\" + cmd + \".xdl\" ); processCmd() also assumes that the XDL file is in a dialogLibrary/ sub-directory. I'll explain how this is part of the add-on's OXT file in a later section. Dialogs.loadAddonDialog() is defined as: // in the Dialogs class public static XDialog loadAddonDialog ( String extensionID , String dialogFnm ) { XDialogProvider dp = Lo . createInstanceMCF ( XDialogProvider . class , \"com.sun.star.awt.DialogProvider\" ); if ( dp == null ) { System . out . println ( \"Could not access the Dialog Provider\" ); return null ; } try { return dp . createDialog ( \"vnd.sun.star.extension://\" + extensionID + \"/\" + dialogFnm ); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not load the dialog: \\\"\" + dialogFnm + \"\\\": \" + e ); return null ; } } // end of loadAddonDialog() The crucial line is the call to XDialogProvider.createDialog(), which constructs the dialog name: vnd . sun . star . extension : //org.openoffice.ezhighlightAddon/ dialogLibrary / EzHighlight The dialog is loaded from the ezhighlightAddon extension.","title":"5.1.  The EzHighlight Dialog"},{"location":"46-Addons.html#52-listening-to-the-dialog","text":"Back in processCmd(), listeners are attached to the loaded dialog, and the dialog is made visible on-screen: // in processCmd() in EzHighlightAddonInpl.java... XControl dialogControl = Dialogs . getDialogControl ( dialog ); initDialog ( dialogControl ); Dialogs . execute ( dialogControl ); Dialogs.getDialogControl() casts the XDialog into an XControl: // in the Dialogs class public static XControl getDialogControl ( XDialog dialog ) { return Lo . qi ( XControl . class , dialog ); } The initDialog() method inside EzHighlightAddonInpl.java attaches three listeners to the dialog: a window listener, an action listener for the \"CommandButton1\" button, and a key listener for the \"TextField1\" text field: // in the EzHighlightAddonInpl class // globals private XTextComponent textBox ; // the text in the dialog's text field private void initDialog ( XControl dialogControl ) { // listen to the dialog window XTopWindow topWin = Dialogs . getDialogWindow ( dialogControl ); topWin . addTopWindowListener ( this ); // Dialogs.showControlInfo(dialogControl); // set listener for Ok button XButton button = Lo . qi ( XButton . class , Dialogs . findControl ( dialogControl , \"CommandButton1\" )); button . addActionListener ( this ); // set listener for text box textBox = Lo . qi ( XTextComponent . class , Dialogs . findControl ( dialogControl , \"TextField1\" )); XWindow xTFWindow = ( XWindow ) Lo . qi ( XWindow . class , textBox ); xTFWindow . addKeyListener ( this ); xTFWindow . setFocus (); } // end of initDialog() These controls and listeners are all from Office's com.sun.star.awt module. The dialog and listeners will be invoked by Office at run time, and so should use its API, not Java's Swing. The call to Dialogs.showControlInfo() is commented out in initDialog(), but is a useful way to double-check the dialog's internal construction, and particularly the IDs of its components. showControlInfo() prints to standard output which will be displayed in the Console window. Figure 13 reports the structure of the EzHighlight.xdl dialog from Figure 12. Figure 13. The Console Window Showing Dialog Details. The dialog contains five components: two labels, two text fields, and a button. Dialogs.findControl() uses a control's name to find it inside a dialog: // in Dialogs class public static XControl findControl ( XControl dialogCtrl , String name ) { XControlContainer ctrlCon = Lo . qi ( XControlContainer . class , dialogCtrl ); return ctrlCon . getControl ( name ); } initDialog() converts the returned \"CommandButton1\" control into an XButton, and the \"TextField1\" control into an XTextComponent so that listeners can be attached to them. EzHighlightAddonInpl implements all of the listener interfaces used by the dialog: XActionListener, XTopWindowListener, and XKeyListener. XActionListener.actionPerformed() deals with button presses, XTopWindowListener.windowClosing() listens for the closing of the dialog, and XKeyListener.keyPressed() captures the user typing into the text field: // in the EzHighlightAddonInpl class // globals private XDialog dialog = null ; private XTextComponent textBox ; public void actionPerformed ( ActionEvent e ) { String info = textBox . getText (); if ( info . equals ( \"\" )) return ; System . out . println ( \"Info: \\\"\" + info + \"\\\"\" ); textBox . setText ( \"\" ); // ADD code here } // end of actionPerformed() public void windowClosing ( EventObject event ) { dialog . endExecute (); } public void keyPressed ( KeyEvent event ) { if ( event . KeyCode == Key . RETURN ) { String info = textBox . getText (); if ( info . equals ( \"\" )) return ; System . out . println ( \"Info: \\\"\" + info + \"\\\"\" ); textBox . setText ( \"\" ); // ADD code here } } // end of keyPressed() The template generated code for actionPerformed() and keyPressed() only print information to the Console window. Add-on specific functionality is added next.","title":"5.2.  Listening to the Dialog"},{"location":"46-Addons.html#6-completing-the-implementation-of-ezhighlightaddoninpl","text":"The completion of EzHighlightAddonInpl.java takes the form of new code in processCmd(), initDialog(), actionPerformed(), and keyPressed(), and a few new global variables. processCmd() converts the XComponent document returned by Lo.addonInitialize() into an XTextDocument, assuming that the currently loaded document is text-based. If it isn't then there's no point continuing: // in the EzHighlightAddonInpl class // globals private XTextDocument textDoc ; // in processCmd() : XComponent doc = Lo . addonInitialize ( xcc ); // added textDoc = Write . getTextDoc ( doc ); if ( textDoc == null ) return ; : initDialog() is extended to access the word count text field. It's only used to report the number of changes, so doesn't need a listener: // in the EzHighlightAddonInpl class // globals private XTextComponent countTextBox ; // in initDialog() : // get a reference to the count text field; added countTextBox = Lo . qi ( XTextComponent . class , Dialogs . findControl ( dialogControl , \"TextField2\" )); : actionPerformed() and keyPressed() must trigger the highlighting code, which is implemented in applyEzHighlighting(): // added to actionPerformed() : int count = applyEzHighlighting ( info ); countTextBox . setText ( \"\" + count ); // added to keyPressed() : int count = applyEzHighlighting ( info ); countTextBox . setText ( \"\" + count ); applyEzHighlighting() is passed the text entered by the user through the dialog. It uses the XReplaceable and XReplaceDescriptor interfaces to perform a search and replace through the document. This technique, and very similar code, was explained in Chapter 9. applyEzHighlighting() is: // in the EzHighlightAddonInpl class // globals private XTextDocument textDoc ; private int applyEzHighlighting ( String searchKey ) /* Matches whole words and is case sensitive. Highlights in bold and red; */ { System . out . println ( \"applyEzHighlighting(): \" + searchKey ); XReplaceable repl = Lo . qi ( XReplaceable . class , textDoc ); XReplaceDescriptor desc = repl . createReplaceDescriptor (); /* Get a XPropertyReplace object for altering the properties of the replaced text */ XPropertyReplace propReplace = Lo . qi ( XPropertyReplace . class , desc ); // Set the replaced text to bold and red PropertyValue wv = new PropertyValue ( \"CharWeight\" , - 1 , FontWeight . BOLD , PropertyState . DIRECT_VALUE ); PropertyValue cv = new PropertyValue ( \"CharColor\" , - 1 , Color . RED . getRGB (), PropertyState . DIRECT_VALUE ); PropertyValue [] props = new PropertyValue [] { cv , wv }; try { propReplace . setReplaceAttributes ( props ); // Only match whole words and be case sensitive desc . setPropertyValue ( \"SearchCaseSensitive\" , true ); desc . setPropertyValue ( \"SearchWords\" , true ); } catch ( com . sun . star . uno . Exception ex ) { System . out . println ( \"Error setting up search properties\" ); return - 1 ; } /* Replaces all instances of searchKey with new Text properties and gets the number of changed instances */ desc . setSearchString ( searchKey ); desc . setReplaceString ( searchKey ); return repl . replaceAll ( desc ); } // end of applyEzHighlighting()","title":"6.  Completing the Implementation of EzHighlightAddonInpl"},{"location":"46-Addons.html#7-configuring-the-add-on","text":"An add-on OXT file requires two configuration files not used by an UNO component: ProtocolHandler.xcu and Addon.xcs.","title":"7.  Configuring the Add-on"},{"location":"46-Addons.html#71-protocolhandlerxcu","text":"ProtocolHandler.xcu specifies which command URLs will be handled by the component. The contents of the file for EzHighlight are: <?xml version='1.0' encoding='UTF-8'?> <oor:component-data oor:name=\"ProtocolHandler\" oor:package=\"org.openoffice.Office\" xmlns:oor=\"https://openoffice.org/2001/registry\" xmlns:xs=\"https://w3.org/2001/XMLSchema\" xmlns:xsi=\"https://w3.org/2001/XMLSchema-instance\"> <node oor:name=\"HandlerSet\"> <node oor:name=\"EzHighlightAddonImpl\" oor:op=\"replace\"> <prop oor:name=\"Protocols\" oor:type=\"oor:string-list\"> <value>org.openoffice.ezhighlightAddon:*</value> </prop> </node> </node> </oor:component-data> The \"EzHighlightAddonImpl\" component will handle all command URLs that begin with the \"org.openoffice.ezhighlightAddon\" extension ID. The \"all\" is specified using the * wildcard. The component name is the name of the generated Java class.","title":"7.1.  ProtocolHandler.xcu"},{"location":"46-Addons.html#72-addonxcs","text":"Addon.xcs defines the add-on's GUI elements, such as its menu and toolbar items (i.e. as seen in Figures 2, 3, and 5). Figure 14 illustrates how the file may set up to five attributes: Figure 14. The Addon.xcs GUI Elements. The \"AddonMenu\" attribute defines the look of the menu item that appears at the end of Office's Tool > Add-ons menu, as in Figure 2. The \"OfficeToolbar\" attribute specifies the appearance of the floating toolbar reached via View > Toolbars > Add-on , as in Figure 3. The \"OfficeMenubar\" attribute is used to add a menu item to Office's main menu bar, which seems a rather poor GUI design choice, so I've chosen not to use it. The OfficeHelp\" attribute creates the add-on's help menu item on Office's Help menu, as in Figure 5. The \"Images\" attribute defines the icons that appear next to the text in the menu and toolbar items. If you look back at Figures 2 and 3, you'll see that no icons appear, but this isn't for want of me trying. This feature seems to be broken, but I'll still explain how to set it up. Aside from \"Images\", the attributes have a similar structure: a menu or toolbar item with five sub-attributes: URL, Title, ImageIdentifier, Context, and Target; I'll not be using sub-menu attributes. The best explanation of Addon.xcs' structure is \"How to distribute your macros with an Addon\" by Bernard Marcelly at https://openoffice.org/documentation/HOW_TO/various_topics/Addons1_1en.pdf , which dates from 2003.","title":"7.2.  Addon.xcs"},{"location":"46-Addons.html#addonmenu-attribute","text":"The \"AddonMenu\" attribute used by the EzHighlight add-on is: <node oor:name=\"AddonMenu\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:EzHighlight</value> </prop> <prop oor:name=\"Title\" oor:type=\"xs:string\"> <value>EzHighlight Text</value> </prop> <prop oor:name=\"ImageIdentifier\" oor:type=\"xs:string\"> <value/> </prop> <prop oor:name=\"Context\" oor:type=\"xs:string\"> <value>com.sun.star.text.TextDocument</value> </prop> <prop oor:name=\"Target\" oor:type=\"xs:string\"> <value>_self</value> </prop> </node> </node> The \"URL\" attribute holds the command URL which is dispatched by Office when the menu item is clicked. The \"Title\" attribute contains the menu item's text, and \"ImageIdentifier\" can be assigned the path to a PNG or BMP file for the text's icon. \"ImageIdentifier\" is left empty here since all the images are defined in the \"Images\" attribute, explained below. The \"Context\" attribute is assigned the document service for the Office application utilizing the add-on. EzHighlight is accessible only from Writer, so \"Context\"'s value is \"com.sun.star.text.TextDocument\". Other application/service mappings are shown in Table 1. Office Application Document Service Writer com.sun.star.text.TextDocument Calc com.sun.star.sheet.SpreadsheetDocument Impress com.sun.star.presentation.PresentationDocument Draw com.sun.star.drawing.DrawingDocument Formula com.sun.star.formula.FormulaProperties Chart com.sun.star.chart.ChartDocument Bibliography com.sun.star.frame.Bibliography Table 1. Office Application/Service Mappings Used by \"Context\" If the \"Context\" field isn't assigned a value, then the add-on will be available in all of Office's applications. The \"Target\" field can be assigned four values: \"_top\", \"_parent\", \"_blank\", and \"_self\", but I've never seen any other value used but \"_self\".","title":"\"AddonMenu\" Attribute"},{"location":"46-Addons.html#officetoolbar-attribute","text":"Figure 2 (EzHighlight's menu item) and Figure 3 (its toolbar item) look the same, and respond in the same way when clicked, so it's no great surprise that the \"OfficeToolbar\" attribute in Addon.xcs is almost exactly the same as \"AddonMenu\": <node oor:name=\"OfficeToolBar\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <node oor:name=\"m1\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:EzHighlight</value> </prop> <prop oor:name=\"Title\" oor:type=\"xs:string\"> <value>EzHighlight Text</value> </prop> <prop oor:name=\"ImageIdentifier\" oor:type=\"xs:string\"> <value/> </prop> <prop oor:name=\"Context\" oor:type=\"xs:string\"> <value>com.sun.star.text.TextDocument</value> </prop> <prop oor:name=\"Target\" oor:type=\"xs:string\"> <value>_self</value> </prop> </node> </node> </node> The difference is an extra attribute which allows a toolbar to hold several items. In the description above, there's one item labeled as \"m1\". The labels can be any unique string, but \"m\" followed by a number is used in most examples.","title":"\"OfficeToolbar\" Attribute"},{"location":"46-Addons.html#officehelp-attribute","text":"The \"OfficeHelp\" attribute is similar to \"OfficeToolbar\" and \"AddonMenu\", but dispatches a different command URL (\"org.openoffice.ezhighlightAddon:help\") and its menu item uses a different title (\"About EzHighlight\"). <node oor:name=\"OfficeHelp\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:help</value> </prop> <prop oor:name=\"Title\" oor:type=\"xs:string\"> <value xml:lang=\"en-US\">About EzHighlight</value> </prop> <prop oor:name=\"ImageIdentifier\" oor:type=\"xs:string\"> <value/> </prop> <prop oor:name=\"Context\" oor:type=\"xs:string\"> <value>com.sun.star.text.TextDocument</value> </prop> <prop oor:name=\"Target\" oor:type=\"xs:string\"> <value>_self</value> </prop> </node> </node>","title":"\"OfficeHelp\" Attribute"},{"location":"46-Addons.html#images-attribute","text":"The \"Images\" attribute specifies the icons used by the GUI elements. An image can be either big or small (26x26 or 16x16 pixels), high contrast or normal, and loaded from a file or coded as hexadecimal text. These different combinations mean there are eight variants to choose from, each with a different property name, which are listed in Table 2. Size in Pixels Contrast Hexadecimal text File name 16x16 normal ImageSmall ImageSmallURL 16x16 high ImageSmallHC ImageSmallHCURL 26x26 normal ImageBig ImageBigURL 26x26 high ImageBigHC ImageBigHCURL Table 2. Image Property Names. The \"Images\" attribute for EzHighlight is: <node oor:name=\"Images\"> <node oor:name=\"org.openoffice.ezhighlightAddon\" oor:op=\"replace\"> <prop oor:name=\"URL\" oor:type=\"xs:string\"> <value>org.openoffice.ezhighlightAddon:EzHighlight</value> </prop> <node oor:name=\"UserDefinedImages\"> <prop oor:name=\"ImageSmallURL\"> <value>%origin%/images/ezhighlight16.png</value> </prop> <prop oor:name=\"ImageBigURL\"> <value>%origin%/images/ezhighlight26.png</value> </prop> </node> </node> </node> The \"UserDefinedImages\" sub-attribute specifies two sizes of normal contrast image, supplied as filenames. %origin% stands for the OXT file, so the two icons are stored in the images/ subdirectory inside that zipped file. The images will be used for the menu and toolbar items associated with the \"org.openoffice.ezhighlightAddon:EzHighlight\" command URL. Unfortunately, the images don't appear, as shown in Figures 2 and 3. The hexadecimal text definition of a small image would be something like: <prop oor:name=\"ImageSmall\"> <value>89504E470D0A1A0A0000000D494844520000001000000 01008060000001FF3FF610000024F494 ... // more numbers </value> </prop> One way to obtain an image's hexadecimal text is to call my ImageHex.java program which prints it to stdout. Unfortunately, the icon still doesn't appear, even when specified in this form.","title":"\"Images\" Attribute"},{"location":"46-Addons.html#8-building-and-installing-the-oxt-file","text":"Figure 7 shows the stages in building and installing the add-on as an extension. These steps are carried out by my installAddon.bat script, which assumes that the various configuration files have already been created and are in certain locations. The completed EzHighlightAddonImpl.java file is compiled, then added to EzHighlight.jar with a manifest that refers to Utils.jar: RegistrationClassName : EzHighlightAddonImpl Class - Path : Utils . jar Utils.jar contains my support classes, which may be required by the add-on at run- time. installAddon.bat will add it to the OXT file along with EzHighlight.jar. installAddon.bat assumes that the add-on configuration files are in a sub-directory with the same name as the add-on. For example, when it's processing the EzHighlight add-on, it looks for a EzHighlight/ folder with the following structure: EzHighlight | Addons.xcu | description.xml | license.txt | package-description.txt | ProtocolHandler.xcu | Utils.jar | +---dialogLibrary | EzHighlight.xdl | +---images | ezhighlight.png | ezhighlight16.png | ezhighlight26.png | \\---META-INF manifest.xml EzHighlight.jar is moved into EzHighlight/, and the folder is zipped into EzHighlight.oxt. The extension is installed into Office using the unopkg tool, in the same way as the UNO component of the last chapter. EzHighlight/ contains three configuration files: ProtocolHandler.xcu, Addons.xcu, and description.xml. description.xml plays the same role as the same-named file for UNO components. Its contents use the same XML attributes: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <description xmlns=\"https://openoffice.org/extensions/description/2006\" xmlns:d=\"https://openoffice.org/extensions/description/2006\" xmlns:xlink=\"https://w3.org/1999/xlink\"> <identifier value=\"org.openoffice.ezhighlightAddon\"/> <version value=\"0.1\"/> <display-name> <name lang=\"en\">EzHighlight Addon</name> </display-name> <publisher> <name xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\" lang=\"en\">Andrew Davison</name> </publisher> <registration> <simple-license accept-by=\"user\" > <license-text xlink:href=\"license.txt\" lang=\"en\"/> </simple-license> </registration> <extension-description> <src lang=\"en-US\" xlink:href=\"package-description.txt\"/> </extension-description> <icon> <default xlink:href=\"images/ezhighlight.png\" /> </icon> <update-information> <src xlink:href=\"https://fivedots.coe.psu.ac.th/~ad/jlop/\"/> </update-information> <dependencies> <OpenOffice.org-minimal-version value=\"3.4\" d:name=\"OpenOffice.org 3.4\"/> </dependencies> <platform value=\"all\" /> </description> The biggest difference is that the extension icon is located in the images/ subdirectory inside EzHighlight/. license.txt and package-description.txt are referenced in the description, which explains why those files are in EzHighlight/. The dialog description (EzHighlight.xdl) is stored in its own subdirectory, dialogLibrary/, to match the dialog loading code in EzHighlightAddonInpl.java: // in processCmd() dialog = Dialogs . loadAddonDialog ( \"org.openoffice.ezhighlightAddon\" , \"dialogLibrary/\" + cmd + \".xdl\" ); The images/ subdirectory contains the extension manager icon (ezhighlight.png) and two sizes of GUI icons (ezhighlight16.png and ezhighlight26.png). The GUI icons must be inside images/ to match the locations specified in the \"Images\" attribute in Addon.xcs.","title":"8.  Building and Installing the OXT File"},{"location":"47-Calc_Add-ins.html","text":"Chapter 47. Calc Add-ins \u00b6 Topics Implementing a Calc Add-in; The IDL definitions of the Functions; XCU creation Example folders: \"Addin Tests\" and \"Utils\" Calc Add-ins are extensions containing spreadsheet functions; my Doubler add-in contains three: doubler() for doubling a supplied value, doublerSum() for summing a cell range after doubling each cell value, and sortByFirstCol() which sorts a supplied cell range returning an array sorted into ascending order based on the first column. Figure 1 shows the Doubler add-in as the first entry in the extension manger after it's been installed in Office. Figure 1. The Doubler Calc Add-in, and other Extensions. I created a small spreadsheet in calcTest.ods using doubler(), doublerSum(), and sortByFirstCol(), which is displayed in Figure 2. Figure 2. Calc Add-in Functions Used in a Spreadsheet. doubler() is called six times to double the values in the \"A\" column, storing them in the \"B\" column. doublerSum() is called twice to double and sum the \"A\" and \"B\" columns, placing the results in C2 and C3. sortByFirstCol() sorts the cell range A1:B6 into ascending order by the values in the \"A\" column, and stores the resulting array in D1:E6. sortByFirstCol() is as an example of an Array function (or formula) because it returns an array which is written into a block of cells (i.e. D1:E6). The slightly tricky way of doing that is to select the block before typing \"=sortByFirstCol(A1:B6)\" into the formula text bar, and then press Shift+Ctrl+Enter instead of the Enter key. The cell range output is denoted by curly braces surrounding the function, which are just visible in the bottom screenshot in Figure 2. Alternatively, the Function Wizard can be called, and its Array box checked as the function's inputs are specified, as in Figure 3. Figure 3. The Function Wizard and sortByFirstCol() The add-in functions from the Doubler extension, and other Office extensions, are listed under the Add-in\" category of the Function Wizard, as shown in Figure 4. Figure 4. The Function Wizard's Add-in Category. If you're unfamiliar with the Function Wizard, then you should download the Calc Guide from https://th.libreoffice.org/get-help/documentation/ . Chapter 7 is about formulas and functions, and Appendix B lists the functions by categories, including the add-ins which come with Calc. The functions-by-category data is also online at https://help.libreoffice.org/Calc/Functions_by_Category/ An interesting wiki page comparing the features of the current version of LibreOffice and MS Office can be found at https://wiki.documentfoundation.org/Feature_Comparison:_LibreOffice_-_Microsoft_Office/ . The spreadsheet section states that LibreOffice Calc has 500 functions versus 468 in MS Excel, with a large overlap between them but with 25 functions unique to Calc 5.2 and 14 unique to Excel 2016. Another interesting comparison is offered by Zeki Bildirici as a spreadsheet at https://wiki.documentfoundation.org/images/c/c6/Excel2013_Calc_Functions_Comparison.ods , which matches functions in Excel 2013 to their equivalents in Calc 3.x. 1. Implementing a Calc Add-in \u00b6 The writing of a Calc add-in became much easier after OpenOffice 2.0.4 was released in 2005, when it became possible to define an add-in as an IDL type, and use the UNO component tools (e.g. idlc, regmerge, javamaker, and uno-skeletonmaker) to generate the add-in's boiler-plate code. Prior to this, the programmer had to write a class that implemented several interfaces including XAddin, XServiceName, and XServiceInfo. I mention this 'ancient' history because the Developer's Guide (no spring chicken itself, having been released in 2009) only explains the pre-2005 approach. There's a lengthy example in chapter 8, which can also be found online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Spreadsheet_Add-Ins/ (or use loGuide \"Spreadsheet Add-Ins\" ). The code (called ExampleAddIn) can be downloaded from https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Spreadsheet According to forum posts, the old approach still works, but I haven\u2019t checked; I'm only going to use the 'new' way of implementing add-ins (post-2005), using IDL types and the UNO component tools. Figure 5 shows the required steps. Figure 5. Implementing a Calc Add-in. One point in favor of this approach is that it's almost identical to the stages needed to create an UNO component, as described in Chapter 45. Figure 5 is very similar to Figure 1 in that chapter, and the batch scripts labeling the arrows are unchanged, except for skelAddin.bat. skelAddin.bat only differs from skelComp.bat of Chapter 45 in a single argument passed to uno-skeletonmaker.exe, which tells it to generate an add-in skeleton rather than a component. The other, more significant, change in Figure 5 is the addition of an XML configuration file called CalcAddin.xcu. It defines the GUI elements for the functions, used by the Function Wizard in Figure 3. A great write-up of this way of coding Calc add-ins by Jan Holst Jensen can be found at https://biochemfusion.com/doc/Calc_addin_howto.html . He explains how to create a DoobieDoo add-in consisting of four Python functions, with the code available at https://wiki.openoffice.org/wiki/Calc/Add-In/Python_How-To/ . There's another good example in the OpenOffice NetBeans integration documentation at https://wiki.openoffice.org/wiki/Calc/Add-In/Project_Type/ . If you skip past the description of NetBeans' project wizard, the generated add-in code section is quite informative. Unlike my example, the add-in can be localized to show documentation in English or German. The specification document for the NetBeans add-in wizard is at https://openoffice.org/specs/sdk/tools/spec_openoffice-netbeans-integration-calc-addin-wizard.odt . In amongst details about dialog structuring, there's some good material on the format of CalcAddin.xcu. I'll explain the XCU format in section 2.5. 2. The IDL definitions of the Functions \u00b6 My Doubler functions (doubler(), doublerSum(), and sortByFirstCol()) are defined in Doubler.idl: #ifndef _org_openoffice_doubler_XDoubler_ #define _org_openoffice_doubler_XDoubler_ #include <com/sun/star/uno/XInterface.idl> module org { module openoffice { module doubler { interface XDoubler { double doubler([in] double value); double doublerSum([in] sequence< sequence< double > > vals); sequence< sequence< double > > sortByFirstCol( [in] sequence< sequence< double > > vals); }; }; }; }; module org { module openoffice { module doubler { service Doubler : XDoubler; }; }; }; #endif The IDL defines an XDoubler interface and Doubler service, both in the org.openoffice.doubler module; XDoubler supports three functions. As mentioned in Chapter 45, the main source for information about IDL types is chapter 3 of the Developer's Guide. The subsection \"Using UNOIDL to Specify New Components\" explains how to define an interface, and the same information is online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Using_UNOIDL_to_Specify_New_Components/ (or use loGuide \"Using UNOIDL\" ). However, add-in functions only support a subset of the IDL input and return types. Input arguments must use \"[in]\", and are restricted to the types long, double, string, and any. Sequences must be two-dimensional (e.g. sequence< sequence >), because they're used to represent cell ranges in the spreadsheet. It's possible to use the XCellRange and XPropertySet as input types, and use sequence as the type of the last argument so it will be assigned the inputs not used by previous arguments. Return types can be long, double, string, and any, or a 2D sequence (e.g. sequence< sequence >) which can be assigned to a cell range in the spreadsheet. XVolatileResult is a special return type which represents a result that may change over time; its value is automatically updated in the cell containing the function. Details on how IDL types are mapped to Java can be found in chapter 2 of the guide, starting at the \"Type Mapping\" subsection (online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/ProUNO/Java/Type_Mappings/ , or via loGuide \"Type Mappings\" ). The Java versions of the add-in function types are also detailed in the online documentation for the AddIn service (use lodoc Addin to find the page). 2.1. Converting IDL into Java Code \u00b6 Figure 5 shows the steps needed to convert Doubler.idl into partial Java code for the add-in functions. The idlc.bat, regmerge.bat, and javamaker.bat scripts are unchanged from Chapter 45, and skelAddin.bat only differs from that chapter's skelComp.bat by calling javamaker.exe with a \"calc-add-in\" argument rather than \"component\". The four calls used to generate the Java code are: > idlc.bat Doubler > regmerge.bat Doubler > javamaker.bat Doubler > skelAddin.bat Doubler or they can be called collectively through genCode.bat: > genCode Doubler Since idlc.bat and skelAddin.bat copy files into \"Program Files/\", they must be run with Administrative privileges, as in Chapter 45. The end result is DoublerImpl.java, which contains all the necessary boiler-plate code, and three stub functions: // part of DoublerImpl.java... public double doubler ( double value ) { return 0 ; } public double doublerSum ( double [][] vals ) { return 0 ; } public double [][] sortByFirstCol ( double [][] vals ) { return new double [ 0 ][ 0 ] ; } In a spreadsheet, doublerSum() and sortByFirstCol() can be passed cell range arguments (e.g. =doublerSum(A1:A6)), which are treated as 2D arrays. The transformation retains the row ordering of the cells in the array, as illustrated by Figure 6. Figure 6. From Cell Range to Input Array, and Output Array to Cell Range. The same mapping is used in reverse if the function returns a 2D array, as in the case of sortByFirstCol(). 2.2. Implementing the Add-in Functions \u00b6 Implementing doubler() and doublerSum() is easy, but I had some problems with sortByFirstCol() when using Java's Arrays.sort(). The code was initially: // added at the start of DoublerImpl.java... import java.util.* ; // import for Arrays and Comparator classes private static final String LOG_FNM = \"c:\\\\arrayInfo.txt\" ; // for debugging // : // completed function stubs public double doubler ( double value ) { return value * 2 ; } public double doublerSum ( double [][] vals ) { double sum = 0 ; for ( int i = 0 ; i < vals . length ; i ++ ) for ( int j = 0 ; j < vals [ i ] . length ; j ++ ) sum += vals [ i ][ j ]* 2 ; return sum ; } // end of doublerSum() public double [][] sortByFirstCol ( double [][] vals ) { FileIO . appendTo ( LOG_FNM , Lo . getTimeStamp () + \": sortByFirstCol()\" ); selectionSort ( vals ); for ( int i = 0 ; i < vals . length ; i ++ ) FileIO . appendTo ( LOG_FNM , \" \" + Arrays . toString ( vals [ i ] )); return vals ; } // end of sortByFirstCol() private void selectionSort ( double [][] vals ) // ascending order based on first column of vals; FAILS ?? { Arrays . sort ( vals , new Comparator < double []> () { public int compare ( double [] row1 , double [] row2 ) // compare first column of each row { FileIO . appendTo ( LOG_FNM , \"compared\" ); // never reached ?? return Double . compare ( row1 [ 0 ] , row2 [ 0 ] ); } }); } // end of selectionSort() FileIO.appendTo() is my way of debugging add-in functions by appending messages to a file. Its main drawback is the lack of a UNIX-like tail command in Windows for monitoring the end of a file; I use tail.exe from the Gow UNIX utilities for Windows ( https://github.com/bmatzelle/gow/wiki/ ). The above version of sortByFirstCol() fails without returning an array for the cell range D1:E6, as can be seen by the block of #VALUE! text in Figure 7. Figure 7. sortByFirstCol() Failing in calcTest.ods. The debugging text written to the log (c:/arrayInfo.txt) shows that Arrays.sort() fails, although why is a mystery. I replaced selectionSort() with my own insertion sort: // part of DoublerImpl.java... private void selectionSort ( double [][] vals ) // ascending order based on first column of vals; WORKS! { double [] temp ; for ( int i = vals . length - 1 ; i > 0 ; i -- ) { int first = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( vals [ j ][ 0 ] > vals [ first ][ 0 ] ) // compare first col values first = j ; } temp = vals [ first ] ; // swap rows vals [ first ] = vals [ i ] ; vals [ i ] = temp ; } } // end of selectionSort() This version of sortByFirstCol() works correctly, and the spreadsheet looks like the screenshot at the bottom of Figure 2. The debugging text confirms the sorting: 2016-11-02 14:04:21: sortByFirstCol() [1.0, 2.0] [3.0, 6.0] [5.0, 10.0] [6.0, 12.0] [8.0, 16.0] [12.0, 24.0] The add-in functions in DoublerImpl.java make use of two of my utility functions, namely Lo.getTimeStamp() and FileIO.appendTo(), so the add-in extension must include utils.jar. 2.3. Functions that use Global State (a Bad Idea) \u00b6 The Java code generated by uno-skeletonmaker.exe includes a reference to Office's component context, stored as a XComponentContext reference: private final XComponentContext m_xContext ; // in DoublerImpl.java The variable is initialized in the constructor: public DoublerImpl ( XComponentContext context ) { m_xContext = context ; } This reference can be used to initialize the globals used by my Lo utility library and other support classes, by calling Lo.addonInitialize(): // part of DoublerImpl()... doc = Lo . addonInitialize ( m_xContext ); Lo.addonInitialize() returns an XComponent instance, which refers to the spreadsheet. These additions to DoublerImpl.java make it possible for doubler(), doublerSum(), and sortByFirstCol() to access and change the spreadsheet independently of their input arguments. For example, it's possible to access document information such as the title bar text, and the supported services: // in DoubleImpl.java // global private XComponent doc ; public double doubler ( double value ) { FileIO . appendTo ( LOG_FNM , \"Window title: \" + GUI . getTitleBar ()); FileIO . appendTo ( LOG_FNM , \"Services for this document:\" ); for ( String service : Info . getServices ( doc )) FileIO . appendTo ( LOG_FNM , \" \" + service ); return value * 2 ; } Calls to FileIO.appendTo() are the only way to 'print' information. The lines appended to the log are: Window title: calcTest.ods - LibreOffice Calc Services for this document: com.sun.star.document.OfficeDocument com.sun.star.sheet.SpreadsheetDocument com.sun.star.sheet.SpreadsheetDocumentSettings However, this way of using add-in functions is poor programming style because it becomes hard to know what a function is doing without checking its implementation. For that reason, I'd avoid this kind of coding unless absolutely necessary. 2.4. Problems with Office Types \u00b6 The input argument types for add-in functions are usually long, double, string, any, or a sequence, but it's also possible to use XCellRange and XPropertySet. Return types are typically long, double, string, any, or a sequence, but a special case is XVolatileResult. I tried using XCellRange as an input type and XVolatileResult as a return type in two functions in Doubler.idl: #ifndef _org_openoffice_doubler_XDoubler_ #define _org_openoffice_doubler_XDoubler_ #include <com/sun/star/uno/XInterface.idl> #include <com/sun/star/table/XCellRange.idl> #include <com/sun/star/sheet/XVolatileResult.idl> module org { module openoffice { module doubler { interface XDoubler { double doubler([in] double value); double doublerSum([in] sequence< sequence< double > > vals); sequence< sequence< double > > sortByFirstCol( [in] sequence< sequence< double > > vals); long usedCells([in] com::sun::star::table::XCellRange cr); // javamaker cannot process this function com::sun::star::sheet::XVolatileResult counter( [in] string aName, [in] double value); // javamaker cannot process this function }; }; }; }; #endif Office's idlc.exe and regmerge.exe tools are happy to process these types, but javamaker.exe always fails to recognize 'com.sun.star.table.XCellRange' and 'com.sun.star.sheet.XVolatileResult', reporting an \"Unknown entity\" error. I tried calling javamaker with the inclusion of extra Office RDB files, such as services.rdb and offapi.rdb, but with no success. I was unable to find an add-in example online that uses XCellRange, perhaps because it's more natural to pass a cell range to a function as an array. XVolatileResult is utilized by the example in the Developer's Guide (ExampleAddIn at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Spreadsheet ), but it employs the old add-in coding style based on implementing the XAddIn interface. 2.5. Creating CalcAddIn.xcu \u00b6 The second half of the Calc add-in development process shown in Figure 5 starts when the programmer has finished writing the add-in functions. It uses the same batch scripts as in Chapter 45: compileOrg.bat, toJar.bat, makeOxt.bat, and pkg.bat. The only difference is that the Doubler/ directory zipped up as an OXT file contains a configuration file, CalcAddIn.xcu.. The folder's structure is: Doubler | CalcAddIn . xcu | description . xml | double . png | license . txt | package - description . txt | Utils . jar | \\ --- META - INF manifest . xml makeOxt.bat moves the Doubler.rdb type data and DoublerImpl.jar into Doubler/, and zips the contents into Doubler.oxt. CalcAddin.xcu contains an XML description for each function in Doubler. For example, sortByFirstCol() is represented by: <node oor:name=\"sortByFirstCol\" oor:op=\"replace\"> <prop oor:name=\"DisplayName\"> <value xml:lang=\"en\">sortByFirstCol</value></prop> <prop oor:name=\"Description\"> <value xml:lang=\"en\">sorts a cell range into ascending order using the first column values of the range</value></prop> <prop oor:name=\"Category\"> <value>Add-In</value></prop> <prop oor:name=\"CompatibilityName\"> <value xml:lang=\"en\">sortByFirstCol</value></prop> <node oor:name=\"Parameters\"> <node oor:name=\"vals\" oor:op=\"replace\"> <prop oor:name=\"DisplayName\"> <value xml:lang=\"en\">cell range</value></prop> <prop oor:name=\"Description\"> <value xml:lang=\"en\">range of doubles</value></prop> </node> </node> </node> There are five fields: \"DisplayName\", \"Description\", \"Category\", \"CompatibilityName\", and \"Parameters\", most of which are utilized by Office's Function Wizard, as shown in Figure 3. The \"Category\" value can be any of the wizard's pop-down list categories, but \"Add- In\" seems the best choice. If you want to use one of the others, a complete list is given in the documentation for getProgrammaticCategoryName() in the XAddin class (use lodoc XAddin to access the page). The simplest value to use for \"CompatibilityName\" is the function's name. This becomes important when the spreadsheet is exported as an Excel XLS file, when the function's name is replaced by this string. According to Jan Holst Jensen in his \"Calc Add-in How-to\" article ( https://biochemfusion.com/doc/Calc_addin_howto.html ), it's possible to supply the name of a .NET or COM Automation function in this field, and have the exported spreadsheet correctly call that Excel function, but I haven't tried that myself. The \"Parameters\" field may contain several sub-nodes, one for each function argument. Each node maps the argument's name in the IDL definition to text shown by the Function Wizard. For example, the IDL definition for sortByFirstCol() is: sequence< sequence< double > > sortByFirstCol( [in] sequence< sequence< double > > vals); The \"vals\" argument is mapped to a display name and description used by the Function Wizard in Figure 3.","title":"Chapter 47. Calc Add-ins"},{"location":"47-Calc_Add-ins.html#chapter-47-calc-add-ins","text":"Topics Implementing a Calc Add-in; The IDL definitions of the Functions; XCU creation Example folders: \"Addin Tests\" and \"Utils\" Calc Add-ins are extensions containing spreadsheet functions; my Doubler add-in contains three: doubler() for doubling a supplied value, doublerSum() for summing a cell range after doubling each cell value, and sortByFirstCol() which sorts a supplied cell range returning an array sorted into ascending order based on the first column. Figure 1 shows the Doubler add-in as the first entry in the extension manger after it's been installed in Office. Figure 1. The Doubler Calc Add-in, and other Extensions. I created a small spreadsheet in calcTest.ods using doubler(), doublerSum(), and sortByFirstCol(), which is displayed in Figure 2. Figure 2. Calc Add-in Functions Used in a Spreadsheet. doubler() is called six times to double the values in the \"A\" column, storing them in the \"B\" column. doublerSum() is called twice to double and sum the \"A\" and \"B\" columns, placing the results in C2 and C3. sortByFirstCol() sorts the cell range A1:B6 into ascending order by the values in the \"A\" column, and stores the resulting array in D1:E6. sortByFirstCol() is as an example of an Array function (or formula) because it returns an array which is written into a block of cells (i.e. D1:E6). The slightly tricky way of doing that is to select the block before typing \"=sortByFirstCol(A1:B6)\" into the formula text bar, and then press Shift+Ctrl+Enter instead of the Enter key. The cell range output is denoted by curly braces surrounding the function, which are just visible in the bottom screenshot in Figure 2. Alternatively, the Function Wizard can be called, and its Array box checked as the function's inputs are specified, as in Figure 3. Figure 3. The Function Wizard and sortByFirstCol() The add-in functions from the Doubler extension, and other Office extensions, are listed under the Add-in\" category of the Function Wizard, as shown in Figure 4. Figure 4. The Function Wizard's Add-in Category. If you're unfamiliar with the Function Wizard, then you should download the Calc Guide from https://th.libreoffice.org/get-help/documentation/ . Chapter 7 is about formulas and functions, and Appendix B lists the functions by categories, including the add-ins which come with Calc. The functions-by-category data is also online at https://help.libreoffice.org/Calc/Functions_by_Category/ An interesting wiki page comparing the features of the current version of LibreOffice and MS Office can be found at https://wiki.documentfoundation.org/Feature_Comparison:_LibreOffice_-_Microsoft_Office/ . The spreadsheet section states that LibreOffice Calc has 500 functions versus 468 in MS Excel, with a large overlap between them but with 25 functions unique to Calc 5.2 and 14 unique to Excel 2016. Another interesting comparison is offered by Zeki Bildirici as a spreadsheet at https://wiki.documentfoundation.org/images/c/c6/Excel2013_Calc_Functions_Comparison.ods , which matches functions in Excel 2013 to their equivalents in Calc 3.x.","title":"Chapter 47. Calc Add-ins"},{"location":"47-Calc_Add-ins.html#1-implementing-a-calc-add-in","text":"The writing of a Calc add-in became much easier after OpenOffice 2.0.4 was released in 2005, when it became possible to define an add-in as an IDL type, and use the UNO component tools (e.g. idlc, regmerge, javamaker, and uno-skeletonmaker) to generate the add-in's boiler-plate code. Prior to this, the programmer had to write a class that implemented several interfaces including XAddin, XServiceName, and XServiceInfo. I mention this 'ancient' history because the Developer's Guide (no spring chicken itself, having been released in 2009) only explains the pre-2005 approach. There's a lengthy example in chapter 8, which can also be found online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Spreadsheet_Add-Ins/ (or use loGuide \"Spreadsheet Add-Ins\" ). The code (called ExampleAddIn) can be downloaded from https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Spreadsheet According to forum posts, the old approach still works, but I haven\u2019t checked; I'm only going to use the 'new' way of implementing add-ins (post-2005), using IDL types and the UNO component tools. Figure 5 shows the required steps. Figure 5. Implementing a Calc Add-in. One point in favor of this approach is that it's almost identical to the stages needed to create an UNO component, as described in Chapter 45. Figure 5 is very similar to Figure 1 in that chapter, and the batch scripts labeling the arrows are unchanged, except for skelAddin.bat. skelAddin.bat only differs from skelComp.bat of Chapter 45 in a single argument passed to uno-skeletonmaker.exe, which tells it to generate an add-in skeleton rather than a component. The other, more significant, change in Figure 5 is the addition of an XML configuration file called CalcAddin.xcu. It defines the GUI elements for the functions, used by the Function Wizard in Figure 3. A great write-up of this way of coding Calc add-ins by Jan Holst Jensen can be found at https://biochemfusion.com/doc/Calc_addin_howto.html . He explains how to create a DoobieDoo add-in consisting of four Python functions, with the code available at https://wiki.openoffice.org/wiki/Calc/Add-In/Python_How-To/ . There's another good example in the OpenOffice NetBeans integration documentation at https://wiki.openoffice.org/wiki/Calc/Add-In/Project_Type/ . If you skip past the description of NetBeans' project wizard, the generated add-in code section is quite informative. Unlike my example, the add-in can be localized to show documentation in English or German. The specification document for the NetBeans add-in wizard is at https://openoffice.org/specs/sdk/tools/spec_openoffice-netbeans-integration-calc-addin-wizard.odt . In amongst details about dialog structuring, there's some good material on the format of CalcAddin.xcu. I'll explain the XCU format in section 2.5.","title":"1.  Implementing a Calc Add-in"},{"location":"47-Calc_Add-ins.html#2-the-idl-definitions-of-the-functions","text":"My Doubler functions (doubler(), doublerSum(), and sortByFirstCol()) are defined in Doubler.idl: #ifndef _org_openoffice_doubler_XDoubler_ #define _org_openoffice_doubler_XDoubler_ #include <com/sun/star/uno/XInterface.idl> module org { module openoffice { module doubler { interface XDoubler { double doubler([in] double value); double doublerSum([in] sequence< sequence< double > > vals); sequence< sequence< double > > sortByFirstCol( [in] sequence< sequence< double > > vals); }; }; }; }; module org { module openoffice { module doubler { service Doubler : XDoubler; }; }; }; #endif The IDL defines an XDoubler interface and Doubler service, both in the org.openoffice.doubler module; XDoubler supports three functions. As mentioned in Chapter 45, the main source for information about IDL types is chapter 3 of the Developer's Guide. The subsection \"Using UNOIDL to Specify New Components\" explains how to define an interface, and the same information is online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/WritingUNO/Using_UNOIDL_to_Specify_New_Components/ (or use loGuide \"Using UNOIDL\" ). However, add-in functions only support a subset of the IDL input and return types. Input arguments must use \"[in]\", and are restricted to the types long, double, string, and any. Sequences must be two-dimensional (e.g. sequence< sequence >), because they're used to represent cell ranges in the spreadsheet. It's possible to use the XCellRange and XPropertySet as input types, and use sequence as the type of the last argument so it will be assigned the inputs not used by previous arguments. Return types can be long, double, string, and any, or a 2D sequence (e.g. sequence< sequence >) which can be assigned to a cell range in the spreadsheet. XVolatileResult is a special return type which represents a result that may change over time; its value is automatically updated in the cell containing the function. Details on how IDL types are mapped to Java can be found in chapter 2 of the guide, starting at the \"Type Mapping\" subsection (online at https://wiki.openoffice.org/wiki/Documentation/DevGuide/ProUNO/Java/Type_Mappings/ , or via loGuide \"Type Mappings\" ). The Java versions of the add-in function types are also detailed in the online documentation for the AddIn service (use lodoc Addin to find the page).","title":"2.  The IDL definitions of the Functions"},{"location":"47-Calc_Add-ins.html#21-converting-idl-into-java-code","text":"Figure 5 shows the steps needed to convert Doubler.idl into partial Java code for the add-in functions. The idlc.bat, regmerge.bat, and javamaker.bat scripts are unchanged from Chapter 45, and skelAddin.bat only differs from that chapter's skelComp.bat by calling javamaker.exe with a \"calc-add-in\" argument rather than \"component\". The four calls used to generate the Java code are: > idlc.bat Doubler > regmerge.bat Doubler > javamaker.bat Doubler > skelAddin.bat Doubler or they can be called collectively through genCode.bat: > genCode Doubler Since idlc.bat and skelAddin.bat copy files into \"Program Files/\", they must be run with Administrative privileges, as in Chapter 45. The end result is DoublerImpl.java, which contains all the necessary boiler-plate code, and three stub functions: // part of DoublerImpl.java... public double doubler ( double value ) { return 0 ; } public double doublerSum ( double [][] vals ) { return 0 ; } public double [][] sortByFirstCol ( double [][] vals ) { return new double [ 0 ][ 0 ] ; } In a spreadsheet, doublerSum() and sortByFirstCol() can be passed cell range arguments (e.g. =doublerSum(A1:A6)), which are treated as 2D arrays. The transformation retains the row ordering of the cells in the array, as illustrated by Figure 6. Figure 6. From Cell Range to Input Array, and Output Array to Cell Range. The same mapping is used in reverse if the function returns a 2D array, as in the case of sortByFirstCol().","title":"2.1.  Converting IDL into Java Code"},{"location":"47-Calc_Add-ins.html#22-implementing-the-add-in-functions","text":"Implementing doubler() and doublerSum() is easy, but I had some problems with sortByFirstCol() when using Java's Arrays.sort(). The code was initially: // added at the start of DoublerImpl.java... import java.util.* ; // import for Arrays and Comparator classes private static final String LOG_FNM = \"c:\\\\arrayInfo.txt\" ; // for debugging // : // completed function stubs public double doubler ( double value ) { return value * 2 ; } public double doublerSum ( double [][] vals ) { double sum = 0 ; for ( int i = 0 ; i < vals . length ; i ++ ) for ( int j = 0 ; j < vals [ i ] . length ; j ++ ) sum += vals [ i ][ j ]* 2 ; return sum ; } // end of doublerSum() public double [][] sortByFirstCol ( double [][] vals ) { FileIO . appendTo ( LOG_FNM , Lo . getTimeStamp () + \": sortByFirstCol()\" ); selectionSort ( vals ); for ( int i = 0 ; i < vals . length ; i ++ ) FileIO . appendTo ( LOG_FNM , \" \" + Arrays . toString ( vals [ i ] )); return vals ; } // end of sortByFirstCol() private void selectionSort ( double [][] vals ) // ascending order based on first column of vals; FAILS ?? { Arrays . sort ( vals , new Comparator < double []> () { public int compare ( double [] row1 , double [] row2 ) // compare first column of each row { FileIO . appendTo ( LOG_FNM , \"compared\" ); // never reached ?? return Double . compare ( row1 [ 0 ] , row2 [ 0 ] ); } }); } // end of selectionSort() FileIO.appendTo() is my way of debugging add-in functions by appending messages to a file. Its main drawback is the lack of a UNIX-like tail command in Windows for monitoring the end of a file; I use tail.exe from the Gow UNIX utilities for Windows ( https://github.com/bmatzelle/gow/wiki/ ). The above version of sortByFirstCol() fails without returning an array for the cell range D1:E6, as can be seen by the block of #VALUE! text in Figure 7. Figure 7. sortByFirstCol() Failing in calcTest.ods. The debugging text written to the log (c:/arrayInfo.txt) shows that Arrays.sort() fails, although why is a mystery. I replaced selectionSort() with my own insertion sort: // part of DoublerImpl.java... private void selectionSort ( double [][] vals ) // ascending order based on first column of vals; WORKS! { double [] temp ; for ( int i = vals . length - 1 ; i > 0 ; i -- ) { int first = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( vals [ j ][ 0 ] > vals [ first ][ 0 ] ) // compare first col values first = j ; } temp = vals [ first ] ; // swap rows vals [ first ] = vals [ i ] ; vals [ i ] = temp ; } } // end of selectionSort() This version of sortByFirstCol() works correctly, and the spreadsheet looks like the screenshot at the bottom of Figure 2. The debugging text confirms the sorting: 2016-11-02 14:04:21: sortByFirstCol() [1.0, 2.0] [3.0, 6.0] [5.0, 10.0] [6.0, 12.0] [8.0, 16.0] [12.0, 24.0] The add-in functions in DoublerImpl.java make use of two of my utility functions, namely Lo.getTimeStamp() and FileIO.appendTo(), so the add-in extension must include utils.jar.","title":"2.2.  Implementing the Add-in Functions"},{"location":"47-Calc_Add-ins.html#23-functions-that-use-global-state-a-bad-idea","text":"The Java code generated by uno-skeletonmaker.exe includes a reference to Office's component context, stored as a XComponentContext reference: private final XComponentContext m_xContext ; // in DoublerImpl.java The variable is initialized in the constructor: public DoublerImpl ( XComponentContext context ) { m_xContext = context ; } This reference can be used to initialize the globals used by my Lo utility library and other support classes, by calling Lo.addonInitialize(): // part of DoublerImpl()... doc = Lo . addonInitialize ( m_xContext ); Lo.addonInitialize() returns an XComponent instance, which refers to the spreadsheet. These additions to DoublerImpl.java make it possible for doubler(), doublerSum(), and sortByFirstCol() to access and change the spreadsheet independently of their input arguments. For example, it's possible to access document information such as the title bar text, and the supported services: // in DoubleImpl.java // global private XComponent doc ; public double doubler ( double value ) { FileIO . appendTo ( LOG_FNM , \"Window title: \" + GUI . getTitleBar ()); FileIO . appendTo ( LOG_FNM , \"Services for this document:\" ); for ( String service : Info . getServices ( doc )) FileIO . appendTo ( LOG_FNM , \" \" + service ); return value * 2 ; } Calls to FileIO.appendTo() are the only way to 'print' information. The lines appended to the log are: Window title: calcTest.ods - LibreOffice Calc Services for this document: com.sun.star.document.OfficeDocument com.sun.star.sheet.SpreadsheetDocument com.sun.star.sheet.SpreadsheetDocumentSettings However, this way of using add-in functions is poor programming style because it becomes hard to know what a function is doing without checking its implementation. For that reason, I'd avoid this kind of coding unless absolutely necessary.","title":"2.3.  Functions that use Global State (a Bad Idea)"},{"location":"47-Calc_Add-ins.html#24-problems-with-office-types","text":"The input argument types for add-in functions are usually long, double, string, any, or a sequence, but it's also possible to use XCellRange and XPropertySet. Return types are typically long, double, string, any, or a sequence, but a special case is XVolatileResult. I tried using XCellRange as an input type and XVolatileResult as a return type in two functions in Doubler.idl: #ifndef _org_openoffice_doubler_XDoubler_ #define _org_openoffice_doubler_XDoubler_ #include <com/sun/star/uno/XInterface.idl> #include <com/sun/star/table/XCellRange.idl> #include <com/sun/star/sheet/XVolatileResult.idl> module org { module openoffice { module doubler { interface XDoubler { double doubler([in] double value); double doublerSum([in] sequence< sequence< double > > vals); sequence< sequence< double > > sortByFirstCol( [in] sequence< sequence< double > > vals); long usedCells([in] com::sun::star::table::XCellRange cr); // javamaker cannot process this function com::sun::star::sheet::XVolatileResult counter( [in] string aName, [in] double value); // javamaker cannot process this function }; }; }; }; #endif Office's idlc.exe and regmerge.exe tools are happy to process these types, but javamaker.exe always fails to recognize 'com.sun.star.table.XCellRange' and 'com.sun.star.sheet.XVolatileResult', reporting an \"Unknown entity\" error. I tried calling javamaker with the inclusion of extra Office RDB files, such as services.rdb and offapi.rdb, but with no success. I was unable to find an add-in example online that uses XCellRange, perhaps because it's more natural to pass a cell range to a function as an array. XVolatileResult is utilized by the example in the Developer's Guide (ExampleAddIn at https://api.libreoffice.org/examples/DevelopersGuide/examples.html#Spreadsheet ), but it employs the old add-in coding style based on implementing the XAddIn interface.","title":"2.4.  Problems with Office Types"},{"location":"47-Calc_Add-ins.html#25-creating-calcaddinxcu","text":"The second half of the Calc add-in development process shown in Figure 5 starts when the programmer has finished writing the add-in functions. It uses the same batch scripts as in Chapter 45: compileOrg.bat, toJar.bat, makeOxt.bat, and pkg.bat. The only difference is that the Doubler/ directory zipped up as an OXT file contains a configuration file, CalcAddIn.xcu.. The folder's structure is: Doubler | CalcAddIn . xcu | description . xml | double . png | license . txt | package - description . txt | Utils . jar | \\ --- META - INF manifest . xml makeOxt.bat moves the Doubler.rdb type data and DoublerImpl.jar into Doubler/, and zips the contents into Doubler.oxt. CalcAddin.xcu contains an XML description for each function in Doubler. For example, sortByFirstCol() is represented by: <node oor:name=\"sortByFirstCol\" oor:op=\"replace\"> <prop oor:name=\"DisplayName\"> <value xml:lang=\"en\">sortByFirstCol</value></prop> <prop oor:name=\"Description\"> <value xml:lang=\"en\">sorts a cell range into ascending order using the first column values of the range</value></prop> <prop oor:name=\"Category\"> <value>Add-In</value></prop> <prop oor:name=\"CompatibilityName\"> <value xml:lang=\"en\">sortByFirstCol</value></prop> <node oor:name=\"Parameters\"> <node oor:name=\"vals\" oor:op=\"replace\"> <prop oor:name=\"DisplayName\"> <value xml:lang=\"en\">cell range</value></prop> <prop oor:name=\"Description\"> <value xml:lang=\"en\">range of doubles</value></prop> </node> </node> </node> There are five fields: \"DisplayName\", \"Description\", \"Category\", \"CompatibilityName\", and \"Parameters\", most of which are utilized by Office's Function Wizard, as shown in Figure 3. The \"Category\" value can be any of the wizard's pop-down list categories, but \"Add- In\" seems the best choice. If you want to use one of the others, a complete list is given in the documentation for getProgrammaticCategoryName() in the XAddin class (use lodoc XAddin to access the page). The simplest value to use for \"CompatibilityName\" is the function's name. This becomes important when the spreadsheet is exported as an Excel XLS file, when the function's name is replaced by this string. According to Jan Holst Jensen in his \"Calc Add-in How-to\" article ( https://biochemfusion.com/doc/Calc_addin_howto.html ), it's possible to supply the name of a .NET or COM Automation function in this field, and have the exported spreadsheet correctly call that Excel function, but I haven't tried that myself. The \"Parameters\" field may contain several sub-nodes, one for each function argument. Each node maps the argument's name in the IDL definition to text shown by the Function Wizard. For example, the IDL definition for sortByFirstCol() is: sequence< sequence< double > > sortByFirstCol( [in] sequence< sequence< double > > vals); The \"vals\" argument is mapped to a display name and description used by the Function Wizard in Figure 3.","title":"2.5.  Creating CalcAddIn.xcu"},{"location":"48-Event_Macros.html","text":"Chapter 48. Event Macros \u00b6 Topics Macro Locations; Naming Macro Functions; Calling Existing Macros; The LibreLogo Macro; Writing a Simple Event Macro; Automating the Assigning of Event Macros Example folders: \"EvMacro Tests\" and \"Utils\" Event macros are functions triggered by the occurrence of events, either within Office or in Office documents. I'll be using event macros with forms, by attaching them to controls such as buttons and textfields. A key difference between event macros and Java listeners is that macros are attached to Office or to documents rather than being part of an external Java program. In practical terms this means that the macro code becomes part of the Office installation or is embedded inside a document's ODF file. I'll spend two chapters discussing event macros: this chapter focuses on how to use existing Office macros, and how to write a simple event macro that's installed by copying it to a specific Office directory. This approach is obviously not ideal, and so the next chapter looks at installing macros as extensions, and by attaching them to documents. The Developer's Guide discusses macros in chapter 18, \"Scripting Framework\", but macro programming has changed since the guide was produced (e.g. macros can now be written in Python), so it's better to read the more current OpenOffice wiki, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Scripting/Scripting_Framework/ (or use loGuide \"Scripting Framework\" ). Most macro programming resources employ Office Basic, and Java rarely gets mentioned, as in chapter 13, \"Getting Started with Macros\", of the \"Getting Started Guide\" (available at https://libreoffice.org/get-help/documentation/ ). That chapter ends with a useful list of online resources, and printed and eBook materials. Probably the best source for Office Basic macro coding is Andrew Pitonyak's website at https://pitonyak.org/oo.php ; I recommend starting with his book, \"OpenOffice.org Macros Explained\" (OOME), which is free to download. There's also a separate book of collected macros, called AndrewMacros.pdf. Another excellent introduction to Office Basic Macros (written in French) is: Programmation OpenOffice.org et LibreOffice: Macros OOoBasic et API Bernard Marcelly and Laurent Godard Eyrolles, 2011 https://editions-eyrolles.com/Livre/9782212132472/programmation-openoffice-org-et-libreoffice/ Two textbooks that focus on Office Basic macros in a particular Office application: Learn OpenOffice.org Spreadsheet Macro Programming: OOoBasic and Calc Automation Mark Alexander Bain Packt Publishing, 2006 https://packtpub.com/hardware-and-creative/learn-openofficeorg-spreadsheet-macro-programming-ooobasic-and-calc-automation/ Database Programming with OpenOffice.org Base and Basic Roberto Benitez Lulu.com, 2011 https://lulu.com/shop/roberto-benitez/database-programming-with-openofficeorg-base-basic/paperback/product-3568728.html 1. Fantastic Macros and Where to Find Them \u00b6 There are four categories of macros: * user: user macros are available only to the user who added them to Office; * share: share macros can be called by all users of that copy of Office; * extension: extension macros are added to office as an extension, and may be available only to the user or be shared (these are discussed in the next chapter); * document: these macros are added to a document rather than to Office, and so are useable only in that document (see the next chapter). These categories are reflected in how the Office GUI displays installed macros in the Macro Selector dialog of Figure 1 (accessible via the Tools > Macros > \"Run Macros\" menu item). Figure 1. The \"Tools > Macros > Run Macros\" Dialog. The top-level folders in Figure 1 are library containers: \"My Macros\" and \"LibreOffice Macros\" are always present, and store user and share macros respectively. If the currently loaded document contains document macros then there will be a third container with the same name as the file (e.g. \"build.odt\" in Figure 1). Extension macros are grouped under the name of the extension file (e.g. \"FormMacros.oxt\"), and may occur in either \"My Macros\" or \"LibreOffice Macros\" depending on if the extension contains user or share macros. Each library container (e.g. \"My Macros\") can hold multiple libraries; each library can contain multiple modules; each module can store multiple macros. For example, Figure 1 shows that the \"My Macros\" container holds three libraries called \"FormMacros.oxt\", \"Standard\", and \"WikiEditor\". The \"FormMacros.oxt\" library (which holds extension macros) consists of a single \"Utils\" module with two macros called \"GetNumber.get\" and \"GetText.show\". I'll be explaining how to create and install this extension in the next chapter. In addition, the Tools > Macros > \"Organize Macros\" menu gives access to macros according to some of the programming languages supported by Office, but Java isn't included (see Figure 2). As a consequence, I'll use the Macro Selector dialog of Figure 1 from now on. Figure 2. The Tools > Macros > \"Organize Macros\" Menu. 2. Where are Macros Stored? \u00b6 Aside from accessing macros through the Office GUI, it's useful to know where they're located in the directory structure. This is especially true for user and share macros since the easiest way to install them is to copy them into Office's designated folders. However, extension macros are installed using the extension manager, and document macros are added to their document using unzipping and zipping. Finding Office's macro folders can be a bit tricky, since their location varies depending on if the macros are user or share, coded in Office Basic or another language, and on the version of Office and OS. The folders for share macros are probably the easiest to find \u2013 they're located inside \\share (e.g. C:\\Program Files\\LibreOffice 5\\share on my machine). Basic macros are in share\\basic while macros in other languages, such as Java, are in subfolders of share\\Scripts (e.g. see Figure 3). Figure 3. The Non-Basic share\\Scripts Macros Folders. In other words, Java share macros will be in: C:\\Program Files\\LibreOffice 5\\share\\Scripts\\java User macros are stored in an 'application data' subfolder for LibreOffice. On Windows, application data starts at the location stored in the APPDATA environment variable, which you can print out: echo %APPDATA% On my work test machine this prints \"C:\\Users\\Ad\\AppData\\Roaming\". You need to locate the LibreOffice subdirectory in the Roaming folder and then its user\\ subdirectory, which will be inside LibreOffice\\5 or perhaps LibreOffice\\4. For instance, on one of my test machines the user folder is: C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user If you haven't previously downloaded or created Java user macros, then you'll have to create a Scripts folder inside user\\, and a java folder inside Scripts. In other words, the Java user macros will be in: C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user\\Scripts\\java 3. Naming Macro Functions \u00b6 The \"Macro Selector dialog displays a list of macros in its right hand window (e.g. \"GetNumber.get\" and \"GetText.show\" in Figure 1), but more detailed function names are required when calling macros from code. A function name is specified as a URI of the form: vnd.sun.star.script:MACROPARAM?language=LANGPARAM &location=LOCPARAM LANGPARAM identifies the macro's programming language, which may be \"Basic\", \"BeanShell\", \"Java\", \"JavaScript\", or \"Python\". LOCPARAM is the macro category, which for Java macros can be \"user\", \"share\", or \"document\". Extension macros use the label \"user:uno_packages/\" or \"share:uno_packages/\" followed by the name of the extension file (e.g. \"user:uno_packages/FormMacros.oxt\"). MACROPARAM takes the form: FOLDER.[PACKAGE_NAME.]CLASS_NAME.FUNCTION_NAME FOLDER is the subdirectory holding the compiled Java code in the user or share java\\ folder, and the package name is optional. The class and function names are displayed by the Macro Selector dialog (see Figure 1). For example, \"GetNumber.get\" refers to the static function get() in the GetNumber class. Information about the URI formats for other languages is given on the \"Scripting Framework URI Specification\" page at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Scripting/Scripting_Framework_URI_Specification/ (or use loGuide \"Scripting Framework URI Specification\" ). Listing and Finding Macro Names \u00b6 Knowing a macro's full name is essential, so I've added some helper functions to the Macros.java utilities class. The ListMacros.java and FindMacros.java examples show how to use them. ListMacros.java calls Macros.getLangScripts() to print the names of the macros written in a given language: // in ListMacros.java public static void main ( String [] args ) { String lang = \"Java\" ; if ( args . length != 1 ) { System . out . println ( \"Usage: run ListMacros [Java | Python | BeanShell | Basic | JavaScript]\" ); System . out . println ( \"Using \\\"Java\\\"\" ); } else lang = args [ 0 ] ; XComponentLoader loader = Lo . loadOffice (); ArrayList < String > scriptURIs = Macros . getLangScripts ( lang ); System . out . println ( lang + \" Macros in Office: (\" + scriptURIs . size () + \")\" ); for ( String scriptURI : scriptURIs ) System . out . println ( \" \" + scriptURI ); Lo . closeOffice (); } // end of main() Macros . getLangScripts () obtains a list of all the macro names by calling Macros . getScripts (), then filters out names based on a \"language=LANGPARAM&\" substring : // in the Macros class public static ArrayList < String > getLangScripts ( String lang ) { if ( ! isMacroLanguage ( lang )) { System . out . println ( \"Not a Macro language; try \\\"Java\\\"\" ); return null ; } ArrayList < String > fScripts = new ArrayList <> (); ArrayList < String > scriptURIs = getScripts (); for ( String scriptURI : scriptURIs ) if ( scriptURI . contains ( \"language=\" + lang + \"&\" )) fScripts . add ( scriptURI ); return fScripts ; } // end of getLangScripts() Macros.getScripts() utilizes services and interfaces in the com.sun.star.script.browse module to examine a scripts tree structure consisting of CONTAINER and SCRIPT nodes \u2013 the CONTAINER nodes are the internal branches of the tree representing libraries and modules, while SCRIPT nodes are the leaves holding macro information. Macros.getScripts() accesses the root of the MACROORGANIZER tree, and collects script names by having getLibScripts() recursively traverse the tree, adding names to a scripts ArrayList: // in the Macros class public static ArrayList < String > getScripts () { ArrayList < String > scripts = new ArrayList <> (); XComponentContext xcc = Lo . getContext (); XBrowseNodeFactory bnf = Lo . qi ( XBrowseNodeFactory . class , xcc . getValueByName ( \"/singletons/com.sun.star.script. browse.theBrowseNodeFactory\" )); XBrowseNode rootNode = Lo . qi ( XBrowseNode . class , bnf . createView ( BrowseNodeFactoryViewTypes . MACROORGANIZER ) ); // for scripts XBrowseNode [] typeNodes = rootNode . getChildNodes (); for ( int i = 0 ; i < typeNodes . length ; i ++ ) { XBrowseNode typeNode = typeNodes [ i ] ; XBrowseNode [] libraryNodes = typeNode . getChildNodes (); for ( int j = 0 ; j < libraryNodes . length ; j ++ ) getLibScripts ( libraryNodes [ j ] , 0 , typeNode . getName (), scripts ); } System . out . println (); return scripts ; } // end of getScripts() public static void getLibScripts ( XBrowseNode browseNode , int level , String path , ArrayList < String > scripts ) { XBrowseNode [] scriptNodes = browseNode . getChildNodes (); if (( scriptNodes . length == 0 ) && ( level > 1 )) // not a top-level library System . out . println ( \"No scripts in \" + path ); for ( int i = 0 ; i < scriptNodes . length ; i ++ ) { XBrowseNode scriptNode = scriptNodes [ i ] ; if ( scriptNode . getType () == BrowseNodeTypes . SCRIPT ) { XPropertySet props = Lo . qi ( XPropertySet . class , scriptNode ); if ( props != null ) { try { scripts . add (( String ) props . getPropertyValue ( \"URI\" )); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } else System . out . println ( \"No props for \" + scriptNode . getName ()); } else if ( scriptNode . getType () == BrowseNodeTypes . CONTAINER ) getLibScripts ( scriptNode , level + 1 , path + \">\" + scriptNode . getName (), scripts ); else System . out . println ( \"Unknown node type\" ); } } // end of getLibScripts() All the Java macros can be listed by calling: run ListMacros Java It will print something like: Java Macros in Office: (6) vnd.sun.star.script:Utils.GetNumber.get?language=Java& location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:Utils.GetText.show?language=Java& location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:HelloWorld.org.libreoffice.example.java_scripts. HelloWorld.printHW?language=Java&location=share vnd.sun.star.script:Highlight.org.libreoffice.example.java_scripts. HighlightText.showForm?language=Java&location=share vnd.sun.star.script:MemoryUsage.org.libreoffice.example.java_scripts. MemoryUsage.updateMemoryUsage?language=Java&location=share vnd.sun.star.script:ShowEvent.ShowEvent.show?language=Java& location=share Six Java macros were found: two are user macros from the FormMacros.oxt extension, and four are share macros. The first three share macros (HelloWorld.printHW, HighlightText.showForm, and MemoryUsage.updateMemoryUsage) are LibreOffice examples; I'll explain the first one: vnd . sun . star . script : HelloWorld . org . libreoffice . example . java_scripts . HelloWorld . printHW ? language = Java & location = share The macro's location parameter is \"location=share\", which means that it appears in the \"LibreOffice Macros\" section of the Macro Selector dialog in Figure 4. Figure 4. The HelloWorld.printHW Macro. The four components of \"HelloWorld.org.libreoffice.example.java_scripts.HelloWorld.printHW\" are: folder: HelloWorld package: org.libreoffice.example.java_scripts class name: HelloWorld function name: printHW The HelloWorld folder is inside C:\\Program Files\\LibreOffice 5\\share\\Scripts\\java\\, as confirmed by Figure 5. Figure 5. The HelloWorld Folder in share\\Scripts\\java. Figure 5 also shows Highlight\\, MemoryUsage and ShowEvent folders which hold the other three share macros listed by ListMacros.java. The HelloWorld folder contains the compiled HelloWorld class in a JAR file, and a parcel-descriptor.xml configuration file, which I'll explain later. It also has the source code for HelloWorld, which isn\u2019t required by Office, but included as an example for developers. Figure 6 shows the contents of HelloWorld. Figure 6. The Contents of the HelloWorld Folder. The format of the HelloWorld class in the JAR file is: package org.libreoffice.example.java_scripts; public class HelloWorld { public static void printHW ( XScriptContext xSc ) { /* code not shown */ } } HelloWorld implements a single printHW() function. My FindMacros.java example calls Macros.findScripts() with a substring, and all the macro names containing that string are printed. For example, a search for \"hello\" returns five matches: Matching Macros in Office: (5) vnd.sun.star.script:Utils.HelloWorld.hello? language=Java&location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:HelloWorld.helloworld.bsh? language=BeanShell&location=share vnd.sun.star.script:HelloWorld.org.libreoffice.example.java_scripts. HelloWorld.printHW?language=Java&location=share vnd.sun.star.script:HelloWorld.helloworld.js? language=JavaScript&location=share vnd.sun.star.script:HelloWorld.py$HelloWorldPython? language=Python&location=share Four of the hello-related scripts are share macros written in BeanShell, Java, JavaScript, and Python. 4. Calling the \"hello\" Macros \u00b6 The TextMacros.java example creates a text document, and calls the four \"hello\" share macros listed above by FindMacros.java. They each add a short piece of text to the document, as displayed on lines 2-5 in Figure 7. Figure 7. A Document with \"hello\" Macros Text. TextMacros.java utilizes Macros.execute() to call the macros: // in TextMacros.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } if ( Macros . getSecurity () == Macros . LOW ) Macros . setSecurity ( Macros . MEDIUM ); XTextCursor cursor = Write . getCursor ( doc ); GUI . setVisible ( doc , true ); Lo . wait ( 1000 ); // make sure the document is visible // before sending it dispatches Write . appendPara ( cursor , \"Hello LibreOffice\" ); Macros . execute ( \"HelloWorld.helloworld.bsh\" , \"BeanShell\" , \"share\" ); Write . endParagraph ( cursor ); Macros . execute ( \"HelloWorld.py$HelloWorldPython\" , \"Python\" , \"share\" ); Write . endParagraph ( cursor ); Macros . execute ( \"HelloWorld.helloworld.js\" , \"JavaScript\" , \"share\" ); Write . endParagraph ( cursor ); Macros . execute ( \"HelloWorld.org.libreoffice.example. java_scripts.HelloWorld.printHW\" , \"Java\" , \"share\" ); Write . endParagraph ( cursor ); Write . appendPara ( cursor , \"Timestamp: \" + Lo . getTimeStamp ()); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The arguments of Macros.execute() are the MACROPARAM, LANGPARAM, and LOCPARAM parts of the macro's URI; they're separated out to make the macro's name a little easier to read. Macros.execute() uses the theMasterScriptProviderFactory service to obtain a XScriptProviderFactory It creates a XScriptProvider which can load the named macro as an XScript object; the script is executed by XScript.invoke(): // in the Macros class public static Object execute ( String macroName , String language , String location ) { return execute ( macroName , null , language , location ); } public static Object execute ( String macroName , Object [] params , String language , String location ) { if ( ! isMacroLanguage ( language )) { System . out . println ( \"\\\"\" + language + \"\\\" is not a macro language name\" ); return null ; } try { /* deprecated approach XScriptProviderFactory spFactory = Lo.createInstanceMCF( XScriptProviderFactory.class, \"com.sun.star.script.provider.MasterScriptProviderFactory\"); */ XComponentContext xcc = Lo . getContext (); XScriptProviderFactory spFactory = Lo . qi ( XScriptProviderFactory . class , xcc . getValueByName ( \"/singletons/com.sun.star.script.provider. theMasterScriptProviderFactory\" )); XScriptProvider sp = spFactory . createScriptProvider ( \"\" ); XScript xScript = sp . getScript ( \"vnd.sun.star.script:\" + macroName + \"?language=\" + language + \"&location=\" + location ); // minimal inout/out parameters short [][] outParamIndex = { { 0 } }; Object [][] outParam = { { null } }; return xScript . invoke ( params , outParamIndex , outParam ); } catch ( Exception e ) { System . out . println ( \"Could not execute macro \" + macroName + \": \" + e ); return null ; } } // end of execute() Input parameters can be passed to invoke(), but the three-argument version of Macros.execute() sets them to null. It's also possible to have the script set output parameters, but my call to XScript.invoke() doesn't use them either. There's no need to pass Macros.execute() a reference to the document. An executing script only requires Office's current context which is retrieved by Lo.getContext(). 4.1. Macro Security Levels \u00b6 Prior to the macro calls in TextMacros.java, there's a call to Macros.getSecurity(). It reports Office's macro execution setting, which is changed to Macros.MEDIUM if the current value is Macros.LOW: // part of TextMacros.java... if ( Macros . getSecurity () == Macros . LOW ) Macros . setSecurity ( Macros . MEDIUM ); The Macros class defines four security constants: LOW, MEDIUM, HIGH, VERY_HIGH, which correspond to the levels used in Office's \"Macro Security\" dialog shown in Figure 8. It is reached via Tools, Options, Security, and the \"Macro Security\" button. Figure 8. The Macro Security Dialog. The Office API has a MacroExecMode class (see lodoc MacroExecMode ) which defines many more security levels, but the four levels in the GUI seem sufficient. Macros.getSecurity() uses Info.getConfig() to access the \"/org.openoffice.Office.Common/Security/Scripting\" configuration node, and look up its \"MacroSecurityLevel\" property: // in the Macros class public static int getSecurity () { System . out . println ( \"Macro security level:\" ); Integer val = ( Integer ) Info . getConfig ( \"/org.openoffice.Office.Common/Security/Scripting\" , \"MacroSecurityLevel\" ); // various tests of val, before returning its int value // : return val . intValue (); } Macros . setSecurity () manipulates the same configuration node but supplies a new value for the \"MacroSecurityLevel\" property : // in the Macros class public static boolean setSecurity ( int level ) { if (( level == Macros . LOW ) || ( level == Macros . MEDIUM ) || ( level == Macros . HIGH ) || ( level == Macros . VERY_HIGH )) { System . out . println ( \"Setting macro security level to \" + level ); return Info . setConfig ( \"/org.openoffice.Office.Common/Security/Scripting\" , \"MacroSecurityLevel\" , Integer . valueOf ( level )); } else { System . out . println ( \"Use Macros class constants: LOW, MEDIUM, HIGH, or VERY_HIGH\" ); return false ; } } // end of setSecurity() 4.2. Implementing the HelloWorld Java Macro \u00b6 The four macros called by TextMacros.java add text to the document, but how exactly? The Java macro is called using: // part of TextMacros.java... Macros . execute ( \"HelloWorld.org.libreoffice.example. java_scripts.HelloWorld.printHW\" , \"Java\" , \"share\" ); This invokes the printHW() static method in the HelloWorld class in the org.libreoffice.example.java_scripts package shown back in Figure 4. The complete code for the class (minus some comments) is: // the HelloWorld class package org.libreoffice.example.java_scripts ; import com.sun.star.script.provider.XScriptContext ; import com.sun.star.uno.* ; import com.sun.star.text.* ; public class HelloWorld { public static void printHW ( XScriptContext xSc ) { XTextDocument xtextdocument = ( XTextDocument ) UnoRuntime . queryInterface ( XTextDocument . class , xSc . getDocument ()); XText xText = xtextdocument . getText (); XTextRange xTextRange = xText . getEnd (); xTextRange . setString ( \"Hello World (in Java)\" ); } // end of printHW() } // end of HelloWorld class XScript.invoke() constructs a one-argument call to printHW(), passing it a XScriptContext object. As we'll see later, a function can be called with different arguments depending on what event triggers the macro. The XScriptContext interface defines four methods which allow the current context, the desktop, and document to be accessed (see lodoc XScriptContext). printHW() utilizes XScriptContext.getDocument() to retrieve the document, and casts it to XTextDocument. This allows the end of the text to be accessed with XTextRange, so a string (\"\"Hello World (in Java)\") can be appended to it. 5. The LibreLogo Macro \u00b6 HelloWorld isn't the most exciting of macro examples. LibreLogo is a fun (and educational) share macro for LibreOffice (see Figure 9), which has been a standard Office add-on since version 4.0. Figure 9. The LibreLogo Macro Module. Normally LibreLogo is accessed through its own View, Toolbars, Logo toolbar, which is just as well since the Macro selector doesn't list any macros in the LibreLogo module (see the empty area on the right of Figure 9). I had to examine the module's Python code in \\share\\Scripts\\python\\LibreLogo\\LibreLogo.py to work out how to call it as a function. My UseLogo.java example creates a text document, writes the logo program text onto the page, followed by LibreLogo's rendering of that program, as in Figure 10. Figure 10. The Page Generated by UseLogo.java. UseLogo.java is: public class UseLogo { public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . wait ( 1000 ); // make sure doc is visible XTextCursor cursor = Write . getCursor ( doc ); String logoCmds = \"repeat 88 [ fd 200 left 89 ] fill\" ; Write . appendPara ( cursor , logoCmds ); Macros . executeLogoCmds ( logoCmds ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of UseLogo class Macros.executeLogoCmds() is a small wrapper around Macros.execute() which calls the commandline() function inside LibreLogo.py: // in the Macros class public static Object executeLogoCmds ( String cmdsStr ) { Object [] params = new String [ 2 ] ; params [ 0 ] = \"\" ; // based on looking at commandline() params [ 1 ] = cmdsStr ; // in LibreLogo.py return execute ( \"LibreLogo/LibreLogo.py$commandline\" , params , \"Python\" , \"share\" ); } The params[] array is treated as two arguments by XScript.invoke() and passed to commandline(). The quick-start and resources pages at librelogo.org are the places to start learning LibreLogo ( https://librelogo.org/quick-start/ and https://librelogo.org/resources/ ). There's also a help page of commands at https://help.libreoffice.org/Writer/LibreLogo_Toolbar/ . A good source of examples, slides, and code is https://numbertext.org/logo/ . The best introductory talk at that site is \"LibreLogo \u2013 Turtle vector graphics for everybody\" from 2012 ( https://numbertext.org/logo/librelogo.pdf ), and there are more recent presentations which update the project. One of its aims was to create a textbook for Hungarian primary and secondary schools (the project lead, L\u00e1szl\u00f3 N\u00e9meth, is Hungarian), which is free to download from https://szabadszoftver.kormany.hu/wp-content/uploads/librelogo_oktatasi_segedanyag_v4.pdf . 6. Writing a Simple Event Macro \u00b6 It's time to start coding our own macros. I'll start by writing a ShowEvent class which reports when various events occur. It does this by implementing several versions of a static show() method: // in ShowEvent.java public class ShowEvent { public static void show ( XScriptContext sc , ActionEvent e ) // triggered by a action event (usually a button press) { display ( \"action\" , getSource ( e )); } public static void show ( XScriptContext sc , TextEvent e ) // called when text changes inside a text component { display ( \"text\" , getSource ( e )); } public static void show ( XScriptContext sc , FocusEvent e ) // called when the focus changes { display ( \"focus\" ); } public static void show ( XScriptContext sc , Short val ) // called from a toolbar { display ( \"toolbar (\" + val + \")\" ); } public static void show ( XScriptContext sc , KeyEvent e ) // called because of a key { display ( \"key \" + e . KeyChar , getSource ( e )); } public static void show ( XScriptContext sc , MouseEvent e ) // called because of the mouse { display ( \"mouse\" ); } public static void show ( XScriptContext sc , com . sun . star . document . DocumentEvent e ) // triggered by a document event { display ( \"document\" , e . EventName ); } public static void show ( XScriptContext sc , EventObject e ) { if ( e != null ) display ( \"object\" , getSource ( e )); else display ( \"object ()\" ); } public static void show ( XScriptContext sc ) // called from a menu or the \"Run Macro...\" menu { display ( \"menu/run\" ); } // support methods; explained shortly // : } // end of ShowEvent class A particular show() function is called depending on the event, and more versions of show() could easily be added since Office supports a wide range of events. Probably the best summary of them is in the online documentation for EventObject (see lodoc EventObject ); EventObject is the superclass for most event types. When I first wrote ShowEvent, I mistakenly assumed that the show() function with the EventObject argument (i.e. the second to last one in the code above) would be the default method called when no other version of show() was suitable. That isn't the case; instead, the single argument show() (i.e. the last function, show(XScriptContext sc) ) is executed. The show() methods utilize display() and showDialog(): // part of the ShowEvent class... private static void display ( String msg ) { showDialog ( msg + \" event\" ); // JOptionPane.showMessageDialog(null, msg + \" event\"); } private static void display ( String msg , String info ) { showDialog ( msg + \" event: \" + info ); // JOptionPane.showMessageDialog(null, msg + \" event: \" + info); } private static void showDialog ( String msg ) { JDialog dlg = new JDialog (( java . awt . Frame ) null , \"Show Event\" ); dlg . getContentPane (). setLayout ( new GridLayout ( 3 , 1 )); dlg . add ( new JLabel ( \"\" )); dlg . add ( new JLabel ( msg , SwingConstants . CENTER )); // centered text dlg . pack (); Random r = new Random (); dlg . setLocation ( 100 + r . nextInt ( 50 ), 100 + r . nextInt ( 50 )); dlg . setVisible ( true ); dlg . setResizable ( false ); dlg . setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ); } // end of showDialog() A modeless dialog is displayed using Java's JDialog rather than JOptionPane.showMessageDialog(), which means that the dialog won't cause Office to suspend until the user closes the window. Each dialog is placed at a slightly random position, so that multiple dialogs created by several events will all hopefully be visible. Another issue is that the dialog's parent is null which means that the dialog may not appear in front of the Office window. No use is made of my utility classes, such as Macros.java or GUI.java. Although this makes the code longer, it also makes this example self-contained, and easier to install. I'll use my support classes in the extension and document examples in the next chapter. Events which are usually triggered by GUI components, such as ActionEvent and TextEvent, are passed to getSource() which attempts to find the name of the component that sent the event: // part of the ShowEvent class... private static String getSource ( EventObject event ) { XControl control = UnoRuntime . queryInterface ( XControl . class , event . Source ); XPropertySet xProps = UnoRuntime . queryInterface ( XPropertySet . class , control . getModel ()); try { return ( String ) xProps . getPropertyValue ( \"Name\" ); } catch ( com . sun . star . uno . Exception e ) { return \"Exception?\" ; } catch ( com . sun . star . uno . RuntimeException e ) { return \"RuntimeException?\" ; } } // end of getSource() 6.1. Installing a Simple Event Macro \u00b6 A Java macro is installed as a JAR file, so ShowEvent.class is packaged as ShowEvent.jar after compilation: compile ShowEvent.java jar cvf ShowEvent.jar ShowEvent.class The JAR is added to a new folder called ShowEvent beneath \\share\\Scripts\\java\\, thereby making it a share macro. It's also necessary to include a parcel-descriptor.xml file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <parcel language=\"Java\" xmlns:parcel=\"scripting.dtd\"> <script language=\"Java\"> <locale lang=\"en\"> <displayname value=\"ShowEvent.show\"/> <description> Shows a dialog with basic event information. </description> </locale> <functionname value=\"ShowEvent.show\"/> <logicalname value=\"ShowEvent.show\"/> <languagedepprops> <prop name=\"classpath\" value=\"ShowEvent.jar\"/> </languagedepprops> </script> </parcel> Of the three 'name' attributes in the XML file, only seems to be used by Office. The text appears in the Macro selector dialog (e.g. see Figure 12 below) when the macro is selected, and adds the JAR to Office's classpath. The final contents of the ShowEvent folder are a JAR and XML file, as shown in Figure 11. Figure 11. The ShowEvent Share Macro Folder. It's a good idea to check that this new macro can be seen by Office. Office should be restarted and the \"LibreOffice Macros\" subsection of the Macro Selector dialog examined. Figure 12 shows the ShowEvent.show macro in the ShowEvent module. Figure 12. Checking for the Presence of ShowEvent.show. 6.2. Using ShowEvent.show in a Form \u00b6 build.odt is a simple form using textfields and buttons shown in Figure 13. Figure 13. The \"build.odt\" Form. The event handling properties of a control are accessed by changing to form design mode (click the \"OK hand\" icon, second from the left in the toolbar at the bottom of Figure 13). Subsequently, the mouse is right-clicked over a control, such as the FIRSTNAME textfield selected in Figure 13. The resulting pop-up menu includes a \"Control\" menu item which displays the control's Properties dialog (see Figure 14). Figure 14. The Properties Dialog for the FIRSTNAME Textfield Control. The Events tab (shown in Figure 14) lists all the events associated with the control, and a macro is attached by pressing on the right-hand \"\u2026\" button for an event. An \"Assign Action\" dialog appears, like the one in Figure 15. Figure 15. The \"Assign Action\" Dialog. Figure 15 shows that the user has selected the \"Key pressed\" event. Clicking on the \"Macro\u2026\" button brings forth the Macro Selector dialog, and a macro can be chosen. Upon returning to the \"Assign Action\" dialog, the event will list the macro in the \"Assigned Action\" column. Clicking \"Ok\" again returns to the properties dialog which now shows the macro name next to the \"Key pressed\" event, as in Figure 16. Figure 16. The Properties Dialog with an Assigned Macro. The macro's arguments (\"share\" and \"Java\") are its category and implementation language. The event/macro link can be tested by returning to the default mode in the form by clicking the \"Ok hand\" icon again. When the user types three letters into the FIRSTNAME textfield (e.g. \"and\"), three dialogs appear, as in Figure 17. Figure 17. Reporting Key Events. I've rearranged the three dialogs in Figure 17 so they're all visible. They're generated by the KeyEvent version of ShowEvent.show: // part of the ShowEvent class... public static void show ( XScriptContext sc , KeyEvent e ) // Called from a key { display ( \"key \" + e . KeyChar , getSource ( e )); } As each letter (\"a', 'n', and 'd') is typed, this version of show() is called. 7. Automating the Assigning of Event Macros \u00b6 The preceding section illustrates that the assignment of macros to events is straightforward, but time-consuming, especially if you have many controls in your form. Fortunately, macros can be assigned programmatically. I first used the \"build.odt\" form of Figure 13 back in Chapter 40 on forms; it wasn't created by hand but generated by BuildForm.java. That program is extended in this section with calls to Forms.assignScript() which assigns a macro to an event in a control. I'll employ Forms.assignScript() so that the FIRSTNAME textfield calls ShowEvent.show whenever its text changes, focus is lost, or a key is pressed. Also, the six buttons at the bottom of the form (see Figure 13) will execute ShowEvent.show when they're pressed. The new code is highlighted in bold in createForm(): // part of BuildForm.java... private void createForm ( XTextDocument doc ) { XPropertySet props = Forms . addLabelledControl ( doc , \"FIRSTNAME\" , \"TextField\" , 11 ); textEvents ( props ); // only the FIRSTNAME textfield has a listener Forms . addLabelledControl ( doc , \"LASTNAME\" , \"TextField\" , 19 ); props = Forms . addLabelledControl ( doc , \"AGE\" , \"NumericField\" , 43 ); Props . setProperty ( props , \"DecimalAccuracy\" , ( short ) 0 ); Forms . addLabelledControl ( doc , \"BIRTHDATE\" , \"FormattedField\" , 51 ); // buttons, all with listeners props = Forms . addButton ( doc , \"first\" , \"<<\" , 2 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"prev\" , \"<\" , 12 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"next\" , \">\" , 22 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"last\" , \">>\" , 32 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"new\" , \">*\" , 42 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"reload\" , \"reload\" , 58 , 63 , 13 ); buttonEvent ( props ); } // end of createForm() The property set for the FIRSTNAME textfield is passed to textEvents(), which calls Forms.assignScript() three times: // part of BuildForm.java... public void textEvents ( XPropertySet props ) { // listen for text change Forms . assignScript ( props , \"XTextListener\" , \"textChanged\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); // listen for focus loss Forms . assignScript ( props , \"XFocusListener\" , \"focusLost\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); // listen for a key press Forms . assignScript ( props , \"XKeyListener\" , \"keyPressed\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); } // end of textEvents() The buttonEvent () method is a ( long ) one - liner : // part of BuildForm.java... public void buttonEvent ( XPropertySet props ) { Forms . assignScript ( props , \"XActionListener\" , \"actionPerformed\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); } It's surprisingly tricky to decide which class and method names should be passed to Forms.assignScript() since the only information about control events are the labels in the Properties dialog (e.g. \"Key pressed\" in Figure 16). It can be hard to map these labels onto suitable class and method names, especially since Office supports so many event types. The best source for suitable listener classes is the online documentation for XEventListener (see lodoc XEventListener); XEventListener is the superclass of most listeners. After the generated form has been saved, it should be opened in Office so its controls' properties can be inspected. For example, the FIRSTNAME textfield's event properties are now as in Figure 18. Figure 18. The Properties Dialog for the FIRSTNAME textfield. Figure 18 confirms that the class/method names used in textEvents() are correct. Forms.assignScript() utilizes the XEventAttacherManager interface which offers multiple methods for attaching and removing scripts from events. The code for Forms.assignScript(): // in the Forms class public static void assignScript ( XPropertySet controlProps , String interfaceName , String methodName , String scriptName , String loc ) { try { XChild propsChild = Lo . qi ( XChild . class , controlProps ); XIndexContainer parentForm = Lo . qi ( XIndexContainer . class , propsChild . getParent ()); int pos = - 1 ; for ( int i = 0 ; i < parentForm . getCount (); i ++ ) { XPropertySet child = Lo . qi ( XPropertySet . class , parentForm . getByIndex ( i ) ); if ( UnoRuntime . areSame ( child , controlProps )) { pos = i ; break ; } } if ( pos == - 1 ) System . out . println ( \"Could not find contol's pos in form\" ); else { XEventAttacherManager manager = Lo . qi ( XEventAttacherManager . class , parentForm ); manager . registerScriptEvent ( pos , new ScriptEventDescriptor ( interfaceName , methodName , \"\" , \"Script\" , \"vnd.sun.star.script:\" + scriptName + \"?language=Java&location=\" + loc )); } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of assignScript() The first half of assignScript() calculates the control's index position inside the parent's form. An index is used by most XEventAttacherManager methods to refer to a control. The last part of assignScript() uses XEventAttacherManager.registerScriptEvent() to attach the script to the control's event. A ScriptEventDescriptor object is constructed from five arguments: the listener's class name, the method to be called in the listener, any extra data for the method (which is \"\" here), the script type (which can be \"Script\" or \"Basic\"), and the macro's full name. If you're unsure about the full name, then use my ListMacros.java or FindMacros.java to display macro details. For example: run FindMacros ShowEvent produces: Matching Macros in Office : ( 1 ) vnd . sun . star . script : ShowEvent . ShowEvent . show ? language = Java & location = share \"ShowEvent.ShowEvent.show\" and \"share\" are passed to Forms.assignScript() as its last two arguments: java // part of BuildForm.java... Forms.assignScript(props, \"XTextListener\", \"textChanged\", \"ShowEvent.ShowEvent.show\", \"share\");","title":"Chapter 48. Event Macros"},{"location":"48-Event_Macros.html#chapter-48-event-macros","text":"Topics Macro Locations; Naming Macro Functions; Calling Existing Macros; The LibreLogo Macro; Writing a Simple Event Macro; Automating the Assigning of Event Macros Example folders: \"EvMacro Tests\" and \"Utils\" Event macros are functions triggered by the occurrence of events, either within Office or in Office documents. I'll be using event macros with forms, by attaching them to controls such as buttons and textfields. A key difference between event macros and Java listeners is that macros are attached to Office or to documents rather than being part of an external Java program. In practical terms this means that the macro code becomes part of the Office installation or is embedded inside a document's ODF file. I'll spend two chapters discussing event macros: this chapter focuses on how to use existing Office macros, and how to write a simple event macro that's installed by copying it to a specific Office directory. This approach is obviously not ideal, and so the next chapter looks at installing macros as extensions, and by attaching them to documents. The Developer's Guide discusses macros in chapter 18, \"Scripting Framework\", but macro programming has changed since the guide was produced (e.g. macros can now be written in Python), so it's better to read the more current OpenOffice wiki, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Scripting/Scripting_Framework/ (or use loGuide \"Scripting Framework\" ). Most macro programming resources employ Office Basic, and Java rarely gets mentioned, as in chapter 13, \"Getting Started with Macros\", of the \"Getting Started Guide\" (available at https://libreoffice.org/get-help/documentation/ ). That chapter ends with a useful list of online resources, and printed and eBook materials. Probably the best source for Office Basic macro coding is Andrew Pitonyak's website at https://pitonyak.org/oo.php ; I recommend starting with his book, \"OpenOffice.org Macros Explained\" (OOME), which is free to download. There's also a separate book of collected macros, called AndrewMacros.pdf. Another excellent introduction to Office Basic Macros (written in French) is: Programmation OpenOffice.org et LibreOffice: Macros OOoBasic et API Bernard Marcelly and Laurent Godard Eyrolles, 2011 https://editions-eyrolles.com/Livre/9782212132472/programmation-openoffice-org-et-libreoffice/ Two textbooks that focus on Office Basic macros in a particular Office application: Learn OpenOffice.org Spreadsheet Macro Programming: OOoBasic and Calc Automation Mark Alexander Bain Packt Publishing, 2006 https://packtpub.com/hardware-and-creative/learn-openofficeorg-spreadsheet-macro-programming-ooobasic-and-calc-automation/ Database Programming with OpenOffice.org Base and Basic Roberto Benitez Lulu.com, 2011 https://lulu.com/shop/roberto-benitez/database-programming-with-openofficeorg-base-basic/paperback/product-3568728.html","title":"Chapter 48. Event Macros"},{"location":"48-Event_Macros.html#1-fantastic-macros-and-where-to-find-them","text":"There are four categories of macros: * user: user macros are available only to the user who added them to Office; * share: share macros can be called by all users of that copy of Office; * extension: extension macros are added to office as an extension, and may be available only to the user or be shared (these are discussed in the next chapter); * document: these macros are added to a document rather than to Office, and so are useable only in that document (see the next chapter). These categories are reflected in how the Office GUI displays installed macros in the Macro Selector dialog of Figure 1 (accessible via the Tools > Macros > \"Run Macros\" menu item). Figure 1. The \"Tools > Macros > Run Macros\" Dialog. The top-level folders in Figure 1 are library containers: \"My Macros\" and \"LibreOffice Macros\" are always present, and store user and share macros respectively. If the currently loaded document contains document macros then there will be a third container with the same name as the file (e.g. \"build.odt\" in Figure 1). Extension macros are grouped under the name of the extension file (e.g. \"FormMacros.oxt\"), and may occur in either \"My Macros\" or \"LibreOffice Macros\" depending on if the extension contains user or share macros. Each library container (e.g. \"My Macros\") can hold multiple libraries; each library can contain multiple modules; each module can store multiple macros. For example, Figure 1 shows that the \"My Macros\" container holds three libraries called \"FormMacros.oxt\", \"Standard\", and \"WikiEditor\". The \"FormMacros.oxt\" library (which holds extension macros) consists of a single \"Utils\" module with two macros called \"GetNumber.get\" and \"GetText.show\". I'll be explaining how to create and install this extension in the next chapter. In addition, the Tools > Macros > \"Organize Macros\" menu gives access to macros according to some of the programming languages supported by Office, but Java isn't included (see Figure 2). As a consequence, I'll use the Macro Selector dialog of Figure 1 from now on. Figure 2. The Tools > Macros > \"Organize Macros\" Menu.","title":"1.  Fantastic Macros and Where to Find Them"},{"location":"48-Event_Macros.html#2-where-are-macros-stored","text":"Aside from accessing macros through the Office GUI, it's useful to know where they're located in the directory structure. This is especially true for user and share macros since the easiest way to install them is to copy them into Office's designated folders. However, extension macros are installed using the extension manager, and document macros are added to their document using unzipping and zipping. Finding Office's macro folders can be a bit tricky, since their location varies depending on if the macros are user or share, coded in Office Basic or another language, and on the version of Office and OS. The folders for share macros are probably the easiest to find \u2013 they're located inside \\share (e.g. C:\\Program Files\\LibreOffice 5\\share on my machine). Basic macros are in share\\basic while macros in other languages, such as Java, are in subfolders of share\\Scripts (e.g. see Figure 3). Figure 3. The Non-Basic share\\Scripts Macros Folders. In other words, Java share macros will be in: C:\\Program Files\\LibreOffice 5\\share\\Scripts\\java User macros are stored in an 'application data' subfolder for LibreOffice. On Windows, application data starts at the location stored in the APPDATA environment variable, which you can print out: echo %APPDATA% On my work test machine this prints \"C:\\Users\\Ad\\AppData\\Roaming\". You need to locate the LibreOffice subdirectory in the Roaming folder and then its user\\ subdirectory, which will be inside LibreOffice\\5 or perhaps LibreOffice\\4. For instance, on one of my test machines the user folder is: C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user If you haven't previously downloaded or created Java user macros, then you'll have to create a Scripts folder inside user\\, and a java folder inside Scripts. In other words, the Java user macros will be in: C:\\Users\\Ad\\AppData\\Roaming\\LibreOffice\\4\\user\\Scripts\\java","title":"2.  Where are Macros Stored?"},{"location":"48-Event_Macros.html#3-naming-macro-functions","text":"The \"Macro Selector dialog displays a list of macros in its right hand window (e.g. \"GetNumber.get\" and \"GetText.show\" in Figure 1), but more detailed function names are required when calling macros from code. A function name is specified as a URI of the form: vnd.sun.star.script:MACROPARAM?language=LANGPARAM &location=LOCPARAM LANGPARAM identifies the macro's programming language, which may be \"Basic\", \"BeanShell\", \"Java\", \"JavaScript\", or \"Python\". LOCPARAM is the macro category, which for Java macros can be \"user\", \"share\", or \"document\". Extension macros use the label \"user:uno_packages/\" or \"share:uno_packages/\" followed by the name of the extension file (e.g. \"user:uno_packages/FormMacros.oxt\"). MACROPARAM takes the form: FOLDER.[PACKAGE_NAME.]CLASS_NAME.FUNCTION_NAME FOLDER is the subdirectory holding the compiled Java code in the user or share java\\ folder, and the package name is optional. The class and function names are displayed by the Macro Selector dialog (see Figure 1). For example, \"GetNumber.get\" refers to the static function get() in the GetNumber class. Information about the URI formats for other languages is given on the \"Scripting Framework URI Specification\" page at https://wiki.openoffice.org/wiki/Documentation/DevGuide/Scripting/Scripting_Framework_URI_Specification/ (or use loGuide \"Scripting Framework URI Specification\" ).","title":"3.  Naming Macro Functions"},{"location":"48-Event_Macros.html#listing-and-finding-macro-names","text":"Knowing a macro's full name is essential, so I've added some helper functions to the Macros.java utilities class. The ListMacros.java and FindMacros.java examples show how to use them. ListMacros.java calls Macros.getLangScripts() to print the names of the macros written in a given language: // in ListMacros.java public static void main ( String [] args ) { String lang = \"Java\" ; if ( args . length != 1 ) { System . out . println ( \"Usage: run ListMacros [Java | Python | BeanShell | Basic | JavaScript]\" ); System . out . println ( \"Using \\\"Java\\\"\" ); } else lang = args [ 0 ] ; XComponentLoader loader = Lo . loadOffice (); ArrayList < String > scriptURIs = Macros . getLangScripts ( lang ); System . out . println ( lang + \" Macros in Office: (\" + scriptURIs . size () + \")\" ); for ( String scriptURI : scriptURIs ) System . out . println ( \" \" + scriptURI ); Lo . closeOffice (); } // end of main() Macros . getLangScripts () obtains a list of all the macro names by calling Macros . getScripts (), then filters out names based on a \"language=LANGPARAM&\" substring : // in the Macros class public static ArrayList < String > getLangScripts ( String lang ) { if ( ! isMacroLanguage ( lang )) { System . out . println ( \"Not a Macro language; try \\\"Java\\\"\" ); return null ; } ArrayList < String > fScripts = new ArrayList <> (); ArrayList < String > scriptURIs = getScripts (); for ( String scriptURI : scriptURIs ) if ( scriptURI . contains ( \"language=\" + lang + \"&\" )) fScripts . add ( scriptURI ); return fScripts ; } // end of getLangScripts() Macros.getScripts() utilizes services and interfaces in the com.sun.star.script.browse module to examine a scripts tree structure consisting of CONTAINER and SCRIPT nodes \u2013 the CONTAINER nodes are the internal branches of the tree representing libraries and modules, while SCRIPT nodes are the leaves holding macro information. Macros.getScripts() accesses the root of the MACROORGANIZER tree, and collects script names by having getLibScripts() recursively traverse the tree, adding names to a scripts ArrayList: // in the Macros class public static ArrayList < String > getScripts () { ArrayList < String > scripts = new ArrayList <> (); XComponentContext xcc = Lo . getContext (); XBrowseNodeFactory bnf = Lo . qi ( XBrowseNodeFactory . class , xcc . getValueByName ( \"/singletons/com.sun.star.script. browse.theBrowseNodeFactory\" )); XBrowseNode rootNode = Lo . qi ( XBrowseNode . class , bnf . createView ( BrowseNodeFactoryViewTypes . MACROORGANIZER ) ); // for scripts XBrowseNode [] typeNodes = rootNode . getChildNodes (); for ( int i = 0 ; i < typeNodes . length ; i ++ ) { XBrowseNode typeNode = typeNodes [ i ] ; XBrowseNode [] libraryNodes = typeNode . getChildNodes (); for ( int j = 0 ; j < libraryNodes . length ; j ++ ) getLibScripts ( libraryNodes [ j ] , 0 , typeNode . getName (), scripts ); } System . out . println (); return scripts ; } // end of getScripts() public static void getLibScripts ( XBrowseNode browseNode , int level , String path , ArrayList < String > scripts ) { XBrowseNode [] scriptNodes = browseNode . getChildNodes (); if (( scriptNodes . length == 0 ) && ( level > 1 )) // not a top-level library System . out . println ( \"No scripts in \" + path ); for ( int i = 0 ; i < scriptNodes . length ; i ++ ) { XBrowseNode scriptNode = scriptNodes [ i ] ; if ( scriptNode . getType () == BrowseNodeTypes . SCRIPT ) { XPropertySet props = Lo . qi ( XPropertySet . class , scriptNode ); if ( props != null ) { try { scripts . add (( String ) props . getPropertyValue ( \"URI\" )); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } else System . out . println ( \"No props for \" + scriptNode . getName ()); } else if ( scriptNode . getType () == BrowseNodeTypes . CONTAINER ) getLibScripts ( scriptNode , level + 1 , path + \">\" + scriptNode . getName (), scripts ); else System . out . println ( \"Unknown node type\" ); } } // end of getLibScripts() All the Java macros can be listed by calling: run ListMacros Java It will print something like: Java Macros in Office: (6) vnd.sun.star.script:Utils.GetNumber.get?language=Java& location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:Utils.GetText.show?language=Java& location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:HelloWorld.org.libreoffice.example.java_scripts. HelloWorld.printHW?language=Java&location=share vnd.sun.star.script:Highlight.org.libreoffice.example.java_scripts. HighlightText.showForm?language=Java&location=share vnd.sun.star.script:MemoryUsage.org.libreoffice.example.java_scripts. MemoryUsage.updateMemoryUsage?language=Java&location=share vnd.sun.star.script:ShowEvent.ShowEvent.show?language=Java& location=share Six Java macros were found: two are user macros from the FormMacros.oxt extension, and four are share macros. The first three share macros (HelloWorld.printHW, HighlightText.showForm, and MemoryUsage.updateMemoryUsage) are LibreOffice examples; I'll explain the first one: vnd . sun . star . script : HelloWorld . org . libreoffice . example . java_scripts . HelloWorld . printHW ? language = Java & location = share The macro's location parameter is \"location=share\", which means that it appears in the \"LibreOffice Macros\" section of the Macro Selector dialog in Figure 4. Figure 4. The HelloWorld.printHW Macro. The four components of \"HelloWorld.org.libreoffice.example.java_scripts.HelloWorld.printHW\" are: folder: HelloWorld package: org.libreoffice.example.java_scripts class name: HelloWorld function name: printHW The HelloWorld folder is inside C:\\Program Files\\LibreOffice 5\\share\\Scripts\\java\\, as confirmed by Figure 5. Figure 5. The HelloWorld Folder in share\\Scripts\\java. Figure 5 also shows Highlight\\, MemoryUsage and ShowEvent folders which hold the other three share macros listed by ListMacros.java. The HelloWorld folder contains the compiled HelloWorld class in a JAR file, and a parcel-descriptor.xml configuration file, which I'll explain later. It also has the source code for HelloWorld, which isn\u2019t required by Office, but included as an example for developers. Figure 6 shows the contents of HelloWorld. Figure 6. The Contents of the HelloWorld Folder. The format of the HelloWorld class in the JAR file is: package org.libreoffice.example.java_scripts; public class HelloWorld { public static void printHW ( XScriptContext xSc ) { /* code not shown */ } } HelloWorld implements a single printHW() function. My FindMacros.java example calls Macros.findScripts() with a substring, and all the macro names containing that string are printed. For example, a search for \"hello\" returns five matches: Matching Macros in Office: (5) vnd.sun.star.script:Utils.HelloWorld.hello? language=Java&location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:HelloWorld.helloworld.bsh? language=BeanShell&location=share vnd.sun.star.script:HelloWorld.org.libreoffice.example.java_scripts. HelloWorld.printHW?language=Java&location=share vnd.sun.star.script:HelloWorld.helloworld.js? language=JavaScript&location=share vnd.sun.star.script:HelloWorld.py$HelloWorldPython? language=Python&location=share Four of the hello-related scripts are share macros written in BeanShell, Java, JavaScript, and Python.","title":"Listing and Finding Macro Names"},{"location":"48-Event_Macros.html#4-calling-the-hello-macros","text":"The TextMacros.java example creates a text document, and calls the four \"hello\" share macros listed above by FindMacros.java. They each add a short piece of text to the document, as displayed on lines 2-5 in Figure 7. Figure 7. A Document with \"hello\" Macros Text. TextMacros.java utilizes Macros.execute() to call the macros: // in TextMacros.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } if ( Macros . getSecurity () == Macros . LOW ) Macros . setSecurity ( Macros . MEDIUM ); XTextCursor cursor = Write . getCursor ( doc ); GUI . setVisible ( doc , true ); Lo . wait ( 1000 ); // make sure the document is visible // before sending it dispatches Write . appendPara ( cursor , \"Hello LibreOffice\" ); Macros . execute ( \"HelloWorld.helloworld.bsh\" , \"BeanShell\" , \"share\" ); Write . endParagraph ( cursor ); Macros . execute ( \"HelloWorld.py$HelloWorldPython\" , \"Python\" , \"share\" ); Write . endParagraph ( cursor ); Macros . execute ( \"HelloWorld.helloworld.js\" , \"JavaScript\" , \"share\" ); Write . endParagraph ( cursor ); Macros . execute ( \"HelloWorld.org.libreoffice.example. java_scripts.HelloWorld.printHW\" , \"Java\" , \"share\" ); Write . endParagraph ( cursor ); Write . appendPara ( cursor , \"Timestamp: \" + Lo . getTimeStamp ()); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The arguments of Macros.execute() are the MACROPARAM, LANGPARAM, and LOCPARAM parts of the macro's URI; they're separated out to make the macro's name a little easier to read. Macros.execute() uses the theMasterScriptProviderFactory service to obtain a XScriptProviderFactory It creates a XScriptProvider which can load the named macro as an XScript object; the script is executed by XScript.invoke(): // in the Macros class public static Object execute ( String macroName , String language , String location ) { return execute ( macroName , null , language , location ); } public static Object execute ( String macroName , Object [] params , String language , String location ) { if ( ! isMacroLanguage ( language )) { System . out . println ( \"\\\"\" + language + \"\\\" is not a macro language name\" ); return null ; } try { /* deprecated approach XScriptProviderFactory spFactory = Lo.createInstanceMCF( XScriptProviderFactory.class, \"com.sun.star.script.provider.MasterScriptProviderFactory\"); */ XComponentContext xcc = Lo . getContext (); XScriptProviderFactory spFactory = Lo . qi ( XScriptProviderFactory . class , xcc . getValueByName ( \"/singletons/com.sun.star.script.provider. theMasterScriptProviderFactory\" )); XScriptProvider sp = spFactory . createScriptProvider ( \"\" ); XScript xScript = sp . getScript ( \"vnd.sun.star.script:\" + macroName + \"?language=\" + language + \"&location=\" + location ); // minimal inout/out parameters short [][] outParamIndex = { { 0 } }; Object [][] outParam = { { null } }; return xScript . invoke ( params , outParamIndex , outParam ); } catch ( Exception e ) { System . out . println ( \"Could not execute macro \" + macroName + \": \" + e ); return null ; } } // end of execute() Input parameters can be passed to invoke(), but the three-argument version of Macros.execute() sets them to null. It's also possible to have the script set output parameters, but my call to XScript.invoke() doesn't use them either. There's no need to pass Macros.execute() a reference to the document. An executing script only requires Office's current context which is retrieved by Lo.getContext().","title":"4.  Calling the \"hello\" Macros"},{"location":"48-Event_Macros.html#41-macro-security-levels","text":"Prior to the macro calls in TextMacros.java, there's a call to Macros.getSecurity(). It reports Office's macro execution setting, which is changed to Macros.MEDIUM if the current value is Macros.LOW: // part of TextMacros.java... if ( Macros . getSecurity () == Macros . LOW ) Macros . setSecurity ( Macros . MEDIUM ); The Macros class defines four security constants: LOW, MEDIUM, HIGH, VERY_HIGH, which correspond to the levels used in Office's \"Macro Security\" dialog shown in Figure 8. It is reached via Tools, Options, Security, and the \"Macro Security\" button. Figure 8. The Macro Security Dialog. The Office API has a MacroExecMode class (see lodoc MacroExecMode ) which defines many more security levels, but the four levels in the GUI seem sufficient. Macros.getSecurity() uses Info.getConfig() to access the \"/org.openoffice.Office.Common/Security/Scripting\" configuration node, and look up its \"MacroSecurityLevel\" property: // in the Macros class public static int getSecurity () { System . out . println ( \"Macro security level:\" ); Integer val = ( Integer ) Info . getConfig ( \"/org.openoffice.Office.Common/Security/Scripting\" , \"MacroSecurityLevel\" ); // various tests of val, before returning its int value // : return val . intValue (); } Macros . setSecurity () manipulates the same configuration node but supplies a new value for the \"MacroSecurityLevel\" property : // in the Macros class public static boolean setSecurity ( int level ) { if (( level == Macros . LOW ) || ( level == Macros . MEDIUM ) || ( level == Macros . HIGH ) || ( level == Macros . VERY_HIGH )) { System . out . println ( \"Setting macro security level to \" + level ); return Info . setConfig ( \"/org.openoffice.Office.Common/Security/Scripting\" , \"MacroSecurityLevel\" , Integer . valueOf ( level )); } else { System . out . println ( \"Use Macros class constants: LOW, MEDIUM, HIGH, or VERY_HIGH\" ); return false ; } } // end of setSecurity()","title":"4.1.  Macro Security Levels"},{"location":"48-Event_Macros.html#42-implementing-the-helloworld-java-macro","text":"The four macros called by TextMacros.java add text to the document, but how exactly? The Java macro is called using: // part of TextMacros.java... Macros . execute ( \"HelloWorld.org.libreoffice.example. java_scripts.HelloWorld.printHW\" , \"Java\" , \"share\" ); This invokes the printHW() static method in the HelloWorld class in the org.libreoffice.example.java_scripts package shown back in Figure 4. The complete code for the class (minus some comments) is: // the HelloWorld class package org.libreoffice.example.java_scripts ; import com.sun.star.script.provider.XScriptContext ; import com.sun.star.uno.* ; import com.sun.star.text.* ; public class HelloWorld { public static void printHW ( XScriptContext xSc ) { XTextDocument xtextdocument = ( XTextDocument ) UnoRuntime . queryInterface ( XTextDocument . class , xSc . getDocument ()); XText xText = xtextdocument . getText (); XTextRange xTextRange = xText . getEnd (); xTextRange . setString ( \"Hello World (in Java)\" ); } // end of printHW() } // end of HelloWorld class XScript.invoke() constructs a one-argument call to printHW(), passing it a XScriptContext object. As we'll see later, a function can be called with different arguments depending on what event triggers the macro. The XScriptContext interface defines four methods which allow the current context, the desktop, and document to be accessed (see lodoc XScriptContext). printHW() utilizes XScriptContext.getDocument() to retrieve the document, and casts it to XTextDocument. This allows the end of the text to be accessed with XTextRange, so a string (\"\"Hello World (in Java)\") can be appended to it.","title":"4.2.  Implementing the HelloWorld Java Macro"},{"location":"48-Event_Macros.html#5-the-librelogo-macro","text":"HelloWorld isn't the most exciting of macro examples. LibreLogo is a fun (and educational) share macro for LibreOffice (see Figure 9), which has been a standard Office add-on since version 4.0. Figure 9. The LibreLogo Macro Module. Normally LibreLogo is accessed through its own View, Toolbars, Logo toolbar, which is just as well since the Macro selector doesn't list any macros in the LibreLogo module (see the empty area on the right of Figure 9). I had to examine the module's Python code in \\share\\Scripts\\python\\LibreLogo\\LibreLogo.py to work out how to call it as a function. My UseLogo.java example creates a text document, writes the logo program text onto the page, followed by LibreLogo's rendering of that program, as in Figure 10. Figure 10. The Page Generated by UseLogo.java. UseLogo.java is: public class UseLogo { public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); XTextDocument doc = Write . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Writer doc creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . wait ( 1000 ); // make sure doc is visible XTextCursor cursor = Write . getCursor ( doc ); String logoCmds = \"repeat 88 [ fd 200 left 89 ] fill\" ; Write . appendPara ( cursor , logoCmds ); Macros . executeLogoCmds ( logoCmds ); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of UseLogo class Macros.executeLogoCmds() is a small wrapper around Macros.execute() which calls the commandline() function inside LibreLogo.py: // in the Macros class public static Object executeLogoCmds ( String cmdsStr ) { Object [] params = new String [ 2 ] ; params [ 0 ] = \"\" ; // based on looking at commandline() params [ 1 ] = cmdsStr ; // in LibreLogo.py return execute ( \"LibreLogo/LibreLogo.py$commandline\" , params , \"Python\" , \"share\" ); } The params[] array is treated as two arguments by XScript.invoke() and passed to commandline(). The quick-start and resources pages at librelogo.org are the places to start learning LibreLogo ( https://librelogo.org/quick-start/ and https://librelogo.org/resources/ ). There's also a help page of commands at https://help.libreoffice.org/Writer/LibreLogo_Toolbar/ . A good source of examples, slides, and code is https://numbertext.org/logo/ . The best introductory talk at that site is \"LibreLogo \u2013 Turtle vector graphics for everybody\" from 2012 ( https://numbertext.org/logo/librelogo.pdf ), and there are more recent presentations which update the project. One of its aims was to create a textbook for Hungarian primary and secondary schools (the project lead, L\u00e1szl\u00f3 N\u00e9meth, is Hungarian), which is free to download from https://szabadszoftver.kormany.hu/wp-content/uploads/librelogo_oktatasi_segedanyag_v4.pdf .","title":"5.  The LibreLogo Macro"},{"location":"48-Event_Macros.html#6-writing-a-simple-event-macro","text":"It's time to start coding our own macros. I'll start by writing a ShowEvent class which reports when various events occur. It does this by implementing several versions of a static show() method: // in ShowEvent.java public class ShowEvent { public static void show ( XScriptContext sc , ActionEvent e ) // triggered by a action event (usually a button press) { display ( \"action\" , getSource ( e )); } public static void show ( XScriptContext sc , TextEvent e ) // called when text changes inside a text component { display ( \"text\" , getSource ( e )); } public static void show ( XScriptContext sc , FocusEvent e ) // called when the focus changes { display ( \"focus\" ); } public static void show ( XScriptContext sc , Short val ) // called from a toolbar { display ( \"toolbar (\" + val + \")\" ); } public static void show ( XScriptContext sc , KeyEvent e ) // called because of a key { display ( \"key \" + e . KeyChar , getSource ( e )); } public static void show ( XScriptContext sc , MouseEvent e ) // called because of the mouse { display ( \"mouse\" ); } public static void show ( XScriptContext sc , com . sun . star . document . DocumentEvent e ) // triggered by a document event { display ( \"document\" , e . EventName ); } public static void show ( XScriptContext sc , EventObject e ) { if ( e != null ) display ( \"object\" , getSource ( e )); else display ( \"object ()\" ); } public static void show ( XScriptContext sc ) // called from a menu or the \"Run Macro...\" menu { display ( \"menu/run\" ); } // support methods; explained shortly // : } // end of ShowEvent class A particular show() function is called depending on the event, and more versions of show() could easily be added since Office supports a wide range of events. Probably the best summary of them is in the online documentation for EventObject (see lodoc EventObject ); EventObject is the superclass for most event types. When I first wrote ShowEvent, I mistakenly assumed that the show() function with the EventObject argument (i.e. the second to last one in the code above) would be the default method called when no other version of show() was suitable. That isn't the case; instead, the single argument show() (i.e. the last function, show(XScriptContext sc) ) is executed. The show() methods utilize display() and showDialog(): // part of the ShowEvent class... private static void display ( String msg ) { showDialog ( msg + \" event\" ); // JOptionPane.showMessageDialog(null, msg + \" event\"); } private static void display ( String msg , String info ) { showDialog ( msg + \" event: \" + info ); // JOptionPane.showMessageDialog(null, msg + \" event: \" + info); } private static void showDialog ( String msg ) { JDialog dlg = new JDialog (( java . awt . Frame ) null , \"Show Event\" ); dlg . getContentPane (). setLayout ( new GridLayout ( 3 , 1 )); dlg . add ( new JLabel ( \"\" )); dlg . add ( new JLabel ( msg , SwingConstants . CENTER )); // centered text dlg . pack (); Random r = new Random (); dlg . setLocation ( 100 + r . nextInt ( 50 ), 100 + r . nextInt ( 50 )); dlg . setVisible ( true ); dlg . setResizable ( false ); dlg . setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ); } // end of showDialog() A modeless dialog is displayed using Java's JDialog rather than JOptionPane.showMessageDialog(), which means that the dialog won't cause Office to suspend until the user closes the window. Each dialog is placed at a slightly random position, so that multiple dialogs created by several events will all hopefully be visible. Another issue is that the dialog's parent is null which means that the dialog may not appear in front of the Office window. No use is made of my utility classes, such as Macros.java or GUI.java. Although this makes the code longer, it also makes this example self-contained, and easier to install. I'll use my support classes in the extension and document examples in the next chapter. Events which are usually triggered by GUI components, such as ActionEvent and TextEvent, are passed to getSource() which attempts to find the name of the component that sent the event: // part of the ShowEvent class... private static String getSource ( EventObject event ) { XControl control = UnoRuntime . queryInterface ( XControl . class , event . Source ); XPropertySet xProps = UnoRuntime . queryInterface ( XPropertySet . class , control . getModel ()); try { return ( String ) xProps . getPropertyValue ( \"Name\" ); } catch ( com . sun . star . uno . Exception e ) { return \"Exception?\" ; } catch ( com . sun . star . uno . RuntimeException e ) { return \"RuntimeException?\" ; } } // end of getSource()","title":"6.  Writing a Simple Event Macro"},{"location":"48-Event_Macros.html#61-installing-a-simple-event-macro","text":"A Java macro is installed as a JAR file, so ShowEvent.class is packaged as ShowEvent.jar after compilation: compile ShowEvent.java jar cvf ShowEvent.jar ShowEvent.class The JAR is added to a new folder called ShowEvent beneath \\share\\Scripts\\java\\, thereby making it a share macro. It's also necessary to include a parcel-descriptor.xml file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <parcel language=\"Java\" xmlns:parcel=\"scripting.dtd\"> <script language=\"Java\"> <locale lang=\"en\"> <displayname value=\"ShowEvent.show\"/> <description> Shows a dialog with basic event information. </description> </locale> <functionname value=\"ShowEvent.show\"/> <logicalname value=\"ShowEvent.show\"/> <languagedepprops> <prop name=\"classpath\" value=\"ShowEvent.jar\"/> </languagedepprops> </script> </parcel> Of the three 'name' attributes in the XML file, only seems to be used by Office. The text appears in the Macro selector dialog (e.g. see Figure 12 below) when the macro is selected, and adds the JAR to Office's classpath. The final contents of the ShowEvent folder are a JAR and XML file, as shown in Figure 11. Figure 11. The ShowEvent Share Macro Folder. It's a good idea to check that this new macro can be seen by Office. Office should be restarted and the \"LibreOffice Macros\" subsection of the Macro Selector dialog examined. Figure 12 shows the ShowEvent.show macro in the ShowEvent module. Figure 12. Checking for the Presence of ShowEvent.show.","title":"6.1.  Installing a Simple Event Macro"},{"location":"48-Event_Macros.html#62-using-showeventshow-in-a-form","text":"build.odt is a simple form using textfields and buttons shown in Figure 13. Figure 13. The \"build.odt\" Form. The event handling properties of a control are accessed by changing to form design mode (click the \"OK hand\" icon, second from the left in the toolbar at the bottom of Figure 13). Subsequently, the mouse is right-clicked over a control, such as the FIRSTNAME textfield selected in Figure 13. The resulting pop-up menu includes a \"Control\" menu item which displays the control's Properties dialog (see Figure 14). Figure 14. The Properties Dialog for the FIRSTNAME Textfield Control. The Events tab (shown in Figure 14) lists all the events associated with the control, and a macro is attached by pressing on the right-hand \"\u2026\" button for an event. An \"Assign Action\" dialog appears, like the one in Figure 15. Figure 15. The \"Assign Action\" Dialog. Figure 15 shows that the user has selected the \"Key pressed\" event. Clicking on the \"Macro\u2026\" button brings forth the Macro Selector dialog, and a macro can be chosen. Upon returning to the \"Assign Action\" dialog, the event will list the macro in the \"Assigned Action\" column. Clicking \"Ok\" again returns to the properties dialog which now shows the macro name next to the \"Key pressed\" event, as in Figure 16. Figure 16. The Properties Dialog with an Assigned Macro. The macro's arguments (\"share\" and \"Java\") are its category and implementation language. The event/macro link can be tested by returning to the default mode in the form by clicking the \"Ok hand\" icon again. When the user types three letters into the FIRSTNAME textfield (e.g. \"and\"), three dialogs appear, as in Figure 17. Figure 17. Reporting Key Events. I've rearranged the three dialogs in Figure 17 so they're all visible. They're generated by the KeyEvent version of ShowEvent.show: // part of the ShowEvent class... public static void show ( XScriptContext sc , KeyEvent e ) // Called from a key { display ( \"key \" + e . KeyChar , getSource ( e )); } As each letter (\"a', 'n', and 'd') is typed, this version of show() is called.","title":"6.2.  Using ShowEvent.show in a Form"},{"location":"48-Event_Macros.html#7-automating-the-assigning-of-event-macros","text":"The preceding section illustrates that the assignment of macros to events is straightforward, but time-consuming, especially if you have many controls in your form. Fortunately, macros can be assigned programmatically. I first used the \"build.odt\" form of Figure 13 back in Chapter 40 on forms; it wasn't created by hand but generated by BuildForm.java. That program is extended in this section with calls to Forms.assignScript() which assigns a macro to an event in a control. I'll employ Forms.assignScript() so that the FIRSTNAME textfield calls ShowEvent.show whenever its text changes, focus is lost, or a key is pressed. Also, the six buttons at the bottom of the form (see Figure 13) will execute ShowEvent.show when they're pressed. The new code is highlighted in bold in createForm(): // part of BuildForm.java... private void createForm ( XTextDocument doc ) { XPropertySet props = Forms . addLabelledControl ( doc , \"FIRSTNAME\" , \"TextField\" , 11 ); textEvents ( props ); // only the FIRSTNAME textfield has a listener Forms . addLabelledControl ( doc , \"LASTNAME\" , \"TextField\" , 19 ); props = Forms . addLabelledControl ( doc , \"AGE\" , \"NumericField\" , 43 ); Props . setProperty ( props , \"DecimalAccuracy\" , ( short ) 0 ); Forms . addLabelledControl ( doc , \"BIRTHDATE\" , \"FormattedField\" , 51 ); // buttons, all with listeners props = Forms . addButton ( doc , \"first\" , \"<<\" , 2 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"prev\" , \"<\" , 12 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"next\" , \">\" , 22 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"last\" , \">>\" , 32 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"new\" , \">*\" , 42 , 63 , 8 ); buttonEvent ( props ); props = Forms . addButton ( doc , \"reload\" , \"reload\" , 58 , 63 , 13 ); buttonEvent ( props ); } // end of createForm() The property set for the FIRSTNAME textfield is passed to textEvents(), which calls Forms.assignScript() three times: // part of BuildForm.java... public void textEvents ( XPropertySet props ) { // listen for text change Forms . assignScript ( props , \"XTextListener\" , \"textChanged\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); // listen for focus loss Forms . assignScript ( props , \"XFocusListener\" , \"focusLost\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); // listen for a key press Forms . assignScript ( props , \"XKeyListener\" , \"keyPressed\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); } // end of textEvents() The buttonEvent () method is a ( long ) one - liner : // part of BuildForm.java... public void buttonEvent ( XPropertySet props ) { Forms . assignScript ( props , \"XActionListener\" , \"actionPerformed\" , \"ShowEvent.ShowEvent.show\" , \"share\" ); } It's surprisingly tricky to decide which class and method names should be passed to Forms.assignScript() since the only information about control events are the labels in the Properties dialog (e.g. \"Key pressed\" in Figure 16). It can be hard to map these labels onto suitable class and method names, especially since Office supports so many event types. The best source for suitable listener classes is the online documentation for XEventListener (see lodoc XEventListener); XEventListener is the superclass of most listeners. After the generated form has been saved, it should be opened in Office so its controls' properties can be inspected. For example, the FIRSTNAME textfield's event properties are now as in Figure 18. Figure 18. The Properties Dialog for the FIRSTNAME textfield. Figure 18 confirms that the class/method names used in textEvents() are correct. Forms.assignScript() utilizes the XEventAttacherManager interface which offers multiple methods for attaching and removing scripts from events. The code for Forms.assignScript(): // in the Forms class public static void assignScript ( XPropertySet controlProps , String interfaceName , String methodName , String scriptName , String loc ) { try { XChild propsChild = Lo . qi ( XChild . class , controlProps ); XIndexContainer parentForm = Lo . qi ( XIndexContainer . class , propsChild . getParent ()); int pos = - 1 ; for ( int i = 0 ; i < parentForm . getCount (); i ++ ) { XPropertySet child = Lo . qi ( XPropertySet . class , parentForm . getByIndex ( i ) ); if ( UnoRuntime . areSame ( child , controlProps )) { pos = i ; break ; } } if ( pos == - 1 ) System . out . println ( \"Could not find contol's pos in form\" ); else { XEventAttacherManager manager = Lo . qi ( XEventAttacherManager . class , parentForm ); manager . registerScriptEvent ( pos , new ScriptEventDescriptor ( interfaceName , methodName , \"\" , \"Script\" , \"vnd.sun.star.script:\" + scriptName + \"?language=Java&location=\" + loc )); } } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of assignScript() The first half of assignScript() calculates the control's index position inside the parent's form. An index is used by most XEventAttacherManager methods to refer to a control. The last part of assignScript() uses XEventAttacherManager.registerScriptEvent() to attach the script to the control's event. A ScriptEventDescriptor object is constructed from five arguments: the listener's class name, the method to be called in the listener, any extra data for the method (which is \"\" here), the script type (which can be \"Script\" or \"Basic\"), and the macro's full name. If you're unsure about the full name, then use my ListMacros.java or FindMacros.java to display macro details. For example: run FindMacros ShowEvent produces: Matching Macros in Office : ( 1 ) vnd . sun . star . script : ShowEvent . ShowEvent . show ? language = Java & location = share \"ShowEvent.ShowEvent.show\" and \"share\" are passed to Forms.assignScript() as its last two arguments: java // part of BuildForm.java... Forms.assignScript(props, \"XTextListener\", \"textChanged\", \"ShowEvent.ShowEvent.show\", \"share\");","title":"7.  Automating the Assigning of Event Macros"},{"location":"49-Ext_Doc_Event_Macros.html","text":"Chapter 49. Extension and Document Event Macros \u00b6 Topics Form Macros as an Extension; Loading an XML Dialog; Building a Dialog at Runtime; Storing Macros inside the (Form) Document; Attaching Macros to Other Events; Executing Macros from the Command Line Example folders: \"EvMacro Tests\" and \"Utils\" The previous chapter introduced event macros, and described how a simple macro could be installed by copying it to a specific Office directory. This chapter looks at two other ways to package macros: as extensions, and by attaching them to documents. 1. Form Macros as an Extension \u00b6 Adding a macro to Office by installing it as an extension means that the user doesn't need to grapple with Office folders and copying files since Office's extension manager does it for them. This section also uses more complex macros than the ones in the previous chapter, namely ones that utilize their own dialogs and employ my utility classes. The FormMacros.oxt extension is created by zipping up a FormMacros folder, which is listed below: FormMacros | description.xml | form.png | license.txt | package-description.txt | +---dialogLibrary | NumExtractor.xdl | +---META-INF | manifest.xml | \\---Utils GetNumber.class GetText.class NumActionListener.class parcel-descriptor.xml Utils.jar The macros are in the Utils folder, and are utilized by the form stored in FormMacrosTest.odt in the ways shown in Figure 1. Figure 1. A Form and its Macros. Figure 1 illustrates the actions of two macros. GetText.show is attached to the form's button, and display the text in the adjacent textfield when the button is pressed. The GetNumber.get macro is attached to the second textfield, and is activated when is pressed. A dialog, created by the macro, offers the user a choice of replacing the text by a number or clearing the textfield. To simplify the example a little, FormMacrosTest.odt was created by hand rather than programmatically. Also, I'm going to attach the extension's macros to the button and textfield using Office's GUI, as explained shortly. I won\u2019t explain all the contents of the FormMacros folder, because most of them were covered in early chapters, particularly in Chapter 45. For example, I won't be describing how I drew the \"Number Extractor\" dialog stored in dialogLibrary\\NumExtractor.xdl since that technique was covered in the last chapter, in section 5. The new elements of FormMacros are the contents of manifest.xml and parcel- descriptor.xml. manifest.xml states the location of the macros inside the extension, which in my case are in the Utils subdirectory. This is encoded as: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <manifest:manifest xmlns:manifest=\"https://openoffice.org/2001/manifest\"> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.framework-script\" manifest:full-path=\"Utils/\" /> </manifest:manifest> parcel-descriptor.xml give details about the two macros, GetText.show and GetNumber.get, which are used by the Macro Selector dialog: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <parcel language=\"Java\" xmlns:parcel=\"scripting.dtd\"> <script language=\"Java\"> <locale lang=\"en\"> <displayname value=\"GetText.show\"/> <description> Shows the text in a textfield </description> </locale> <functionname value=\"GetText.show\"/> <logicalname value=\"GetText.show\"/> <languagedepprops> <prop name=\"classpath\" value=\".:GetText:Utils.jar\"/> </languagedepprops> </script> <script language=\"Java\"> <locale lang=\"en\"> <displayname value=\"GetNumber.get\"/> <description> Extract an integer from a textfield </description> </locale> <functionname value=\"GetNumber.get\"/> <logicalname value=\"GetNumber.get\"/> <languagedepprops> <prop name=\"classpath\" value=\".:GetNumber:Utils.jar\"/> </languagedepprops> </script> </parcel> There's an important difference between this parcel-descriptor.xml and the one given for ShowEvent.show in the previous chapter, related to the new macros' classpaths: < prop name = \"classpath\" value = \".:GetText:Utils.jar\" /> and < prop name = \"classpath\" value = \".:GetNumber:Utils.jar\" /> The classpath line for ShowEvent.show was: < prop name = \"classpath\" value = \"ShowEvent.jar\" /> The difference, which took many hours of experimentation to find, is due to the inclusion of my utilities classes as a JAR in Utils. When Utils.jar is in the extension, Office is unable to recognize GetText.show and GetNumber.get packaged as JARs (e.g. as GetText.jar and GetNumber.jar). It appears that Office can only add a single JAR to its classpath with . Instead I've stored the macros as .class files in Utils. In addition, it's necessary to include \".\" in the classpath so NumActionListener.class can be found at runtime. The three Java files (GetText.java, GetNumber.java, and NumActionListener.java) are compiled and manually copied into FormMacros\\Utils. Then the installMacros.bat batch script zips up the folder as an OXT file, and calls unopkg.exe to install it. The extension manager displays the \"Form Macros\" as in Figure 2. Figure 2. The Form Macros Extension. By default, extension macros are installed as user macros, as can be seen in the Macro Selector dialog in Figure 3. Figure 3. The User Extension Macros in the Macro Selector. The Utils subdirectory of the extension has become a module called Utils. The full names of the extension macros can be obtained using my ListMacros.java or FindMacros.java examples. For example: run FindMacros Utils produces: Matching Macros in Office: (2) vnd.sun.star.script:Utils.GetNumber.get? language=Java&location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:Utils.GetText.show? language=Java&location=user:uno_packages/FormMacros.oxt 1.1. The GetText.show Macro \u00b6 GetText.show is triggered when a button is pressed; it displays the text currently in the \"Text Box 1\" textfield inside a message box (see Figure 1). The code for the class is: // in GetText.java public class GetText { private static final String LOG_FNM = \"c://macrosInfo.txt\" ; // log file for storing debugging output public static void show ( XScriptContext sc , ActionEvent e ) // Called when a button pressed { String controlName = Forms . getEventSourceName ( e ); FileIO . appendTo ( LOG_FNM , \"\\\"\" + controlName + \"\\\" sent ActionEvent at \" + Lo . getTimeStamp ()); XComponent doc = Lo . scriptInitialize ( sc ); if ( doc == null ) return ; // for debugging Console console = new Console (); console . setVisible ( true ); Forms . listForms ( doc ); XControlModel textBox = Forms . getControlModel ( doc , \"Text Box 1\" ); // Props.showObjProps(\"TextBox\", textBox); String textContents = ( String ) Props . getProperty ( textBox , \"Text\" ); GUI . showXMessageBox ( \"Textbox text\" , textContents ); console . setVisible ( false ); console . closeDown (); } // end of show() for ActionEvent } // end of GetText class The class implements a single show() method suitable for responding to ActionEvents. Forms.getEventSourceName() returns the name of the control that sent the event and FileIO.appendTo() writes the details to a log file. This log is useful for debugging, and can be removed when the macro is finished. Lo.scriptInitialize() uses the macro's XScriptContext object to initialize globals maintained by my Lo class: // in the Lo class // globals private static XComponentContext xcc = null ; private static XDesktop xDesktop = null ; private static XMultiComponentFactory mcFactory = null ; private static XMultiServiceFactory msFactory = null ; public static XComponent scriptInitialize ( XScriptContext sc ) { if ( sc == null ) { System . out . println ( \"Script Context is null\" ); return null ; } xcc = sc . getComponentContext (); if ( xcc == null ) { System . out . println ( \"Could not access component context\" ); return null ; } mcFactory = xcc . getServiceManager (); if ( mcFactory == null ) { System . out . println ( \"Office Service Manager is unavailable\" ); return null ; } xDesktop = sc . getDesktop (); if ( xDesktop == null ) { System . out . println ( \"Could not access desktop\" ); return null ; } XComponent doc = xDesktop . getCurrentComponent (); if ( doc == null ) { System . out . println ( \"Could not access document\" ); return null ; } msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); return doc ; } // end of scriptInitialize() The log approach is fine for simple debugging, but it's also possible to create a Console window for displaying more complex textual output. One useful thing to report are the form's control details, by calling Forms.listForms(). The Console window looks as in Figure 4. Figure 4. The Console Window Output for GetText.show. The control names in Figure 4 include \"Text Box 1\", which is used by Forms.getControlModel() to reference the textfield control: // part of show() in GetText.java... XControlModel textBox = Forms . getControlModel ( doc , \"Text Box 1\" ); String textContents = ( String ) Props . getProperty ( textBox , \"Text\" ); GUI . showXMessageBox ( \"Textbox text\" , textContents ); 1.2. The GetNumber.get Macro \u00b6 The second textfield in Figure 1 is called \"AgeText\". Its listener processes the text when the user types , which is implemented using a keypress listener, as shown in Figure 5. Figure 5. The \"AgeText\" Properties Dialog. GetNumber.get is woken up by every keypress, which should be ignored until the key is . Then the text is read from the \"AgeText\" textfield, and the extracted number displayed in the \"Number Extractor\" dialog (shown in Figure 1). This dialog has its own listener (a NumActionListener object) attached to the \"Ok\" and \"Cancel\" buttons which updates the \"AgeText\" textfield depending on which is pressed. The GetNumber class defines a single static get() method, suitable for receiving KeyEvents: // in GetNumber.java public static void get ( XScriptContext sc , KeyEvent e ) { String controlName = Forms . getEventSourceName ( e ); if ( e . KeyCode == Key . RETURN ) { // return typed XComponent doc = Lo . scriptInitialize ( sc ); if ( doc != null ) { XControlModel cModel = Forms . getControlModel ( doc , controlName ); if ( Forms . isTextField ( cModel )) loadXDLDialog ( cModel ); // runtimeDialog(cModel); } } } // end of get() When the key is pressed, Forms.getControlModel() searches the form for the control that sent the event (i.e. the \"AgeText\" textfield). If the control is a textfield then the \"Number Extractor\" dialog is displayed in one of two ways \u2013 either loadXDLDialog() loads the dialog's XML from dialogLibrary\\NumExtractor.xdl inside the extension, or runtimeDialog() creates the dialog dynamically by calling methods in my Dialogs utility class. I'll look at each approach in the next two sections. 1.3. Loading an XML Dialog \u00b6 Chapter 46 on Add-ons describes how to use Office's dialog editor to create a dialog and export it as an XDL file. The same steps were used to create NumExtractor.xdl, which is shown in Figure 6. Figure 6. The NumExtractor.xdl Dialog. The XML contents of NumExtractor.xdl are: <? xml version = \"1.0\" encoding = \"UTF-8\" ?> <! DOCTYPE dlg : window PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"dialog.dtd\" > < dlg : window xmlns : dlg = \"https://openoffice.org/2000/dialog\" xmlns : script = \"https://openoffice.org/2000/script\" dlg : id = \"NumExtractor\" dlg : left = \"109\" dlg : top = \"73\" dlg : width = \"94\" dlg : height = \"44\" dlg : closeable = \"true\" dlg : moveable = \"true\" dlg : title = \"Number Extractor\" > < dlg : bulletinboard > < dlg : text dlg : id = \"Label1\" dlg : tab - index = \"0\" dlg : left = \"8\" dlg : top = \"11\" dlg : width = \"48\" dlg : height = \"10\" dlg : value = \"Extracted number: \" dlg : align = \"right\" /> < dlg : button dlg : id = \"CommandButton1\" dlg : tab - index = \"2\" dlg : left = \"8\" dlg : top = \"27\" dlg : width = \"33\" dlg : height = \"12\" dlg : value = \"Ok\" /> < dlg : textfield dlg : id = \"TextField1\" dlg : tab - index = \"1\" dlg : left = \"61\" dlg : top = \"9\" dlg : width = \"24\" dlg : height = \"12\" dlg : align = \"center\" dlg : readonly = \"true\" /> < dlg : button dlg : id = \"CommandButton2\" dlg : tab - index = \"3\" dlg : left = \"52\" dlg : top = \"27\" dlg : width = \"33\" dlg : height = \"12\" dlg : value = \"Cancel\" /> </ dlg : bulletinboard > </ dlg : window > The most important things to note for later are the control IDs; in particular, the textfield and button names: \"TextField1\", \"CommandButton1\", and \"CommandButton2\". loadXDLDialog() utilizes Dialogs.loadAddonDialog() described in Chapter 46 to obtain a reference to the dialog. It's initialized by initDialog() and made live by XDialog.execute(): // in GetNumber.java private static void loadXDLDialog ( XControlModel cModel ) { XDialog dialog = Dialogs . loadAddonDialog ( \"org.openoffice.formmacros\" , \"dialogLibrary/NumExtractor.xdl\" ); if ( dialog == null ) return ; initDialog ( dialog , cModel ); dialog . execute (); } // end of loadXDLDialog() initDialog() fills the dialog's textfield with numerical data extracted from the form's \"AgeText\" field, and attaches a NumActionListener to its buttons: // part of GetNumber.java private static void initDialog ( XDialog dialog , XControlModel cModel ) { XControl dialogCtrl = Dialogs . getDialogControl ( dialog ); if ( dialogCtrl == null ) return ; int val = extractDigits ( ( String ) Props . getProperty ( cModel , \"Text\" )); // store extracted number in dialog's read-only text field; // the names of the controls are hardwired XTextComponent numFieldTB = Lo . qi ( XTextComponent . class , Dialogs . findControl ( dialogCtrl , \"TextField1\" )); numFieldTB . setText ( \"\" + val ); // assign same listener to both buttons NumActionListener naListener = new NumActionListener ( dialog , cModel , val ); XButton okButton = Lo . qi ( XButton . class , Dialogs . findControl ( dialogCtrl , \"CommandButton1\" )); okButton . addActionListener ( naListener ); XButton cancelButton = Lo . qi ( XButton . class , Dialogs . findControl ( dialogCtrl , \"CommandButton2\" )); cancelButton . addActionListener ( naListener ); } // end of initDialog() Dialogs.findControl() finds the dialog's textfield and buttons using the IDs that we saw in NumExtractor.xdl. The NumActionListener class is included in the extension's Utils folder. It's a standard button listener, but uses Office's XActionListener and ActionEvent not the Java classes with similar names: // in NumActionListener.java public class NumActionListener implements XActionListener { private XDialog dialog ; private XControlModel cModel ; private int val ; public NumActionListener ( XDialog dialog , XControlModel cModel , int val ) { this . dialog = dialog ; this . cModel = cModel ; this . val = val ; } // end of NumActionListener() public void actionPerformed ( ActionEvent e ) { String buttonName = Dialogs . getEventSourceName ( e ); System . out . println ( \"Event received from : \" + buttonName ); if ( buttonName . equals ( \"CommandButton1\" )) // \"OK\" button Props . setProperty ( cModel , \"Text\" , \"\" + val ); // put val in text field else if ( buttonName . equals ( \"CommandButton2\" )) // \"Cancel\" Props . setProperty ( cModel , \"Text\" , \"\" ); // clear text field dialog . endExecute (); } // end of actionPerformed() public void disposing ( EventObject e ) { } } // end of NumActionListener class The number extracted from the \"AgeText\" textfield is passed to the listener via its constructor, along with a reference to the control. If the user presses \"Ok\" then the number is written into the textfield, otherwise an empty string is used to clear its contents. 1.4. Building a Dialog at Runtime \u00b6 Office's dialog editor is the easiest way to construct a dialog, but there may be situations where you want to create a simple dialog at run time. The commented-out call to runtimeDialog() in GetNumber.get shows how to do this using my Dialog class functions: // part of GetNumber.java private static void runtimeDialog ( XControlModel cModel ) { XControl dialogCtrl = makeDialogControl (); if ( dialogCtrl == null ) return ; XDialog dialog = Dialogs . createDialogPeer ( dialogCtrl ); if ( dialog == null ) return ; initDialog ( dialog , cModel ); dialog . execute (); } // end of runtimeDialog() The dialog generated by makeDialogControl() (see Figure 7) is very similar to the one defined in NumExtractor.xdl. Figure 7. The Rendering of the Runtime Dialog. makeDialogControl() creates an empty dialog, and fills it with a label, textfield and two buttons: // part of GetNumber.java private static XControl makeDialogControl () { XControl dialogCtrl = Dialogs . createDialogControl ( 109 , 73 , 94 , 44 , \"Number Extractor\" ); if ( dialogCtrl == null ) System . out . println ( \"dialog control is null\" ); // log(\"Dialog name:\" + Dialogs.getControlName(dialogCtrl)); // reports \"OfficeDialog1\" XControl xc = Dialogs . insertLabel ( dialogCtrl , 8 , 11 , 48 , \"Extracted Number: \" ); // log(\"Label name:\" + Dialogs.getControlName(xc)); // FixedText1 xc = Dialogs . insertTextField ( dialogCtrl , 61 , 9 , 24 , \"\" ); // log(\"Text field name:\" + Dialogs.getControlName(xc)); // TextField1 xc = Dialogs . insertButton ( dialogCtrl , 9 , 27 , 33 , \"Ok\" ); // log(\"Ok button name:\" + Dialogs.getControlName(xc)); // CommandButton1 xc = Dialogs . insertButton ( dialogCtrl , 52 , 27 , 33 , \"Cancel\" ); // log(\"Cancel button name:\" + Dialogs.getControlName(xc)); // CommandButton2 return dialogCtrl ; } // end of makeDialogControl() One tricky aspect is deciding on the control positions and widths passed to the Dialogs.insertXXX() methods. I based them on the values in NumExtractor.xdl. initDialog() is again used to initialize the dialog's textfield and buttons, which assumes they are called \"TextField1\", \"CommandButton1\", and \"CommandButton2\". I confirmed this for the runtime dialog by writing their name to the log file: // part of GetNumber.java // global private static final String LOG_FNM = \"c://macrosInfo.txt\" ; private static void log ( String msg ) { FileIO . appendTo ( LOG_FNM , msg ); } 1.5. Dialogs and their Controls \u00b6 Dialog controls utilize the same model-view framework as form controls (which were described back in Chapter 39). Controls store data as properties spread over a hierarchy centered around UnoControlModel in the com.sun.star.awt module. A small fragment of that hierarchy is shown in Figure 8. Figure 8. UnoControlModel and Some Subclasses. A dialog is represented by UnoControlDialogModel, which stores properties such as the title, a background image or color, and windowing flags such as whether it is closeable. Its XNameContainer interface allows the names of its component controls to be accessed. Some of the important properties, such as the (x, y) position of a control, are a little hard to find \u2013 they're not in UnoControlModel but its superclass, UnoControlDialogElement. The other part of the model-view framework are views which represent how a control is drawn. Views for different controls are subclasses of the UnoControl service, as shown in Figure 9. Figure 9. UnoControl and Some Subclasses. UnoControl's XControl contains methods for linking a model to a view. Also, subclass interfaces, such as XButton and XTextComponent, are where listeners are attached to controls. It helps to remember the naming conventions illustrated by Figures 8 and 9 \u2013 a service containing the word \"Model\" is almost always for storing data, while a service without the word \"Model\" is almost always a view. Figure 9 doesn't include a dialog view; it's sufficiently different to deserve its own diagram, Figure 10. Figure 10. The UnoControlDialog Service. UnoControlDialog isn't a subclass of UnoControl, but its interface, XUnoControlDialog, still inherits XControl and so can be linked to a model. It also inherits XControlContainer which allows controls to be added to and removed from a dialog. XDialog contains execute() which makes a dialog active on screen. Dialogs.createDialogControl() creates a dialog view and model, and links them. The dialog is initialized by setting various properties in its model: // in the Dialogs class public static XControl createDialogControl ( int x , int y , int width , int height , String title ) { try { XControl dialogCtrl = Lo . createInstanceMCF ( XControl . class , \"com.sun.star.awt.UnoControlDialog\" ); XControlModel xControlModel = Lo . createInstanceMCF ( XControlModel . class , \"com.sun.star.awt.UnoControlDialogModel\" ); dialogCtrl . setModel ( xControlModel ); // link view and model XPropertySet props = getControlProps ( dialogCtrl . getModel ()); props . setPropertyValue ( \"PositionX\" , x ); props . setPropertyValue ( \"PositionY\" , y ); props . setPropertyValue ( \"Height\" , height ); props . setPropertyValue ( \"Width\" , width ); props . setPropertyValue ( \"Title\" , title ); props . setPropertyValue ( \"Name\" , \"OfficeDialog\" ); props . setPropertyValue ( \"Step\" , 0 ); props . setPropertyValue ( \"Moveable\" , true ); props . setPropertyValue ( \"TabIndex\" , new Short (( short ) 0 )); return dialogCtrl ; } catch ( Exception ex ) { System . out . println ( \"Could not create dialog control: \" + ex ); return null ; } } // end of createDialogControl() makeDialogControl() in the GetNumber class adds a label, textfield, and two buttons to the dialog by calling Dialogs.insertXXX() methods. These methods are all quite similar, so I'll only explain insertButton(). Its job is to create a button model, and initialize its properties: // in the Dialogs class public static XControl insertButton ( XControl dialogCtrl , int x , int y , int width , String label ) { return insertButton ( dialogCtrl , x , y , width , label , PushButtonType . STANDARD_value ); } public static XControl insertButton ( XControl dialogCtrl , int x , int y , int width , String label , int pushButtonType ) { try { // create a button model XMultiServiceFactory msf = Lo . qi ( XMultiServiceFactory . class , dialogCtrl . getModel ()); Object model = msf . createInstance ( \"com.sun.star.awt.UnoControlButtonModel\" ); // generate a unique name for the control XNameContainer nameCon = getDialogNmCon ( dialogCtrl ); String nm = createName ( nameCon , \"CommandButton\" ); // set properties in the model XPropertySet props = getControlProps ( model ); props . setPropertyValue ( \"PositionX\" , x ); props . setPropertyValue ( \"PositionY\" , y ); props . setPropertyValue ( \"Height\" , 14 ); props . setPropertyValue ( \"Width\" , width ); props . setPropertyValue ( \"Label\" , label ); props . setPropertyValue ( \"PushButtonType\" , new Short (( short ) pushButtonType )); props . setPropertyValue ( \"Name\" , nm ); // add the model to the dialog nameCon . insertByName ( nm , model ); // get the dialog's container holding all the control views XControlContainer ctrlCon = Lo . qi ( XControlContainer . class , dialogCtrl ); // use the model's name to get its view inside the dialog return ctrlCon . getControl ( nm ); } catch ( Exception ex ) { System . out . println ( \"Could not create button control: \" + ex ); return null ; } } // end of insertButton() First the model is created and added to the dialog. Its view is retrieved from the dialog's control container, and returned as an XControl object. Back in GetNumber.runtimeDialog(), the dialog's window (or peer) is linked to the Office window by Dialogs.createDialogPeer(): // in the Dialogs class public static XDialog createDialogPeer ( XControl dialogCtrl ) { XWindow xWindow = ( XWindow ) Lo . qi ( XWindow . class , dialogCtrl ); xWindow . setVisible ( false ); // set dialog window invisible until it is executed XToolkit xToolkit = Lo . createInstanceMCF ( XToolkit . class , \"com.sun.star.awt.Toolkit\" ); XWindowPeer windowParentPeer = xToolkit . getDesktopWindow (); dialogCtrl . createPeer ( xToolkit , windowParentPeer ); XComponent dialogComponent = Lo . qi ( XComponent . class , dialogCtrl ); return getDialog ( dialogCtrl ); } // end of createDialogPeer() 2. Storing Macros inside the (Form) Document \u00b6 The previous section examined how to add macros to Office as extensions. Another popular way of utilizing macros is to embed them inside documents. I'll create a variation of the previous form, with the same functionality for its text fields, but GetText.show and GetNumber.get (and its dialog and listener) will be stored inside the document. Office documents, such as FormMacrosTest.odt, can be manipulated as zip files; I chose 7-Zip ( https://7-zip.org/ ) for the purpose, because it's powerful, open source, and can be executed from the command line and from DOS batch scripts. I'm reusing the same form from the previous section, but stored in FormDocMacros.odt. It's unzipped using my unzipDoc.bat script to create a folder called FormDocMacros_odt. The macros are added by modifying this folder: two new subdirectories are created, and the manifest.xml file changed, as illustrated by Figure 11. Figure 11. The Changed FormDocMacros_odt Folder The dialogLibrary folder contains the same \"Number Extractor\" dialog definition as before. The Scripts\\java\\Utils folder contains Macros.jar, and a new version of parcel-descriptor.xml. Macros.jar is different from the earlier extension, which used three classes (GetText.class, GetNumber.class, and NumActionListener.class) and Utils.jar. Unfortunately, this combination doesn't work for document macros. Instead, Macros.jar is a renamed version of Utils.jar with GetText.class, GetNumber.class, and NumActionListener.class added to it. This change to the code organization is reflected in parcel-descriptor.xml. The classpath entries for the two macros become: manifest.xml specifies the structure of FormDocMacros_odt\\, so lines are added describing dialogLibrary and Scripts: // added to manifest.xml <manifest:file-entry manifest:media-type=\"text/xml\" manifest:full-path= \"Scripts/java/Utils/parcel-descriptor.xml\"/> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.dialog-library\" manifest:full-path=\"dialogLibrary/\" /> <manifest:file-entry manifest:media-type=\"\" manifest:full-path=\"dialogLibrary/NumExtractor.xdl\" /> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/java/Utils/\"/> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/java/\"/> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/\"/> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/java/Utils/Macros.jar\"/> FormDocMacros_odt is re-zipped, becoming FormDocMacros.odt. Double-clicking on it causes it to open, to display the same form as before, but only after the user has clicked \"Enable Macros\" in the security warning (see Figure 12). Figure 12. The Macro Security Warning when Opening FormDocMacros.odt. Although the form is the same as previously, the button and textfield must be configured to use the document macros rather than macros stored inside Office. For example, the button's \"Execute action\" event should be assigned to GetText.show in the document, as in Figure 13. Figure 13. Selecting a Document Macro. The resulting event is displayed in Figure 14. Figure 14. The \"Execute action\" Event. 3. Attaching Macros to Other Events \u00b6 This chapter and the last have concentrated on adding macros to form controls, but other parts of Office, and other documents, can utilize event macros as well. A summary of the different ways that event macros can be employed is given on the wiki page \"Scripting LibreOffice\" at https://help.libreoffice.org/Common/Scripting/ . It lists uses for event macros such as: attached to form controls (already described); attached to menu items and toolbar icons (this is covered by Add-ons in Chapter 46); attached to Office and document events (described next); attached to key combinations; attached to an embedded object, such as a chart; attached to a graphic; attached to a hyperlink. The Tools, Customize dialog window supports the connection of event macros to menus, keyboards, toolbars, and events, as shown in Figure 15. Figure 15. The Tools > Customize Dialog. The Events tab in Figure 15 has a pop-down list at its bottom which allows macros to be attached to Office events (as in the figure) or to events associated with the currently open document. A macro is selected via the \"Macro\u2026\" button which takes the user to the Macro Selector dialog. In Figure 15, I've attached ShowEvent.show to the Office events \"Start Application\" and \"Open Document\". When Office starts it will display the dialog window on the left of Figure 16, and the dialog on the right when the document is opened. Figure 16. The ShowEvent.show Dialogs for Office Events. These dialogs are drawn by the DocumentEvent version of show() in the ShowEvent class: // in the ShowEvent class public static void show ( XScriptContext sc , com . sun . star . document . DocumentEvent e ) { display ( \"document\" , e . EventName ); } Automatic Macro Attachment \u00b6 It's possible to automate the attachment of macros to Office and document events, as illustrated by the DocEvents.java example: // in DocEvents.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); Macros . listOfficeEvents (); // list the \"OnStartApp\" and \"OnLoad\" Office event properties PropertyValue [] osaProps = Macros . getEventProps ( \"OnStartApp\" ); Props . showProps ( \"OnStartApp Event\" , osaProps ); PropertyValue [] olProps = Macros . getEventProps ( \"OnLoad\" ); Props . showProps ( \"OnLoad Event\" , olProps ); // attach macros to event if it does not have macros already if ( Lo . isNullOrEmpty ( ( String ) Props . getProp ( osaProps , \"Script\" ))) Macros . setEventScript ( \"OnStartApp\" , \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" ); if ( Lo . isNullOrEmpty ( ( String ) Props . getProp ( olProps , \"Script\" ))) Macros . setEventScript ( \"OnLoad\" , \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" ); XTextDocument doc = Write . openDoc ( \"build.odt\" , loader ); if ( doc == null ) { System . out . println ( \"Could not open build.odt\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . wait ( 2000 ); Macros . listDocEvents ( doc ); // list the \"OnPageCountChange\" doc event properties PropertyValue [] opccProps = Macros . getDocEventProps ( doc , \"OnPageCountChange\" ); Props . showProps ( \"OnPageCountChange Event\" , opccProps ); if ( Lo . isNullOrEmpty ( ( String ) Props . getProp ( opccProps , \"Script\" ))) { Macros . setDocEventScript ( doc , \"OnPageCountChange\" , \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" ); Lo . save ( doc ); // must save doc after event macro change } Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The program begins by listing all the names of the Office events by calling Macros.listOfficeEvents(), and then the properties for the \"OnStartApp\" and \"OnLoad\" events. It attaches ShowEvent.show to the two events, resulting in the macro setup in Figure 15. The output from Macros.listOfficeEvents() is: Event Handler names No. of names: 28 \"OnCloseApp\" \"OnCopyTo\" \"OnCopyToDone\" \"OnCopyToFailed\" \"OnCreate\" \"OnFocus\" \"OnLoad\" \"OnLoadFinished\" \"OnModeChanged\" \"OnModifyChanged\" \"OnNew\" \"OnPrepareUnload\" \"OnPrepareViewClosing\" \"OnPrint\" \"OnSave\" \"OnSaveAs\" \"OnSaveAsDone\" \"OnSaveAsFailed\" \"OnSaveDone\" \"OnSaveFailed\" \"OnStartApp\" \"OnStorageChanged\" \"OnTitleChanged\" \"OnUnfocus\" \"OnUnload\" \"OnViewClosed\" \"OnViewCreated\" \"OnVisAreaChanged\" These names can be mapped without too much difficulty to the strings in the \"Events\" column of Figure 15. The properties listed for the \"OnStartApp\" and \"OnLoad\" events are: Properties for \"OnStartApp Event\": EventType: Script Script: Properties for \"OnLoad Event\": EventType: Script Script: In other words, neither events have macros attached to them at the start of DocEvents.java. Events are manipulated using the XEventSupplier interface. Its relevant services and interfaces are shown in Figure 17. Figure 17. The XEventSupplier Interface. Document events are reached through the OfficeDocument service while Office events are obtained via theGlobalEventBroadcaster (or the deprecated GlobalEventBroadcaster). Macro.listOfficeEvents() starts with the theGlobalEventBroadcaster service, and uses XEventSupplier.getEvents() to obtain an XNameReplace object which is a named container whose entries can be changed: // in the Macros class public static void listOfficeEvents () { System . out . println ( \"\\nEvent Handler names\" ); XNameReplace eventHandlers = getEventHandlers (); Lo . printNames ( eventHandlers . getElementNames () ); } public static XNameReplace getEventHandlers () { XGlobalEventBroadcaster geb = theGlobalEventBroadcaster . get ( Lo . getContext ()); return geb . getEvents (); } Macros.getEventProps() looks up a specific event handler, and casts its entry in the XNameReplace container to a PropertyValue array: // in Macros class public static PropertyValue [] getEventProps ( String eventName ) { XNameReplace eventHandlers = getEventHandlers (); return getEventProps ( eventHandlers , eventName ); } public static PropertyValue [] getEventProps ( XNameReplace eventHandlers , String eventName ) { try { Object oProps = eventHandlers . getByName ( eventName ); if ( AnyConverter . isVoid ( oProps )) // or conversion may fail return null ; else return ( PropertyValue [] ) oProps ; } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not find event \" + eventName ); return null ; } } // end of getEventProps() Macros.setEventScript() utilizes getEventProps() to get the PropertyValue[] array for a given event, and sets the \"Script\" property to be the full name of the macro (e.g. \"vnd.sun.star.script:ShowEvent.ShowEvent.show?language=Java&location=share\"). Then the original entry in the XNameReplace object is updated with the changed property: public static void setEventScript ( String eventName , String scriptName ) { PropertyValue [] evProps = getEventProps ( eventName ); if ( evProps != null ) Props . setProp ( evProps , \"Script\" , scriptName ); else evProps = Props . makeProps ( \"EventType\" , \"Script\" , \"Script\" , scriptName ); XNameReplace eventHandlers = getEventHandlers (); try { eventHandlers . replaceByName ( eventName , evProps ); System . out . println ( \"Set script for \" + eventName + \" to \\\"\" + scriptName + \"\\\"\" ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not set script \" + eventName ); } } // end of setEventScript() The Macros utilities class contains similar methods for getting and setting document events. Macros.listDocEvents(), Macros.getDocEventProps(), and Macros.setDocEventScript() get the XEventSupplier object from the document via its OfficeDocument service. Macros.listDocEvents() prints the following document event names: Doc Event Handler names No. of names: 34 \"OnCloseApp\" \"OnCopyTo\" \"OnCopyToDone\" \"OnCopyToFailed\" \"OnCreate\" \"OnFieldMerge\" \"OnFieldMergeFinished\" \"OnFocus\" \"OnLayoutFinished\" \"OnLoad\" \"OnLoadFinished\" \"OnMailMerge\" \"OnMailMergeFinished\" \"OnModeChanged\" \"OnModifyChanged\" \"OnNew\" \"OnPageCountChange\" \"OnPrepareUnload\" \"OnPrepareViewClosing\" \"OnPrint\" \"OnSave\" \"OnSaveAs\" \"OnSaveAsDone\" \"OnSaveAsFailed\" \"OnSaveDone\" \"OnSaveFailed\" \"OnStartApp\" \"OnStorageChanged\" \"OnTitleChanged\" \"OnUnfocus\" \"OnUnload\" \"OnViewClosed\" \"OnViewCreated\" \"OnVisAreaChanged\" There's a big overlap with Office events, and the difference between the same-named events, such as \"OnLoad\", is that the Office version is fired when any document is loaded, whereas the document \"OnLoad\" will only fire for the loading of \"build.odt\". DocEvent.java attaches ShowEvent.show to its \"OnPageCountChange\" event, and the document is saved so the change is remembered. The change can be confirmed by opening the document and checking the Event tab of the Tools, Customize dialog. The \"OnPageCountChange\" setting is at the end of the events, as in Figure 18. Figure 18. The Event tab of the Tools > Customize Dialog. Note that the \"Save in:\" pop-down list at the bottom of the dialog shows the document name instead of \"LibreOffice\". 4. Executing Macros from the Command Line \u00b6 One of the show() method in the ShowEvent class doesn't have an event argument: // part of ShowEvent.java public static void show ( XScriptContext sc ) { display ( \"menu/run\" ); } This method can be called in a number of different situations: when the macro is attached to a menu item; when the macro is executed from the \"Run Macro...\" menu item of the Tools, Macros menu; if there's no suitable event handling version of show(), then this version acts as a default; when the macro is executed from the command line. The last approach can be employed when Office is called from the command line to open a document. The command line arguments can include the full name of a macro, which will cause its \"run\" version to be called. For example: office.exe build.odt \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" \"build.odt\" is opened, and the ShowEvent.show share macro executed. The execMacro.bat batch file in the examples simplifies these command line parameters.","title":"Chapter 49. Extension and Document Event Macros"},{"location":"49-Ext_Doc_Event_Macros.html#chapter-49-extension-and-document-event-macros","text":"Topics Form Macros as an Extension; Loading an XML Dialog; Building a Dialog at Runtime; Storing Macros inside the (Form) Document; Attaching Macros to Other Events; Executing Macros from the Command Line Example folders: \"EvMacro Tests\" and \"Utils\" The previous chapter introduced event macros, and described how a simple macro could be installed by copying it to a specific Office directory. This chapter looks at two other ways to package macros: as extensions, and by attaching them to documents.","title":"Chapter 49. Extension and Document Event Macros"},{"location":"49-Ext_Doc_Event_Macros.html#1-form-macros-as-an-extension","text":"Adding a macro to Office by installing it as an extension means that the user doesn't need to grapple with Office folders and copying files since Office's extension manager does it for them. This section also uses more complex macros than the ones in the previous chapter, namely ones that utilize their own dialogs and employ my utility classes. The FormMacros.oxt extension is created by zipping up a FormMacros folder, which is listed below: FormMacros | description.xml | form.png | license.txt | package-description.txt | +---dialogLibrary | NumExtractor.xdl | +---META-INF | manifest.xml | \\---Utils GetNumber.class GetText.class NumActionListener.class parcel-descriptor.xml Utils.jar The macros are in the Utils folder, and are utilized by the form stored in FormMacrosTest.odt in the ways shown in Figure 1. Figure 1. A Form and its Macros. Figure 1 illustrates the actions of two macros. GetText.show is attached to the form's button, and display the text in the adjacent textfield when the button is pressed. The GetNumber.get macro is attached to the second textfield, and is activated when is pressed. A dialog, created by the macro, offers the user a choice of replacing the text by a number or clearing the textfield. To simplify the example a little, FormMacrosTest.odt was created by hand rather than programmatically. Also, I'm going to attach the extension's macros to the button and textfield using Office's GUI, as explained shortly. I won\u2019t explain all the contents of the FormMacros folder, because most of them were covered in early chapters, particularly in Chapter 45. For example, I won't be describing how I drew the \"Number Extractor\" dialog stored in dialogLibrary\\NumExtractor.xdl since that technique was covered in the last chapter, in section 5. The new elements of FormMacros are the contents of manifest.xml and parcel- descriptor.xml. manifest.xml states the location of the macros inside the extension, which in my case are in the Utils subdirectory. This is encoded as: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <manifest:manifest xmlns:manifest=\"https://openoffice.org/2001/manifest\"> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.framework-script\" manifest:full-path=\"Utils/\" /> </manifest:manifest> parcel-descriptor.xml give details about the two macros, GetText.show and GetNumber.get, which are used by the Macro Selector dialog: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <parcel language=\"Java\" xmlns:parcel=\"scripting.dtd\"> <script language=\"Java\"> <locale lang=\"en\"> <displayname value=\"GetText.show\"/> <description> Shows the text in a textfield </description> </locale> <functionname value=\"GetText.show\"/> <logicalname value=\"GetText.show\"/> <languagedepprops> <prop name=\"classpath\" value=\".:GetText:Utils.jar\"/> </languagedepprops> </script> <script language=\"Java\"> <locale lang=\"en\"> <displayname value=\"GetNumber.get\"/> <description> Extract an integer from a textfield </description> </locale> <functionname value=\"GetNumber.get\"/> <logicalname value=\"GetNumber.get\"/> <languagedepprops> <prop name=\"classpath\" value=\".:GetNumber:Utils.jar\"/> </languagedepprops> </script> </parcel> There's an important difference between this parcel-descriptor.xml and the one given for ShowEvent.show in the previous chapter, related to the new macros' classpaths: < prop name = \"classpath\" value = \".:GetText:Utils.jar\" /> and < prop name = \"classpath\" value = \".:GetNumber:Utils.jar\" /> The classpath line for ShowEvent.show was: < prop name = \"classpath\" value = \"ShowEvent.jar\" /> The difference, which took many hours of experimentation to find, is due to the inclusion of my utilities classes as a JAR in Utils. When Utils.jar is in the extension, Office is unable to recognize GetText.show and GetNumber.get packaged as JARs (e.g. as GetText.jar and GetNumber.jar). It appears that Office can only add a single JAR to its classpath with . Instead I've stored the macros as .class files in Utils. In addition, it's necessary to include \".\" in the classpath so NumActionListener.class can be found at runtime. The three Java files (GetText.java, GetNumber.java, and NumActionListener.java) are compiled and manually copied into FormMacros\\Utils. Then the installMacros.bat batch script zips up the folder as an OXT file, and calls unopkg.exe to install it. The extension manager displays the \"Form Macros\" as in Figure 2. Figure 2. The Form Macros Extension. By default, extension macros are installed as user macros, as can be seen in the Macro Selector dialog in Figure 3. Figure 3. The User Extension Macros in the Macro Selector. The Utils subdirectory of the extension has become a module called Utils. The full names of the extension macros can be obtained using my ListMacros.java or FindMacros.java examples. For example: run FindMacros Utils produces: Matching Macros in Office: (2) vnd.sun.star.script:Utils.GetNumber.get? language=Java&location=user:uno_packages/FormMacros.oxt vnd.sun.star.script:Utils.GetText.show? language=Java&location=user:uno_packages/FormMacros.oxt","title":"1.  Form Macros as an Extension"},{"location":"49-Ext_Doc_Event_Macros.html#11-the-gettextshow-macro","text":"GetText.show is triggered when a button is pressed; it displays the text currently in the \"Text Box 1\" textfield inside a message box (see Figure 1). The code for the class is: // in GetText.java public class GetText { private static final String LOG_FNM = \"c://macrosInfo.txt\" ; // log file for storing debugging output public static void show ( XScriptContext sc , ActionEvent e ) // Called when a button pressed { String controlName = Forms . getEventSourceName ( e ); FileIO . appendTo ( LOG_FNM , \"\\\"\" + controlName + \"\\\" sent ActionEvent at \" + Lo . getTimeStamp ()); XComponent doc = Lo . scriptInitialize ( sc ); if ( doc == null ) return ; // for debugging Console console = new Console (); console . setVisible ( true ); Forms . listForms ( doc ); XControlModel textBox = Forms . getControlModel ( doc , \"Text Box 1\" ); // Props.showObjProps(\"TextBox\", textBox); String textContents = ( String ) Props . getProperty ( textBox , \"Text\" ); GUI . showXMessageBox ( \"Textbox text\" , textContents ); console . setVisible ( false ); console . closeDown (); } // end of show() for ActionEvent } // end of GetText class The class implements a single show() method suitable for responding to ActionEvents. Forms.getEventSourceName() returns the name of the control that sent the event and FileIO.appendTo() writes the details to a log file. This log is useful for debugging, and can be removed when the macro is finished. Lo.scriptInitialize() uses the macro's XScriptContext object to initialize globals maintained by my Lo class: // in the Lo class // globals private static XComponentContext xcc = null ; private static XDesktop xDesktop = null ; private static XMultiComponentFactory mcFactory = null ; private static XMultiServiceFactory msFactory = null ; public static XComponent scriptInitialize ( XScriptContext sc ) { if ( sc == null ) { System . out . println ( \"Script Context is null\" ); return null ; } xcc = sc . getComponentContext (); if ( xcc == null ) { System . out . println ( \"Could not access component context\" ); return null ; } mcFactory = xcc . getServiceManager (); if ( mcFactory == null ) { System . out . println ( \"Office Service Manager is unavailable\" ); return null ; } xDesktop = sc . getDesktop (); if ( xDesktop == null ) { System . out . println ( \"Could not access desktop\" ); return null ; } XComponent doc = xDesktop . getCurrentComponent (); if ( doc == null ) { System . out . println ( \"Could not access document\" ); return null ; } msFactory = Lo . qi ( XMultiServiceFactory . class , doc ); return doc ; } // end of scriptInitialize() The log approach is fine for simple debugging, but it's also possible to create a Console window for displaying more complex textual output. One useful thing to report are the form's control details, by calling Forms.listForms(). The Console window looks as in Figure 4. Figure 4. The Console Window Output for GetText.show. The control names in Figure 4 include \"Text Box 1\", which is used by Forms.getControlModel() to reference the textfield control: // part of show() in GetText.java... XControlModel textBox = Forms . getControlModel ( doc , \"Text Box 1\" ); String textContents = ( String ) Props . getProperty ( textBox , \"Text\" ); GUI . showXMessageBox ( \"Textbox text\" , textContents );","title":"1.1.  The GetText.show Macro"},{"location":"49-Ext_Doc_Event_Macros.html#12-the-getnumberget-macro","text":"The second textfield in Figure 1 is called \"AgeText\". Its listener processes the text when the user types , which is implemented using a keypress listener, as shown in Figure 5. Figure 5. The \"AgeText\" Properties Dialog. GetNumber.get is woken up by every keypress, which should be ignored until the key is . Then the text is read from the \"AgeText\" textfield, and the extracted number displayed in the \"Number Extractor\" dialog (shown in Figure 1). This dialog has its own listener (a NumActionListener object) attached to the \"Ok\" and \"Cancel\" buttons which updates the \"AgeText\" textfield depending on which is pressed. The GetNumber class defines a single static get() method, suitable for receiving KeyEvents: // in GetNumber.java public static void get ( XScriptContext sc , KeyEvent e ) { String controlName = Forms . getEventSourceName ( e ); if ( e . KeyCode == Key . RETURN ) { // return typed XComponent doc = Lo . scriptInitialize ( sc ); if ( doc != null ) { XControlModel cModel = Forms . getControlModel ( doc , controlName ); if ( Forms . isTextField ( cModel )) loadXDLDialog ( cModel ); // runtimeDialog(cModel); } } } // end of get() When the key is pressed, Forms.getControlModel() searches the form for the control that sent the event (i.e. the \"AgeText\" textfield). If the control is a textfield then the \"Number Extractor\" dialog is displayed in one of two ways \u2013 either loadXDLDialog() loads the dialog's XML from dialogLibrary\\NumExtractor.xdl inside the extension, or runtimeDialog() creates the dialog dynamically by calling methods in my Dialogs utility class. I'll look at each approach in the next two sections.","title":"1.2.  The GetNumber.get Macro"},{"location":"49-Ext_Doc_Event_Macros.html#13-loading-an-xml-dialog","text":"Chapter 46 on Add-ons describes how to use Office's dialog editor to create a dialog and export it as an XDL file. The same steps were used to create NumExtractor.xdl, which is shown in Figure 6. Figure 6. The NumExtractor.xdl Dialog. The XML contents of NumExtractor.xdl are: <? xml version = \"1.0\" encoding = \"UTF-8\" ?> <! DOCTYPE dlg : window PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"dialog.dtd\" > < dlg : window xmlns : dlg = \"https://openoffice.org/2000/dialog\" xmlns : script = \"https://openoffice.org/2000/script\" dlg : id = \"NumExtractor\" dlg : left = \"109\" dlg : top = \"73\" dlg : width = \"94\" dlg : height = \"44\" dlg : closeable = \"true\" dlg : moveable = \"true\" dlg : title = \"Number Extractor\" > < dlg : bulletinboard > < dlg : text dlg : id = \"Label1\" dlg : tab - index = \"0\" dlg : left = \"8\" dlg : top = \"11\" dlg : width = \"48\" dlg : height = \"10\" dlg : value = \"Extracted number: \" dlg : align = \"right\" /> < dlg : button dlg : id = \"CommandButton1\" dlg : tab - index = \"2\" dlg : left = \"8\" dlg : top = \"27\" dlg : width = \"33\" dlg : height = \"12\" dlg : value = \"Ok\" /> < dlg : textfield dlg : id = \"TextField1\" dlg : tab - index = \"1\" dlg : left = \"61\" dlg : top = \"9\" dlg : width = \"24\" dlg : height = \"12\" dlg : align = \"center\" dlg : readonly = \"true\" /> < dlg : button dlg : id = \"CommandButton2\" dlg : tab - index = \"3\" dlg : left = \"52\" dlg : top = \"27\" dlg : width = \"33\" dlg : height = \"12\" dlg : value = \"Cancel\" /> </ dlg : bulletinboard > </ dlg : window > The most important things to note for later are the control IDs; in particular, the textfield and button names: \"TextField1\", \"CommandButton1\", and \"CommandButton2\". loadXDLDialog() utilizes Dialogs.loadAddonDialog() described in Chapter 46 to obtain a reference to the dialog. It's initialized by initDialog() and made live by XDialog.execute(): // in GetNumber.java private static void loadXDLDialog ( XControlModel cModel ) { XDialog dialog = Dialogs . loadAddonDialog ( \"org.openoffice.formmacros\" , \"dialogLibrary/NumExtractor.xdl\" ); if ( dialog == null ) return ; initDialog ( dialog , cModel ); dialog . execute (); } // end of loadXDLDialog() initDialog() fills the dialog's textfield with numerical data extracted from the form's \"AgeText\" field, and attaches a NumActionListener to its buttons: // part of GetNumber.java private static void initDialog ( XDialog dialog , XControlModel cModel ) { XControl dialogCtrl = Dialogs . getDialogControl ( dialog ); if ( dialogCtrl == null ) return ; int val = extractDigits ( ( String ) Props . getProperty ( cModel , \"Text\" )); // store extracted number in dialog's read-only text field; // the names of the controls are hardwired XTextComponent numFieldTB = Lo . qi ( XTextComponent . class , Dialogs . findControl ( dialogCtrl , \"TextField1\" )); numFieldTB . setText ( \"\" + val ); // assign same listener to both buttons NumActionListener naListener = new NumActionListener ( dialog , cModel , val ); XButton okButton = Lo . qi ( XButton . class , Dialogs . findControl ( dialogCtrl , \"CommandButton1\" )); okButton . addActionListener ( naListener ); XButton cancelButton = Lo . qi ( XButton . class , Dialogs . findControl ( dialogCtrl , \"CommandButton2\" )); cancelButton . addActionListener ( naListener ); } // end of initDialog() Dialogs.findControl() finds the dialog's textfield and buttons using the IDs that we saw in NumExtractor.xdl. The NumActionListener class is included in the extension's Utils folder. It's a standard button listener, but uses Office's XActionListener and ActionEvent not the Java classes with similar names: // in NumActionListener.java public class NumActionListener implements XActionListener { private XDialog dialog ; private XControlModel cModel ; private int val ; public NumActionListener ( XDialog dialog , XControlModel cModel , int val ) { this . dialog = dialog ; this . cModel = cModel ; this . val = val ; } // end of NumActionListener() public void actionPerformed ( ActionEvent e ) { String buttonName = Dialogs . getEventSourceName ( e ); System . out . println ( \"Event received from : \" + buttonName ); if ( buttonName . equals ( \"CommandButton1\" )) // \"OK\" button Props . setProperty ( cModel , \"Text\" , \"\" + val ); // put val in text field else if ( buttonName . equals ( \"CommandButton2\" )) // \"Cancel\" Props . setProperty ( cModel , \"Text\" , \"\" ); // clear text field dialog . endExecute (); } // end of actionPerformed() public void disposing ( EventObject e ) { } } // end of NumActionListener class The number extracted from the \"AgeText\" textfield is passed to the listener via its constructor, along with a reference to the control. If the user presses \"Ok\" then the number is written into the textfield, otherwise an empty string is used to clear its contents.","title":"1.3.  Loading an XML Dialog"},{"location":"49-Ext_Doc_Event_Macros.html#14-building-a-dialog-at-runtime","text":"Office's dialog editor is the easiest way to construct a dialog, but there may be situations where you want to create a simple dialog at run time. The commented-out call to runtimeDialog() in GetNumber.get shows how to do this using my Dialog class functions: // part of GetNumber.java private static void runtimeDialog ( XControlModel cModel ) { XControl dialogCtrl = makeDialogControl (); if ( dialogCtrl == null ) return ; XDialog dialog = Dialogs . createDialogPeer ( dialogCtrl ); if ( dialog == null ) return ; initDialog ( dialog , cModel ); dialog . execute (); } // end of runtimeDialog() The dialog generated by makeDialogControl() (see Figure 7) is very similar to the one defined in NumExtractor.xdl. Figure 7. The Rendering of the Runtime Dialog. makeDialogControl() creates an empty dialog, and fills it with a label, textfield and two buttons: // part of GetNumber.java private static XControl makeDialogControl () { XControl dialogCtrl = Dialogs . createDialogControl ( 109 , 73 , 94 , 44 , \"Number Extractor\" ); if ( dialogCtrl == null ) System . out . println ( \"dialog control is null\" ); // log(\"Dialog name:\" + Dialogs.getControlName(dialogCtrl)); // reports \"OfficeDialog1\" XControl xc = Dialogs . insertLabel ( dialogCtrl , 8 , 11 , 48 , \"Extracted Number: \" ); // log(\"Label name:\" + Dialogs.getControlName(xc)); // FixedText1 xc = Dialogs . insertTextField ( dialogCtrl , 61 , 9 , 24 , \"\" ); // log(\"Text field name:\" + Dialogs.getControlName(xc)); // TextField1 xc = Dialogs . insertButton ( dialogCtrl , 9 , 27 , 33 , \"Ok\" ); // log(\"Ok button name:\" + Dialogs.getControlName(xc)); // CommandButton1 xc = Dialogs . insertButton ( dialogCtrl , 52 , 27 , 33 , \"Cancel\" ); // log(\"Cancel button name:\" + Dialogs.getControlName(xc)); // CommandButton2 return dialogCtrl ; } // end of makeDialogControl() One tricky aspect is deciding on the control positions and widths passed to the Dialogs.insertXXX() methods. I based them on the values in NumExtractor.xdl. initDialog() is again used to initialize the dialog's textfield and buttons, which assumes they are called \"TextField1\", \"CommandButton1\", and \"CommandButton2\". I confirmed this for the runtime dialog by writing their name to the log file: // part of GetNumber.java // global private static final String LOG_FNM = \"c://macrosInfo.txt\" ; private static void log ( String msg ) { FileIO . appendTo ( LOG_FNM , msg ); }","title":"1.4.  Building a Dialog at Runtime"},{"location":"49-Ext_Doc_Event_Macros.html#15-dialogs-and-their-controls","text":"Dialog controls utilize the same model-view framework as form controls (which were described back in Chapter 39). Controls store data as properties spread over a hierarchy centered around UnoControlModel in the com.sun.star.awt module. A small fragment of that hierarchy is shown in Figure 8. Figure 8. UnoControlModel and Some Subclasses. A dialog is represented by UnoControlDialogModel, which stores properties such as the title, a background image or color, and windowing flags such as whether it is closeable. Its XNameContainer interface allows the names of its component controls to be accessed. Some of the important properties, such as the (x, y) position of a control, are a little hard to find \u2013 they're not in UnoControlModel but its superclass, UnoControlDialogElement. The other part of the model-view framework are views which represent how a control is drawn. Views for different controls are subclasses of the UnoControl service, as shown in Figure 9. Figure 9. UnoControl and Some Subclasses. UnoControl's XControl contains methods for linking a model to a view. Also, subclass interfaces, such as XButton and XTextComponent, are where listeners are attached to controls. It helps to remember the naming conventions illustrated by Figures 8 and 9 \u2013 a service containing the word \"Model\" is almost always for storing data, while a service without the word \"Model\" is almost always a view. Figure 9 doesn't include a dialog view; it's sufficiently different to deserve its own diagram, Figure 10. Figure 10. The UnoControlDialog Service. UnoControlDialog isn't a subclass of UnoControl, but its interface, XUnoControlDialog, still inherits XControl and so can be linked to a model. It also inherits XControlContainer which allows controls to be added to and removed from a dialog. XDialog contains execute() which makes a dialog active on screen. Dialogs.createDialogControl() creates a dialog view and model, and links them. The dialog is initialized by setting various properties in its model: // in the Dialogs class public static XControl createDialogControl ( int x , int y , int width , int height , String title ) { try { XControl dialogCtrl = Lo . createInstanceMCF ( XControl . class , \"com.sun.star.awt.UnoControlDialog\" ); XControlModel xControlModel = Lo . createInstanceMCF ( XControlModel . class , \"com.sun.star.awt.UnoControlDialogModel\" ); dialogCtrl . setModel ( xControlModel ); // link view and model XPropertySet props = getControlProps ( dialogCtrl . getModel ()); props . setPropertyValue ( \"PositionX\" , x ); props . setPropertyValue ( \"PositionY\" , y ); props . setPropertyValue ( \"Height\" , height ); props . setPropertyValue ( \"Width\" , width ); props . setPropertyValue ( \"Title\" , title ); props . setPropertyValue ( \"Name\" , \"OfficeDialog\" ); props . setPropertyValue ( \"Step\" , 0 ); props . setPropertyValue ( \"Moveable\" , true ); props . setPropertyValue ( \"TabIndex\" , new Short (( short ) 0 )); return dialogCtrl ; } catch ( Exception ex ) { System . out . println ( \"Could not create dialog control: \" + ex ); return null ; } } // end of createDialogControl() makeDialogControl() in the GetNumber class adds a label, textfield, and two buttons to the dialog by calling Dialogs.insertXXX() methods. These methods are all quite similar, so I'll only explain insertButton(). Its job is to create a button model, and initialize its properties: // in the Dialogs class public static XControl insertButton ( XControl dialogCtrl , int x , int y , int width , String label ) { return insertButton ( dialogCtrl , x , y , width , label , PushButtonType . STANDARD_value ); } public static XControl insertButton ( XControl dialogCtrl , int x , int y , int width , String label , int pushButtonType ) { try { // create a button model XMultiServiceFactory msf = Lo . qi ( XMultiServiceFactory . class , dialogCtrl . getModel ()); Object model = msf . createInstance ( \"com.sun.star.awt.UnoControlButtonModel\" ); // generate a unique name for the control XNameContainer nameCon = getDialogNmCon ( dialogCtrl ); String nm = createName ( nameCon , \"CommandButton\" ); // set properties in the model XPropertySet props = getControlProps ( model ); props . setPropertyValue ( \"PositionX\" , x ); props . setPropertyValue ( \"PositionY\" , y ); props . setPropertyValue ( \"Height\" , 14 ); props . setPropertyValue ( \"Width\" , width ); props . setPropertyValue ( \"Label\" , label ); props . setPropertyValue ( \"PushButtonType\" , new Short (( short ) pushButtonType )); props . setPropertyValue ( \"Name\" , nm ); // add the model to the dialog nameCon . insertByName ( nm , model ); // get the dialog's container holding all the control views XControlContainer ctrlCon = Lo . qi ( XControlContainer . class , dialogCtrl ); // use the model's name to get its view inside the dialog return ctrlCon . getControl ( nm ); } catch ( Exception ex ) { System . out . println ( \"Could not create button control: \" + ex ); return null ; } } // end of insertButton() First the model is created and added to the dialog. Its view is retrieved from the dialog's control container, and returned as an XControl object. Back in GetNumber.runtimeDialog(), the dialog's window (or peer) is linked to the Office window by Dialogs.createDialogPeer(): // in the Dialogs class public static XDialog createDialogPeer ( XControl dialogCtrl ) { XWindow xWindow = ( XWindow ) Lo . qi ( XWindow . class , dialogCtrl ); xWindow . setVisible ( false ); // set dialog window invisible until it is executed XToolkit xToolkit = Lo . createInstanceMCF ( XToolkit . class , \"com.sun.star.awt.Toolkit\" ); XWindowPeer windowParentPeer = xToolkit . getDesktopWindow (); dialogCtrl . createPeer ( xToolkit , windowParentPeer ); XComponent dialogComponent = Lo . qi ( XComponent . class , dialogCtrl ); return getDialog ( dialogCtrl ); } // end of createDialogPeer()","title":"1.5.  Dialogs and their Controls"},{"location":"49-Ext_Doc_Event_Macros.html#2-storing-macros-inside-the-form-document","text":"The previous section examined how to add macros to Office as extensions. Another popular way of utilizing macros is to embed them inside documents. I'll create a variation of the previous form, with the same functionality for its text fields, but GetText.show and GetNumber.get (and its dialog and listener) will be stored inside the document. Office documents, such as FormMacrosTest.odt, can be manipulated as zip files; I chose 7-Zip ( https://7-zip.org/ ) for the purpose, because it's powerful, open source, and can be executed from the command line and from DOS batch scripts. I'm reusing the same form from the previous section, but stored in FormDocMacros.odt. It's unzipped using my unzipDoc.bat script to create a folder called FormDocMacros_odt. The macros are added by modifying this folder: two new subdirectories are created, and the manifest.xml file changed, as illustrated by Figure 11. Figure 11. The Changed FormDocMacros_odt Folder The dialogLibrary folder contains the same \"Number Extractor\" dialog definition as before. The Scripts\\java\\Utils folder contains Macros.jar, and a new version of parcel-descriptor.xml. Macros.jar is different from the earlier extension, which used three classes (GetText.class, GetNumber.class, and NumActionListener.class) and Utils.jar. Unfortunately, this combination doesn't work for document macros. Instead, Macros.jar is a renamed version of Utils.jar with GetText.class, GetNumber.class, and NumActionListener.class added to it. This change to the code organization is reflected in parcel-descriptor.xml. The classpath entries for the two macros become: manifest.xml specifies the structure of FormDocMacros_odt\\, so lines are added describing dialogLibrary and Scripts: // added to manifest.xml <manifest:file-entry manifest:media-type=\"text/xml\" manifest:full-path= \"Scripts/java/Utils/parcel-descriptor.xml\"/> <manifest:file-entry manifest:media-type= \"application/vnd.sun.star.dialog-library\" manifest:full-path=\"dialogLibrary/\" /> <manifest:file-entry manifest:media-type=\"\" manifest:full-path=\"dialogLibrary/NumExtractor.xdl\" /> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/java/Utils/\"/> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/java/\"/> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/\"/> <manifest:file-entry manifest:media-type=\"application/binary\" manifest:full-path=\"Scripts/java/Utils/Macros.jar\"/> FormDocMacros_odt is re-zipped, becoming FormDocMacros.odt. Double-clicking on it causes it to open, to display the same form as before, but only after the user has clicked \"Enable Macros\" in the security warning (see Figure 12). Figure 12. The Macro Security Warning when Opening FormDocMacros.odt. Although the form is the same as previously, the button and textfield must be configured to use the document macros rather than macros stored inside Office. For example, the button's \"Execute action\" event should be assigned to GetText.show in the document, as in Figure 13. Figure 13. Selecting a Document Macro. The resulting event is displayed in Figure 14. Figure 14. The \"Execute action\" Event.","title":"2.  Storing Macros inside the (Form) Document"},{"location":"49-Ext_Doc_Event_Macros.html#3-attaching-macros-to-other-events","text":"This chapter and the last have concentrated on adding macros to form controls, but other parts of Office, and other documents, can utilize event macros as well. A summary of the different ways that event macros can be employed is given on the wiki page \"Scripting LibreOffice\" at https://help.libreoffice.org/Common/Scripting/ . It lists uses for event macros such as: attached to form controls (already described); attached to menu items and toolbar icons (this is covered by Add-ons in Chapter 46); attached to Office and document events (described next); attached to key combinations; attached to an embedded object, such as a chart; attached to a graphic; attached to a hyperlink. The Tools, Customize dialog window supports the connection of event macros to menus, keyboards, toolbars, and events, as shown in Figure 15. Figure 15. The Tools > Customize Dialog. The Events tab in Figure 15 has a pop-down list at its bottom which allows macros to be attached to Office events (as in the figure) or to events associated with the currently open document. A macro is selected via the \"Macro\u2026\" button which takes the user to the Macro Selector dialog. In Figure 15, I've attached ShowEvent.show to the Office events \"Start Application\" and \"Open Document\". When Office starts it will display the dialog window on the left of Figure 16, and the dialog on the right when the document is opened. Figure 16. The ShowEvent.show Dialogs for Office Events. These dialogs are drawn by the DocumentEvent version of show() in the ShowEvent class: // in the ShowEvent class public static void show ( XScriptContext sc , com . sun . star . document . DocumentEvent e ) { display ( \"document\" , e . EventName ); }","title":"3.  Attaching Macros to Other Events"},{"location":"49-Ext_Doc_Event_Macros.html#automatic-macro-attachment","text":"It's possible to automate the attachment of macros to Office and document events, as illustrated by the DocEvents.java example: // in DocEvents.java public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); Macros . listOfficeEvents (); // list the \"OnStartApp\" and \"OnLoad\" Office event properties PropertyValue [] osaProps = Macros . getEventProps ( \"OnStartApp\" ); Props . showProps ( \"OnStartApp Event\" , osaProps ); PropertyValue [] olProps = Macros . getEventProps ( \"OnLoad\" ); Props . showProps ( \"OnLoad Event\" , olProps ); // attach macros to event if it does not have macros already if ( Lo . isNullOrEmpty ( ( String ) Props . getProp ( osaProps , \"Script\" ))) Macros . setEventScript ( \"OnStartApp\" , \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" ); if ( Lo . isNullOrEmpty ( ( String ) Props . getProp ( olProps , \"Script\" ))) Macros . setEventScript ( \"OnLoad\" , \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" ); XTextDocument doc = Write . openDoc ( \"build.odt\" , loader ); if ( doc == null ) { System . out . println ( \"Could not open build.odt\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . wait ( 2000 ); Macros . listDocEvents ( doc ); // list the \"OnPageCountChange\" doc event properties PropertyValue [] opccProps = Macros . getDocEventProps ( doc , \"OnPageCountChange\" ); Props . showProps ( \"OnPageCountChange Event\" , opccProps ); if ( Lo . isNullOrEmpty ( ( String ) Props . getProp ( opccProps , \"Script\" ))) { Macros . setDocEventScript ( doc , \"OnPageCountChange\" , \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" ); Lo . save ( doc ); // must save doc after event macro change } Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() The program begins by listing all the names of the Office events by calling Macros.listOfficeEvents(), and then the properties for the \"OnStartApp\" and \"OnLoad\" events. It attaches ShowEvent.show to the two events, resulting in the macro setup in Figure 15. The output from Macros.listOfficeEvents() is: Event Handler names No. of names: 28 \"OnCloseApp\" \"OnCopyTo\" \"OnCopyToDone\" \"OnCopyToFailed\" \"OnCreate\" \"OnFocus\" \"OnLoad\" \"OnLoadFinished\" \"OnModeChanged\" \"OnModifyChanged\" \"OnNew\" \"OnPrepareUnload\" \"OnPrepareViewClosing\" \"OnPrint\" \"OnSave\" \"OnSaveAs\" \"OnSaveAsDone\" \"OnSaveAsFailed\" \"OnSaveDone\" \"OnSaveFailed\" \"OnStartApp\" \"OnStorageChanged\" \"OnTitleChanged\" \"OnUnfocus\" \"OnUnload\" \"OnViewClosed\" \"OnViewCreated\" \"OnVisAreaChanged\" These names can be mapped without too much difficulty to the strings in the \"Events\" column of Figure 15. The properties listed for the \"OnStartApp\" and \"OnLoad\" events are: Properties for \"OnStartApp Event\": EventType: Script Script: Properties for \"OnLoad Event\": EventType: Script Script: In other words, neither events have macros attached to them at the start of DocEvents.java. Events are manipulated using the XEventSupplier interface. Its relevant services and interfaces are shown in Figure 17. Figure 17. The XEventSupplier Interface. Document events are reached through the OfficeDocument service while Office events are obtained via theGlobalEventBroadcaster (or the deprecated GlobalEventBroadcaster). Macro.listOfficeEvents() starts with the theGlobalEventBroadcaster service, and uses XEventSupplier.getEvents() to obtain an XNameReplace object which is a named container whose entries can be changed: // in the Macros class public static void listOfficeEvents () { System . out . println ( \"\\nEvent Handler names\" ); XNameReplace eventHandlers = getEventHandlers (); Lo . printNames ( eventHandlers . getElementNames () ); } public static XNameReplace getEventHandlers () { XGlobalEventBroadcaster geb = theGlobalEventBroadcaster . get ( Lo . getContext ()); return geb . getEvents (); } Macros.getEventProps() looks up a specific event handler, and casts its entry in the XNameReplace container to a PropertyValue array: // in Macros class public static PropertyValue [] getEventProps ( String eventName ) { XNameReplace eventHandlers = getEventHandlers (); return getEventProps ( eventHandlers , eventName ); } public static PropertyValue [] getEventProps ( XNameReplace eventHandlers , String eventName ) { try { Object oProps = eventHandlers . getByName ( eventName ); if ( AnyConverter . isVoid ( oProps )) // or conversion may fail return null ; else return ( PropertyValue [] ) oProps ; } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not find event \" + eventName ); return null ; } } // end of getEventProps() Macros.setEventScript() utilizes getEventProps() to get the PropertyValue[] array for a given event, and sets the \"Script\" property to be the full name of the macro (e.g. \"vnd.sun.star.script:ShowEvent.ShowEvent.show?language=Java&location=share\"). Then the original entry in the XNameReplace object is updated with the changed property: public static void setEventScript ( String eventName , String scriptName ) { PropertyValue [] evProps = getEventProps ( eventName ); if ( evProps != null ) Props . setProp ( evProps , \"Script\" , scriptName ); else evProps = Props . makeProps ( \"EventType\" , \"Script\" , \"Script\" , scriptName ); XNameReplace eventHandlers = getEventHandlers (); try { eventHandlers . replaceByName ( eventName , evProps ); System . out . println ( \"Set script for \" + eventName + \" to \\\"\" + scriptName + \"\\\"\" ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( \"Could not set script \" + eventName ); } } // end of setEventScript() The Macros utilities class contains similar methods for getting and setting document events. Macros.listDocEvents(), Macros.getDocEventProps(), and Macros.setDocEventScript() get the XEventSupplier object from the document via its OfficeDocument service. Macros.listDocEvents() prints the following document event names: Doc Event Handler names No. of names: 34 \"OnCloseApp\" \"OnCopyTo\" \"OnCopyToDone\" \"OnCopyToFailed\" \"OnCreate\" \"OnFieldMerge\" \"OnFieldMergeFinished\" \"OnFocus\" \"OnLayoutFinished\" \"OnLoad\" \"OnLoadFinished\" \"OnMailMerge\" \"OnMailMergeFinished\" \"OnModeChanged\" \"OnModifyChanged\" \"OnNew\" \"OnPageCountChange\" \"OnPrepareUnload\" \"OnPrepareViewClosing\" \"OnPrint\" \"OnSave\" \"OnSaveAs\" \"OnSaveAsDone\" \"OnSaveAsFailed\" \"OnSaveDone\" \"OnSaveFailed\" \"OnStartApp\" \"OnStorageChanged\" \"OnTitleChanged\" \"OnUnfocus\" \"OnUnload\" \"OnViewClosed\" \"OnViewCreated\" \"OnVisAreaChanged\" There's a big overlap with Office events, and the difference between the same-named events, such as \"OnLoad\", is that the Office version is fired when any document is loaded, whereas the document \"OnLoad\" will only fire for the loading of \"build.odt\". DocEvent.java attaches ShowEvent.show to its \"OnPageCountChange\" event, and the document is saved so the change is remembered. The change can be confirmed by opening the document and checking the Event tab of the Tools, Customize dialog. The \"OnPageCountChange\" setting is at the end of the events, as in Figure 18. Figure 18. The Event tab of the Tools > Customize Dialog. Note that the \"Save in:\" pop-down list at the bottom of the dialog shows the document name instead of \"LibreOffice\".","title":"Automatic Macro Attachment"},{"location":"49-Ext_Doc_Event_Macros.html#4-executing-macros-from-the-command-line","text":"One of the show() method in the ShowEvent class doesn't have an event argument: // part of ShowEvent.java public static void show ( XScriptContext sc ) { display ( \"menu/run\" ); } This method can be called in a number of different situations: when the macro is attached to a menu item; when the macro is executed from the \"Run Macro...\" menu item of the Tools, Macros menu; if there's no suitable event handling version of show(), then this version acts as a default; when the macro is executed from the command line. The last approach can be employed when Office is called from the command line to open a document. The command line arguments can include the full name of a macro, which will cause its \"run\" version to be called. For example: office.exe build.odt \"vnd.sun.star.script:ShowEvent.ShowEvent.show? language=Java&location=share\" \"build.odt\" is opened, and the ShowEvent.show share macro executed. The execMacro.bat batch file in the examples simplifies these command line parameters.","title":"4.  Executing Macros from the Command Line"},{"location":"50%20Part%209%20The%20ODF%20Format.html","text":"Part 9 The ODF Format \u00b6","title":"Part 9 The ODF Format"},{"location":"50%20Part%209%20The%20ODF%20Format.html#part-9-the-odf-format","text":"","title":"Part 9 The ODF Format"},{"location":"50-Importing_XML.html","text":"Chapter 50. Importing XML \u00b6 Topics XSLT Filters; Using Filters with Java; Alternatives to XSLT Filters: DOM Parsing, Node and Attribute Data Extraction, JAXB Conversion Example folders: \"Filter Tests\" and \"Utils\" This chapter is mostly about importing XML data into Office. I start by looking at XSLT import (and export) filters, which give the best results but require the programmer to know a great deal about XML and the ODF file format. The second half of the chapter is about three simpler techniques for importing XML which require less comprehensive XML skills and no knowledge of ODF. The drawback is that the resulting document may be less 'beautiful', often requiring some manual post-processing to remove unnecessary white space and data. You'd be correct in thinking that Office can already import XML, but you may be disappointed with the results: a simple XML file, such as pay.xml shown below, is imported unchanged, as plain text: <?xml version=\"1.0\"?> <payments> <payment> <purpose>CD</purpose> <amount>12.95</amount> <tax>19.1234</tax> <maturity>2008-03-01</maturity> </payment> <payment> <purpose>DVD</purpose> <amount>19.95</amount> <tax>19.4321</tax> <maturity>2008-03-02</maturity> </payment> <payment> <purpose>Clothes</purpose> <amount>99.95</amount> <tax>18.5678</tax> <maturity>2008-03-03</maturity> </payment> <payment> <purpose>Book</purpose> <amount>9.49</amount> <tax>18.9876</tax> <maturity>2008-03-04</maturity> </payment> </payments> Office offers many ways of loading XML through the \"All files ( . )\" popdown list in the Open dialog. Figure 1 shows my selection of \"Flat XML ODF Spreadsheet\": Figure 1. Selecting an XML Import Format. Unfortunately, the result isn't a nice spreadsheet of the payments, but a Writer document containing all the data and XML tags. Flat XML is for encoding an OpenDocument format (ODF) document as a single text file, which contrasts with how it's usually stored as a zipped folder of several files and sub-folders. pay.xml isn't a Flat XML file, and so Office drops back to treating it as plain text, and uses Writer to display it. Incidentally, there are several Flat XML formats aimed at the different Office applications, Writer, Calc, Draw, and Impress. 1. Filters to the Rescue \u00b6 pay.xml can be opened as a spreadsheet with the help of an input filter. There are a few ways of writing these, as explained by Fridrich Strba in his blog post \"Extending the Swiss Army knife - an overview about writing of filters for LibreOffice\" ( https://fridrich.blogspot.com/2013/08/extending-swiss-army-knife-overview.html ). The easiest way of implementing an XML input filter is with XSLT (eXtensible Stylesheet Language: Transformations). The filter is utilized by the XSLT processor inside Office to load and transform the XML, as illustrated in Figure 2. Figure 2. Using an XSLT filter. XSLT is designed for transforming XML into other textual formats; in this case, it will convert the simple XML used by pay.xml into the Flat XML used by Calc. Office's XSLT processor used to be Saxon ( https://saxon.sourceforge.net/ ), a Java API, but was replaced in 2012 by the libxslt C library ( https://xmlsoft.org/libxslt/ ). This implements XSLT 1.0 with some extensions, so it's best to avoid using features from the newer XSLT 2.0. One source for learning XLST in the context of ODF is: OASIS OpenDocument Essentials J. David Eisenberg, 2005 https://books.evc-cit.info/ The book includes a chapter on filters, and an appendix that overviews XSLT and XPath (XPath is used for locating parts of the input document for processing). Eisenberg's website has a free draft of the text, and all the examples and support code. The site often seems to be offline, but the book can be found elsewhere, including at Lulu: https://lulu.com/shop/j-david-eisenberg/oasis-opendocument-essentials/paperback/product-392512.html If you feel the need for more information on XSLT, a good text by the developer of Saxon is: XSLT 2.0 and XPath 2.0 Programmer's Reference Michael Kay Wrox Pub., May 2008, 4 th Ed. There's a somewhat shorter XSLT tutorial at W3Schools: https://w3schools.com/xml/xsl_intro.asp A useful forum post, \"Create XSLT filters for import and export\" ( https://forum.openoffice.org/en/forum/viewtopic.php?t=3490 ), by user hol.sten contains XSLT import and export filters for pay.xml (in fact, it's his example). The filters are installed via Office's Tools > \"XML Filter Settings\" menu item. Clicking on the \"New\" button of the filter settings window brings up a dialog containing two tabs shown in Figure 3. Figure 3. The XML Filter Settings Dialog Tabs. Figure 3 shows that I've created a \"Pay\" filter set containing hol.sten's import and export filters stored in payImport.xsl and payExport.xsl. The import filter will convert XML to Flat XML for Calc, as stated in the \"Application\" field of the General tab. After clicking \"Ok\", the Pay filter set is added to the settings window in Figure 4. Figure 4. The Pay Filter in the Settings Window. When pay.xml is opened, the Pay import filter appears in the Calc section of the \"All Files ( . ) popdown list, as seen in Figure 5. Figure 5. The Calc Pay Import Filter. The \"XML Payments\" text in Figure 5 comes from the \"Name of file type\" textfield in the General tab of the dialog in Figure 3. The resulting Calc document is shown in Figure 6. Figure 6. Pay.xml Imported as a Spreadsheet. 1.1. The Clubs Example \u00b6 There's another nice XSLT import and export filter set in chapter 9 of Eisenberg's book. clubs.xml consists of a sequence of associations, each one made up of a sequence of clubs. A typical club entry looks like: <club id=\"Q21\" charter=\"2002\"> <name>Castro Valley Wrestling Club</name> <contact>Ron Maes</contact> <location>Castro Valley</location> <phone>510-555-1491</phone> <email>cvwcron@example.com</email> <age-groups type=\"KCJOW\"/> <info>Practices every Tuesday and Thursday at 5:00 P.M. at Castro Valley High School mat room.</info> </club> A helpful way of visualizing this information is with the XML editor at https://xmlgrid.net/ , which renders it as in Figure 7. Figure 7. Visualization of clubs.xml. There are 17 associations; the first is called \"BAWA\" and contains 11 clubs Eisenberg's clubsImport.xsl and clubsExport.xsl filters are imported into Office using the \"XML Filter Settings\" dialog in Figure 8. Figure 8. The XML Filter Settings Dialog Again. I've called the filter set \"Clubs\", and it uses clubsImport.xsl to produce Flat XML for Writer. There's also a Writer template called clubsTemplate.ott, which applies styles to the imported data. When clubs.xml is opened, the Clubs import filter appears in the Writer section of the \"All Files ( . ) popdown list, as in Figure 9. Figure 9. The Writer Clubs Import Filter. The start of the resulting Writer document looks like Figure 10. Figure 10. Clubs.xml as a Writer Document. 1.2. Command Line Importing (and Exporting) \u00b6 Import filter selection can be time-consuming because of the large number listed in \"Open\"s popdown list. A quicker approach is to call Office from the command line, supplying the filename and filter name as arguments. Most of Office's command line arguments are listed at https://help.libreoffice.org/Common/Starting_the_Software_With_Parameters/ , and a few others when office.exe is invoked with the -h option. The filter commands are -- infilter and --convert-to, which I've wrapped up in two batch scripts called infilter.bat and convert.bat. The hardest part of using these commands is the need to supply a filter name, which corresponds to the \"Filter name\" textfield string in the General tab of the XML Filter Settings dialog. The pay.xml import filter is \"Pay\", as shown in the left hand window in Figure 3; the clubs.xml filter is \"Clubs\", as in Figure 8. The infilter.bat script takes a filename and input filter name argument: infilter pay.xml \"Pay\" This causes Office to open pay.xml using the \"Pay\" import filter, creating the spreadsheet shown in Figure 6. The convert.bat script takes an Office filename and conversion string as arguments. In the simple case, the string is the extension of the exported file. For example, the following exports the Writer document as XML: convert simpleText.odt xml If there are several filters to choose from (as there are for XML), then the default one is used; for this example the Flat XML exporter for Writer will be employed. If a different export filter is required then its name must be appended to the conversion string after a \":\". For instance: convert payment.ods \"xml:Pay\" This exports the payments spreadsheet using the \"Pay\" filter, resulting in a file called payment.xml which has the same format as the original example at the start of the chapter. 1.3. Finding a Filter Name \u00b6 The calls to infilter.bat and convert.bat rely on the user knowing a filter's name (e.g. \"Pay\" or \"Clubs\"). I knew these because I installed them, but what about the names of other filters in Office? A list of filters present in OpenOffice in 2007 can be found at https://wiki.openoffice.org/wiki/Framework/Article/Filter/FilterList_OOo_3_0/ . However, a better approach is to call my FiltersInfo.java example which prints all the filters currently installed in Office, and some extra details about the \"AbiWord\", \"Pay\", and \"Clubs\" filters: // in FiltersInfo.java public class FiltersInfo { public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); // print the names of all the filters in Office String [] filterNms = Info . getFilterNames (); System . out . println ( \"Filter Names\" ); Lo . printNames ( filterNms , 3 ); // print some extra info on 3 filters PropertyValue [] props = Info . getFilterProps ( \"AbiWord\" ); Props . showProps ( \"AbiWord Filter\" , props ); props = Info . getFilterProps ( \"Pay\" ); Props . showProps ( \"Pay Filter\" , props ); props = Info . getFilterProps ( \"Clubs\" ); Props . showProps ( \"Clubs Filter\" , props ); int flags = ( int ) Props . getValue ( \"Flags\" , props ); System . out . println ( \"Filter flags: \" + Integer . toHexString ( flags )); System . out . println ( \" Import: \" + Info . isImport ( flags )); System . out . println ( \" Export: \" + Info . isExport ( flags )); Lo . closeOffice (); } // end of main() } // end of FiltersInfo class The output from FiltersInfo starts with a long list of filter names: Filter Names No. of names: 235 \"AbiWord\" \"Apple Keynote\" \"Apple Numbers\" \"Apple Pages\" \"BMP - MS Windows\" \"BroadBand eBook\" \"Calc MS Excel 2007 Binary\" \"Calc MS Excel 2007 VBA XML\" : \"ClarisWorks_Draw\" \"ClarisWorks_Impress\" \"Clubs\" : \"Palm_Text_Document\" \"PalmDoc\" \"Pay\" : : \"XHTML Draw File\" \"XHTML Impress File\" \"XHTML Writer File\" \"XPM\" In the above list, I've included the lines that include the \"Pay\" and \"Clubs\" filter names. The names are obtained by Info.getFilterNames(), which utilizes the FilterFactory service: // in the Info class public static String [] getFilterNames () { XNameAccess na = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.document.FilterFactory\" ); if ( na == null ) { System . out . println ( \"No Filter factory found\" ); return null ; } else return na . getElementNames (); } // end of getFilterNames() Sometimes it's useful to know more about a filter than just it's name, such as whether it's for importing, exporting, or both. Additional information is available as an array of properties, by calling Info.getFilterProps() with the filter's name: // in the Info class public static PropertyValue [] getFilterProps ( String filterNm ) { XNameAccess na = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.document.FilterFactory\" ); if ( na == null ) { System . out . println ( \"No Filter factory found\" ); return null ; } else { try { return ( PropertyValue [] ) na . getByName ( filterNm ); } catch ( Exception e ) { System . out . println ( \"Could not find filter for \" + filterNm ); return null ; } } } // end of getFilterProps() getFilterProps() is called three times in FiltersInfo.java to retrieve details about the \"AbiWord\", \"Pay\", and \"Clubs\" filters. The output for \"Clubs\" is: Properties for \"Clubs Filter\": UserData: [com.sun.star.documentconversion.XSLTFilter, false, com.sun.star.comp.Writer.XMLOasisImporter, com.sun.star.comp.Writer.XMLOasisExporter, file:///C:/Users/Dell/Desktop/LibreOffice%20Tests/Filter%20Tests/club sImport.xsl, file:///C:/Users/Dell/Desktop/LibreOffice%20Tests/Filter%20Tests/club sExport.xsl, , ] TemplateName: file:///C:/Users/Dell/AppData/Roaming/LibreOffice/4/user/template/Clu bs/clubsTemplate.ott Name: Clubs Type: Clubs UIComponent: FileFormatVersion: 0 FilterService: com.sun.star.comp.Writer.XmlFilterAdaptor DocumentService: com.sun.star.text.TextDocument Flags: 524355 UINames: [ en-US = XML Clubs ] UIName: XML Clubs Finalized: false Mandatory: false The UserData and TemplateName properties indicate that \"Clubs\" contains an import and export filter for Writer's Flat XML, and also a template. Filter properties are explained in the online documentation for the FilterFactory service (use lodoc FilterFactory to access it), and also in the \"Properties of a Filter\" subsection of the \"Integrating Import and Export Filters\" section of chapter 6 of the Developer's Guide (online at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Properties_of_a_Filter/ , or use loGuide \"Properties of a Filter\" ). The most cryptic of the properties is the filter flags integer (524355 in the example above). It's actually a collection of bitwise OR'ed hexadecimals, and FiltersInfo.java shows how they can be accessed: // part of FiltersInfo.java... int flags = ( int ) Props . getValue ( \"Flags\" , props ); System . out . println ( \"Filter flags: \" + Integer . toHexString ( flags )); // print as a hexadecimal string System . out . println ( \" Import: \" + Info . isImport ( flags )); System . out . println ( \" Export: \" + Info . isExport ( flags )); The output is: Filter flags: 80043 Import: true Export: true The hexadecimals that might appear in the flag are listed in the online \"Properties of a Filter\" subsection ( https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Properties_of_a_Filter/ ). I've included a few isXXX() methods in the Info utilities class for testing for their presence. The above example reports that the \"Clubs\" filter contains both an import and export filter. 2. Using Filters with Java \u00b6 Java contains an assortment of XML processing capabilities, grouped under the JAXP (Java API for XML Processing) heading. They include DOM and SAX parsing, XML schema validation, and XSLT transformation. The JDK's XSLT processor is Xalan ( https://xml.apache.org/xalan-j/ ), which supports XSLT 1.0, and so is roughly equivalent to Office's libxslt library. This means that I can use the \"Pay\" and \"Clubs\" filters outside of Office by passing them to Java's Xalan processor. There's a lot of information about JAXP online, including in Oracle's tutorial at https://docs.oracle.com/javase/tutorial/jaxp/ . Also \"XSLT 2.0 and XPath 2.0 Programmer's Reference\" by Michael Kay, which I mentioned earlier, includes an appendix on JAXP. 2.1. Importing XML with Java \u00b6 My ApplyInFilter.java example converts an XML file into an Office document in two steps. First it uses an XSLT import filter to generate Flat XML which it saves to a temporary file. The program then loads that file into Office with one of its Flat XML filters. The correct one is chosen by looking at the filename extension supplied for the final document. For example: run ApplyInFilter pay.xml payImport.xsl payment.ods pay.xml is transformed into Flat XML with payImport.xsl. Office isn't used since Java's XSLT processor is sufficient. However, at the next step the temporary file is loaded using Office's \"Flat XML for Spreadsheets\" filter. This filter is selected by noting the \"ods\" extension of payment.ods. Another example: run ApplyInFilter clubs.xml clubsImport.xsl clubs.odt This converts clubs.xml into a Writer document stored in clubs.odt using the \"Clubs\" import filter. ApplyInFilter.java doesn't support templates, so the data saved to clubs.odt isn't nicely formatted like Figure 10. The ApplyInFilter program: public class ApplyInFilter { public static void main ( String [] args ) { if ( args . length != 3 ) { System . out . println ( \"Usage: java ApplyInFilter <XML fnm> <Flat XML import filter> <new ODF>\" ); return ; } // convert the data to Flat XML String xmlStr = XML . applyXSLT ( args [ 0 ] , args [ 1 ] ); if ( xmlStr == null ) { System . out . println ( \"Filtering failed\" ); return ; } // save flat XML data in a temp file String flatFnm = FileIO . createTempFile ( \"xml\" ); FileIO . saveString ( flatFnm , xmlStr ); XComponentLoader loader = Lo . loadOffice (); // get the type of the output file String odfFnm = args [ 2 ] ; String docType = Lo . ext2DocType ( Info . getExt ( odfFnm )); System . out . println ( \"Doc type: \" + docType ); // open temp file using the correct Flat XML filter XComponent doc = Lo . openFlatDoc ( flatFnm , docType , loader ); if ( doc == null ) System . out . println ( \"Document creation failed\" ); else { GUI . setVisible ( doc , true ); Lo . waitEnter (); Lo . saveDoc ( doc , odfFnm ); Lo . closeDoc ( doc ); } Lo . closeOffice (); } // end of main() } // end of ApplyInFilter class Java ' s XSLT processor is called by XML . applyXSLT (): // in the XML class public static String applyXSLT ( String xmlFnm , String xslFnm ) { try { TransformerFactory tf = TransformerFactory . newInstance (); Source xslt = new StreamSource ( new File ( xslFnm )); Transformer t = tf . newTransformer ( xslt ); System . out . println ( \"Applying filter \" + xslFnm + \" to \" + xmlFnm ); Source text = new StreamSource ( new File ( xmlFnm )); StreamResult result = new StreamResult ( new StringWriter ()); t . transform ( text , result ); return result . getWriter (). toString (); } catch ( Exception e ) { System . out . println ( \"Unable to transform \" + xmlFnm + \" with \" + xslFnm ); System . out . println ( \" \" + e ); return null ; } } // end of applyXSLT() The resulting Flat XML is saved to a temporary file by ApplyInFilter.java, and then the document type of the output file is obtained: // part of ApplyInFilter.java... String docType = Lo . ext2DocType ( Info . getExt ( odfFnm )); The docType string is \"scalc\" when the ODT file is payment.ods, and \"swriter\" for clubs.odt. Lo.openFlatDoc() uses the document type to select the correct Flat XML filter, and passes it to Lo.openDoc() as the \"FilterName\" property: // in the Lo class public static XComponent openFlatDoc ( String fnm , String docType , XComponentLoader loader ) { String nm = XML . getFlatFilterName ( docType ); return openDoc ( fnm , loader , Props . makeProps ( \"FilterName\" , nm )); } XML.getFlatFilterName() maps a document type to an appropriate Flat XML filter name: // in the XML class public static String getFlatFilterName ( String docType ) { if ( docType == Lo . WRITER_STR ) return \"OpenDocument Text Flat XML\" ; else if ( docType == Lo . CALC_STR ) return \"OpenDocument Spreadsheet Flat XML\" ; else if ( docType == Lo . DRAW_STR ) return \"OpenDocument Drawing Flat XML\" ; else if ( docType == Lo . IMPRESS_STR ) return \"OpenDocument Presentation Flat XML\" ; else { System . out . println ( \"No Flat XML filter for this document type; using Flat text\" ); return \"OpenDocument Text Flat XML\" ; } } // end of getFlatFilterName() 2.2. Exporting XML with Java \u00b6 My ApplyOutFilter.java example saves the specified document in Flat XML form to a temporary file. Then it applies an XSLT output filter to transform it into simple XML, which is saved in a new file. For example: run ApplyOutFilter payment.ods payExport.xsl payEx.xml payment.ods contains the spreadsheet shown in Figure 6, and the transformation fills payEx.xml with text almost identical to that on the first page of the chapter. Another example: run ApplyOutFilter clubs.odt clubsExport.xsl clubsEx.xml clubs.odt must contain data formatted by the clubs template (i.e. like the example in Figure 10). This is necessary because clubsExport.xsl utilizes paragraph styles to decide how to change the text. I had to slightly modify the style names used in Eisenberg's export filter. He utilized names containing spaces (e.g. \"Club Name\", \"Club Code\", \"Age Groups\", and \"Club Info\"), but Office automatically changes spaces inside names to \" 20 \". So I had to change the XSLT rules to refer to these names (i.e. \"Club_20_Name\", \"Club_20_Code\", \"Age_20_Groups\", and \"Club_20_Info\"). The ApplyOutFilter program : public class ApplyOutFilter { public static void main ( String [] args ) { if ( args . length != 3 ) { System . out . println ( \"Usage: java ApplyOutFilter <XML file> <Flat XML export filter> <new XML file>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open document: \" + args [ 0 ] ); Lo . closeOffice (); return ; } // save flat XML data String flatFnm = FileIO . createTempFile ( \"xml\" ); Lo . saveDoc ( doc , flatFnm ); Lo . closeDoc ( doc ); // use XSLT to convert Flat XML into simple XML String filteredXML = XML . applyXSLT ( flatFnm , args [ 1 ] ); if ( filteredXML == null ) System . out . println ( \"Filtering failed\" ); else { // indent, print, and save String xmlStr = XML . indent2Str ( filteredXML ); System . out . println ( xmlStr ); FileIO . saveString ( args [ 2 ] , xmlStr ); } Lo . closeOffice (); } // end of main() } // end of ApplyOutFilter class At the end of ApplyOutFilter.java, the XML text in xmlStr is indented and printed. The indention is carried out by XML.indent2Str() which calls XML.applyXSLT2str() with an indenting transformation loaded from indent.xsl: // in the XML class // global private static final String INDENT_FNM = \"indent.xsl\" ; // for indenting XML tags, and adding newlines between tags public static String indent2Str ( String xmlStr ) { return applyXSLT2str ( xmlStr , FileIO . getUtilsFolder () + INDENT_FNM ); } applyXSLT2str() is a variant of XML.applyXSLT() which reads XML from a string rather than a file. 3. Alternatives to XSLT Filters \u00b6 The obvious drawback of the XSLT filter approach is that filter writing requires the programmer to be knowledgable about XSLT, XPath, and the details of the Flat XML format. Another way to write import and export filter is to utilize the ImportFilter and ExportFilter services in the com.sun.star.document module, which are shown in Figure 11. Figure 11. The ImportFilter and ExportFilter Services. These services allow the implementation of non-XML based transformations by utilizing the ImportFilter and ExportFilter services rather than their XMLImportFilter and XMLExportFilter subclasses. The subclasses employ SAX, an event-driven way of parsing XML. If you're interested in using ImportFilter and ExportFilter, the Developer's guide gives some details in the \"Integrating Import and Export Filters\" section of chapter 6 on \"Office Development\". The information is also online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Integrating_Import_and_Export_Filters/ , or use loGuide \"Import and Export Filters\" . But I'm not going to use these services due to their complexity, and I'm about to stop using XSLT as well. Instead I'm going to look at three easier ways to import XML into Office: Data extraction by DOM parsing; Node and attribute data extraction as labeled strings; JAXB conversion of XML to Java objects. The drawback of these simpler approaches is that the imported data will usually need some post-processing to make it look as good as import filter results. 3.1. Data Extraction by DOM Parsing \u00b6 Document Object Model (DOM) parsing converts an XML document into a tree of nodes; the three main types are: Elements; Attributes; The data/values held by the elements and attributes. The DOM API is quite low-level, supporting functions such as getFirstChild() and getNextSibling() in Java's Node class. This motivated the introduction of XPath, and other tree models such as JDOM. Fortunately, I won't be needing those more advanced features. Nodes are found by searching for their name. When a possible match is discovered, the node's children usually need to be examined to determine the node type. For instance, node data has the type Node.TEXT_NODE, while an attribute has the type Node.ATTRIBUTE. There are many online tutorials on Java and DOM, such as Oracle's at https://docs.oracle.com/javase/tutorial/jaxp/dom/ . Two other good ones are mkyong's starting at https://mkyong.com/tutorials/java-xml-tutorials/ and \"Easy DOM Parsing in Java\" by Eric Bruno at https://drdobbs.com/jvm/easy-dom-parsing-in-java/231002580/ . I've 'borrowed' some of Bruno's DOM functions for my XML.java support class, and his company.xml example. A textbook on Java and XML: Pro XML Development with Java Technology Ajay and Deepak Vohra Apress, 2006 The company.xml file contains details about three companies: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <Companies> <Company> <Name>ABC</Name> <Executive type=\"CEO\"> <LastName>Smith</LastName> <FirstName>Jim</FirstName> <street>123 Broad Street</street> <city>Manchester</city> <state>Cheshire</state> <zip>11234</zip> </Executive> </Company> <Company> <Name>NBC</Name> <Executive type=\"President\"> <LastName>Jones</LastName> <FirstName>Lucy</FirstName> <street>23 Bradford St</street> <city>Asbury</city> <state>Lincs</state> <zip>33451</zip> </Executive> </Company> <Company> <Name>BBC</Name> <Executive type=\"Boss\"> <LastName>Singh</LastName> <FirstName>Oxley</FirstName> <street>16d Towers</street> <city>Wimbledon</city> <state>London</state> <zip>77392</zip> </Executive> </Company> </Companies> When writing DOM code, it helps to visualize its structure. One way is to load the file into the editor at https://xmlgrid.net/ , which displays the tree-like structure in Figure 12. Figure 12. The Tree Structure of company.xml. Clicking on the arrow heads expand or contract the tree view. My ExamineCompany.java example loads this data as a DOM tree, and extracts various information: // in ExamineCompany.java public class ExamineCompany { public static void main ( String [] args ) throws Exception { Document doc = XML . loadDoc ( \"company.xml\" ); NodeList root = doc . getChildNodes (); // get the document's root // move down the tree to the executive in the first company node Node comps = XML . getNode ( \"Companies\" , root ); Node comp = XML . getNode ( \"Company\" , comps . getChildNodes ()); Node exec = XML . getNode ( \"Executive\" , comp . getChildNodes ()); // print the executive's data String execType = XML . getNodeAttr ( \"type\" , exec ); NodeList exNodes = exec . getChildNodes (); String lastName = XML . getNodeValue ( \"LastName\" , exNodes ); String firstName = XML . getNodeValue ( \"FirstName\" , exNodes ); String street = XML . getNodeValue ( \"street\" , exNodes ); String city = XML . getNodeValue ( \"city\" , exNodes ); String state = XML . getNodeValue ( \"state\" , exNodes ); String zip = XML . getNodeValue ( \"zip\" , exNodes ); System . out . println ( execType ); System . out . println ( lastName + \", \" + firstName ); System . out . println ( street ); System . out . println ( city + \", \" + state + \" \" + zip ); // get all the data in the tree for a given node/tag name NodeList lnNodes = doc . getElementsByTagName ( \"LastName\" ); ArrayList < String > lastnames = XML . getNodeValues ( lnNodes ); System . out . println ( \"All lastnames:\" ); for ( String lastname : lastnames ) System . out . println ( \" \" + lastname ); } // end of main() } // end of ExamineCompany class The program outputs details about the first company, and the lastnames of all the company bosses: CEO Smith, Jim 123 Broad Street Manchester, Cheshire 11234 All lastnames: Smith Jones Singh XML.getNode() searches through a list of nodes, and returns the first with the specified tag name: // in the XML class public static Node getNode ( String tagName , NodeList nodes ) { for ( int i = 0 ; i < nodes . getLength (); i ++ ) { Node node = nodes . item ( i ); if ( node . getNodeName (). equalsIgnoreCase ( tagName )) return node ; } return null ; } // end of getNode() XML.getNodeValue() looks for a node in a list based on its tag name, and extracts the data stored beneath that node. // in the XML class public static String getNodeValue ( String tagName , NodeList nodes ) { if ( nodes == null ) return \"\" ; for ( int i = 0 ; i < nodes . getLength (); i ++ ) { Node n = nodes . item ( i ); if ( n . getNodeName (). equalsIgnoreCase ( tagName )) return getNodeValue ( n ); } return \"\" ; } // end of getNodeValue() The second version of XML.getNodeValue() retrieves the text from a node's TEXT_NODE child (if there is one): // in the XML class public static String getNodeValue ( Node node ) { if ( node == null ) return \"\" ; NodeList childNodes = node . getChildNodes (); for ( int i = 0 ; i < childNodes . getLength (); i ++ ) { Node n = childNodes . item ( i ); if ( n . getNodeType () == Node . TEXT_NODE ) return n . getNodeValue (). trim (); } return \"\" ; } // end of getNodeValue() XML.getNodeValues() constructs a list of the data stored in all the supplied nodes: // in the XML class public static ArrayList < String > getNodeValues ( NodeList nodes ) { if ( nodes == null ) return null ; ArrayList < String > vals = new ArrayList < String > (); for ( int i = 0 ; i < nodes . getLength (); i ++ ) { String val = getNodeValue ( nodes . item ( i )); if ( val != null ) vals . add ( val ); } return vals ; } // end of getNodeValues() XML.getNodeAttr() extracts data from a node's attribute: // in the XML class public static String getNodeAttr ( String attrName , Node node ) { if ( node == null ) return \"\" ; NamedNodeMap attrs = node . getAttributes (); if ( attrs == null ) return \"\" ; for ( int i = 0 ; i < attrs . getLength (); i ++ ) { Node attr = attrs . item ( i ); if ( attr . getNodeName (). equalsIgnoreCase ( attrName )) return attr . getNodeValue (). trim (); } return \"\" ; } // end of getNodeAttr() Converting XML to Spreadsheet Data It's fairly easy to map XML data into a spreadsheet format of rows and columns. Consider pay.xml from earlier: <?xml version=\"1.0\"?> <payments> <payment> <purpose>CD</purpose> <amount>12.95</amount> <tax>19.1234</tax> <maturity>2008-03-01</maturity> </payment> <payment> <purpose>DVD</purpose> <amount>19.95</amount> <tax>19.4321</tax> <maturity>2008-03-02</maturity> </payment> <payment> <purpose>Clothes</purpose> <amount>99.95</amount> <tax>18.5678</tax> <maturity>2008-03-03</maturity> </payment> <payment> <purpose>Book</purpose> <amount>9.49</amount> <tax>18.9876</tax> <maturity>2008-03-04</maturity> </payment> </payments> It can be viewed as a sequence of payment objects, each containing four fields (purpose, amount, tax, and maturity). Each payment object can be mapped to a spreadsheet row, and its fields to four columns in that row. This format can be represented by a 2D array, which is easily constructed using the DOM API. My CreatePay.java example utilizes XML.getAllNodeValues() to build a 2D array from the pay.xml data, and calls Calc.setArray() to add the data to a new Calc document: // in CreatePay.java public class CreatePay { public static void main ( String args [] ) { Document xdoc = XML . loadDoc ( \"pay.xml\" ); NodeList pays = xdoc . getElementsByTagName ( \"payment\" ); if ( pays == null ) return ; Object [][] data = XML . getAllNodeValues ( pays , new String [] { \"purpose\" , \"amount\" , \"tax\" , \"maturity\" }); Lo . printTable ( \"payments\" , data ); XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . setArray ( sheet , \"A1\" , data ); // Lo.saveDoc(doc, \"payCreated.ods\"); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of CreatePay class The list of payment nodes is obtained using: // part of CreatePay.java... NodeList pays = xdoc . getElementsByTagName ( \"payment\" ); The 2D array of payment data is constructed by : // part of CreatePay.java... Object [][] data = XML . getAllNodeValues ( pays , new String [] { \"purpose\" , \"amount\" , \"tax\" , \"maturity\" }); The first argument of getAllNodeValues() is the list of nodes to be scanned, and the second parameter is an array of tag names. The named nodes are assumed to be children of each node in the list, and their data becomes one row in the 2D array. The method's code: // in the XML class public static Object [][] getAllNodeValues ( NodeList rowNodes , String [] colIDs ) { int numRows = rowNodes . getLength (); int numCols = colIDs . length ; Object [][] data = new Object [ numRows + 1 ][ numCols ] ; // put column names in first row of array for ( int col = 0 ; col < numCols ; col ++ ) data [ 0 ][ col ] = Lo . capitalize ( colIDs [ col ] ); for ( int i = 0 ; i < numRows ; i ++ ) { // extract column data for ith row NodeList colNodes = rowNodes . item ( i ). getChildNodes (); for ( int col = 0 ; col < numCols ; col ++ ) data [ i + 1 ][ col ] = getNodeValue ( colIDs [ col ] , colNodes ); } return data ; } // end of getAllNodeValues() XML.getAllNodeValues() also adds a header row to the array made up of the tag names. The resulting table is printing by Lo.printTables(): -- payments ---------------- Purpose Amount Tax Maturity CD 12.95 19.1234 2008-03-01 DVD 19.95 19.4321 2008-03-02 Clothes 99.95 18.5678 2008-03-03 Book 9.49 18.9876 2008-03-04 ----------------------------- Calc.setArray() adds the table to the spreadsheet, which ends up like Figure 13. Figure 13. The Spreadsheet Generated by CreatePay.java. XML.getAllNodeValues() doesn't always produce such good results, as illustrated by the CreateAssoc.java example which converts part of clubs.xml into a spreadsheet. As explained earlier, clubs.xml consists of a sequence of associations, with each one made up of a sequence of clubs. The most natural spreadsheet mapping would be to assign each association to its own sheet, and convert each club into a row on that sheet. A club consists of seven elements and two attributes, as seen in the following example: <club id=\"Q21\" charter=\"2002\"> <name>Castro Valley Wrestling Club</name> <contact>Ron Maes</contact> <location>Castro Valley</location> <phone>510-555-1491</phone> <email>cvwcron@example.com</email> <age-groups type=\"KCJOW\"/> <info>Practices every Tuesday and Thursday at 5:00 P.M. at Castro Valley High School mat room.</info> </club> Probably the best spreadsheet representation would be to use nine columns, so the attributes could be listed. This approach is employed by the xmlgrid.net website as shown in Figure 14. Figure 14. Part of the Clubs Information. Unfortunately, XML.getAllNodeValues() as currently coded doesn't extract attribute information, so the id and charter data will be missed. The CreateAssoc.java example loads clubs.xml, and selects the first association. Its list of clubs is passed to XML.getAllNodeValues() for conversion into an array. The complete program is: // in CreateAssoc.java public class CreateAssoc { public static void main ( String args [] ) { Document xdoc = XML . loadDoc ( \"clubs.xml\" ); NodeList root = xdoc . getChildNodes (); // get the first association Node cdb = XML . getNode ( \"club-database\" , root ); Node assoc1 = XML . getNode ( \"association\" , cdb . getChildNodes ()); NodeList clubs = assoc1 . getChildNodes (); // convert clubs information into an array Object [][] data = XML . getAllNodeValues ( clubs , new String [] { \"name\" , \"contact\" , \"location\" , \"phone\" , \"email\" }); Lo . printTable ( \"clubs\" , data ); XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . setArray ( sheet , \"A1\" , data ); // Lo.saveDoc(doc, \"clubsCreated.ods\"); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of CreateAssoc class XML.getAllNodeValues() only requests data for five of the seven elements (\"name\", \"contact\", \"location\", \"phone\", \"email\") to reduce the information returned. The resulting spreadsheet is shown in Figure 15. Figure 15. Part of the Spreadsheet Generated by CreateAssoc.java. An obvious issue is the empty rows between the clubs data, caused by the simple XML.getAllNodeValues() implementation. It assumes that every node supplies one row of data because of its data element child. Howevere, each club also contains attributes which adds an extra empty row to the output. 3.2. Node and Attribute Data Extraction as Labeled Strings \u00b6 Not all XML data can be so easily mapped to a 2D format, especially collections such as weather.xml: <?xml version=\"1.0\" encoding=\"UTF-8\"?><current> <city id=\"1610780\" name=\"Hat Yai\"> <coord lat=\"7.01\" lon=\"100.48\"/> <country>TH</country> <sun rise=\"2017-01-01T23:30:31\" set=\"2017-01-02T11:14:18\"/> </city> <temperature max=\"25\" min=\"25\" unit=\"metric\" value=\"25\"/> <humidity unit=\"%\" value=\"94\"/> <pressure unit=\"hPa\" value=\"1011\"/> <wind> <speed name=\"Gentle Breeze\" value=\"3.6\"/> <gusts/> <direction code=\"NNE\" name=\"North-northeast\" value=\"30\"/> </wind> <clouds name=\"broken clouds\" value=\"75\"/> <visibility value=\"5000\"/> <precipitation mode=\"no\"/> <weather icon=\"10n\" number=\"501\" value=\"moderate rain\"/> <lastupdate value=\"2017-01-02T15:30:00\"/> </current> This data was downloaded from OpenWeatherMap using the API at https://api.openweathermap.org/ . Unlike pay.xml or clubs.xml there's no sequence of objects that would naturally become rows of a spreadsheet. In addition, the data is mostly represented by attributes rather than text nodes. In situations like this, a good general approach is to convert the XML to simpler text, removing XML labels except for the element and attribute names. As a result, my ExtractXMLInfo.java example produces the following output when applied to weather.xml: current city id= \"1610780\" name= \"Hat Yai\" coord lat= \"7.01\" lon= \"100.48\" country: \"TH\" sun rise= \"2017-01-01T23:30:31\" set= \"2017-01-02T11:14:18\" temperature max= \"25\" min= \"25\" unit= \"metric\" value= \"25\" humidity unit= \"%\" value= \"94\" pressure unit= \"hPa\" value= \"1011\" wind speed name= \"Gentle Breeze\" value= \"3.6\" gusts direction code= \"NNE\" name= \"North-northeast\" value= \"30\" clouds name= \"broken clouds\" value= \"75\" visibility value= \"5000\" precipitation mode= \"no\" weather icon= \"10n\" number= \"501\" value= \"moderate rain\" lastupdate value= \"2017-01-02T15:30:00\" Line indentation is retained, and is utilized when the data is loaded into Office. As another example, consider pay.xml which ExtractXMLInfo.java converts into: payments payment purpose: \"CD\" amount: \"12.95\" tax: \"19.1234\" maturity: \"2008-03-01\" payment purpose: \"DVD\" amount: \"19.95\" tax: \"19.4321\" maturity: \"2008-03-02\" payment purpose: \"Clothes\" amount: \"99.95\" tax: \"18.5678\" maturity: \"2008-03-03\" payment purpose: \"Book\" amount: \"9.49\" tax: \"18.9876\" maturity: \"2008-03-04\" The elements and attributes with data are highlighted by adding a \":\" or \"=\" after their names. Also, the data is always doubly quoted. ExtractXMLInfo.java travels over the DOM tree, printing what it finds to a text file: // in ExtractXMLInfo.java public static void main ( String [] args ) throws Exception { if ( args . length != 1 ) { System . out . println ( \"Usage: run ExtractXMLInfo <XML file>\" ); return ; } Document doc = XML . loadDoc ( args [ 0 ] ); if ( doc == null ) return ; String fname = Info . getName ( args [ 0 ] ); String outFnm = fname + \"XML.txt\" ; System . out . println ( \"Writing XML data from \" + args [ 0 ] + \" to \" + outFnm ); PrintWriter pw = new PrintWriter ( new FileWriter ( outFnm )); NodeList root = doc . getChildNodes (); // there may be multiple trees; visit each one for ( int i = 0 ; i < root . getLength (); i ++ ) { visitNode ( pw , root . item ( i ), \"\" ); pw . write ( \"\\n\" ); } pw . close (); } // end of main() visitNode() prints the node's tag, any attribute data, any text child node data, and recursively visits the rest of the node's children: // part of ExtractXMLInfo.java private static void visitNode ( PrintWriter pw , Node node , String ind ) { pw . write ( ind + node . getNodeName ()); visitAttrs ( pw , node ); // examine all the child nodes NodeList nodeList = node . getChildNodes (); for ( int i = 0 ; i < nodeList . getLength (); i ++ ) { Node child = nodeList . item ( i ); if ( child . getNodeType () == Node . TEXT_NODE ) { String trimmedVal = child . getNodeValue (). trim (); if ( trimmedVal . length () == 0 ) pw . write ( \"\\n\" ); else pw . write ( \": \\\"\" + trimmedVal + \"\\\"\" ); // element names with values end with ':' } else if ( child . getNodeType () == Node . ELEMENT_NODE ) visitNode ( pw , child , ind + \" \" ); } } // end of visitNode() visitAttrs() prints attribute names and data: // part of ExtractXMLInfo.java private static void visitAttrs ( PrintWriter pw , Node node ) { NamedNodeMap attrs = node . getAttributes (); if ( attrs != null ) { for ( int i = 0 ; i < attrs . getLength (); i ++ ) { Node attr = attrs . item ( i ); pw . write ( \" \" + attr . getNodeName () + \"= \\\"\" + attr . getNodeValue () + \"\\\"\" ); // attribute names end with '=' } } } // end of visitAttrs() When ExtractXMLInfo.java has finished stripping the XML, the next stage is to call BuildXMLSheet.java to load the text into Office as a Calc sheet. This is done by converting it into a 2D array which is added to the spreadsheet by Calc.setArray(). The main() function of BuildXMLSheet.java calls getData() to create the array: // in BuildXMLSheet.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run BuildXMLSheet <XML textfile>\" ); return ; } Object [][] data = getData ( args [ 0 ] ); Lo . printTable ( args [ 0 ] + \" data\" , data ); XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 2000 ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . setArray ( sheet , \"A1\" , data ); // Lo.saveDoc(doc, \"createdSS.ods\"); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() getData() builds the array in two steps: initially a list of differently sized arrays is created, one for each input line. Then the list is converted into a 2D array where every row has the same length. // part of BuildXMLSheet.java private static Object [][] getData ( String fnm ) { int maxCols = 0 ; // max number of columns across all rows // each input line is stored as an array inside a list ArrayList < Object []> rows = new ArrayList < Object []> (); System . out . println ( \"Reading data from \" + fnm ); try { BufferedReader br = new BufferedReader ( new FileReader ( fnm )); String line ; while (( line = br . readLine ()) != null ) { Object [] toks = splitLine ( line ); // read a line as an array of tokens (strings) if ( toks . length > 0 ) rows . add ( toks ); if ( toks . length > maxCols ) maxCols = toks . length ; } } catch ( IOException e ) { System . out . println ( \"Could not read \" + fnm ); return null ; } // convert list of different length arrays into a // fixed length 2D array Object [][] data = new Object [ rows . size () ][ maxCols ] ; for ( int r = 0 ; r < rows . size (); r ++ ) { Object [] row = rows . get ( r ); for ( int c = 0 ; c < maxCols ; c ++ ) { if ( c >= row . length ) data [ r ][ c ] = \"\" ; // pad out array row with empty strings else data [ r ][ c ] = row [ c ] ; } } return data ; } // end of getData() splitLine () converts an input line into an array of tokens . // part of BuildXMLSheet.java private static String [] splitLine ( String ln ) { ln += \" \" ; // To detect last token when not quoted... boolean inQuote = false ; boolean isIndenting = true ; int numSpaces = 0 ; StringBuilder word = new StringBuilder (); ArrayList < String > toks = new ArrayList < String > (); // used to store tokens for the final array for ( int i = 0 ; i < ln . length (); i ++ ) { char ch = ln . charAt ( i ); if ( ch != ' ' && isIndenting ) isIndenting = false ; if ( ch == ' ' && isIndenting ) { numSpaces ++ ; if ( numSpaces % 2 == 0 ) toks . add ( \"\" ); // convert two space indent into \"\" } else if ( ch == '\\\"' || ch == ' ' && ! inQuote ) { // treat a double quoted string as one token if ( ch == '\\\"' ) inQuote = ! inQuote ; if ( ! inQuote && word . length () > 0 ) { char lastCh = word . charAt ( word . length () - 1 ); if (( lastCh == ':' ) || ( lastCh == '=' )) // strip element and attribute assignment symbols word . deleteCharAt ( word . length () - 1 ); toks . add ( word . toString ()); word . delete ( 0 , word . length ()); } } else word . append ( ch ); } return toks . toArray ( new String [ toks . size () ] ); } // end of splitLine() Every two spaces at the start of a line is stored as an empty string in the row array. These strings will later occupy spreadsheet cells at the start of a row, causing the actual data to be 'indented' to cells further to the right. Special care is taken to treat a doubly quoted string as a single token, and any word ending with ':' or '=' has that character stripped away. These characters signify that the element or attribute name has associated data. Figure 16 shows how the weather data is loaded as a spreadsheet by BuildXMLSheet.java. Figure 16. BuildXMLSheet Applied to Weather Data. Figure 17 shows the results for the payments data. Figure 17. BuildXMLSheet Applied to Payments Data. 3.3. JAXB Conversion of XML to Java Objects \u00b6 Java Architecture for XML Binding (JAXB) provides methods for unmarshalling (converting) XML documents into Java classes and objects, and for marshalling Java objects back into XML documents. I'm interested in the unmarshalling parts so data can be passed to Office as Java objects rather than as XML. Most of the magic of the XML-to-Java conversion is performed by Java's xjc.exe tool which comes as part of the JDK (you'll find it in %java_home%\\bin on Windows). xjc processes an XML schema (an XSD file) rather than XML since the schema contains information about the XML's underlying structure. The good news is that there are websites, such as freeformatter.com, which can generate XSD from supplied XML ( https://freeformatter.com/xsd-generator.html ). I employed its \"Salami slice\" translator so that the Java code generated later by xjc is a bit simpler to read. freeformatter.com converted pay.xml into the following XSD: <xs:schema attributeFormDefault=\"unqualified\" elementFormDefault=\"qualified\" xmlns:xs=\"https://w3.org/2001/XMLSchema\"> <xs:element name=\"purpose\" type=\"xs:string\"/> <xs:element name=\"amount\" type=\"xs:float\"/> <xs:element name=\"tax\" type=\"xs:float\"/> <xs:element name=\"maturity\" type=\"xs:date\"/> <xs:element name=\"payment\"> <xs:complexType> <xs:sequence> <xs:element ref=\"purpose\"/> <xs:element ref=\"amount\"/> <xs:element ref=\"tax\"/> <xs:element ref=\"maturity\"/> </xs:sequence> </xs:complexType> </xs:element> <xs:element name=\"payments\"> <xs:complexType> <xs:sequence> <xs:element ref=\"payment\" maxOccurs=\"unbounded\" minOccurs=\"0\"/> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> The schema gives the names and types for each field in a payment object, and makes payments a sequence of payment objects. A good tutorial on XSD can be found at w3schools.com: https://w3schools.com/Xml/schema_intro.asp If the resulting schema is stored in pay.xsd, then xjc generates Java classes like so: xjc -p Pay pay.xsd The \u2013p option supplies a package name which causes the potentially numerous classes to be stored in a folder of that name. Details about xjc can be found at https://docs.oracle.com/javase/6/docs/technotes/tools/share/xjc.html , or by calling xjc - help. Three classes are written to the Pay folder: Payments.java, Payment.java, and ObjectFactory.java. The first two are Java version of the XML elements, while ObjectFactory is used to create the Java objects at runtime. Figure 18 shows class diagrams for the code. Figure 18. The Payments Class Diagrams. As you might expect, the XML sequence of Payment objects inside Payments is implemented as a list in Java. The details of the ObjectFactory aren't important, but the get/set methods in the Payments and Payment classes will be useful. My UnmarshallPay.java example shows how to use these classes: // in UnmarshallPay.java import java.io.* ; import java.util.* ; import javax.xml.bind.* ; import Pay.* ; // the package for the Pay classes public class UnmarshallPay { public static void main ( String [] args ) { try { // initialize the Payments objects using pay.xml JAXBContext jaxbContext = JAXBContext . newInstance ( Payments . class ); Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller (); Payments pays = ( Payments ) jaxbUnmarshaller . unmarshal ( new File ( \"pay.xml\" )); List < Payment > payList = pays . getPayment (); // print payment names and amounts System . out . println ( \"Payments\" ); for ( Payment p : payList ) System . out . println ( \" \" + p . getPurpose () + \": \" + p . getAmount ()); } catch ( JAXBException e ) { e . printStackTrace (); } } // end of main() } // end of UnmarshallPay class main() creates an Unmarshaller object for the Payments class, which is initialized with data from pay.xml. It then iterates through the Payment objects and prints their purpose and amount fields. The output is: Payments CD: 12.95 DVD: 19.95 Clothes: 99.95 Book: 9.49 Now that the XML data is available through Java (using various get methods), it is quite easy to extend UnmarshallPay.java to write it into an Office document. clubs.xml as Java Code \u00b6 The JAXB manipulation of clubs.xml follows the same steps as used on pay.xml: Convert clubs.xml to XSD at freeformatter.com using the \"Salami Slice\" mapping. Convert company.xsd into Java classes with xjc: xjc -p Clubs clubs.xsd Compile the Clubs package: javac Clubs/*.java Figure 19 shows the Clubs class diagrams. Figure 19. The Clubs Class Diagrams. The top-level class is ClubDatabase which maintains a list of Association objects. Each Association object holds a list of Club objects. Club contains get/set methods for accessing its fields. My UnmarshallClubs.java example shows how to use these classes: // in UnmarshallClubs.java import java.io.* ; import java.util.* ; import javax.xml.bind.* ; import Clubs.* ; // the package for the Club classes public class UnmarshallClubs { public static void main ( String [] args ) { try { // initialize the Clubs objects using clubs.xml JAXBContext jaxbContext = JAXBContext . newInstance ( ClubDatabase . class ); Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller (); ClubDatabase cd = ( ClubDatabase ) jaxbUnmarshaller . unmarshal ( new File ( \"clubs.xml\" )); List < Association > assocList = cd . getAssociation (); // print club names for all the associations System . out . println ( \"Associations\" ); for ( Association assoc : assocList ) { System . out . println ( \" \" + assoc . getId ()); List < Club > clubs = assoc . getClub (); for ( Club club : clubs ) System . out . println ( \" \" + club . getName ()); } } catch ( JAXBException e ) { e . printStackTrace (); } } // end of main() } // end of UnmarshallClubs class The unmarshalling is similar to before except that the ClubDatabase object is initialized with data from clubs.xml. The code iterates through the clubs in each association, printing their names: Associations BAWA Castro Valley Wrestling Club Coastside Grapplers Dixon Ram Wrestling East Bay Freestylers Fairfield WrestlingClub Godfather Wrestling Club Golden Gate Wrestling Club Mat Club USA Pirate Wrestling Club SF Elite Wrestling Titan Wrestling Club CAGWA Big Bear Grizzlies Wrestling Club California Grapplers Youth Wrestling : : South Coast Wrestling Club West Hills Hawks Naming Conflicts \u00b6 The xjc tool works so well that a deep understanding of JAXB isn't usually needed. The exception is when the XML contains a name conflict, which occurs if two or more attributes have the same name. There's a number of \"value\" name conflicts in weather.xml, which I've highlighted below: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <current> <city id=\"1610780\" name=\"Hat Yai\"> <coord lat=\"7.01\" lon=\"100.48\"/> <country>TH</country> <sun rise=\"2017-01-01T23:30:31\" set=\"2017-01-02T11:14:18\"/> </city> <temperature max=\"25\" min=\"25\" unit=\"metric\" value=\"25\"/> <humidity unit=\"%\" value=\"94\"/> <pressure unit=\"hPa\" value=\"1011\"/> <wind> <speed name=\"Gentle Breeze\" value=\"3.6\"/> <gusts/> <direction code=\"NNE\" name=\"North-northeast\" value=\"30\"/> </wind> <clouds name=\"broken clouds\" value=\"75\"/> <visibility value=\"5000\"/> <precipitation mode=\"no\"/> <weather icon=\"10n\" number=\"501\" value=\"moderate rain\"/> <lastupdate value=\"2017-01-02T15:30:00\"/> </current> The \"value\" attribute is used nine times in different contexts. This doesn't pose a problem for freeformatter.com, which quietly generates weather.xsd. The name conflict is only reported when xjc tries to generate Java classes: > xjc -p Weather weather.xsd parsing a schema... [ERROR] Property \"Value\" is already defined. Use <jaxb:property> to resolve this conflict. : // many more error messages \u2026 As the error message advises, I need to add jaxb:property annotations to the XSD file to allow xjc to correctly translate the attributes. For example, the first offender in weather.xsd is: <xs:attribute type=\"xs:float\" name=\"value\"/> Its jaxb:property annotation is: <xs:attribute type=\"xs:float\" name=\"value\"> <!-- avoid \"value\" name conflict --> <xs:annotation> <xs:appinfo> <jaxb:property name=\"valueAttribute\"/> </xs:appinfo> </xs:annotation> </xs:attribute> This same change is applied to all the other conflicting attribute names. In addition, the new \"jaxb\" label must be linked to its JAXB schema at the start of the XSD file: <!-- in the xs:schema element --> xmlns:jaxb=\"https://java.sun.com/xml/ns/jaxb\" jaxb:version=\"2.1\" If you want to understand what's happening in more detail, the best place to start is the tutorial at Oracle: https://docs.oracle.com/javase/tutorial/jaxb/intro/ . When xjc is passed this modified weather.xsd file, the Java classes are correctly generated. Figure 20 shows only the class names to reduce the diagram's size. Figure 20. The Weather Class Diagrams. The top-level class is Current which stores the weather attributes as objects. My UnmarshallWeather.java example examines weather.xml to report if it was raining on the report day: // in UnmarshallWeather.java public class UnmarshallWeather { public static void main ( String [] args ) { try { JAXBContext jaxbContext = JAXBContext . newInstance ( Current . class ); Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller (); Current currWeather = ( Current ) jaxbUnmarshaller . unmarshal ( new File ( \"weather.xml\" )); // get precipitation as a boolean String rainingStatus = currWeather . getPrecipitation (). getValue (); boolean isRaining = rainingStatus . equals ( \"yes\" ); // get date in day/month/year format XMLGregorianCalendar gCal = currWeather . getLastupdate (). getValueAttribute (); Calendar cal = gCal . toGregorianCalendar (); SimpleDateFormat formatter = new SimpleDateFormat ( \"dd/MM/yyyy\" ); formatter . setTimeZone ( cal . getTimeZone ()); String dateStr = formatter . format ( cal . getTime ()); if ( isRaining ) System . out . println ( \"It was raining on \" + dateStr ); else System . out . println ( \"It was NOT raining on \" + dateStr ); } catch ( JAXBException e ) { e . printStackTrace (); } } // end of main() } // end of UnmarshallWeather class The output is: It was NOT raining on 02/01/2017","title":"Chapter 50. Importing XML"},{"location":"50-Importing_XML.html#chapter-50-importing-xml","text":"Topics XSLT Filters; Using Filters with Java; Alternatives to XSLT Filters: DOM Parsing, Node and Attribute Data Extraction, JAXB Conversion Example folders: \"Filter Tests\" and \"Utils\" This chapter is mostly about importing XML data into Office. I start by looking at XSLT import (and export) filters, which give the best results but require the programmer to know a great deal about XML and the ODF file format. The second half of the chapter is about three simpler techniques for importing XML which require less comprehensive XML skills and no knowledge of ODF. The drawback is that the resulting document may be less 'beautiful', often requiring some manual post-processing to remove unnecessary white space and data. You'd be correct in thinking that Office can already import XML, but you may be disappointed with the results: a simple XML file, such as pay.xml shown below, is imported unchanged, as plain text: <?xml version=\"1.0\"?> <payments> <payment> <purpose>CD</purpose> <amount>12.95</amount> <tax>19.1234</tax> <maturity>2008-03-01</maturity> </payment> <payment> <purpose>DVD</purpose> <amount>19.95</amount> <tax>19.4321</tax> <maturity>2008-03-02</maturity> </payment> <payment> <purpose>Clothes</purpose> <amount>99.95</amount> <tax>18.5678</tax> <maturity>2008-03-03</maturity> </payment> <payment> <purpose>Book</purpose> <amount>9.49</amount> <tax>18.9876</tax> <maturity>2008-03-04</maturity> </payment> </payments> Office offers many ways of loading XML through the \"All files ( . )\" popdown list in the Open dialog. Figure 1 shows my selection of \"Flat XML ODF Spreadsheet\": Figure 1. Selecting an XML Import Format. Unfortunately, the result isn't a nice spreadsheet of the payments, but a Writer document containing all the data and XML tags. Flat XML is for encoding an OpenDocument format (ODF) document as a single text file, which contrasts with how it's usually stored as a zipped folder of several files and sub-folders. pay.xml isn't a Flat XML file, and so Office drops back to treating it as plain text, and uses Writer to display it. Incidentally, there are several Flat XML formats aimed at the different Office applications, Writer, Calc, Draw, and Impress.","title":"Chapter 50. Importing XML"},{"location":"50-Importing_XML.html#1-filters-to-the-rescue","text":"pay.xml can be opened as a spreadsheet with the help of an input filter. There are a few ways of writing these, as explained by Fridrich Strba in his blog post \"Extending the Swiss Army knife - an overview about writing of filters for LibreOffice\" ( https://fridrich.blogspot.com/2013/08/extending-swiss-army-knife-overview.html ). The easiest way of implementing an XML input filter is with XSLT (eXtensible Stylesheet Language: Transformations). The filter is utilized by the XSLT processor inside Office to load and transform the XML, as illustrated in Figure 2. Figure 2. Using an XSLT filter. XSLT is designed for transforming XML into other textual formats; in this case, it will convert the simple XML used by pay.xml into the Flat XML used by Calc. Office's XSLT processor used to be Saxon ( https://saxon.sourceforge.net/ ), a Java API, but was replaced in 2012 by the libxslt C library ( https://xmlsoft.org/libxslt/ ). This implements XSLT 1.0 with some extensions, so it's best to avoid using features from the newer XSLT 2.0. One source for learning XLST in the context of ODF is: OASIS OpenDocument Essentials J. David Eisenberg, 2005 https://books.evc-cit.info/ The book includes a chapter on filters, and an appendix that overviews XSLT and XPath (XPath is used for locating parts of the input document for processing). Eisenberg's website has a free draft of the text, and all the examples and support code. The site often seems to be offline, but the book can be found elsewhere, including at Lulu: https://lulu.com/shop/j-david-eisenberg/oasis-opendocument-essentials/paperback/product-392512.html If you feel the need for more information on XSLT, a good text by the developer of Saxon is: XSLT 2.0 and XPath 2.0 Programmer's Reference Michael Kay Wrox Pub., May 2008, 4 th Ed. There's a somewhat shorter XSLT tutorial at W3Schools: https://w3schools.com/xml/xsl_intro.asp A useful forum post, \"Create XSLT filters for import and export\" ( https://forum.openoffice.org/en/forum/viewtopic.php?t=3490 ), by user hol.sten contains XSLT import and export filters for pay.xml (in fact, it's his example). The filters are installed via Office's Tools > \"XML Filter Settings\" menu item. Clicking on the \"New\" button of the filter settings window brings up a dialog containing two tabs shown in Figure 3. Figure 3. The XML Filter Settings Dialog Tabs. Figure 3 shows that I've created a \"Pay\" filter set containing hol.sten's import and export filters stored in payImport.xsl and payExport.xsl. The import filter will convert XML to Flat XML for Calc, as stated in the \"Application\" field of the General tab. After clicking \"Ok\", the Pay filter set is added to the settings window in Figure 4. Figure 4. The Pay Filter in the Settings Window. When pay.xml is opened, the Pay import filter appears in the Calc section of the \"All Files ( . ) popdown list, as seen in Figure 5. Figure 5. The Calc Pay Import Filter. The \"XML Payments\" text in Figure 5 comes from the \"Name of file type\" textfield in the General tab of the dialog in Figure 3. The resulting Calc document is shown in Figure 6. Figure 6. Pay.xml Imported as a Spreadsheet.","title":"1.  Filters to the Rescue"},{"location":"50-Importing_XML.html#11-the-clubs-example","text":"There's another nice XSLT import and export filter set in chapter 9 of Eisenberg's book. clubs.xml consists of a sequence of associations, each one made up of a sequence of clubs. A typical club entry looks like: <club id=\"Q21\" charter=\"2002\"> <name>Castro Valley Wrestling Club</name> <contact>Ron Maes</contact> <location>Castro Valley</location> <phone>510-555-1491</phone> <email>cvwcron@example.com</email> <age-groups type=\"KCJOW\"/> <info>Practices every Tuesday and Thursday at 5:00 P.M. at Castro Valley High School mat room.</info> </club> A helpful way of visualizing this information is with the XML editor at https://xmlgrid.net/ , which renders it as in Figure 7. Figure 7. Visualization of clubs.xml. There are 17 associations; the first is called \"BAWA\" and contains 11 clubs Eisenberg's clubsImport.xsl and clubsExport.xsl filters are imported into Office using the \"XML Filter Settings\" dialog in Figure 8. Figure 8. The XML Filter Settings Dialog Again. I've called the filter set \"Clubs\", and it uses clubsImport.xsl to produce Flat XML for Writer. There's also a Writer template called clubsTemplate.ott, which applies styles to the imported data. When clubs.xml is opened, the Clubs import filter appears in the Writer section of the \"All Files ( . ) popdown list, as in Figure 9. Figure 9. The Writer Clubs Import Filter. The start of the resulting Writer document looks like Figure 10. Figure 10. Clubs.xml as a Writer Document.","title":"1.1.  The Clubs Example"},{"location":"50-Importing_XML.html#12-command-line-importing-and-exporting","text":"Import filter selection can be time-consuming because of the large number listed in \"Open\"s popdown list. A quicker approach is to call Office from the command line, supplying the filename and filter name as arguments. Most of Office's command line arguments are listed at https://help.libreoffice.org/Common/Starting_the_Software_With_Parameters/ , and a few others when office.exe is invoked with the -h option. The filter commands are -- infilter and --convert-to, which I've wrapped up in two batch scripts called infilter.bat and convert.bat. The hardest part of using these commands is the need to supply a filter name, which corresponds to the \"Filter name\" textfield string in the General tab of the XML Filter Settings dialog. The pay.xml import filter is \"Pay\", as shown in the left hand window in Figure 3; the clubs.xml filter is \"Clubs\", as in Figure 8. The infilter.bat script takes a filename and input filter name argument: infilter pay.xml \"Pay\" This causes Office to open pay.xml using the \"Pay\" import filter, creating the spreadsheet shown in Figure 6. The convert.bat script takes an Office filename and conversion string as arguments. In the simple case, the string is the extension of the exported file. For example, the following exports the Writer document as XML: convert simpleText.odt xml If there are several filters to choose from (as there are for XML), then the default one is used; for this example the Flat XML exporter for Writer will be employed. If a different export filter is required then its name must be appended to the conversion string after a \":\". For instance: convert payment.ods \"xml:Pay\" This exports the payments spreadsheet using the \"Pay\" filter, resulting in a file called payment.xml which has the same format as the original example at the start of the chapter.","title":"1.2.  Command Line Importing (and Exporting)"},{"location":"50-Importing_XML.html#13-finding-a-filter-name","text":"The calls to infilter.bat and convert.bat rely on the user knowing a filter's name (e.g. \"Pay\" or \"Clubs\"). I knew these because I installed them, but what about the names of other filters in Office? A list of filters present in OpenOffice in 2007 can be found at https://wiki.openoffice.org/wiki/Framework/Article/Filter/FilterList_OOo_3_0/ . However, a better approach is to call my FiltersInfo.java example which prints all the filters currently installed in Office, and some extra details about the \"AbiWord\", \"Pay\", and \"Clubs\" filters: // in FiltersInfo.java public class FiltersInfo { public static void main ( String [] args ) { XComponentLoader loader = Lo . loadOffice (); // print the names of all the filters in Office String [] filterNms = Info . getFilterNames (); System . out . println ( \"Filter Names\" ); Lo . printNames ( filterNms , 3 ); // print some extra info on 3 filters PropertyValue [] props = Info . getFilterProps ( \"AbiWord\" ); Props . showProps ( \"AbiWord Filter\" , props ); props = Info . getFilterProps ( \"Pay\" ); Props . showProps ( \"Pay Filter\" , props ); props = Info . getFilterProps ( \"Clubs\" ); Props . showProps ( \"Clubs Filter\" , props ); int flags = ( int ) Props . getValue ( \"Flags\" , props ); System . out . println ( \"Filter flags: \" + Integer . toHexString ( flags )); System . out . println ( \" Import: \" + Info . isImport ( flags )); System . out . println ( \" Export: \" + Info . isExport ( flags )); Lo . closeOffice (); } // end of main() } // end of FiltersInfo class The output from FiltersInfo starts with a long list of filter names: Filter Names No. of names: 235 \"AbiWord\" \"Apple Keynote\" \"Apple Numbers\" \"Apple Pages\" \"BMP - MS Windows\" \"BroadBand eBook\" \"Calc MS Excel 2007 Binary\" \"Calc MS Excel 2007 VBA XML\" : \"ClarisWorks_Draw\" \"ClarisWorks_Impress\" \"Clubs\" : \"Palm_Text_Document\" \"PalmDoc\" \"Pay\" : : \"XHTML Draw File\" \"XHTML Impress File\" \"XHTML Writer File\" \"XPM\" In the above list, I've included the lines that include the \"Pay\" and \"Clubs\" filter names. The names are obtained by Info.getFilterNames(), which utilizes the FilterFactory service: // in the Info class public static String [] getFilterNames () { XNameAccess na = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.document.FilterFactory\" ); if ( na == null ) { System . out . println ( \"No Filter factory found\" ); return null ; } else return na . getElementNames (); } // end of getFilterNames() Sometimes it's useful to know more about a filter than just it's name, such as whether it's for importing, exporting, or both. Additional information is available as an array of properties, by calling Info.getFilterProps() with the filter's name: // in the Info class public static PropertyValue [] getFilterProps ( String filterNm ) { XNameAccess na = Lo . createInstanceMCF ( XNameAccess . class , \"com.sun.star.document.FilterFactory\" ); if ( na == null ) { System . out . println ( \"No Filter factory found\" ); return null ; } else { try { return ( PropertyValue [] ) na . getByName ( filterNm ); } catch ( Exception e ) { System . out . println ( \"Could not find filter for \" + filterNm ); return null ; } } } // end of getFilterProps() getFilterProps() is called three times in FiltersInfo.java to retrieve details about the \"AbiWord\", \"Pay\", and \"Clubs\" filters. The output for \"Clubs\" is: Properties for \"Clubs Filter\": UserData: [com.sun.star.documentconversion.XSLTFilter, false, com.sun.star.comp.Writer.XMLOasisImporter, com.sun.star.comp.Writer.XMLOasisExporter, file:///C:/Users/Dell/Desktop/LibreOffice%20Tests/Filter%20Tests/club sImport.xsl, file:///C:/Users/Dell/Desktop/LibreOffice%20Tests/Filter%20Tests/club sExport.xsl, , ] TemplateName: file:///C:/Users/Dell/AppData/Roaming/LibreOffice/4/user/template/Clu bs/clubsTemplate.ott Name: Clubs Type: Clubs UIComponent: FileFormatVersion: 0 FilterService: com.sun.star.comp.Writer.XmlFilterAdaptor DocumentService: com.sun.star.text.TextDocument Flags: 524355 UINames: [ en-US = XML Clubs ] UIName: XML Clubs Finalized: false Mandatory: false The UserData and TemplateName properties indicate that \"Clubs\" contains an import and export filter for Writer's Flat XML, and also a template. Filter properties are explained in the online documentation for the FilterFactory service (use lodoc FilterFactory to access it), and also in the \"Properties of a Filter\" subsection of the \"Integrating Import and Export Filters\" section of chapter 6 of the Developer's Guide (online at: https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Properties_of_a_Filter/ , or use loGuide \"Properties of a Filter\" ). The most cryptic of the properties is the filter flags integer (524355 in the example above). It's actually a collection of bitwise OR'ed hexadecimals, and FiltersInfo.java shows how they can be accessed: // part of FiltersInfo.java... int flags = ( int ) Props . getValue ( \"Flags\" , props ); System . out . println ( \"Filter flags: \" + Integer . toHexString ( flags )); // print as a hexadecimal string System . out . println ( \" Import: \" + Info . isImport ( flags )); System . out . println ( \" Export: \" + Info . isExport ( flags )); The output is: Filter flags: 80043 Import: true Export: true The hexadecimals that might appear in the flag are listed in the online \"Properties of a Filter\" subsection ( https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Properties_of_a_Filter/ ). I've included a few isXXX() methods in the Info utilities class for testing for their presence. The above example reports that the \"Clubs\" filter contains both an import and export filter.","title":"1.3.  Finding a Filter Name"},{"location":"50-Importing_XML.html#2-using-filters-with-java","text":"Java contains an assortment of XML processing capabilities, grouped under the JAXP (Java API for XML Processing) heading. They include DOM and SAX parsing, XML schema validation, and XSLT transformation. The JDK's XSLT processor is Xalan ( https://xml.apache.org/xalan-j/ ), which supports XSLT 1.0, and so is roughly equivalent to Office's libxslt library. This means that I can use the \"Pay\" and \"Clubs\" filters outside of Office by passing them to Java's Xalan processor. There's a lot of information about JAXP online, including in Oracle's tutorial at https://docs.oracle.com/javase/tutorial/jaxp/ . Also \"XSLT 2.0 and XPath 2.0 Programmer's Reference\" by Michael Kay, which I mentioned earlier, includes an appendix on JAXP.","title":"2.  Using Filters with Java"},{"location":"50-Importing_XML.html#21-importing-xml-with-java","text":"My ApplyInFilter.java example converts an XML file into an Office document in two steps. First it uses an XSLT import filter to generate Flat XML which it saves to a temporary file. The program then loads that file into Office with one of its Flat XML filters. The correct one is chosen by looking at the filename extension supplied for the final document. For example: run ApplyInFilter pay.xml payImport.xsl payment.ods pay.xml is transformed into Flat XML with payImport.xsl. Office isn't used since Java's XSLT processor is sufficient. However, at the next step the temporary file is loaded using Office's \"Flat XML for Spreadsheets\" filter. This filter is selected by noting the \"ods\" extension of payment.ods. Another example: run ApplyInFilter clubs.xml clubsImport.xsl clubs.odt This converts clubs.xml into a Writer document stored in clubs.odt using the \"Clubs\" import filter. ApplyInFilter.java doesn't support templates, so the data saved to clubs.odt isn't nicely formatted like Figure 10. The ApplyInFilter program: public class ApplyInFilter { public static void main ( String [] args ) { if ( args . length != 3 ) { System . out . println ( \"Usage: java ApplyInFilter <XML fnm> <Flat XML import filter> <new ODF>\" ); return ; } // convert the data to Flat XML String xmlStr = XML . applyXSLT ( args [ 0 ] , args [ 1 ] ); if ( xmlStr == null ) { System . out . println ( \"Filtering failed\" ); return ; } // save flat XML data in a temp file String flatFnm = FileIO . createTempFile ( \"xml\" ); FileIO . saveString ( flatFnm , xmlStr ); XComponentLoader loader = Lo . loadOffice (); // get the type of the output file String odfFnm = args [ 2 ] ; String docType = Lo . ext2DocType ( Info . getExt ( odfFnm )); System . out . println ( \"Doc type: \" + docType ); // open temp file using the correct Flat XML filter XComponent doc = Lo . openFlatDoc ( flatFnm , docType , loader ); if ( doc == null ) System . out . println ( \"Document creation failed\" ); else { GUI . setVisible ( doc , true ); Lo . waitEnter (); Lo . saveDoc ( doc , odfFnm ); Lo . closeDoc ( doc ); } Lo . closeOffice (); } // end of main() } // end of ApplyInFilter class Java ' s XSLT processor is called by XML . applyXSLT (): // in the XML class public static String applyXSLT ( String xmlFnm , String xslFnm ) { try { TransformerFactory tf = TransformerFactory . newInstance (); Source xslt = new StreamSource ( new File ( xslFnm )); Transformer t = tf . newTransformer ( xslt ); System . out . println ( \"Applying filter \" + xslFnm + \" to \" + xmlFnm ); Source text = new StreamSource ( new File ( xmlFnm )); StreamResult result = new StreamResult ( new StringWriter ()); t . transform ( text , result ); return result . getWriter (). toString (); } catch ( Exception e ) { System . out . println ( \"Unable to transform \" + xmlFnm + \" with \" + xslFnm ); System . out . println ( \" \" + e ); return null ; } } // end of applyXSLT() The resulting Flat XML is saved to a temporary file by ApplyInFilter.java, and then the document type of the output file is obtained: // part of ApplyInFilter.java... String docType = Lo . ext2DocType ( Info . getExt ( odfFnm )); The docType string is \"scalc\" when the ODT file is payment.ods, and \"swriter\" for clubs.odt. Lo.openFlatDoc() uses the document type to select the correct Flat XML filter, and passes it to Lo.openDoc() as the \"FilterName\" property: // in the Lo class public static XComponent openFlatDoc ( String fnm , String docType , XComponentLoader loader ) { String nm = XML . getFlatFilterName ( docType ); return openDoc ( fnm , loader , Props . makeProps ( \"FilterName\" , nm )); } XML.getFlatFilterName() maps a document type to an appropriate Flat XML filter name: // in the XML class public static String getFlatFilterName ( String docType ) { if ( docType == Lo . WRITER_STR ) return \"OpenDocument Text Flat XML\" ; else if ( docType == Lo . CALC_STR ) return \"OpenDocument Spreadsheet Flat XML\" ; else if ( docType == Lo . DRAW_STR ) return \"OpenDocument Drawing Flat XML\" ; else if ( docType == Lo . IMPRESS_STR ) return \"OpenDocument Presentation Flat XML\" ; else { System . out . println ( \"No Flat XML filter for this document type; using Flat text\" ); return \"OpenDocument Text Flat XML\" ; } } // end of getFlatFilterName()","title":"2.1.  Importing XML with Java"},{"location":"50-Importing_XML.html#22-exporting-xml-with-java","text":"My ApplyOutFilter.java example saves the specified document in Flat XML form to a temporary file. Then it applies an XSLT output filter to transform it into simple XML, which is saved in a new file. For example: run ApplyOutFilter payment.ods payExport.xsl payEx.xml payment.ods contains the spreadsheet shown in Figure 6, and the transformation fills payEx.xml with text almost identical to that on the first page of the chapter. Another example: run ApplyOutFilter clubs.odt clubsExport.xsl clubsEx.xml clubs.odt must contain data formatted by the clubs template (i.e. like the example in Figure 10). This is necessary because clubsExport.xsl utilizes paragraph styles to decide how to change the text. I had to slightly modify the style names used in Eisenberg's export filter. He utilized names containing spaces (e.g. \"Club Name\", \"Club Code\", \"Age Groups\", and \"Club Info\"), but Office automatically changes spaces inside names to \" 20 \". So I had to change the XSLT rules to refer to these names (i.e. \"Club_20_Name\", \"Club_20_Code\", \"Age_20_Groups\", and \"Club_20_Info\"). The ApplyOutFilter program : public class ApplyOutFilter { public static void main ( String [] args ) { if ( args . length != 3 ) { System . out . println ( \"Usage: java ApplyOutFilter <XML file> <Flat XML export filter> <new XML file>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open document: \" + args [ 0 ] ); Lo . closeOffice (); return ; } // save flat XML data String flatFnm = FileIO . createTempFile ( \"xml\" ); Lo . saveDoc ( doc , flatFnm ); Lo . closeDoc ( doc ); // use XSLT to convert Flat XML into simple XML String filteredXML = XML . applyXSLT ( flatFnm , args [ 1 ] ); if ( filteredXML == null ) System . out . println ( \"Filtering failed\" ); else { // indent, print, and save String xmlStr = XML . indent2Str ( filteredXML ); System . out . println ( xmlStr ); FileIO . saveString ( args [ 2 ] , xmlStr ); } Lo . closeOffice (); } // end of main() } // end of ApplyOutFilter class At the end of ApplyOutFilter.java, the XML text in xmlStr is indented and printed. The indention is carried out by XML.indent2Str() which calls XML.applyXSLT2str() with an indenting transformation loaded from indent.xsl: // in the XML class // global private static final String INDENT_FNM = \"indent.xsl\" ; // for indenting XML tags, and adding newlines between tags public static String indent2Str ( String xmlStr ) { return applyXSLT2str ( xmlStr , FileIO . getUtilsFolder () + INDENT_FNM ); } applyXSLT2str() is a variant of XML.applyXSLT() which reads XML from a string rather than a file.","title":"2.2.  Exporting XML with Java"},{"location":"50-Importing_XML.html#3-alternatives-to-xslt-filters","text":"The obvious drawback of the XSLT filter approach is that filter writing requires the programmer to be knowledgable about XSLT, XPath, and the details of the Flat XML format. Another way to write import and export filter is to utilize the ImportFilter and ExportFilter services in the com.sun.star.document module, which are shown in Figure 11. Figure 11. The ImportFilter and ExportFilter Services. These services allow the implementation of non-XML based transformations by utilizing the ImportFilter and ExportFilter services rather than their XMLImportFilter and XMLExportFilter subclasses. The subclasses employ SAX, an event-driven way of parsing XML. If you're interested in using ImportFilter and ExportFilter, the Developer's guide gives some details in the \"Integrating Import and Export Filters\" section of chapter 6 on \"Office Development\". The information is also online, starting at https://wiki.openoffice.org/wiki/Documentation/DevGuide/OfficeDev/Integrating_Import_and_Export_Filters/ , or use loGuide \"Import and Export Filters\" . But I'm not going to use these services due to their complexity, and I'm about to stop using XSLT as well. Instead I'm going to look at three easier ways to import XML into Office: Data extraction by DOM parsing; Node and attribute data extraction as labeled strings; JAXB conversion of XML to Java objects. The drawback of these simpler approaches is that the imported data will usually need some post-processing to make it look as good as import filter results.","title":"3.  Alternatives to XSLT Filters"},{"location":"50-Importing_XML.html#31-data-extraction-by-dom-parsing","text":"Document Object Model (DOM) parsing converts an XML document into a tree of nodes; the three main types are: Elements; Attributes; The data/values held by the elements and attributes. The DOM API is quite low-level, supporting functions such as getFirstChild() and getNextSibling() in Java's Node class. This motivated the introduction of XPath, and other tree models such as JDOM. Fortunately, I won't be needing those more advanced features. Nodes are found by searching for their name. When a possible match is discovered, the node's children usually need to be examined to determine the node type. For instance, node data has the type Node.TEXT_NODE, while an attribute has the type Node.ATTRIBUTE. There are many online tutorials on Java and DOM, such as Oracle's at https://docs.oracle.com/javase/tutorial/jaxp/dom/ . Two other good ones are mkyong's starting at https://mkyong.com/tutorials/java-xml-tutorials/ and \"Easy DOM Parsing in Java\" by Eric Bruno at https://drdobbs.com/jvm/easy-dom-parsing-in-java/231002580/ . I've 'borrowed' some of Bruno's DOM functions for my XML.java support class, and his company.xml example. A textbook on Java and XML: Pro XML Development with Java Technology Ajay and Deepak Vohra Apress, 2006 The company.xml file contains details about three companies: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <Companies> <Company> <Name>ABC</Name> <Executive type=\"CEO\"> <LastName>Smith</LastName> <FirstName>Jim</FirstName> <street>123 Broad Street</street> <city>Manchester</city> <state>Cheshire</state> <zip>11234</zip> </Executive> </Company> <Company> <Name>NBC</Name> <Executive type=\"President\"> <LastName>Jones</LastName> <FirstName>Lucy</FirstName> <street>23 Bradford St</street> <city>Asbury</city> <state>Lincs</state> <zip>33451</zip> </Executive> </Company> <Company> <Name>BBC</Name> <Executive type=\"Boss\"> <LastName>Singh</LastName> <FirstName>Oxley</FirstName> <street>16d Towers</street> <city>Wimbledon</city> <state>London</state> <zip>77392</zip> </Executive> </Company> </Companies> When writing DOM code, it helps to visualize its structure. One way is to load the file into the editor at https://xmlgrid.net/ , which displays the tree-like structure in Figure 12. Figure 12. The Tree Structure of company.xml. Clicking on the arrow heads expand or contract the tree view. My ExamineCompany.java example loads this data as a DOM tree, and extracts various information: // in ExamineCompany.java public class ExamineCompany { public static void main ( String [] args ) throws Exception { Document doc = XML . loadDoc ( \"company.xml\" ); NodeList root = doc . getChildNodes (); // get the document's root // move down the tree to the executive in the first company node Node comps = XML . getNode ( \"Companies\" , root ); Node comp = XML . getNode ( \"Company\" , comps . getChildNodes ()); Node exec = XML . getNode ( \"Executive\" , comp . getChildNodes ()); // print the executive's data String execType = XML . getNodeAttr ( \"type\" , exec ); NodeList exNodes = exec . getChildNodes (); String lastName = XML . getNodeValue ( \"LastName\" , exNodes ); String firstName = XML . getNodeValue ( \"FirstName\" , exNodes ); String street = XML . getNodeValue ( \"street\" , exNodes ); String city = XML . getNodeValue ( \"city\" , exNodes ); String state = XML . getNodeValue ( \"state\" , exNodes ); String zip = XML . getNodeValue ( \"zip\" , exNodes ); System . out . println ( execType ); System . out . println ( lastName + \", \" + firstName ); System . out . println ( street ); System . out . println ( city + \", \" + state + \" \" + zip ); // get all the data in the tree for a given node/tag name NodeList lnNodes = doc . getElementsByTagName ( \"LastName\" ); ArrayList < String > lastnames = XML . getNodeValues ( lnNodes ); System . out . println ( \"All lastnames:\" ); for ( String lastname : lastnames ) System . out . println ( \" \" + lastname ); } // end of main() } // end of ExamineCompany class The program outputs details about the first company, and the lastnames of all the company bosses: CEO Smith, Jim 123 Broad Street Manchester, Cheshire 11234 All lastnames: Smith Jones Singh XML.getNode() searches through a list of nodes, and returns the first with the specified tag name: // in the XML class public static Node getNode ( String tagName , NodeList nodes ) { for ( int i = 0 ; i < nodes . getLength (); i ++ ) { Node node = nodes . item ( i ); if ( node . getNodeName (). equalsIgnoreCase ( tagName )) return node ; } return null ; } // end of getNode() XML.getNodeValue() looks for a node in a list based on its tag name, and extracts the data stored beneath that node. // in the XML class public static String getNodeValue ( String tagName , NodeList nodes ) { if ( nodes == null ) return \"\" ; for ( int i = 0 ; i < nodes . getLength (); i ++ ) { Node n = nodes . item ( i ); if ( n . getNodeName (). equalsIgnoreCase ( tagName )) return getNodeValue ( n ); } return \"\" ; } // end of getNodeValue() The second version of XML.getNodeValue() retrieves the text from a node's TEXT_NODE child (if there is one): // in the XML class public static String getNodeValue ( Node node ) { if ( node == null ) return \"\" ; NodeList childNodes = node . getChildNodes (); for ( int i = 0 ; i < childNodes . getLength (); i ++ ) { Node n = childNodes . item ( i ); if ( n . getNodeType () == Node . TEXT_NODE ) return n . getNodeValue (). trim (); } return \"\" ; } // end of getNodeValue() XML.getNodeValues() constructs a list of the data stored in all the supplied nodes: // in the XML class public static ArrayList < String > getNodeValues ( NodeList nodes ) { if ( nodes == null ) return null ; ArrayList < String > vals = new ArrayList < String > (); for ( int i = 0 ; i < nodes . getLength (); i ++ ) { String val = getNodeValue ( nodes . item ( i )); if ( val != null ) vals . add ( val ); } return vals ; } // end of getNodeValues() XML.getNodeAttr() extracts data from a node's attribute: // in the XML class public static String getNodeAttr ( String attrName , Node node ) { if ( node == null ) return \"\" ; NamedNodeMap attrs = node . getAttributes (); if ( attrs == null ) return \"\" ; for ( int i = 0 ; i < attrs . getLength (); i ++ ) { Node attr = attrs . item ( i ); if ( attr . getNodeName (). equalsIgnoreCase ( attrName )) return attr . getNodeValue (). trim (); } return \"\" ; } // end of getNodeAttr() Converting XML to Spreadsheet Data It's fairly easy to map XML data into a spreadsheet format of rows and columns. Consider pay.xml from earlier: <?xml version=\"1.0\"?> <payments> <payment> <purpose>CD</purpose> <amount>12.95</amount> <tax>19.1234</tax> <maturity>2008-03-01</maturity> </payment> <payment> <purpose>DVD</purpose> <amount>19.95</amount> <tax>19.4321</tax> <maturity>2008-03-02</maturity> </payment> <payment> <purpose>Clothes</purpose> <amount>99.95</amount> <tax>18.5678</tax> <maturity>2008-03-03</maturity> </payment> <payment> <purpose>Book</purpose> <amount>9.49</amount> <tax>18.9876</tax> <maturity>2008-03-04</maturity> </payment> </payments> It can be viewed as a sequence of payment objects, each containing four fields (purpose, amount, tax, and maturity). Each payment object can be mapped to a spreadsheet row, and its fields to four columns in that row. This format can be represented by a 2D array, which is easily constructed using the DOM API. My CreatePay.java example utilizes XML.getAllNodeValues() to build a 2D array from the pay.xml data, and calls Calc.setArray() to add the data to a new Calc document: // in CreatePay.java public class CreatePay { public static void main ( String args [] ) { Document xdoc = XML . loadDoc ( \"pay.xml\" ); NodeList pays = xdoc . getElementsByTagName ( \"payment\" ); if ( pays == null ) return ; Object [][] data = XML . getAllNodeValues ( pays , new String [] { \"purpose\" , \"amount\" , \"tax\" , \"maturity\" }); Lo . printTable ( \"payments\" , data ); XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . setArray ( sheet , \"A1\" , data ); // Lo.saveDoc(doc, \"payCreated.ods\"); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of CreatePay class The list of payment nodes is obtained using: // part of CreatePay.java... NodeList pays = xdoc . getElementsByTagName ( \"payment\" ); The 2D array of payment data is constructed by : // part of CreatePay.java... Object [][] data = XML . getAllNodeValues ( pays , new String [] { \"purpose\" , \"amount\" , \"tax\" , \"maturity\" }); The first argument of getAllNodeValues() is the list of nodes to be scanned, and the second parameter is an array of tag names. The named nodes are assumed to be children of each node in the list, and their data becomes one row in the 2D array. The method's code: // in the XML class public static Object [][] getAllNodeValues ( NodeList rowNodes , String [] colIDs ) { int numRows = rowNodes . getLength (); int numCols = colIDs . length ; Object [][] data = new Object [ numRows + 1 ][ numCols ] ; // put column names in first row of array for ( int col = 0 ; col < numCols ; col ++ ) data [ 0 ][ col ] = Lo . capitalize ( colIDs [ col ] ); for ( int i = 0 ; i < numRows ; i ++ ) { // extract column data for ith row NodeList colNodes = rowNodes . item ( i ). getChildNodes (); for ( int col = 0 ; col < numCols ; col ++ ) data [ i + 1 ][ col ] = getNodeValue ( colIDs [ col ] , colNodes ); } return data ; } // end of getAllNodeValues() XML.getAllNodeValues() also adds a header row to the array made up of the tag names. The resulting table is printing by Lo.printTables(): -- payments ---------------- Purpose Amount Tax Maturity CD 12.95 19.1234 2008-03-01 DVD 19.95 19.4321 2008-03-02 Clothes 99.95 18.5678 2008-03-03 Book 9.49 18.9876 2008-03-04 ----------------------------- Calc.setArray() adds the table to the spreadsheet, which ends up like Figure 13. Figure 13. The Spreadsheet Generated by CreatePay.java. XML.getAllNodeValues() doesn't always produce such good results, as illustrated by the CreateAssoc.java example which converts part of clubs.xml into a spreadsheet. As explained earlier, clubs.xml consists of a sequence of associations, with each one made up of a sequence of clubs. The most natural spreadsheet mapping would be to assign each association to its own sheet, and convert each club into a row on that sheet. A club consists of seven elements and two attributes, as seen in the following example: <club id=\"Q21\" charter=\"2002\"> <name>Castro Valley Wrestling Club</name> <contact>Ron Maes</contact> <location>Castro Valley</location> <phone>510-555-1491</phone> <email>cvwcron@example.com</email> <age-groups type=\"KCJOW\"/> <info>Practices every Tuesday and Thursday at 5:00 P.M. at Castro Valley High School mat room.</info> </club> Probably the best spreadsheet representation would be to use nine columns, so the attributes could be listed. This approach is employed by the xmlgrid.net website as shown in Figure 14. Figure 14. Part of the Clubs Information. Unfortunately, XML.getAllNodeValues() as currently coded doesn't extract attribute information, so the id and charter data will be missed. The CreateAssoc.java example loads clubs.xml, and selects the first association. Its list of clubs is passed to XML.getAllNodeValues() for conversion into an array. The complete program is: // in CreateAssoc.java public class CreateAssoc { public static void main ( String args [] ) { Document xdoc = XML . loadDoc ( \"clubs.xml\" ); NodeList root = xdoc . getChildNodes (); // get the first association Node cdb = XML . getNode ( \"club-database\" , root ); Node assoc1 = XML . getNode ( \"association\" , cdb . getChildNodes ()); NodeList clubs = assoc1 . getChildNodes (); // convert clubs information into an array Object [][] data = XML . getAllNodeValues ( clubs , new String [] { \"name\" , \"contact\" , \"location\" , \"phone\" , \"email\" }); Lo . printTable ( \"clubs\" , data ); XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . setArray ( sheet , \"A1\" , data ); // Lo.saveDoc(doc, \"clubsCreated.ods\"); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of CreateAssoc class XML.getAllNodeValues() only requests data for five of the seven elements (\"name\", \"contact\", \"location\", \"phone\", \"email\") to reduce the information returned. The resulting spreadsheet is shown in Figure 15. Figure 15. Part of the Spreadsheet Generated by CreateAssoc.java. An obvious issue is the empty rows between the clubs data, caused by the simple XML.getAllNodeValues() implementation. It assumes that every node supplies one row of data because of its data element child. Howevere, each club also contains attributes which adds an extra empty row to the output.","title":"3.1.  Data Extraction by DOM Parsing"},{"location":"50-Importing_XML.html#32-node-and-attribute-data-extraction-as-labeled-strings","text":"Not all XML data can be so easily mapped to a 2D format, especially collections such as weather.xml: <?xml version=\"1.0\" encoding=\"UTF-8\"?><current> <city id=\"1610780\" name=\"Hat Yai\"> <coord lat=\"7.01\" lon=\"100.48\"/> <country>TH</country> <sun rise=\"2017-01-01T23:30:31\" set=\"2017-01-02T11:14:18\"/> </city> <temperature max=\"25\" min=\"25\" unit=\"metric\" value=\"25\"/> <humidity unit=\"%\" value=\"94\"/> <pressure unit=\"hPa\" value=\"1011\"/> <wind> <speed name=\"Gentle Breeze\" value=\"3.6\"/> <gusts/> <direction code=\"NNE\" name=\"North-northeast\" value=\"30\"/> </wind> <clouds name=\"broken clouds\" value=\"75\"/> <visibility value=\"5000\"/> <precipitation mode=\"no\"/> <weather icon=\"10n\" number=\"501\" value=\"moderate rain\"/> <lastupdate value=\"2017-01-02T15:30:00\"/> </current> This data was downloaded from OpenWeatherMap using the API at https://api.openweathermap.org/ . Unlike pay.xml or clubs.xml there's no sequence of objects that would naturally become rows of a spreadsheet. In addition, the data is mostly represented by attributes rather than text nodes. In situations like this, a good general approach is to convert the XML to simpler text, removing XML labels except for the element and attribute names. As a result, my ExtractXMLInfo.java example produces the following output when applied to weather.xml: current city id= \"1610780\" name= \"Hat Yai\" coord lat= \"7.01\" lon= \"100.48\" country: \"TH\" sun rise= \"2017-01-01T23:30:31\" set= \"2017-01-02T11:14:18\" temperature max= \"25\" min= \"25\" unit= \"metric\" value= \"25\" humidity unit= \"%\" value= \"94\" pressure unit= \"hPa\" value= \"1011\" wind speed name= \"Gentle Breeze\" value= \"3.6\" gusts direction code= \"NNE\" name= \"North-northeast\" value= \"30\" clouds name= \"broken clouds\" value= \"75\" visibility value= \"5000\" precipitation mode= \"no\" weather icon= \"10n\" number= \"501\" value= \"moderate rain\" lastupdate value= \"2017-01-02T15:30:00\" Line indentation is retained, and is utilized when the data is loaded into Office. As another example, consider pay.xml which ExtractXMLInfo.java converts into: payments payment purpose: \"CD\" amount: \"12.95\" tax: \"19.1234\" maturity: \"2008-03-01\" payment purpose: \"DVD\" amount: \"19.95\" tax: \"19.4321\" maturity: \"2008-03-02\" payment purpose: \"Clothes\" amount: \"99.95\" tax: \"18.5678\" maturity: \"2008-03-03\" payment purpose: \"Book\" amount: \"9.49\" tax: \"18.9876\" maturity: \"2008-03-04\" The elements and attributes with data are highlighted by adding a \":\" or \"=\" after their names. Also, the data is always doubly quoted. ExtractXMLInfo.java travels over the DOM tree, printing what it finds to a text file: // in ExtractXMLInfo.java public static void main ( String [] args ) throws Exception { if ( args . length != 1 ) { System . out . println ( \"Usage: run ExtractXMLInfo <XML file>\" ); return ; } Document doc = XML . loadDoc ( args [ 0 ] ); if ( doc == null ) return ; String fname = Info . getName ( args [ 0 ] ); String outFnm = fname + \"XML.txt\" ; System . out . println ( \"Writing XML data from \" + args [ 0 ] + \" to \" + outFnm ); PrintWriter pw = new PrintWriter ( new FileWriter ( outFnm )); NodeList root = doc . getChildNodes (); // there may be multiple trees; visit each one for ( int i = 0 ; i < root . getLength (); i ++ ) { visitNode ( pw , root . item ( i ), \"\" ); pw . write ( \"\\n\" ); } pw . close (); } // end of main() visitNode() prints the node's tag, any attribute data, any text child node data, and recursively visits the rest of the node's children: // part of ExtractXMLInfo.java private static void visitNode ( PrintWriter pw , Node node , String ind ) { pw . write ( ind + node . getNodeName ()); visitAttrs ( pw , node ); // examine all the child nodes NodeList nodeList = node . getChildNodes (); for ( int i = 0 ; i < nodeList . getLength (); i ++ ) { Node child = nodeList . item ( i ); if ( child . getNodeType () == Node . TEXT_NODE ) { String trimmedVal = child . getNodeValue (). trim (); if ( trimmedVal . length () == 0 ) pw . write ( \"\\n\" ); else pw . write ( \": \\\"\" + trimmedVal + \"\\\"\" ); // element names with values end with ':' } else if ( child . getNodeType () == Node . ELEMENT_NODE ) visitNode ( pw , child , ind + \" \" ); } } // end of visitNode() visitAttrs() prints attribute names and data: // part of ExtractXMLInfo.java private static void visitAttrs ( PrintWriter pw , Node node ) { NamedNodeMap attrs = node . getAttributes (); if ( attrs != null ) { for ( int i = 0 ; i < attrs . getLength (); i ++ ) { Node attr = attrs . item ( i ); pw . write ( \" \" + attr . getNodeName () + \"= \\\"\" + attr . getNodeValue () + \"\\\"\" ); // attribute names end with '=' } } } // end of visitAttrs() When ExtractXMLInfo.java has finished stripping the XML, the next stage is to call BuildXMLSheet.java to load the text into Office as a Calc sheet. This is done by converting it into a 2D array which is added to the spreadsheet by Calc.setArray(). The main() function of BuildXMLSheet.java calls getData() to create the array: // in BuildXMLSheet.java public static void main ( String [] args ) { if ( args . length != 1 ) { System . out . println ( \"Usage: run BuildXMLSheet <XML textfile>\" ); return ; } Object [][] data = getData ( args [ 0 ] ); Lo . printTable ( args [ 0 ] + \" data\" , data ); XComponentLoader loader = Lo . loadOffice (); XSpreadsheetDocument doc = Calc . createDoc ( loader ); if ( doc == null ) { System . out . println ( \"Document creation failed\" ); Lo . closeOffice (); return ; } GUI . setVisible ( doc , true ); Lo . delay ( 2000 ); XSpreadsheet sheet = Calc . getSheet ( doc , 0 ); Calc . setArray ( sheet , \"A1\" , data ); // Lo.saveDoc(doc, \"createdSS.ods\"); Lo . waitEnter (); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() getData() builds the array in two steps: initially a list of differently sized arrays is created, one for each input line. Then the list is converted into a 2D array where every row has the same length. // part of BuildXMLSheet.java private static Object [][] getData ( String fnm ) { int maxCols = 0 ; // max number of columns across all rows // each input line is stored as an array inside a list ArrayList < Object []> rows = new ArrayList < Object []> (); System . out . println ( \"Reading data from \" + fnm ); try { BufferedReader br = new BufferedReader ( new FileReader ( fnm )); String line ; while (( line = br . readLine ()) != null ) { Object [] toks = splitLine ( line ); // read a line as an array of tokens (strings) if ( toks . length > 0 ) rows . add ( toks ); if ( toks . length > maxCols ) maxCols = toks . length ; } } catch ( IOException e ) { System . out . println ( \"Could not read \" + fnm ); return null ; } // convert list of different length arrays into a // fixed length 2D array Object [][] data = new Object [ rows . size () ][ maxCols ] ; for ( int r = 0 ; r < rows . size (); r ++ ) { Object [] row = rows . get ( r ); for ( int c = 0 ; c < maxCols ; c ++ ) { if ( c >= row . length ) data [ r ][ c ] = \"\" ; // pad out array row with empty strings else data [ r ][ c ] = row [ c ] ; } } return data ; } // end of getData() splitLine () converts an input line into an array of tokens . // part of BuildXMLSheet.java private static String [] splitLine ( String ln ) { ln += \" \" ; // To detect last token when not quoted... boolean inQuote = false ; boolean isIndenting = true ; int numSpaces = 0 ; StringBuilder word = new StringBuilder (); ArrayList < String > toks = new ArrayList < String > (); // used to store tokens for the final array for ( int i = 0 ; i < ln . length (); i ++ ) { char ch = ln . charAt ( i ); if ( ch != ' ' && isIndenting ) isIndenting = false ; if ( ch == ' ' && isIndenting ) { numSpaces ++ ; if ( numSpaces % 2 == 0 ) toks . add ( \"\" ); // convert two space indent into \"\" } else if ( ch == '\\\"' || ch == ' ' && ! inQuote ) { // treat a double quoted string as one token if ( ch == '\\\"' ) inQuote = ! inQuote ; if ( ! inQuote && word . length () > 0 ) { char lastCh = word . charAt ( word . length () - 1 ); if (( lastCh == ':' ) || ( lastCh == '=' )) // strip element and attribute assignment symbols word . deleteCharAt ( word . length () - 1 ); toks . add ( word . toString ()); word . delete ( 0 , word . length ()); } } else word . append ( ch ); } return toks . toArray ( new String [ toks . size () ] ); } // end of splitLine() Every two spaces at the start of a line is stored as an empty string in the row array. These strings will later occupy spreadsheet cells at the start of a row, causing the actual data to be 'indented' to cells further to the right. Special care is taken to treat a doubly quoted string as a single token, and any word ending with ':' or '=' has that character stripped away. These characters signify that the element or attribute name has associated data. Figure 16 shows how the weather data is loaded as a spreadsheet by BuildXMLSheet.java. Figure 16. BuildXMLSheet Applied to Weather Data. Figure 17 shows the results for the payments data. Figure 17. BuildXMLSheet Applied to Payments Data.","title":"3.2.  Node and Attribute Data Extraction as Labeled Strings"},{"location":"50-Importing_XML.html#33-jaxb-conversion-of-xml-to-java-objects","text":"Java Architecture for XML Binding (JAXB) provides methods for unmarshalling (converting) XML documents into Java classes and objects, and for marshalling Java objects back into XML documents. I'm interested in the unmarshalling parts so data can be passed to Office as Java objects rather than as XML. Most of the magic of the XML-to-Java conversion is performed by Java's xjc.exe tool which comes as part of the JDK (you'll find it in %java_home%\\bin on Windows). xjc processes an XML schema (an XSD file) rather than XML since the schema contains information about the XML's underlying structure. The good news is that there are websites, such as freeformatter.com, which can generate XSD from supplied XML ( https://freeformatter.com/xsd-generator.html ). I employed its \"Salami slice\" translator so that the Java code generated later by xjc is a bit simpler to read. freeformatter.com converted pay.xml into the following XSD: <xs:schema attributeFormDefault=\"unqualified\" elementFormDefault=\"qualified\" xmlns:xs=\"https://w3.org/2001/XMLSchema\"> <xs:element name=\"purpose\" type=\"xs:string\"/> <xs:element name=\"amount\" type=\"xs:float\"/> <xs:element name=\"tax\" type=\"xs:float\"/> <xs:element name=\"maturity\" type=\"xs:date\"/> <xs:element name=\"payment\"> <xs:complexType> <xs:sequence> <xs:element ref=\"purpose\"/> <xs:element ref=\"amount\"/> <xs:element ref=\"tax\"/> <xs:element ref=\"maturity\"/> </xs:sequence> </xs:complexType> </xs:element> <xs:element name=\"payments\"> <xs:complexType> <xs:sequence> <xs:element ref=\"payment\" maxOccurs=\"unbounded\" minOccurs=\"0\"/> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> The schema gives the names and types for each field in a payment object, and makes payments a sequence of payment objects. A good tutorial on XSD can be found at w3schools.com: https://w3schools.com/Xml/schema_intro.asp If the resulting schema is stored in pay.xsd, then xjc generates Java classes like so: xjc -p Pay pay.xsd The \u2013p option supplies a package name which causes the potentially numerous classes to be stored in a folder of that name. Details about xjc can be found at https://docs.oracle.com/javase/6/docs/technotes/tools/share/xjc.html , or by calling xjc - help. Three classes are written to the Pay folder: Payments.java, Payment.java, and ObjectFactory.java. The first two are Java version of the XML elements, while ObjectFactory is used to create the Java objects at runtime. Figure 18 shows class diagrams for the code. Figure 18. The Payments Class Diagrams. As you might expect, the XML sequence of Payment objects inside Payments is implemented as a list in Java. The details of the ObjectFactory aren't important, but the get/set methods in the Payments and Payment classes will be useful. My UnmarshallPay.java example shows how to use these classes: // in UnmarshallPay.java import java.io.* ; import java.util.* ; import javax.xml.bind.* ; import Pay.* ; // the package for the Pay classes public class UnmarshallPay { public static void main ( String [] args ) { try { // initialize the Payments objects using pay.xml JAXBContext jaxbContext = JAXBContext . newInstance ( Payments . class ); Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller (); Payments pays = ( Payments ) jaxbUnmarshaller . unmarshal ( new File ( \"pay.xml\" )); List < Payment > payList = pays . getPayment (); // print payment names and amounts System . out . println ( \"Payments\" ); for ( Payment p : payList ) System . out . println ( \" \" + p . getPurpose () + \": \" + p . getAmount ()); } catch ( JAXBException e ) { e . printStackTrace (); } } // end of main() } // end of UnmarshallPay class main() creates an Unmarshaller object for the Payments class, which is initialized with data from pay.xml. It then iterates through the Payment objects and prints their purpose and amount fields. The output is: Payments CD: 12.95 DVD: 19.95 Clothes: 99.95 Book: 9.49 Now that the XML data is available through Java (using various get methods), it is quite easy to extend UnmarshallPay.java to write it into an Office document.","title":"3.3.  JAXB Conversion of XML to Java Objects"},{"location":"50-Importing_XML.html#clubsxml-as-java-code","text":"The JAXB manipulation of clubs.xml follows the same steps as used on pay.xml: Convert clubs.xml to XSD at freeformatter.com using the \"Salami Slice\" mapping. Convert company.xsd into Java classes with xjc: xjc -p Clubs clubs.xsd Compile the Clubs package: javac Clubs/*.java Figure 19 shows the Clubs class diagrams. Figure 19. The Clubs Class Diagrams. The top-level class is ClubDatabase which maintains a list of Association objects. Each Association object holds a list of Club objects. Club contains get/set methods for accessing its fields. My UnmarshallClubs.java example shows how to use these classes: // in UnmarshallClubs.java import java.io.* ; import java.util.* ; import javax.xml.bind.* ; import Clubs.* ; // the package for the Club classes public class UnmarshallClubs { public static void main ( String [] args ) { try { // initialize the Clubs objects using clubs.xml JAXBContext jaxbContext = JAXBContext . newInstance ( ClubDatabase . class ); Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller (); ClubDatabase cd = ( ClubDatabase ) jaxbUnmarshaller . unmarshal ( new File ( \"clubs.xml\" )); List < Association > assocList = cd . getAssociation (); // print club names for all the associations System . out . println ( \"Associations\" ); for ( Association assoc : assocList ) { System . out . println ( \" \" + assoc . getId ()); List < Club > clubs = assoc . getClub (); for ( Club club : clubs ) System . out . println ( \" \" + club . getName ()); } } catch ( JAXBException e ) { e . printStackTrace (); } } // end of main() } // end of UnmarshallClubs class The unmarshalling is similar to before except that the ClubDatabase object is initialized with data from clubs.xml. The code iterates through the clubs in each association, printing their names: Associations BAWA Castro Valley Wrestling Club Coastside Grapplers Dixon Ram Wrestling East Bay Freestylers Fairfield WrestlingClub Godfather Wrestling Club Golden Gate Wrestling Club Mat Club USA Pirate Wrestling Club SF Elite Wrestling Titan Wrestling Club CAGWA Big Bear Grizzlies Wrestling Club California Grapplers Youth Wrestling : : South Coast Wrestling Club West Hills Hawks","title":"clubs.xml as Java Code"},{"location":"50-Importing_XML.html#naming-conflicts","text":"The xjc tool works so well that a deep understanding of JAXB isn't usually needed. The exception is when the XML contains a name conflict, which occurs if two or more attributes have the same name. There's a number of \"value\" name conflicts in weather.xml, which I've highlighted below: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <current> <city id=\"1610780\" name=\"Hat Yai\"> <coord lat=\"7.01\" lon=\"100.48\"/> <country>TH</country> <sun rise=\"2017-01-01T23:30:31\" set=\"2017-01-02T11:14:18\"/> </city> <temperature max=\"25\" min=\"25\" unit=\"metric\" value=\"25\"/> <humidity unit=\"%\" value=\"94\"/> <pressure unit=\"hPa\" value=\"1011\"/> <wind> <speed name=\"Gentle Breeze\" value=\"3.6\"/> <gusts/> <direction code=\"NNE\" name=\"North-northeast\" value=\"30\"/> </wind> <clouds name=\"broken clouds\" value=\"75\"/> <visibility value=\"5000\"/> <precipitation mode=\"no\"/> <weather icon=\"10n\" number=\"501\" value=\"moderate rain\"/> <lastupdate value=\"2017-01-02T15:30:00\"/> </current> The \"value\" attribute is used nine times in different contexts. This doesn't pose a problem for freeformatter.com, which quietly generates weather.xsd. The name conflict is only reported when xjc tries to generate Java classes: > xjc -p Weather weather.xsd parsing a schema... [ERROR] Property \"Value\" is already defined. Use <jaxb:property> to resolve this conflict. : // many more error messages \u2026 As the error message advises, I need to add jaxb:property annotations to the XSD file to allow xjc to correctly translate the attributes. For example, the first offender in weather.xsd is: <xs:attribute type=\"xs:float\" name=\"value\"/> Its jaxb:property annotation is: <xs:attribute type=\"xs:float\" name=\"value\"> <!-- avoid \"value\" name conflict --> <xs:annotation> <xs:appinfo> <jaxb:property name=\"valueAttribute\"/> </xs:appinfo> </xs:annotation> </xs:attribute> This same change is applied to all the other conflicting attribute names. In addition, the new \"jaxb\" label must be linked to its JAXB schema at the start of the XSD file: <!-- in the xs:schema element --> xmlns:jaxb=\"https://java.sun.com/xml/ns/jaxb\" jaxb:version=\"2.1\" If you want to understand what's happening in more detail, the best place to start is the tutorial at Oracle: https://docs.oracle.com/javase/tutorial/jaxb/intro/ . When xjc is passed this modified weather.xsd file, the Java classes are correctly generated. Figure 20 shows only the class names to reduce the diagram's size. Figure 20. The Weather Class Diagrams. The top-level class is Current which stores the weather attributes as objects. My UnmarshallWeather.java example examines weather.xml to report if it was raining on the report day: // in UnmarshallWeather.java public class UnmarshallWeather { public static void main ( String [] args ) { try { JAXBContext jaxbContext = JAXBContext . newInstance ( Current . class ); Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller (); Current currWeather = ( Current ) jaxbUnmarshaller . unmarshal ( new File ( \"weather.xml\" )); // get precipitation as a boolean String rainingStatus = currWeather . getPrecipitation (). getValue (); boolean isRaining = rainingStatus . equals ( \"yes\" ); // get date in day/month/year format XMLGregorianCalendar gCal = currWeather . getLastupdate (). getValueAttribute (); Calendar cal = gCal . toGregorianCalendar (); SimpleDateFormat formatter = new SimpleDateFormat ( \"dd/MM/yyyy\" ); formatter . setTimeZone ( cal . getTimeZone ()); String dateStr = formatter . format ( cal . getTime ()); if ( isRaining ) System . out . println ( \"It was raining on \" + dateStr ); else System . out . println ( \"It was NOT raining on \" + dateStr ); } catch ( JAXBException e ) { e . printStackTrace (); } } // end of main() } // end of UnmarshallWeather class The output is: It was NOT raining on 02/01/2017","title":"Naming Conflicts"},{"location":"51-Simple_ODF.html","text":"Chapter 51. Simple ODF \u00b6 Topics The OpenDocument Format; Doc Information; Unzipping an ODF Doc; the Simple Java API for ODF (Apache ODF Toolkit): making docs (text, sheet, and slides), slide movement, doc concatenation (text, sheet, and slides) Example folders: \"ODFToolkit Tests\" and \"Utils\" An OpenDocument Format (ODF) document is a zipped folder containing an assortment of XML files, images, and other resources. This makes it possible to manipulate using zip/unzip and XML features, but that isn't a good idea due to the complexity of the formats. This chapter looks at a few of these lower-level techniques, but is mainly about the Simple API for ODF, a sub-project of the Apache ODF Toolkit ( https://incubator.apache.org/odftoolkit/simple/ ). It's a small Java API for creating, modifying and extracting data from ODF documents, built on top of the ODFDOM library ( https://incubator.apache.org/odftoolkit/odfdom/ ). Rather surprisingly, its support for the concatenation of documents is better than that in the Office API. 1. The OpenDocument Format \u00b6 The contents of an ODF document (i.e. the zipped folder) depend on its type (e.g. does it contain a spreadsheet, presentation, or text?), but several files always appear inside the folder: content.xml: the document's textual contents, but not binary data such as images; meta.xml: the document's meta information, such as the author's name and the last modification date. The data is most easily viewed through Office's File > Properties menu item; styles.xml: the styles used for the document's pages, paragraphs, text formats, and others, which are usually set via the Styles and Formatting dialogs in Office; settings.xml: information specific to the application and document's display, such as the window's size/position, printer settings, and whether headers and footers are visible; manifest.xml: this lists the content of the zipped folder, and is stored in the META-INF/ subdirectory; mimetype: a one-line file listing the document's MIME-type. The easiest way of viewing these files and folders is to unzip the ODF file using a utility such as 7-Zip, as in Figure 1. Figure 1. An Unzipped View of algs.odp. Figure 1's Configurations2/ folder stores localization information for the Office GUI; Pictures/ stores the images used in the document; Thumbnails/ holds a small 128x128 picture of the document in thumbnail.png. The wikipedia page about ODF is quite informative ( https://en.wikipedia.org/wiki/OpenDocument/ ), as is its entry for the OpenDocument technical specification ( https://en.wikipedia.org/wiki/OpenDocument_technical_specification/ ). There's a quick summary of the OpenDocument Format (ODF) at https://help.libreoffice.org/Common/XML_File_Formats/ . The ODF standard was developed by the Organization for the Advancement of Structured Information Standards (OASIS) consortium ( https://oasis-open.org/ ), whose website hosts a lot of information. A related community site is https://opendocument.xml.org/ The most complete textbook on ODF is: OASIS OpenDocument Essentials J. David Eisenberg, 2005 https://books.evc-cit.info/ The associated website has a free draft of the book, and all the examples and support code. The site often seems to be offline, but the book can be found at other locations. A recent version can be purchased at Lulu: https://lulu.com/shop/j-david-eisenberg/oasis-opendocument-essentials/paperback/product-392512.html 2. Document Information \u00b6 There's little need to directly manipulate a document's XML files since the Office API offers high-level techniques for accessing most of their information. For example, part of meta.xml for algs.odp is: <office:meta> <dc:title>PowerPoint Presentation</dc:title> <dc:date>2017-01-06T16:53:58.639000000</dc:date> <meta:editing-cycles>4</meta:editing-cycles> <meta:editing-duration>PT1M52S</meta:editing-duration> <meta:generator>LibreOffice/5.1.0.3$ Windows_x86LibreOffice_project/ 5e3e00a007d9b3b6efb6797a8b8e57b51ab1f737</meta:generator> <meta:document-statistic meta:object-count=\"92\"/> <meta:user-defined meta:name=\"Secret\">Made in Thailand</meta:user-defined> </office:meta> This data is displayed in the General tab of the File, Properties window in Figure 2. Figure 2. File, Properties Window. Rather than attempting to extract and parse meta.xml, this information is reachable through the XDocumentProperties interface which I described back in Chapter 3, section 2. The following DocInfo.java example uses Info.printDocProperties() to print document details: // in DocInfo.java public class DocInfo { public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run DocInfo <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } System . out . println (); Props . showObjProps ( \"Document\" , doc ); Info . printDocProperties ( doc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of DocInfo class When DocInfo is passed algs.odp, some of the output is: Document Properties Info Author: Title: PowerPoint Presentation Subject: Description: Generator: LibreOffice/5.1.0.3$Windows_x86 LibreOffice_project/ 5e3e00a007d9b3b6efb6797a8b8e57b51ab1f737 : Modification Date: Jan 06, 2017 16:53 : Secret == Made in Thailand Info.printDocProperties() calls many XDocumentProperties.getXXX() methods to obtain these details: // in the Info class public static void printDocProperties ( Object doc ) { XDocumentPropertiesSupplier docPropsSupp = Lo . qi ( XDocumentPropertiesSupplier . class , doc ); XDocumentProperties dps = docPropsSupp . getDocumentProperties (); printDocProps ( dps ); XPropertyContainer udProps = dps . getUserDefinedProperties (); Props . showObjProps ( \"UserDefined Info\" , udProps ); } // end of printDocProperties() public static void printDocProps ( XDocumentProperties dps ) { System . out . println ( \"Document Properties Info\" ); System . out . println ( \" Author: \" + dps . getAuthor ()); System . out . println ( \" Title: \" + dps . getTitle ()); System . out . println ( \" Subject: \" + dps . getSubject ()); : // many more prints } // end of printDocProps() XDocumentProperties replaces the deprecated XDocumentInfo interface, which has been removed from LibreOffice (although it's still in OpenOffice). The two classes manipulate almost the same information, but the older XDocumentInfo can retrieve the document's MIME-type, which is absent from XDocumentProperties. One way of obtaining this would be to access the mimetype file zipped inside the document, as shown next. 3. Unzipping an ODF Document \u00b6 My DocUnzip.java example shows how it's possible to list the zipped contents of a document, access its MIME-type, and extract a zipped file: // in DocUnzip.java public class DocUnzip { public static void main ( String args [] ) { if (( args . length < 1 ) || ( args . length > 2 )) { System . out . println ( \"Usage: run DocUnzip <fnm> [<ExtractFnm>]\" ); return ; } XComponentLoader loader = Lo . loadOffice (); FileIO . zipList ( args [ 0 ] ); // FileIO.zipListUno(args[0]); // only names listed // get zip access to the document XZipFileAccess zfa = FileIO . zipAccess ( args [ 0 ] ); String mimeType = FileIO . getMimeType ( zfa ); System . out . println ( \"MIME type: \" + mimeType ); System . out . println ( \"Other MIME type approach: \" + Info . getMIMEType ( args [ 0 ] )); // convert MIME-type too other forms int docType = Info . mimeDocType ( mimeType ); System . out . println ( \"Doc Type: \" + docType + \"; \" + Lo . docTypeStr ( docType )); if ( args . length == 2 ) // extract the named file FileIO . unzipFile ( zfa , args [ 1 ] ); Lo . closeOffice (); } // end of main() } // end of DocUnzip class The program can be called like so: run DocUnzip algs.odp content.xml content.xml will be unzipped from algs.odp and saved as contentCopy.xml in the local directory. The rest of the output is: Listing of algs.odp: Raw Size Size Date Time Name -------- ------- ------- ------- -------- 47 47 Jan 6, 2017 9:54:00 AM mimetype 0 0 Jan 6, 2017 9:54:00 AM Configurations2/popupmenu/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/floater/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/images/Bitmaps/ 0 2 Jan 6, 2017 9:54:00 AM Configurations2/accelerator/current.xml 0 0 Jan 6, 2017 9:54:00 AM Configurations2/menubar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/progressbar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/toolbar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/statusbar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/toolpanel/ 83608 6501 Jan 6, 2017 9:54:00 AM styles.xml 4364 4364 Jan 6, 2017 9:54:00 AM Pictures/100000000000004600000035E6F1CB2181A9ACF1.png 16977 16977 Jan 6, 2017 9:54:00 AM Pictures/10000000000003080000002A0A348B9039C3652D.png 20480 20480 Jan 6, 2017 9:54:00 AM Pictures/10000000000001F4000001F4E2E69E1D.jpg 45056 45056 Jan 6, 2017 9:54:00 AM Pictures/10000000000000C8000000EEB0A3D2D2.jpg 8192 8192 Jan 6, 2017 9:54:00 AM Pictures/10000000000000E1000000E1B343DD04.jpg 40960 40960 Jan 6, 2017 9:54:00 AM Pictures/10000000000000E60000015E784CAA37.jpg 69632 69632 Jan 6, 2017 9:54:00 AM Pictures/10000000000000DC000000FF9A43DBBF.jpg 28672 28672 Jan 6, 2017 9:54:00 AM Pictures/100000000000011800000160792BAA16.jpg 12288 12288 Jan 6, 2017 9:54:00 AM Pictures/10000000000000DC0000014B7CFE8C49.jpg 11901 11901 Jan 6, 2017 9:54:00 AM Pictures/10000000000000BC0000010DD7ECB1F7.jpg 18238 18238 Jan 6, 2017 9:54:02 AM Thumbnails/thumbnail.png 86313 8040 Jan 6, 2017 9:54:02 AM content.xml 6037 913 Jan 6, 2017 9:54:02 AM settings.xml 1141 491 Jan 6, 2017 9:54:02 AM meta.xml 2248 452 Jan 6, 2017 9:54:02 AM META-INF/manifest.xml MIME type: application/vnd.oasis.opendocument.presentation Other MIME type approach: application/vnd.oasis.opendocument.presentation Doc Type: 5; simpress Extracting content.xml Saving to contentCopy.xml Most of the output is a detailed listing of the zipped contents of algs.odp. 3.1. Listing the Contents of a Zipped Folder \u00b6 There are two \"zipList\" functions in the FileIO utility class. FileIO.zipListUno() is simpler since only file and folder names are printed: // in the FileIO class public static void zipListUno ( String fnm ) { XZipFileAccess zfa = zipAccess ( fnm ); XNameAccess nmAccess = Lo . qi ( XNameAccess . class , zfa ); String [] names = nmAccess . getElementNames (); System . out . println ( \"\\nZipped Contents of \" + fnm ); Lo . printNames ( names , 1 ); } // end of zipListUno() public static XZipFileAccess zipAccess ( String fnm ) // get zip access to the document using Office API { return Lo . createInstanceMCF ( XZipFileAccess . class , \"com.sun.star.packages.zip.ZipFileAccess\" , new Object [] { fnmToURL ( fnm ) }); } XZipFileAccess is created by instantiating the ZipFileAccess service with the document's filename. The interface is cast to XNameAccess which allows the names of the zipped files to be retrieved as an array of strings. Figure 3 shows the relationships between the service and interfaces. Figure 3. The ZipFileAccess Service. The ZipFileAccess service and interfaces are in the com.sun.star.packages.zip module, which includes a ZipEntry class for holding information about each zipped file (e.g. its compressed size). I was unable to find a way of creating ZipEntry objects, but Java contains a complete zip API. By using Java rather than Office, I was able to implement a more fancy \"zipList\": // in the FileIO class public static void zipList ( String fnm ) // using the Java API { DateFormat df = DateFormat . getDateInstance (); // date format DateFormat tf = DateFormat . getTimeInstance (); // time format tf . setTimeZone ( TimeZone . getDefault () ); try { ZipFile zfile = new ZipFile ( fnm ); System . out . println ( \"Listing of \" + zfile . getName () + \":\" ); System . out . println ( \"Raw Size Size Date Time Name\" ); System . out . println ( \"--- ---- ---- ---- ---- ----\" ); Enumeration <? extends java . util . zip . ZipEntry > zfs = zfile . entries (); while ( zfs . hasMoreElements ()) { java . util . zip . ZipEntry entry = ( java . util . zip . ZipEntry ) zfs . nextElement (); Date d = new Date ( entry . getTime ()); System . out . print ( padSpaces ( entry . getSize (), 9 ) + \" \" ); System . out . print ( padSpaces ( entry . getCompressedSize (), 7 ) + \" \" ); System . out . print ( \" \" + df . format ( d ) + \" \" ); System . out . print ( \" \" + tf . format ( d ) + \" \" ); System . out . println ( \" \" + entry . getName ()); } System . out . println (); } catch ( java . io . IOException e ) { System . out . println ( e ); } } // end of zipList() Another advantage of switching to Java are the large number of online examples of zip manipulation; my zipList() function is closely based on one at https://drdobbs.com/jvm/java-and-the-zip-file-format/184410339/ . 3.2. Extracting a MIME-type \u00b6 FileIO.getMimeType() employs XZipFileAccess.getStreamByPattern() to access the zipped mimetype file as an input stream. // in the FileIO class public static String getMimeType ( XZipFileAccess zfa ) { try { XInputStream inStream = zfa . getStreamByPattern ( \"mimetype\" ); String [] lines = FileIO . readLines ( inStream ); if ( lines != null ) return lines [ 0 ] . trim (); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } System . out . println ( \"No mimetype found\" ); return null ; } // end of getMimeType() There ' s an alternative approach which looks up the file ' s MIME - type using the Java API class MimetypesFileTypeMap : // in the Info class // global private static final String MIME_FNM = \"mime.types\" ; public static String getMIMEType ( String fnm ) { try { MimetypesFileTypeMap mftMap = new MimetypesFileTypeMap ( FileIO . getUtilsFolder () + MIME_FNM ); return mftMap . getContentType ( new File ( fnm )); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not find \" + MIME_FNM ); return \"application/octet-stream\" ; // better than nothing } } // end of getMIMEType() The MimetypesFileTypeMap () constructor examines a list of MIME - types loaded from the utility classes folder . Most of my utility functions use document ' types ' coded as integers rather than as MIME - type strings ; the values are defined at the start of the Lo utility class : // in the Lo class public static final int UNKNOWN = 0 ; public static final int WRITER = 1 ; public static final int BASE = 2 ; public static final int CALC = 3 ; public static final int DRAW = 4 ; public static final int IMPRESS = 5 ; public static final int MATH = 6 ; Info . mimeDocType () maps ODF MIME - type strings to one of these integers : // in the Info class public static int mimeDocType ( String mimeType ) { if ( mimeType == null ) return Lo . UNKNOWN ; if ( mimeType . contains ( \"vnd.oasis.opendocument.text\" )) return Lo . WRITER ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.base\" )) return Lo . BASE ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.spreadsheet\" )) return Lo . CALC ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.graphics\" ) || mimeType . contains ( \"vnd.oasis.opendocument.image\" ) || mimeType . contains ( \"vnd.oasis.opendocument.chart\" )) return Lo . DRAW ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.presentation\" )) return Lo . IMPRESS ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.formula\" )) return Lo . MATH ; else return Lo . UNKNOWN ; } // end of mimeDocType() Some of my functions also utilize short document type strings, which are also defined in the Lo class: // in the Lo class // docType strings public static final String UNKNOWN_STR = \"unknown\" ; public static final String WRITER_STR = \"swriter\" ; public static final String BASE_STR = \"sbase\" ; public static final String CALC_STR = \"scalc\" ; public static final String DRAW_STR = \"sdraw\" ; public static final String IMPRESS_STR = \"simpress\" ; public static final String MATH_STR = \"smath\" ; Lo.docTypeStr() maps document type integers to these strings. 3.3. Extracting a Zipped File \u00b6 The XZipFileAccess.getStreamByPattern() method used in FileIO.getMimeType() is also employed by FileIO.unzipFile() to extract a zipped file: // in FileIO class public static void unzipFile ( XZipFileAccess zfa , String fnm ) { String fileName = Info . getName ( fnm ); String ext = Info . getExt ( fnm ); try { System . out . println ( \"Extracting \" + fnm ); XInputStream inStream = zfa . getStreamByPattern ( \"*\" + fnm ); XSimpleFileAccess3 fileAcc = Lo . createInstanceMCF ( XSimpleFileAccess3 . class , \"com.sun.star.ucb.SimpleFileAccess\" ); String copyFnm = ( ext == null ) ? ( fileName + \"Copy\" ) : ( fileName + \"Copy.\" + ext ); System . out . println ( \"Saving to \" + copyFnm ); fileAcc . writeFile ( FileIO . fnmToURL ( copyFnm ), inStream ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of unzipFile() The XZipFileAccess.getStreamByPattern() call includes the wildcard character \"*\" so the filename will be found even if prefixed by a directory path, as in the case of an ODF document's manifest.xml which is stored in \"META-INF/manifest.xml\". I utilize Office's IO interface, XSimpleFileAccess3, which supports writeFile() to directly connect an XInputStream to a file. The filename of the extracted data is constructed from the zipped filename with the addition of \"Copy\". 4. Higher-level Manipulation of ODF \u00b6 Manipulating an ODF document as zipped files and XML is a recipe for highly complex (and probably bug-ridden) code. And why bother when the Office API offers all the necessary functionality in a higher-level framework? \"Maslow's hammer\" maxim comes to mind; it states: \"if all you have is a hammer, then everything looks like a nail\". In other words, it's useful to know about ODF APIs other than Office's since they might offer better, easier ways of doing some tasks. As a consequence, I'm going to spend the rest of the chapter looking at the Simple Java API for ODF, a sub-project of Apache ODF Toolkit ( https://incubator.apache.org/odftoolkit/simple/ ). It's a relatively small Java API for creating, modifying and extracting data from ODF documents, built on top of the ODFDOM library ( https://incubator.apache.org/odftoolkit/odfdom/ ). Its best features are the cookbook pages at https://incubator.apache.org/odftoolkit/simple/document/cookbook/ , the Getting Started Guide ( https://incubator.apache.org/odftoolkit/simple/gettingstartguide.html ), and its demo pages ( https://incubator.apache.org/odftoolkit/simple/demo/ ). The cookbook contains examples for manipulating text documents, presentations, tables in text documents and spreadsheets, charts, style handling, text navigation, text extraction, text fields, text forms, and document metadata. The API documentation is at https://incubator.apache.org/odftoolkit/mvn-site/0.8-incubating/simple-odf/apidocs/ , and a mail archive at https://mail-archives.apache.org/mod_mbox/incubator-odf-users/ By far the worst feature of the API is the large number of libraries that must be installed before even a lowly \"Hello World\" example will work. Fortunately, I've included copies of those libraries at this chapter's website at https://fivedots.coe.psu.ac.th/~ad/jlop/ . The Simple API doesn't have the depth of features of Office, so it's best suited for the creation of simple text documents, spreadsheets, and presentations. However, it has better support for combining documents (e.g. concatenating two slide decks into a single one), and can move/copy slides in a presentation much more easily than Office; look back at Chapter 17, sections 4 and 5 for my complaints about that. 4.1. Building Simple Documents \u00b6 This subsection looks at how the Simple API can be used to create text, spreadsheet, and slide documents. Make a Text Document My MakeTextDoc.java example creates a text document containing an image, some text, a list, and a table.; the result is shown in Figure 4. Figure 4. The Output of MakeTextDoc.java. This isn't quite what the output looks like in the \"Getting Started Guide\", where the program is called HelloWorld.java \u2013 in the guide the first paragraph is beneath the image rather than to one side. The MakeTextDoc.java code: public class MakeTextDoc { public static void main ( String [] args ) { try { TextDocument doc = TextDocument . newTextDocument (); doc . newImage ( new URI ( \"odf-logo.png\" )); // add paragraphs and list doc . addParagraph ( \"Hello World, Hello Simple ODF!\" ); doc . addParagraph ( \"The following is a list.\" ); List list = doc . addList (); String [] items = { \"item1\" , \"item2\" , \"item3\" }; list . addItems ( items ); // add table Table table = doc . addTable ( 2 , 2 ); Cell cell = table . getCellByPosition ( 0 , 0 ); cell . setStringValue ( \"Hello World!\" ); System . out . println ( \"Creating MakeTextDoc.odt\" ); doc . save ( \"MakeTextDoc.odt\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MakeTextDoc class I was unable to find a way of changing the image's text wrap property to affect the paragraph's position. It's probably do-able using the lower-level ODFDOM library, but the programming information for that part of ODF Toolkit is mostly limited to its API documentation. However, there's a good introductory tutorial at https://langintro.com/odfdom_tutorials/ . Make a Spreadsheet \u00b6 The MakeSheet.java example creates a spreadsheet with a single sheet, and a few cells of data, as in Figure 5. Figure 5. The Output of MakeSheet.java. The program: public class MakeSheet { public static void main ( String [] args ) { try { SpreadsheetDocument doc = SpreadsheetDocument . newSpreadsheetDocument (); Table sheet = doc . getSheetByIndex ( 0 ); sheet . getCellByPosition ( 0 , 0 ). setStringValue ( \"Hello\" ); for ( int row = 0 ; row < 5 ; row ++ ) sheet . getCellByPosition ( 1 , row ). setDoubleValue ( row * 2.0 ); System . out . println ( \"Saving document to makeSheet.ods\" ); doc . save ( \"makeSheet.ods\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MakeSheet class Make a Slide Deck \u00b6 The MakeSlides.java example creates a slide deck. The first slide contains a title, the second some bulleted text and a picture, and the third slide is blank, as in Figure 6. Figure 6. The Output of MakeSlides.java. The program: public class MakeSlides { public static void main ( String [] args ) { try { PresentationDocument doc = PresentationDocument . newPresentationDocument (); // a title slide Slide slide1 = doc . newSlide ( 0 , \"slide1\" , SlideLayout . TITLE_ONLY ); Textbox titleBox = slide1 . getTextboxByUsage ( PresentationClass . TITLE ). get ( 0 ); titleBox . setTextContent ( \"Important Slide Presentation\" ); // a slide with text bullets and a picture Slide slide2 = doc . newSlide ( 1 , \"slide2\" , SlideLayout . TITLE_OUTLINE ); titleBox = slide2 . getTextboxByUsage ( PresentationClass . TITLE ). get ( 0 ); titleBox . setTextContent ( \"Overview\" ); Textbox outline = slide2 . getTextboxByUsage ( PresentationClass . OUTLINE ). get ( 0 ); List txtList = outline . addList (); // two bullets txtList . addItem ( \"Item 1\" ); txtList . addItem ( \"Item 2\" ); Image image = Image . newImage ( slide2 , new URI ( \"skinner.png\" )); FrameRectangle rect = image . getRectangle (); rect . setX ( 8 ); // position the image rect . setY ( 4 ); image . setRectangle ( rect ); System . out . println ( \"Saving document to makeSlides.odp\" ); doc . save ( \"makeSlides.odp\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MakeSlides class Programming with this part of the API is a littlie tricky since slide elements are represented by different types of boxes. I also found it hard to determine the position of the image, except by trial-and-error. 4.2. Moving a Slide \u00b6 Back in Chapter 17, section 4, I had to use copy and paste dispatch commands in the slide-sorter view to rearrange a deck. Moving a slide in the Simple API is much easier, as shown in MoveSlide.java, which moves the first slide of the deck to its end: public class MoveSlide { public static void main ( String [] args ) { try { PresentationDocument doc = PresentationDocument . loadDocument ( \"algs.odp\" ); int numSlides = doc . getSlideCount (); System . out . println ( \"Moving first slide to the end\" ); doc . moveSlide ( 0 , numSlides ); // why not numSlides-1? System . out . println ( \"Saving document to algsMoved.odp\" ); doc . save ( \"algsMoved.odp\" ); doc . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MoveSlide class PresentationDocument.moveSlide() works without a hitch, although I'm confused why I need to supply numSlides as the second numerical argument rather than numSlides-1. There's also a PresentationDocument.copySlide() method for copying. 4.3. Combining Two Documents \u00b6 This subsection presents three short programs that combine two text documents, appends the sheets of two spreadsheets, and concatenates two slide decks. These examples are much simpler to program than equivalent ones using the Office API. Combining Text Documents \u00b6 CombineTexts.java adds the contents of doc2.odt to the end of the contents of doc1.odt, separating them with a page break. The result is saved to combined.odt: public class CombineTexts { public static void main ( String [] args ) { try { TextDocument doc1 = TextDocument . loadDocument ( \"doc1.odt\" ); TextDocument doc2 = TextDocument . loadDocument ( \"doc2.odt\" ); doc1 . addPageBreak (); Paragraph lastPara = doc1 . getParagraphByReverseIndex ( 0 , false ); // insert contents at end and copy styles doc1 . insertContentFromDocumentAfter ( doc2 , lastPara , true ); System . out . println ( \"Saving combination to combined.odt\" ); doc1 . save ( \"combined.odt\" ); doc1 . close (); doc2 . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of CombineTexts class The crucial method is TextDocument.insertContentFromDocumentAfter(). Combining Spreadsheets \u00b6 CombineSheets.java places the sheets in ss2.odt after the sheets in ss1.odt, and saves the result in combined.ods: public class CombineSheets { public static void main ( String [] args ) { try { SpreadsheetDocument doc1 = SpreadsheetDocument . loadDocument ( \"ss1.ods\" ); SpreadsheetDocument doc2 = SpreadsheetDocument . loadDocument ( \"ss2.ods\" ); int numSheets2 = doc2 . getSheetCount (); // add sheets of second document to end of first doc for ( int i = 0 ; i < numSheets2 ; i ++ ) { Table t = doc2 . getSheetByIndex ( i ); doc1 . appendSheet ( t , t . getTableName ()); } System . out . println ( \"Saving combination to combined.ods\" ); doc1 . save ( \"combined.ods\" ); doc1 . close (); doc2 . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of CombineSheets class Sadly there isn't a single method that appends tables. Instead I've used a loop to append each sheet from ss2.ods after the sheets in ss1.ods. Combining Slide Decks \u00b6 CombineDecks.java adds the slides in deck2.odp after the slides in deck1.odp, saving the result in combined.odp: public class CombineDecks { public static void main ( String [] args ) { try { PresentationDocument doc1 = PresentationDocument . loadDocument ( \"deck1.odp\" ); PresentationDocument doc2 = PresentationDocument . loadDocument ( \"deck2.odp\" ); doc1 . appendPresentation ( doc2 ); System . out . println ( \"Saving combination to combined.odp\" ); doc1 . save ( \"combined.odp\" ); doc1 . close (); doc2 . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of CombineDecks class The PresentationDocument.appendPresentation() method does all the work, and should be compared to my hacky Office solution in Chapter 17, section 5.","title":"Chapter 51. Simple ODF"},{"location":"51-Simple_ODF.html#chapter-51-simple-odf","text":"Topics The OpenDocument Format; Doc Information; Unzipping an ODF Doc; the Simple Java API for ODF (Apache ODF Toolkit): making docs (text, sheet, and slides), slide movement, doc concatenation (text, sheet, and slides) Example folders: \"ODFToolkit Tests\" and \"Utils\" An OpenDocument Format (ODF) document is a zipped folder containing an assortment of XML files, images, and other resources. This makes it possible to manipulate using zip/unzip and XML features, but that isn't a good idea due to the complexity of the formats. This chapter looks at a few of these lower-level techniques, but is mainly about the Simple API for ODF, a sub-project of the Apache ODF Toolkit ( https://incubator.apache.org/odftoolkit/simple/ ). It's a small Java API for creating, modifying and extracting data from ODF documents, built on top of the ODFDOM library ( https://incubator.apache.org/odftoolkit/odfdom/ ). Rather surprisingly, its support for the concatenation of documents is better than that in the Office API.","title":"Chapter 51. Simple ODF"},{"location":"51-Simple_ODF.html#1-the-opendocument-format","text":"The contents of an ODF document (i.e. the zipped folder) depend on its type (e.g. does it contain a spreadsheet, presentation, or text?), but several files always appear inside the folder: content.xml: the document's textual contents, but not binary data such as images; meta.xml: the document's meta information, such as the author's name and the last modification date. The data is most easily viewed through Office's File > Properties menu item; styles.xml: the styles used for the document's pages, paragraphs, text formats, and others, which are usually set via the Styles and Formatting dialogs in Office; settings.xml: information specific to the application and document's display, such as the window's size/position, printer settings, and whether headers and footers are visible; manifest.xml: this lists the content of the zipped folder, and is stored in the META-INF/ subdirectory; mimetype: a one-line file listing the document's MIME-type. The easiest way of viewing these files and folders is to unzip the ODF file using a utility such as 7-Zip, as in Figure 1. Figure 1. An Unzipped View of algs.odp. Figure 1's Configurations2/ folder stores localization information for the Office GUI; Pictures/ stores the images used in the document; Thumbnails/ holds a small 128x128 picture of the document in thumbnail.png. The wikipedia page about ODF is quite informative ( https://en.wikipedia.org/wiki/OpenDocument/ ), as is its entry for the OpenDocument technical specification ( https://en.wikipedia.org/wiki/OpenDocument_technical_specification/ ). There's a quick summary of the OpenDocument Format (ODF) at https://help.libreoffice.org/Common/XML_File_Formats/ . The ODF standard was developed by the Organization for the Advancement of Structured Information Standards (OASIS) consortium ( https://oasis-open.org/ ), whose website hosts a lot of information. A related community site is https://opendocument.xml.org/ The most complete textbook on ODF is: OASIS OpenDocument Essentials J. David Eisenberg, 2005 https://books.evc-cit.info/ The associated website has a free draft of the book, and all the examples and support code. The site often seems to be offline, but the book can be found at other locations. A recent version can be purchased at Lulu: https://lulu.com/shop/j-david-eisenberg/oasis-opendocument-essentials/paperback/product-392512.html","title":"1.  The OpenDocument Format"},{"location":"51-Simple_ODF.html#2-document-information","text":"There's little need to directly manipulate a document's XML files since the Office API offers high-level techniques for accessing most of their information. For example, part of meta.xml for algs.odp is: <office:meta> <dc:title>PowerPoint Presentation</dc:title> <dc:date>2017-01-06T16:53:58.639000000</dc:date> <meta:editing-cycles>4</meta:editing-cycles> <meta:editing-duration>PT1M52S</meta:editing-duration> <meta:generator>LibreOffice/5.1.0.3$ Windows_x86LibreOffice_project/ 5e3e00a007d9b3b6efb6797a8b8e57b51ab1f737</meta:generator> <meta:document-statistic meta:object-count=\"92\"/> <meta:user-defined meta:name=\"Secret\">Made in Thailand</meta:user-defined> </office:meta> This data is displayed in the General tab of the File, Properties window in Figure 2. Figure 2. File, Properties Window. Rather than attempting to extract and parse meta.xml, this information is reachable through the XDocumentProperties interface which I described back in Chapter 3, section 2. The following DocInfo.java example uses Info.printDocProperties() to print document details: // in DocInfo.java public class DocInfo { public static void main ( String args [] ) { if ( args . length < 1 ) { System . out . println ( \"Usage: run DocInfo <fnm>\" ); return ; } XComponentLoader loader = Lo . loadOffice (); XComponent doc = Lo . openDoc ( args [ 0 ] , loader ); if ( doc == null ) { System . out . println ( \"Could not open \" + args [ 0 ] ); Lo . closeOffice (); return ; } System . out . println (); Props . showObjProps ( \"Document\" , doc ); Info . printDocProperties ( doc ); Lo . closeDoc ( doc ); Lo . closeOffice (); } // end of main() } // end of DocInfo class When DocInfo is passed algs.odp, some of the output is: Document Properties Info Author: Title: PowerPoint Presentation Subject: Description: Generator: LibreOffice/5.1.0.3$Windows_x86 LibreOffice_project/ 5e3e00a007d9b3b6efb6797a8b8e57b51ab1f737 : Modification Date: Jan 06, 2017 16:53 : Secret == Made in Thailand Info.printDocProperties() calls many XDocumentProperties.getXXX() methods to obtain these details: // in the Info class public static void printDocProperties ( Object doc ) { XDocumentPropertiesSupplier docPropsSupp = Lo . qi ( XDocumentPropertiesSupplier . class , doc ); XDocumentProperties dps = docPropsSupp . getDocumentProperties (); printDocProps ( dps ); XPropertyContainer udProps = dps . getUserDefinedProperties (); Props . showObjProps ( \"UserDefined Info\" , udProps ); } // end of printDocProperties() public static void printDocProps ( XDocumentProperties dps ) { System . out . println ( \"Document Properties Info\" ); System . out . println ( \" Author: \" + dps . getAuthor ()); System . out . println ( \" Title: \" + dps . getTitle ()); System . out . println ( \" Subject: \" + dps . getSubject ()); : // many more prints } // end of printDocProps() XDocumentProperties replaces the deprecated XDocumentInfo interface, which has been removed from LibreOffice (although it's still in OpenOffice). The two classes manipulate almost the same information, but the older XDocumentInfo can retrieve the document's MIME-type, which is absent from XDocumentProperties. One way of obtaining this would be to access the mimetype file zipped inside the document, as shown next.","title":"2.  Document Information"},{"location":"51-Simple_ODF.html#3-unzipping-an-odf-document","text":"My DocUnzip.java example shows how it's possible to list the zipped contents of a document, access its MIME-type, and extract a zipped file: // in DocUnzip.java public class DocUnzip { public static void main ( String args [] ) { if (( args . length < 1 ) || ( args . length > 2 )) { System . out . println ( \"Usage: run DocUnzip <fnm> [<ExtractFnm>]\" ); return ; } XComponentLoader loader = Lo . loadOffice (); FileIO . zipList ( args [ 0 ] ); // FileIO.zipListUno(args[0]); // only names listed // get zip access to the document XZipFileAccess zfa = FileIO . zipAccess ( args [ 0 ] ); String mimeType = FileIO . getMimeType ( zfa ); System . out . println ( \"MIME type: \" + mimeType ); System . out . println ( \"Other MIME type approach: \" + Info . getMIMEType ( args [ 0 ] )); // convert MIME-type too other forms int docType = Info . mimeDocType ( mimeType ); System . out . println ( \"Doc Type: \" + docType + \"; \" + Lo . docTypeStr ( docType )); if ( args . length == 2 ) // extract the named file FileIO . unzipFile ( zfa , args [ 1 ] ); Lo . closeOffice (); } // end of main() } // end of DocUnzip class The program can be called like so: run DocUnzip algs.odp content.xml content.xml will be unzipped from algs.odp and saved as contentCopy.xml in the local directory. The rest of the output is: Listing of algs.odp: Raw Size Size Date Time Name -------- ------- ------- ------- -------- 47 47 Jan 6, 2017 9:54:00 AM mimetype 0 0 Jan 6, 2017 9:54:00 AM Configurations2/popupmenu/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/floater/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/images/Bitmaps/ 0 2 Jan 6, 2017 9:54:00 AM Configurations2/accelerator/current.xml 0 0 Jan 6, 2017 9:54:00 AM Configurations2/menubar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/progressbar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/toolbar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/statusbar/ 0 0 Jan 6, 2017 9:54:00 AM Configurations2/toolpanel/ 83608 6501 Jan 6, 2017 9:54:00 AM styles.xml 4364 4364 Jan 6, 2017 9:54:00 AM Pictures/100000000000004600000035E6F1CB2181A9ACF1.png 16977 16977 Jan 6, 2017 9:54:00 AM Pictures/10000000000003080000002A0A348B9039C3652D.png 20480 20480 Jan 6, 2017 9:54:00 AM Pictures/10000000000001F4000001F4E2E69E1D.jpg 45056 45056 Jan 6, 2017 9:54:00 AM Pictures/10000000000000C8000000EEB0A3D2D2.jpg 8192 8192 Jan 6, 2017 9:54:00 AM Pictures/10000000000000E1000000E1B343DD04.jpg 40960 40960 Jan 6, 2017 9:54:00 AM Pictures/10000000000000E60000015E784CAA37.jpg 69632 69632 Jan 6, 2017 9:54:00 AM Pictures/10000000000000DC000000FF9A43DBBF.jpg 28672 28672 Jan 6, 2017 9:54:00 AM Pictures/100000000000011800000160792BAA16.jpg 12288 12288 Jan 6, 2017 9:54:00 AM Pictures/10000000000000DC0000014B7CFE8C49.jpg 11901 11901 Jan 6, 2017 9:54:00 AM Pictures/10000000000000BC0000010DD7ECB1F7.jpg 18238 18238 Jan 6, 2017 9:54:02 AM Thumbnails/thumbnail.png 86313 8040 Jan 6, 2017 9:54:02 AM content.xml 6037 913 Jan 6, 2017 9:54:02 AM settings.xml 1141 491 Jan 6, 2017 9:54:02 AM meta.xml 2248 452 Jan 6, 2017 9:54:02 AM META-INF/manifest.xml MIME type: application/vnd.oasis.opendocument.presentation Other MIME type approach: application/vnd.oasis.opendocument.presentation Doc Type: 5; simpress Extracting content.xml Saving to contentCopy.xml Most of the output is a detailed listing of the zipped contents of algs.odp.","title":"3.  Unzipping an ODF Document"},{"location":"51-Simple_ODF.html#31-listing-the-contents-of-a-zipped-folder","text":"There are two \"zipList\" functions in the FileIO utility class. FileIO.zipListUno() is simpler since only file and folder names are printed: // in the FileIO class public static void zipListUno ( String fnm ) { XZipFileAccess zfa = zipAccess ( fnm ); XNameAccess nmAccess = Lo . qi ( XNameAccess . class , zfa ); String [] names = nmAccess . getElementNames (); System . out . println ( \"\\nZipped Contents of \" + fnm ); Lo . printNames ( names , 1 ); } // end of zipListUno() public static XZipFileAccess zipAccess ( String fnm ) // get zip access to the document using Office API { return Lo . createInstanceMCF ( XZipFileAccess . class , \"com.sun.star.packages.zip.ZipFileAccess\" , new Object [] { fnmToURL ( fnm ) }); } XZipFileAccess is created by instantiating the ZipFileAccess service with the document's filename. The interface is cast to XNameAccess which allows the names of the zipped files to be retrieved as an array of strings. Figure 3 shows the relationships between the service and interfaces. Figure 3. The ZipFileAccess Service. The ZipFileAccess service and interfaces are in the com.sun.star.packages.zip module, which includes a ZipEntry class for holding information about each zipped file (e.g. its compressed size). I was unable to find a way of creating ZipEntry objects, but Java contains a complete zip API. By using Java rather than Office, I was able to implement a more fancy \"zipList\": // in the FileIO class public static void zipList ( String fnm ) // using the Java API { DateFormat df = DateFormat . getDateInstance (); // date format DateFormat tf = DateFormat . getTimeInstance (); // time format tf . setTimeZone ( TimeZone . getDefault () ); try { ZipFile zfile = new ZipFile ( fnm ); System . out . println ( \"Listing of \" + zfile . getName () + \":\" ); System . out . println ( \"Raw Size Size Date Time Name\" ); System . out . println ( \"--- ---- ---- ---- ---- ----\" ); Enumeration <? extends java . util . zip . ZipEntry > zfs = zfile . entries (); while ( zfs . hasMoreElements ()) { java . util . zip . ZipEntry entry = ( java . util . zip . ZipEntry ) zfs . nextElement (); Date d = new Date ( entry . getTime ()); System . out . print ( padSpaces ( entry . getSize (), 9 ) + \" \" ); System . out . print ( padSpaces ( entry . getCompressedSize (), 7 ) + \" \" ); System . out . print ( \" \" + df . format ( d ) + \" \" ); System . out . print ( \" \" + tf . format ( d ) + \" \" ); System . out . println ( \" \" + entry . getName ()); } System . out . println (); } catch ( java . io . IOException e ) { System . out . println ( e ); } } // end of zipList() Another advantage of switching to Java are the large number of online examples of zip manipulation; my zipList() function is closely based on one at https://drdobbs.com/jvm/java-and-the-zip-file-format/184410339/ .","title":"3.1.  Listing the Contents of a Zipped Folder"},{"location":"51-Simple_ODF.html#32-extracting-a-mime-type","text":"FileIO.getMimeType() employs XZipFileAccess.getStreamByPattern() to access the zipped mimetype file as an input stream. // in the FileIO class public static String getMimeType ( XZipFileAccess zfa ) { try { XInputStream inStream = zfa . getStreamByPattern ( \"mimetype\" ); String [] lines = FileIO . readLines ( inStream ); if ( lines != null ) return lines [ 0 ] . trim (); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } System . out . println ( \"No mimetype found\" ); return null ; } // end of getMimeType() There ' s an alternative approach which looks up the file ' s MIME - type using the Java API class MimetypesFileTypeMap : // in the Info class // global private static final String MIME_FNM = \"mime.types\" ; public static String getMIMEType ( String fnm ) { try { MimetypesFileTypeMap mftMap = new MimetypesFileTypeMap ( FileIO . getUtilsFolder () + MIME_FNM ); return mftMap . getContentType ( new File ( fnm )); } catch ( java . lang . Exception e ) { System . out . println ( \"Could not find \" + MIME_FNM ); return \"application/octet-stream\" ; // better than nothing } } // end of getMIMEType() The MimetypesFileTypeMap () constructor examines a list of MIME - types loaded from the utility classes folder . Most of my utility functions use document ' types ' coded as integers rather than as MIME - type strings ; the values are defined at the start of the Lo utility class : // in the Lo class public static final int UNKNOWN = 0 ; public static final int WRITER = 1 ; public static final int BASE = 2 ; public static final int CALC = 3 ; public static final int DRAW = 4 ; public static final int IMPRESS = 5 ; public static final int MATH = 6 ; Info . mimeDocType () maps ODF MIME - type strings to one of these integers : // in the Info class public static int mimeDocType ( String mimeType ) { if ( mimeType == null ) return Lo . UNKNOWN ; if ( mimeType . contains ( \"vnd.oasis.opendocument.text\" )) return Lo . WRITER ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.base\" )) return Lo . BASE ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.spreadsheet\" )) return Lo . CALC ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.graphics\" ) || mimeType . contains ( \"vnd.oasis.opendocument.image\" ) || mimeType . contains ( \"vnd.oasis.opendocument.chart\" )) return Lo . DRAW ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.presentation\" )) return Lo . IMPRESS ; else if ( mimeType . contains ( \"vnd.oasis.opendocument.formula\" )) return Lo . MATH ; else return Lo . UNKNOWN ; } // end of mimeDocType() Some of my functions also utilize short document type strings, which are also defined in the Lo class: // in the Lo class // docType strings public static final String UNKNOWN_STR = \"unknown\" ; public static final String WRITER_STR = \"swriter\" ; public static final String BASE_STR = \"sbase\" ; public static final String CALC_STR = \"scalc\" ; public static final String DRAW_STR = \"sdraw\" ; public static final String IMPRESS_STR = \"simpress\" ; public static final String MATH_STR = \"smath\" ; Lo.docTypeStr() maps document type integers to these strings.","title":"3.2.  Extracting a MIME-type"},{"location":"51-Simple_ODF.html#33-extracting-a-zipped-file","text":"The XZipFileAccess.getStreamByPattern() method used in FileIO.getMimeType() is also employed by FileIO.unzipFile() to extract a zipped file: // in FileIO class public static void unzipFile ( XZipFileAccess zfa , String fnm ) { String fileName = Info . getName ( fnm ); String ext = Info . getExt ( fnm ); try { System . out . println ( \"Extracting \" + fnm ); XInputStream inStream = zfa . getStreamByPattern ( \"*\" + fnm ); XSimpleFileAccess3 fileAcc = Lo . createInstanceMCF ( XSimpleFileAccess3 . class , \"com.sun.star.ucb.SimpleFileAccess\" ); String copyFnm = ( ext == null ) ? ( fileName + \"Copy\" ) : ( fileName + \"Copy.\" + ext ); System . out . println ( \"Saving to \" + copyFnm ); fileAcc . writeFile ( FileIO . fnmToURL ( copyFnm ), inStream ); } catch ( com . sun . star . uno . Exception e ) { System . out . println ( e ); } } // end of unzipFile() The XZipFileAccess.getStreamByPattern() call includes the wildcard character \"*\" so the filename will be found even if prefixed by a directory path, as in the case of an ODF document's manifest.xml which is stored in \"META-INF/manifest.xml\". I utilize Office's IO interface, XSimpleFileAccess3, which supports writeFile() to directly connect an XInputStream to a file. The filename of the extracted data is constructed from the zipped filename with the addition of \"Copy\".","title":"3.3.  Extracting a Zipped File"},{"location":"51-Simple_ODF.html#4-higher-level-manipulation-of-odf","text":"Manipulating an ODF document as zipped files and XML is a recipe for highly complex (and probably bug-ridden) code. And why bother when the Office API offers all the necessary functionality in a higher-level framework? \"Maslow's hammer\" maxim comes to mind; it states: \"if all you have is a hammer, then everything looks like a nail\". In other words, it's useful to know about ODF APIs other than Office's since they might offer better, easier ways of doing some tasks. As a consequence, I'm going to spend the rest of the chapter looking at the Simple Java API for ODF, a sub-project of Apache ODF Toolkit ( https://incubator.apache.org/odftoolkit/simple/ ). It's a relatively small Java API for creating, modifying and extracting data from ODF documents, built on top of the ODFDOM library ( https://incubator.apache.org/odftoolkit/odfdom/ ). Its best features are the cookbook pages at https://incubator.apache.org/odftoolkit/simple/document/cookbook/ , the Getting Started Guide ( https://incubator.apache.org/odftoolkit/simple/gettingstartguide.html ), and its demo pages ( https://incubator.apache.org/odftoolkit/simple/demo/ ). The cookbook contains examples for manipulating text documents, presentations, tables in text documents and spreadsheets, charts, style handling, text navigation, text extraction, text fields, text forms, and document metadata. The API documentation is at https://incubator.apache.org/odftoolkit/mvn-site/0.8-incubating/simple-odf/apidocs/ , and a mail archive at https://mail-archives.apache.org/mod_mbox/incubator-odf-users/ By far the worst feature of the API is the large number of libraries that must be installed before even a lowly \"Hello World\" example will work. Fortunately, I've included copies of those libraries at this chapter's website at https://fivedots.coe.psu.ac.th/~ad/jlop/ . The Simple API doesn't have the depth of features of Office, so it's best suited for the creation of simple text documents, spreadsheets, and presentations. However, it has better support for combining documents (e.g. concatenating two slide decks into a single one), and can move/copy slides in a presentation much more easily than Office; look back at Chapter 17, sections 4 and 5 for my complaints about that.","title":"4.  Higher-level Manipulation of ODF"},{"location":"51-Simple_ODF.html#41-building-simple-documents","text":"This subsection looks at how the Simple API can be used to create text, spreadsheet, and slide documents. Make a Text Document My MakeTextDoc.java example creates a text document containing an image, some text, a list, and a table.; the result is shown in Figure 4. Figure 4. The Output of MakeTextDoc.java. This isn't quite what the output looks like in the \"Getting Started Guide\", where the program is called HelloWorld.java \u2013 in the guide the first paragraph is beneath the image rather than to one side. The MakeTextDoc.java code: public class MakeTextDoc { public static void main ( String [] args ) { try { TextDocument doc = TextDocument . newTextDocument (); doc . newImage ( new URI ( \"odf-logo.png\" )); // add paragraphs and list doc . addParagraph ( \"Hello World, Hello Simple ODF!\" ); doc . addParagraph ( \"The following is a list.\" ); List list = doc . addList (); String [] items = { \"item1\" , \"item2\" , \"item3\" }; list . addItems ( items ); // add table Table table = doc . addTable ( 2 , 2 ); Cell cell = table . getCellByPosition ( 0 , 0 ); cell . setStringValue ( \"Hello World!\" ); System . out . println ( \"Creating MakeTextDoc.odt\" ); doc . save ( \"MakeTextDoc.odt\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MakeTextDoc class I was unable to find a way of changing the image's text wrap property to affect the paragraph's position. It's probably do-able using the lower-level ODFDOM library, but the programming information for that part of ODF Toolkit is mostly limited to its API documentation. However, there's a good introductory tutorial at https://langintro.com/odfdom_tutorials/ .","title":"4.1.  Building Simple Documents"},{"location":"51-Simple_ODF.html#make-a-spreadsheet","text":"The MakeSheet.java example creates a spreadsheet with a single sheet, and a few cells of data, as in Figure 5. Figure 5. The Output of MakeSheet.java. The program: public class MakeSheet { public static void main ( String [] args ) { try { SpreadsheetDocument doc = SpreadsheetDocument . newSpreadsheetDocument (); Table sheet = doc . getSheetByIndex ( 0 ); sheet . getCellByPosition ( 0 , 0 ). setStringValue ( \"Hello\" ); for ( int row = 0 ; row < 5 ; row ++ ) sheet . getCellByPosition ( 1 , row ). setDoubleValue ( row * 2.0 ); System . out . println ( \"Saving document to makeSheet.ods\" ); doc . save ( \"makeSheet.ods\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MakeSheet class","title":"Make a Spreadsheet"},{"location":"51-Simple_ODF.html#make-a-slide-deck","text":"The MakeSlides.java example creates a slide deck. The first slide contains a title, the second some bulleted text and a picture, and the third slide is blank, as in Figure 6. Figure 6. The Output of MakeSlides.java. The program: public class MakeSlides { public static void main ( String [] args ) { try { PresentationDocument doc = PresentationDocument . newPresentationDocument (); // a title slide Slide slide1 = doc . newSlide ( 0 , \"slide1\" , SlideLayout . TITLE_ONLY ); Textbox titleBox = slide1 . getTextboxByUsage ( PresentationClass . TITLE ). get ( 0 ); titleBox . setTextContent ( \"Important Slide Presentation\" ); // a slide with text bullets and a picture Slide slide2 = doc . newSlide ( 1 , \"slide2\" , SlideLayout . TITLE_OUTLINE ); titleBox = slide2 . getTextboxByUsage ( PresentationClass . TITLE ). get ( 0 ); titleBox . setTextContent ( \"Overview\" ); Textbox outline = slide2 . getTextboxByUsage ( PresentationClass . OUTLINE ). get ( 0 ); List txtList = outline . addList (); // two bullets txtList . addItem ( \"Item 1\" ); txtList . addItem ( \"Item 2\" ); Image image = Image . newImage ( slide2 , new URI ( \"skinner.png\" )); FrameRectangle rect = image . getRectangle (); rect . setX ( 8 ); // position the image rect . setY ( 4 ); image . setRectangle ( rect ); System . out . println ( \"Saving document to makeSlides.odp\" ); doc . save ( \"makeSlides.odp\" ); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MakeSlides class Programming with this part of the API is a littlie tricky since slide elements are represented by different types of boxes. I also found it hard to determine the position of the image, except by trial-and-error.","title":"Make a Slide Deck"},{"location":"51-Simple_ODF.html#42-moving-a-slide","text":"Back in Chapter 17, section 4, I had to use copy and paste dispatch commands in the slide-sorter view to rearrange a deck. Moving a slide in the Simple API is much easier, as shown in MoveSlide.java, which moves the first slide of the deck to its end: public class MoveSlide { public static void main ( String [] args ) { try { PresentationDocument doc = PresentationDocument . loadDocument ( \"algs.odp\" ); int numSlides = doc . getSlideCount (); System . out . println ( \"Moving first slide to the end\" ); doc . moveSlide ( 0 , numSlides ); // why not numSlides-1? System . out . println ( \"Saving document to algsMoved.odp\" ); doc . save ( \"algsMoved.odp\" ); doc . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of MoveSlide class PresentationDocument.moveSlide() works without a hitch, although I'm confused why I need to supply numSlides as the second numerical argument rather than numSlides-1. There's also a PresentationDocument.copySlide() method for copying.","title":"4.2.  Moving a Slide"},{"location":"51-Simple_ODF.html#43-combining-two-documents","text":"This subsection presents three short programs that combine two text documents, appends the sheets of two spreadsheets, and concatenates two slide decks. These examples are much simpler to program than equivalent ones using the Office API.","title":"4.3.  Combining Two Documents"},{"location":"51-Simple_ODF.html#combining-text-documents","text":"CombineTexts.java adds the contents of doc2.odt to the end of the contents of doc1.odt, separating them with a page break. The result is saved to combined.odt: public class CombineTexts { public static void main ( String [] args ) { try { TextDocument doc1 = TextDocument . loadDocument ( \"doc1.odt\" ); TextDocument doc2 = TextDocument . loadDocument ( \"doc2.odt\" ); doc1 . addPageBreak (); Paragraph lastPara = doc1 . getParagraphByReverseIndex ( 0 , false ); // insert contents at end and copy styles doc1 . insertContentFromDocumentAfter ( doc2 , lastPara , true ); System . out . println ( \"Saving combination to combined.odt\" ); doc1 . save ( \"combined.odt\" ); doc1 . close (); doc2 . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of CombineTexts class The crucial method is TextDocument.insertContentFromDocumentAfter().","title":"Combining Text Documents"},{"location":"51-Simple_ODF.html#combining-spreadsheets","text":"CombineSheets.java places the sheets in ss2.odt after the sheets in ss1.odt, and saves the result in combined.ods: public class CombineSheets { public static void main ( String [] args ) { try { SpreadsheetDocument doc1 = SpreadsheetDocument . loadDocument ( \"ss1.ods\" ); SpreadsheetDocument doc2 = SpreadsheetDocument . loadDocument ( \"ss2.ods\" ); int numSheets2 = doc2 . getSheetCount (); // add sheets of second document to end of first doc for ( int i = 0 ; i < numSheets2 ; i ++ ) { Table t = doc2 . getSheetByIndex ( i ); doc1 . appendSheet ( t , t . getTableName ()); } System . out . println ( \"Saving combination to combined.ods\" ); doc1 . save ( \"combined.ods\" ); doc1 . close (); doc2 . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of CombineSheets class Sadly there isn't a single method that appends tables. Instead I've used a loop to append each sheet from ss2.ods after the sheets in ss1.ods.","title":"Combining Spreadsheets"},{"location":"51-Simple_ODF.html#combining-slide-decks","text":"CombineDecks.java adds the slides in deck2.odp after the slides in deck1.odp, saving the result in combined.odp: public class CombineDecks { public static void main ( String [] args ) { try { PresentationDocument doc1 = PresentationDocument . loadDocument ( \"deck1.odp\" ); PresentationDocument doc2 = PresentationDocument . loadDocument ( \"deck2.odp\" ); doc1 . appendPresentation ( doc2 ); System . out . println ( \"Saving combination to combined.odp\" ); doc1 . save ( \"combined.odp\" ); doc1 . close (); doc2 . close (); } catch ( Exception e ) { System . out . println ( e ); } } // end of main() } // end of CombineDecks class The PresentationDocument.appendPresentation() method does all the work, and should be compared to my hacky Office solution in Chapter 17, section 5.","title":"Combining Slide Decks"}]}