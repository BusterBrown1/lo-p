
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="LibreOffice Programming (LO-P) is intended for programmers who want  to learn how to use the the LibreOffice API. This allows programs to control  and manipulate LibreOffice's text, drawing, presentation, spreadsheet, and  database applications, and a lot more (e.g. its spell checker, forms  designer, and charting tools).  ">
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.0.6">
    
    
      
        <title>Chapter 5. Text API Overview - LibreOffice Programming</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.2c0c5eaf.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="css/extra.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="preference" data-md-color-primary="" data-md-color-accent="">
      
        <script>matchMedia("(prefers-color-scheme: dark)").matches&&document.body.setAttribute("data-md-color-scheme","slate")</script>
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-5-text-api-overview" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="LibreOffice Programming" class="md-header__button md-logo" aria-label="LibreOffice Programming" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LibreOffice Programming
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 5. Text API Overview
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/flywire/lo-p/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lo-p
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="LibreOffice Programming" class="md-nav__button md-logo" aria-label="LibreOffice Programming" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    LibreOffice Programming
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/flywire/lo-p/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lo-p
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        Preface
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="01%20Part%201%20Basics.html" class="md-nav__link">
        Part 1 Basics
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="01-Concepts.html" class="md-nav__link">
        Chapter 1. LibreOffice API Concepts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="02-Starting_and_Stopping.html" class="md-nav__link">
        Chapter 2. Starting and Stopping
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="03-Examining.html" class="md-nav__link">
        Chapter 3. Examining
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="04-Listening.html" class="md-nav__link">
        Chapter 4. Listening, and Other Techniques
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="05%20Part%202%20Writer.html" class="md-nav__link">
        Part 2 Writer
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Chapter 5. Text API Overview
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="05-Text_API_Overview.html" class="md-nav__link md-nav__link--active">
        Chapter 5. Text API Overview
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-an-overview-of-the-text-document-api" class="md-nav__link">
    1.  An Overview of the Text Document API
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-extracting-text-from-a-document" class="md-nav__link">
    2.  Extracting Text from a Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-cursor-iteration" class="md-nav__link">
    3.  Cursor Iteration
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-creating-cursors" class="md-nav__link">
    4.  Creating Cursors
  </a>
  
    <nav class="md-nav" aria-label="4.  Creating Cursors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-counting-words" class="md-nav__link">
    4.1.  Counting Words
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-displaying-lines" class="md-nav__link">
    4.2.  Displaying Lines
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-creating-a-document" class="md-nav__link">
    5.  Creating a Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-using-and-comparing-text-cursors" class="md-nav__link">
    6.  Using and Comparing Text Cursors
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-insertingchanging-text-in-a-document" class="md-nav__link">
    7.  Inserting/Changing Text in a Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-treating-a-document-as-paragraphs-and-text-portions" class="md-nav__link">
    8.  Treating a Document as Paragraphs and Text Portions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-appending-documents-together" class="md-nav__link">
    9.  Appending Documents Together
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="06-Text_Styles.html" class="md-nav__link">
        Chapter 6. Text Styles
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="07-Non-text_Content.html" class="md-nav__link">
        Chapter 7. Text Content Other than Strings
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="08-Graphic_Content.html" class="md-nav__link">
        Chapter 8. Graphic Content
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="09-Text_Search.html" class="md-nav__link">
        Chapter 9. Text Search and Replace
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="10-Linguistics.html" class="md-nav__link">
        Chapter 10. The Linguistics API
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="11%20Part%203%20Draw%20%26%20Impress.html" class="md-nav__link">
        Part 3 Draw & Impress
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="11-Draw_Impress_APIs.html" class="md-nav__link">
        Chapter 11. Draw/Impress APIs Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="12-Examining_DrawImpress.html" class="md-nav__link">
        Chapter 12. Examining a Draw/Impress
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="13-Basic_Shapes.html" class="md-nav__link">
        Chapter 13. Drawing Basic Shapes
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="14-Animation.html" class="md-nav__link">
        Chapter 14. Animation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="15-Complex_Shapes.html" class="md-nav__link">
        Chapter 15. Complex Shapes
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="16-Making_Slides.html" class="md-nav__link">
        Chapter 16. Making Slides
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="17-Slide_Deck_Manipulation.html" class="md-nav__link">
        Chapter 17. Slide Deck Manipulation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="18-Slide_Shows.html" class="md-nav__link">
        Chapter 18. Slide Shows
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="19%20Part%204%20Calc.html" class="md-nav__link">
        Part 4 Calc
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="19-Calc_API_Overview.html" class="md-nav__link">
        Chapter 19. Calc API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="20-Spreadsheet_Manipulation.html" class="md-nav__link">
        Chapter 20. Spreadsheet Displaying and
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="21-Extracting_Data.html" class="md-nav__link">
        Chapter 21. Extracting Data
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="22-Styles.html" class="md-nav__link">
        Chapter 22. Styles
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="23-Garlic_Secrets.html" class="md-nav__link">
        Chapter 23. Garlic Secrets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="24-Complex_Data_Manipulation.html" class="md-nav__link">
        Chapter 24. Complex Data Manipulation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="25-Monitoring_Sheets.html" class="md-nav__link">
        Chapter 25. Monitoring Sheets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="26-Search_Replace.html" class="md-nav__link">
        Chapter 26. Search and Replace
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="27-Funcs_Analysis.html" class="md-nav__link">
        Chapter 27. Functions and Data Analysis
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="28%20Part%205%20Chart.html" class="md-nav__link">
        Part 5 Chart
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="28-Chart2_API_Overview.html" class="md-nav__link">
        Chapter 28. Chart2 API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="29-Column_Charts.html" class="md-nav__link">
        Chapter 29. Column Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="30-Bar_Pie_Area_Line_Charts.html" class="md-nav__link">
        Chapter 30. Bar, Pie, Area, Line Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="31-XY_Scatter_Charts.html" class="md-nav__link">
        Chapter 31. XY (Scatter) Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="32-Bubble_Net_Stock_Charts.html" class="md-nav__link">
        Chapter 32. Bubble, Net, Stock Charts
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="33-Charts_in_Others_Docs.html" class="md-nav__link">
        Chapter 33. Using Charts in Other
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="34%20Part%206%20Base.html" class="md-nav__link">
        Part 6 Base
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="34-JDBC_to_Base_API.html" class="md-nav__link">
        Chapter 34. From JDBC to the Base API
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="35-Examining_Base_Docs.html" class="md-nav__link">
        Chapter 35. Examining Base Documents
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="36-RowSets_DB_Context.html" class="md-nav__link">
        Chapter 36. Using RowSets and Database
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="37-Driver_Manager.html" class="md-nav__link">
        Chapter 37. Using the Driver Manager
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="38-ODB_as_Zip.html" class="md-nav__link">
        Chapter 38. Treating an ODB File as a
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="39%20Part%207%20Cross-application.html" class="md-nav__link">
        Part 7 Cross-application
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="39-Forms_API_Overview.html" class="md-nav__link">
        Chapter 39. Forms API Overview
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="40-Building_a_Form.html" class="md-nav__link">
        Chapter 40. Building a Form
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="41-Printing.html" class="md-nav__link">
        Chapter 41. Printing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="42-Sending_E-mail.html" class="md-nav__link">
        Chapter 42. Sending E-mail
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="43-Using_the_Clipboard.html" class="md-nav__link">
        Chapter 43. Using the Clipboard
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="44-Office_as_GUI_Comp.html" class="md-nav__link">
        Chapter 44. Office as a GUI Component
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="45%20Part%208%20Extending%20LibreOffice.html" class="md-nav__link">
        Part 8 Extending LibreOffice
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="45-UNO_Components.html" class="md-nav__link">
        Chapter 45. Coding UNO Components
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="46-Addons.html" class="md-nav__link">
        Chapter 46. Add-ons
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="47-Calc_Add-ins.html" class="md-nav__link">
        Chapter 47. Calc Add-ins
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="48-Event_Macros.html" class="md-nav__link">
        Chapter 48. Event Macros
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="49-Ext_Doc_Event_Macros.html" class="md-nav__link">
        Chapter 49. Extension and Document
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="50%20Part%209%20The%20ODF%20Format.html" class="md-nav__link">
        Part 9 The ODF Format
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="50-Importing_XML.html" class="md-nav__link">
        Chapter 50. Importing XML
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="51-Simple_ODF.html" class="md-nav__link">
        Chapter 51. Simple ODF
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-an-overview-of-the-text-document-api" class="md-nav__link">
    1.  An Overview of the Text Document API
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-extracting-text-from-a-document" class="md-nav__link">
    2.  Extracting Text from a Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-cursor-iteration" class="md-nav__link">
    3.  Cursor Iteration
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-creating-cursors" class="md-nav__link">
    4.  Creating Cursors
  </a>
  
    <nav class="md-nav" aria-label="4.  Creating Cursors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-counting-words" class="md-nav__link">
    4.1.  Counting Words
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-displaying-lines" class="md-nav__link">
    4.2.  Displaying Lines
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-creating-a-document" class="md-nav__link">
    5.  Creating a Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-using-and-comparing-text-cursors" class="md-nav__link">
    6.  Using and Comparing Text Cursors
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-insertingchanging-text-in-a-document" class="md-nav__link">
    7.  Inserting/Changing Text in a Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-treating-a-document-as-paragraphs-and-text-portions" class="md-nav__link">
    8.  Treating a Document as Paragraphs and Text Portions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-appending-documents-together" class="md-nav__link">
    9.  Appending Documents Together
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/flywire/lo-p/edit/master/docs/05-Text_API_Overview.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="chapter-5-text-api-overview">Chapter 5. Text API Overview</h1>
<p>The next few chapters look at programming with the text 
document part of the Office API. This chapter begins with 
a quick overview of the text API, then a detailed look at 
text cursors for moving about in a document, extracting 
text, and adding/inserting new text.  </p>
<p>Text cursors aren't the only way to move around inside a 
document; it's also possible to iterate over a document by 
treating it as a sequence of paragraphs. </p>
<p>The chapter finishes with a look at how two (or more) text 
documents can be appended. </p>
<p>The online Developer's Guide begins text document programming at<br />
https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Text_Documents 
(the easiest way of accessing that page is to type loguide writer). It corresponds to 
Chapter 7 in the printed guide (available at 
https://wiki.openoffice.org/w/images/d/d9/DevelopersGuide_OOo3.1.0.pdf), but the 
Web material is better structured and formatted. </p>
<p>The guide's text programming examples are in TextDocuments.java, downloadable 
from http://api.libreoffice.org/examples/DevelopersGuide/examples.html#Text. </p>
<p>Although the code is long, it's well-organized. Some smaller text processing examples 
are available at http://api.libreoffice.org/examples/examples.html#Java_examples. </p>
<p>This chapter (and later ones) assume that you're familiar with Writer, including text 
concepts such as paragraph styles. If you're not, then I recommend the "Writer 
Guide", a user manual, available at http://www.libreoffice.org/get-
help/documentation/ or 
https://wiki.documentfoundation.org/Documentation/Publications. </p>
<h2 id="1-an-overview-of-the-text-document-api">1.  An Overview of the Text Document API</h2>
<p>The API is centered around four text document services which subclass 
OfficeDocument, as shown in Figure 1. </p>
<div class="admonition note">
<p class="admonition-title">Topics</p>
<p>API Overview; </p>
</div>
<p>Text Cursors; Extracting 
Text; Cursor Iteration; 
Creating Cursors; 
Creating a Document; 
Using and Comparing 
Text Cursors; 
Inserting/Changing Text 
in a Document; Text 
Enumeration; 
Appending Documents 
Example folders: "Text 
Tests" and "Utils" </p>
<p><img alt="" src="images/05-Text_API_Overview-1.png" /></p>
<p>Figure 1. The Text Document Services. </p>
<p>I'll be concentrating on the TextDocument service, which is documented at 
http://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1text_1_1TextD
ocument.html. Or you can type lodoc TextDocument service, which unfortunately 
takes you to the IDL page for TextDocument; to reach the documentation, click on 
"TextDocument" under the "Classes" heading.  </p>
<p>The GlobalDocument service in Figure 1 is employed by master documents, such as a 
book or thesis. A master document is typically made up of links to files holding its 
parts, such as chapters, bibliography, and appendices.  </p>
<p>The WebDocument service in Figure 1 is for manipulating web pages, although its 
also possible to generate HTML files with the TextDocument service. </p>
<p>TextDocument, GlobalDocument, and WebDocument are mostly empty because those 
services don't define any interfaces or properties. The GenericTextDocument service 
is where  the action takes place, as summarized in Figure 2. </p>
<p><img alt="" src="images/05-Text_API_Overview-2.png" /></p>
<p>Figure 2. The Text Document Services, and some Interfaces. </p>
<p>The numerous 'Supplier' interfaces in Figure 2 are Office's way of accessing different 
elements in a document. For example, XStyleFamiliesSupplier manages character, 
paragraph, and other styles, while XTextTableSupplier deals with tables.  </p>
<p>I'll be looking at these suppliers in later chapters, which is why they're highlighted, 
but for now let's only consider the XTextDocument interface at the top right of the 
GenericTextDocument service box in Figure 2<br />
XTextDocument has a getText() method for returning an XText object. XText 
supports functionality related to text ranges and positions, cursors, and text contents. </p>
<p>It inherits XSimpleText and XTextRange, as indicated in Figure 3. </p>
<p><img alt="" src="images/05-Text_API_Overview-3.png" /></p>
<p>Figure 3. XText and its Superclasses. </p>
<p>Text content covers a multitude, such as embedded images, tables, footnotes, and text 
fields. Many of the suppliers shown in Figure 2 (e.g. XTextTablesSupplier) are for 
iterating through text content (e.g. accessing the document's tables).  </p>
<p>I'll concentrate on ordinary text in this chapter, and look at more esoteric content 
forms in Chapters 7 and 8. </p>
<p>A text document can utilize eight different cursors, which fall into two groups, as in </p>
<p><img alt="" src="images/05-Text_API_Overview-4.png" /></p>
<p>Figure 4. </p>
<p><img alt="" src="images/05-Text_API_Overview-4.png" /></p>
<p>Figure 4. Types of Cursor. </p>
<p>XTextCursor contains methods for moving around the document, and an instance is 
often called a model cursor because of its close links to the document's data. A 
program can create multiple XTextCursor objects if it wants, and can convert an 
XTextCursor into XParagraphCursor, XSentenceCursor, or XWordCursor. The 
differences are that while an XTextCursor moves through a document character by 
character, the others travel in units of paragraphs, sentences, and words.  </p>
<p>A program may employ a single XTextViewCursor cursor, to represent the cursor the 
user sees in the Writer application window; for this reason, it's often called the view 
cursor. XTextViewCursor can be converted into a XLineCursor, XPageCursor, or 
XScreenCursor object, which allows it to move in terms of lines, pages, or screens.  </p>
<p>A cursor's location is specified using a text range, which can be the currently selected 
text, or a position in the document. A text position is a text range that begins and ends 
at the same point. </p>
<h2 id="2-extracting-text-from-a-document">2.  Extracting Text from a Document</h2>
<p>The ExtractText.java example opens a document using Lo.openOffice(), and tries to 
print its text: </p>
<p>public static void main(String[] args) 
{ 
  if (args.length != 1) { 
    System.out.println("Usage: ExtractText fnm"); 
    return; 
  } </p>
<p>XComponentLoader loader = Lo.loadOffice(); 
  XComponent doc = Lo.openDoc(args[0], loader); 
  if (doc == null) { 
    System.out.println("Could not open " + args[0]); 
    Lo.closeOffice(); 
    return; 
  } </p>
<p>if (Info.isDocType(doc, Lo.WRITER_SERVICE)) { 
    XTextDocument textDoc = Write.getTextDoc(doc); 
    XTextCursor cursor = Write.getCursor(textDoc); 
    String text = Write.getAllText(cursor); 
    System.out.println("--------- Text Content --------"); 
    System.out.println(text); 
    System.out.println("-------------------------------"); 
  } 
  else 
    System.out.println("Extraction unsupported for this doc type"); </p>
<p>Lo.closeDoc(doc); 
  Lo.closeOffice(); 
} // end of main() </p>
<p>Info.isDocType() tests the document's type by casting it into an XServiceInfo 
interface. Then it calls XServiceInfo.supportsService() to check the document's 
service capabilities: </p>
<p>public static boolean isDocType(Object doc, String docType) 
// in the Info utility class 
{ XServiceInfo si = Lo.qi(XServiceInfo.class, doc); 
  return si.supportsService(docType); 
} </p>
<p>The argument type of the document is Object rather than XComponent so that a wider 
range of objects can be passed to the function for testing. </p>
<p>The service names for documents are hard to remember, so they're defined as 
constants in my Lo class: </p>
<p>// in the Lo class 
public static final String WRITER_SERVICE =<br />
               "com.sun.star.text.TextDocument"; 
public static final String BASE_SERVICE =<br />
               "com.sun.star.sdb.OfficeDatabaseDocument"; 
public static final String CALC_SERVICE =<br />
               "com.sun.star.sheet.SpreadsheetDocument"; 
public static final String DRAW_SERVICE =<br />
               "com.sun.star.drawing.DrawingDocument"; 
public static final String IMPRESS_SERVICE =<br />
              "com.sun.star.presentation.PresentationDocument"; 
public static final String MATH_SERVICE =<br />
              "com.sun.star.formula.FormulaProperties"; </p>
<p>Write.getTextDoc() uses Lo.qi() to cast the document's XComponent interface into an 
XTextDocument: 
XTextDocument textDoc = Lo.qi(XTextDocument.class, doc); 
This may fail (i.e. return null) if the loaded document isn't an instance of the 
TextDocument service.  </p>
<p>The casting 'power' of Lo.qi() is confusing – it depends on the document's service 
type. All text documents are instances of the TextDocument service (see Figure 2). </p>
<p>This means that Lo.qi() can 'switch' between any of the interfaces defined by 
TextDocument or its superclasses (i.e. the interfaces in GenericTextDocument or 
OfficeDocument). For instance, the following cast is fine: </p>
<p>XStyleFamiliesSupplier xSupplier = 
                   Lo.qi(XStyleFamiliesSupplier.class, doc); </p>
<p>This changes the instance into an XStyleFamiliesSupplier, which can access the 
document's styles.  </p>
<p>Alternatively, the following converts the instance into a supplier defined in 
OfficeDocument: 
XDocumentPropertiesSupplier xSupplier = 
               Lo.qi(XDocumentPropertiesSupplier.class, doc); </p>
<p>Most of the examples in this chapter and the next few cast the document to 
XTextDocument since that interface can access the document's contents as an XText 
object: </p>
<p>XTextDocument textDoc = Lo.qi(XTextDocument.class, doc); 
XText xText = textDoc.getText(); </p>
<p>The XText instance can access all the capabilities shown in Figure 3.  </p>
<p>A common next step is to create a cursor for moving around the document. This is 
easy since XText inherits XSimpleText which has a createTextCursor() method: 
XTextCursor textCursor = xText.createTextCursor(); 
These few lines are so useful that I've put them inside a Write.getCursor() method: </p>
<p>public static XTextCursor getCursor(XTextDocument textDoc) 
// get cursor from a text document 
{ 
  XText xText = textDoc.getText(); 
  if (xText == null) { 
    System.out.println("Text not found in document"); 
    return null; 
  } 
  else 
    return xText.createTextCursor(); 
}  // end of getCursor() </p>
<p>An XTextCursor can be converted into other kinds of model cursors (e.g. </p>
<p>XParagraphCursor, XSentenceCursor, XWordCursor; see Figure 4). That's not 
necessary in for the ExtractText.java example; instead, the XTextCursor is passed to 
Write.getAllText() to access the text as a sequence of characters: </p>
<p>public static String getAllText(XTextCursor cursor) 
{ 
  cursor.gotoStart(false); 
  cursor.gotoEnd(true); 
  String text = cursor.getString(); 
  cursor.gotoEnd(false);    // to deselect everything in the doc 
  return text; 
}  // end of getAllText() </p>
<p>All cursor movement operations take a boolean argument which specifies whether the 
movement should also select the text. For example, in getAllText(), 
cursor.gotoStart(false) shifts the cursor to the start of the text without selecting 
anything. The subsequent call to cursor.gotoEnd(true) moves the cursor to the end of 
the text and selects all the text moved over. The call to getString() on the third line 
returns the selection (i.e. all the text in the document). </p>
<p>Two other useful XTextCursor methods are: 
boolean goLeft(short charCount, boolean isSelected)<br />
boolean goRight(short charCount, boolean isSelected) 
They move the cursor left or right by a given number of characters, and the boolean 
argument specifies whether the text moved over is selected.  </p>
<p>All cursor methods return a boolean result which indicates if the move (and optional 
selection) was successful. </p>
<p>Another method worth knowing is: 
boolean gotoRange(XTextRange textRange, boolean isSelected)<br />
gotoRange() takes an XTextRange argument, which represents a selected region or 
position where the cursor should be moved to. For example, it's possible to find a 
bookmark in a document, extract its text range/position, and move the cursor to that 
location with gotoRange(). I'll show code for doing this in Chapter 7. </p>
<p>The XTextCursor methods are documented at 
http://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1text_1_1XTex
tCursor.html (or type lodoc XTextCursor). </p>
<p>A Problem with Write.getAllText() 
Write.getAllText() may fail if supplied with a very large document because 
XTextCursor.getString() might be unable to construct a big enough String object. For 
that reason, it's better to iterate over large documents returning a paragraph of text at a 
time. These iteration techniques are described next. </p>
<h2 id="3-cursor-iteration">3.  Cursor Iteration</h2>
<p>My HighlightText.java example uses paragraph and word cursors (i.e. the 
XParagraphCursor and XWordCursor interfaces in Figure 4). It also employs the view 
cursor, an XTextViewCursor instance, to control the Writer application's visible 
cursor.  </p>
<p>The main() function of HighlightText: </p>
<p>public static void main(String args[]) 
{ 
  if (args.length &lt; 1) { 
    System.out.println("Usage: run HighlightText <fnm>"); 
    return; 
  } </p>
<p>XComponentLoader loader = Lo.loadOffice(); 
  XTextDocument doc = Write.openDoc(args[0], loader); 
  if (doc == null) { 
    System.out.println("Could not open " + args[0]); 
    Lo.closeOffice(); 
    return; 
  } </p>
<p>GUI.setVisible(doc, true);  // make doc visible on-screen </p>
<p>showParagraphs(doc); 
  System.out.println("Word count: " + countWords(doc)); 
  showLines(doc); </p>
<p>Lo.closeDoc(doc); 
  Lo.closeOffice(); 
}  // end of main() </p>
<p>main() calls Write.openDoc() to return the opened document as an XTextDocument 
instance. If you recall, the previous ExtractText.java example started with an 
XComponent instance by calling Lo.openDoc(), and then converted it to 
XTextDocument. Write.openDoc() returns the XTextDocument reference in one go. </p>
<p>showParagraphs() moves the visible on-screen cursor through the document, 
highlighting a paragraph at a time. This requires two cursors – an instance of 
XTextViewCursor and a separate XParagraphCursor. The paragraph cursor is capable 
of moving through the document paragraph-by-paragraph, but it's a model cursor, so 
invisible to the user looking at the document on-screen. showParagraphs() extracts the 
start and end positions of each paragraph and uses them to move the view cursor, 
which is visible. </p>
<p>The code for showParagraphs(): </p>
<p>private static void showParagraphs(XTextDocument doc) 
{ 
  XTextViewCursor tvc = Write.getViewCursor(doc); 
  XParagraphCursor paraCursor = Write.getParagraphCursor(doc); 
  paraCursor.gotoStart(false);    <br />
              // go to start of text; no selection 
  do { 
    paraCursor.gotoEndOfParagraph(true); // select 1 paragraph 
    String currPara = paraCursor.getString(); 
    if (currPara.length() &gt; 0) { 
      // move view cursor to highlight current paragraph 
      tvc.gotoRange( paraCursor.getStart(), false); 
      tvc.gotoRange( paraCursor.getEnd(), true); </p>
<pre><code>  Lo.wait(500);   // slow down paragraph changing speed 
}
</code></pre>
<p>} while (paraCursor.gotoNextParagraph(false)); 
}  // end of showParagraphs() </p>
<p>The code utilizes two Write utility functions (Write.getViewCursor() and 
Write.getParagraphCursor()) to create the cursors. The subsequent do-while loop is a 
common coding pattern for iterating over a text document: </p>
<p>paraCursor.gotoStart(false);<br />
do { 
  paraCursor.gotoEndOfParagraph(true);   // select 1 paragraph </p>
<p>// do something to the selected text range... </p>
<p>} while (paraCursor.gotoNextParagraph(false)); </p>
<p>gotoNextParagraph() tries to move the cursor to the beginning of the next paragraph. </p>
<p>If the moves fails (i.e. when the cursor has reached the end of the document), the 
function returns false, and the loop terminates.  </p>
<p>The call to gotoEndOfParagraph() at the beginning of the loop moves the cursor to the 
end of the paragraph and selects its text. Since the cursor was originally at the start of 
the paragraph, the selection will span that paragraph. </p>
<p>XParagraphCursor and the sentence and word cursors inherit XTextCursor, as shown 
in Figure 5. </p>
<p><img alt="" src="images/05-Text_API_Overview-5.png" /></p>
<p>Figure 5. The Model Cursors Inheritance Hierarchy. </p>
<p>Since all these cursors also inherit XTextRange, they can easily access and change 
their text selections/positions. In the showParagraphs() method above, the two ends of 
the paragraph are obtained by calling the inherited XTextRange.getStart() and 
XTextRange.getEnd(), and the positions are used to move the view cursor: </p>
<p>XTextViewCursor tvc = Write.getViewCursor(doc); 
       : 
tvc.gotoRange(paraCursor.getStart(), false); 
tvc.gotoRange(paraCursor.getEnd(), true); </p>
<p>gotoRange() sets the text range/position of the view cursor: the first call moves the 
cursor to the paragraph's starting position without selecting anything, and the second 
moves it to the end position, selecting all the text in between. Since this is a view 
cursor, the selection is visible on-screen, as illustrated in Figure 6. </p>
<p><img alt="" src="images/05-Text_API_Overview-6.png" /></p>
<p>Figure 6. A Selected Paragraph. </p>
<p>Note that getStart() and getEnd() do not return integers but collapsed text ranges, 
which is Office-lingo for a range that starts and ends at the same cursor position. </p>
<p>Somewhat confusingly, the XTextViewCursor interface inherits XTextCursor (as 
shown in Figure 7). This only means that XTextViewCursor supports the same 
character-based movement and text range operations as the model-based cursor. </p>
<p><img alt="" src="images/05-Text_API_Overview-7.png" /></p>
<p>Figure 7. The XTextViewCursor Inheritance Hierarchy. </p>
<h2 id="4-creating-cursors">4.  Creating Cursors</h2>
<p>An XTextCursor is created by calling Write.getCursor(), which can then be converted 
into a paragraph, sentence, or word cursor by using Lo.qi(). For example, the Write 
utility class defines getParagraphCursor() as: </p>
<p>public static XParagraphCursor getParagraphCursor( 
                                      XTextDocument textDoc) 
{ XTextCursor cursor = getCursor(textDoc); 
  if (cursor == null) { 
    System.out.println("Text cursor is null"); 
    return null; 
  } 
  else 
    return Lo.qi(XParagraphCursor.class, cursor); <br />
}  // end of getParagraphCursor() </p>
<p>Obtaining the view cursor is a little more tricky since it's only accessible via the 
document's controller.  </p>
<p>As described in Chapter 1, section 5 about the FCM relationship, the controller is 
reached via the document's model, as shown in the first two lines of 
Write.getViewCursor(): </p>
<p>public static XTextViewCursor getViewCursor(XTextDocument textDoc) 
{ 
  XModel model = Lo.qi(XModel.class, textDoc); 
  XController xController = model.getCurrentController(); </p>
<p>// the controller supplies the TextViewCursor 
  XTextViewCursorSupplier supplier = Lo.qi( 
                   XTextViewCursorSupplier.class, xController); 
  return supplier.getViewCursor(); 
}  // end of getViewCursor() </p>
<p>The view cursor isn't directly accessible from the controller; a supplier must be 
queried, even though there's only one view cursor per document. </p>
<h3 id="41-counting-words">4.1.  Counting Words</h3>
<p>countWords() in HightlightText.java shows how to iterate over the document using a 
word cursor: </p>
<p>private static int countWords(XTextDocument doc) 
{ 
  XWordCursor wordCursor = Write.getWordCursor(doc); 
  wordCursor.gotoStart(false);     // go to start of text </p>
<p>int wordCount = 0; 
  String currWord; 
  do { 
    wordCursor.gotoEndOfWord(true); 
    currWord = wordCursor.getString(); 
    if (currWord.length() &gt; 0) 
      wordCount++; 
  } while( wordCursor.gotoNextWord(false)); 
  return wordCount; 
}  // end of countWords() </p>
<p>This uses the same kind of do-while loop as showParagraphs() except that the 
XTextWordCursor methods gotoEndOfWord() and gotoNextWord() control the 
iteration. Also, there's no need for an XTextViewCursor instance since the selected 
words aren't shown on the screen. </p>
<h3 id="42-displaying-lines">4.2.  Displaying Lines</h3>
<p>showLines() in HightlightText.java iterates over the document highlighting a line at a 
time. Don't confuse this with sentence selection because a sentence may consist of 
several lines on the screen. A sentence is part of the text's organization (i.e. in terms 
of words, sentences, and paragraphs) while a line is part of the document view (i.e. </p>
<p>line, page, screen). This means that XLineCursor is a view cursor, which is obtained 
by converting XTextViewCursor with Lo.qi(): </p>
<p>XTextViewCursor tvc = Write.getViewCursor(doc); 
XLineCursor lineCursor =  Lo.qi(XLineCursor.class, tvc);  </p>
<p>The line cursor has limited functionality compared to the model cursors (paragraph, 
sentence, word). In particular, there's no "next' function for moving to the next line 
(unlike gotoNextParagraph() or gotoNextWord()). The screen cursor also lacks this 
ability, but the page cursor offers jumpToNextPage().  </p>
<p>One way of getting around the absence of a 'next' operation is shown in showLines(): </p>
<p>private static void showLines(XTextDocument doc) 
{ 
  XTextViewCursor tvc = Write.getViewCursor(doc); 
  tvc.gotoStart(false);     // go to start of text </p>
<p>XLineCursor lineCursor =<br />
         Lo.qi(XLineCursor.class, tvc);  </p>
<p>boolean haveText = true; 
  do { 
    lineCursor.gotoStartOfLine(false); 
    lineCursor.gotoEndOfLine(true);  // select 1 line </p>
<pre><code>Lo.wait(500);   // slow down the line changing speed 
tvc.collapseToEnd();  // make selection disappear

haveText = tvc.goRight((short) 1, true); // move 1 char
</code></pre>
<p>} while (haveText); 
}  // end of showLines() </p>
<p>The view cursor is manipulated using the XTextViewCursor object and the 
XLineCursor line cursor. This is possible since the two references point to the same 
on-screen cursor. Either one can move it around the display. </p>
<p>Inside the loop, XLineCursor's gotoStartOfLine() and gotoEndOfLine() highlight a 
single line. Then the XTextViewCursor instance deselects the line, by moving the 
cursor to the end of the selection with collapseToEnd(). At the end of the loop, 
goRight() tries to move the cursor one character to the right. If goRight() succeeds 
then the cursor is shifted one position to the first character of the next line. When the 
loop repeats, this line will be selected. If doRight() fails, then there are no more 
characters to be read from the document, and the loop finishes. </p>
<h2 id="5-creating-a-document">5.  Creating a Document</h2>
<p>All the examples so far have involved the manipulation of an existing document. The 
HelloText.java example creates a new text document, containing two short 
paragraphs, and saves it as "hello.odt". The main() function is: </p>
<p>public static void main(String[] args) 
{ 
  XComponentLoader loader = Lo.loadOffice(); 
  XTextDocument doc = Write.createDoc(loader); </p>
<p>if (doc == null) { 
    System.out.println("Writer doc creation failed"); 
    Lo.closeOffice(); 
    return; 
  } </p>
<p>GUI.setVisible(doc, true);    // make the document visible </p>
<p>XTextCursor cursor = Write.getCursor(doc); 
  cursor.gotoEnd(false);  <br />
           // move cursor to end of doc before appending </p>
<p>Write.appendPara(cursor, "Hello LibreOffice.\n"); 
  Lo.wait(1000);   // slow things down so they can be seen </p>
<p>Write.appendPara(cursor, "How are you?."); 
  Lo.wait(2000); </p>
<p>Lo.saveDoc(doc, "hello.odt"); 
         // or use extension doc, docx, rtf, pdf, txt 
  Lo.closeDoc(doc); 
  Lo.closeOffice(); 
} // end of main() </p>
<p>Write.createDoc() calls Lo.createDoc() with the text document service name (the 
Lo.WRITER_STR constant is "swriter"). Office creates a TextDocument service with 
an XComponent interface, which is cast to the XTextDocument interface, and 
returned: </p>
<p>// in the Write class 
public static XTextDocument createDoc(XComponentLoader loader) 
{<br />
  XComponent doc = Lo.createDoc(Lo.WRITER_STR, loader); <br />
  return Lo.qi(XTextDocument.class, doc); 
} </p>
<p>Text documents are saved using Lo.saveDoc() which was described in Chapter 2. </p>
<p>saveDoc() examines the filename's extension to determine its type. The known 
extensions include doc, docx, rtf, odt, pdf, and txt.  </p>
<p>Back in HelloText.java, a cursor is needed before text can be added; one is created by 
calling Write.getCursor().  </p>
<p>The call to XTextCursor.gotoEnd() isn't really necessary because the new cursor is 
pointing to an empty document so is already at its end. It's included to emphasize the 
assumption by Write.appendPara() (and other Write.appendXXX() functions) that the 
cursor is positioned at the end of the document before new text is added. </p>
<p>Write.appendPara() calls three other methods in the Write utility class: </p>
<p>// in the Write class 
public static int appendPara(XTextCursor cursor, String text) 
{ append(cursor, text); 
  append(cursor, ControlCharacter.PARAGRAPH_BREAK); 
  return getPosition(cursor); 
} </p>
<p>The 'append' name is utilized several times in Write – one version takes a string as its 
second argument, the other a short representing a control character: </p>
<p>// in the Write class 
public static int append(XTextCursor cursor, String text) 
{ cursor.setString(text); 
  cursor.gotoEnd(false); 
  return getPosition(cursor); 
}  // end of append() </p>
<p>public static int append(XTextCursor cursor, short ctrlChar) 
{ XText xText = cursor.getText(); 
  xText.insertControlCharacter(cursor, ctrlChar, false); 
  cursor.gotoEnd(false); 
  return getPosition(cursor); 
} </p>
<p>The first append() function uses XTextCursor.setString() to add the user-supplied 
string. The second function employs XTextCursor.insertControlCharacter(). After the 
addition of the text or character, the cursor is moved to the end of the document, and 
getPosition() is called to return the cursor's new position as an integer: </p>
<p>public static int getPosition(XTextCursor cursor) 
{  return (cursor.getText().getString()).length();  } </p>
<p>getPosition() is not very robust – it assumes that getString() will be able to convert the 
document's text into a string. This may fail if the document is very big (you may 
recall the same problem with my Write.getAllText() described earlier). </p>
<p>Office deals with this size issue by using XTextRange instances, which encapsulate 
text ranges and positions. Write.getPosition() returns an integer because its easier to 
understand when you're first learning to program with Office. It's better style to use 
and compare XTextRanges rather than integer positions, an approach I'll demonstrate 
in the next section. </p>
<h2 id="6-using-and-comparing-text-cursors">6.  Using and Comparing Text Cursors</h2>
<p>My TalkingBook.java example utilizes the third-party library FreeTTS 
(http://freetts.sourceforge.net/) to convert text into speech. The inner workings of 
FreeTTS aren't relevant here, so are hidden inside a support class called Speaker. It 
has three public methods: 
 Speaker(): instantiates a FreeTTS instance – a male voice 
 say(String s): converts the string s into speech 
 dispose(): closes down the FreeTTS instance 
TalkingBook employs two text cursors: a paragraph cursor that iterates over the 
paragraphs in the document, and a sentence cursor that iterates over all the sentences 
in the current paragraph and passes each sentence to Speaker.say(). FreeTTS is 
capable of speaking long or short sequences of text, but TalkingBook processes a 
sentence at a time since this sounds more natural when spoken. </p>
<p>The crucial function in TalkingBook.java is speakSentences(): </p>
<p>private static void speakSentences(XTextDocument doc) 
{ 
  Speaker speaker = new Speaker();  // create FreeTTS voice </p>
<p>XTextViewCursor tvc = Write.getViewCursor(doc); 
  XParagraphCursor paraCursor = Write.getParagraphCursor(doc); 
  paraCursor.gotoStart(false);     // go to start of text </p>
<p>// create range comparer for the entire document 
  XTextRangeCompare comparer =  Lo.qi( 
                        XTextRangeCompare.class, doc.getText()); </p>
<p>String currParaStr, currSentStr; 
  do { 
    paraCursor.gotoEndOfParagraph(true);  // select 1 paragraph 
    XTextRange endPara = paraCursor.getEnd(); </p>
<pre><code>currParaStr = paraCursor.getString();

if (currParaStr.length() &gt; 0) { 
  // set sentence cursor to start of paragraph 
  XTextCursor cursor =  
        paraCursor.getText().createTextCursorByRange( 
                                       paraCursor.getStart()); 
  XSentenceCursor sc = Lo.qi( 
                              XSentenceCursor.class, cursor); 
  sc.gotoStartOfSentence(false);   // goto start  
  do { 
    sc.gotoEndOfSentence(true);   // select 1 sentence 
    if (comparer.compareRegionEnds(endPara, sc.getEnd()) &gt; 0) 
      // has sentence cursor passed end of current paragraph? 
      break;

    // move view cursor to highlight current sentence 
    tvc.gotoRange(sc.getStart(), false); 
    tvc.gotoRange(sc.getEnd(), true);

    currSentStr = stripNonWordChars(sc.getString()); 
                  // clean up string to make speech nicer  
    if (currSentStr.length() &gt; 0) 
      speaker.say(currSentStr); 
  } while (sc.gotoNextSentence(false)); 
}
</code></pre>
<p>} while (paraCursor.gotoNextParagraph(false)); </p>
<p>speaker.dispose(); 
}  // end of speakSentences() </p>
<p>speakSentences() comprises two nested loops: the outer loop iterates through the 
paragraphs, and the inner loop through the sentences in the current paragraph. </p>
<p>The sentence cursor is created like so: </p>
<p>XTextCursor cursor =<br />
        paraCursor.getText().createTextCursorByRange( 
                                     paraCursor.getStart()); 
XSentenceCursor sc = <br />
        Lo.qi(XSentenceCursor.class, cursor);  </p>
<p>The XText reference is returned by paraCursor.getText(), and a text cursor is created. </p>
<p>createTextCursorByRange() allows the start position of the cursor to be specified. The 
text cursor is converted into a sentence cursor with Lo.qi(). </p>
<p>The tricky aspect of this code is the meaning of paraCursor.getText() which is the 
XText object that paraCursor utilizes. This is not a single paragraph but the entire text 
document. Remember that the paragraph cursor is created with: 
XParagraphCursor paraCursor = Write.getParagraphCursor(doc); 
This corresponds to: </p>
<p>XText xText = doc.getText(); 
XTextCursor textCursor = xText.createTextCursor(); 
XParagraphCursor paraCursor = Lo.qi( 
                         XParagraphCursor.class, textCursor); </p>
<p>Both the paragraph and sentence cursors refer to 
the entire text document. This means that I cannot 
code the inner loop using the coding pattern from 
before. That would result in something like the 
following: </p>
<p>// set sentence cursor to point to start 
of this paragraph 
XTextCursor cursor = paraCursor.getText().createTextCursorByRange( 
                                            paraCursor.getStart()) 
XSentenceCursor sc = Lo.qi( 
                                   XSentenceCursor.class, cursor); </p>
<p>sc.gotoStartOfSentence(false);   // goto start<br />
do { 
  sc.gotoEndOfSentence(true);    // select 1 sentence 
  // do something with the sentence 
  //  : 
} while (sc.gotoNextSentence(false)); </p>
<p>The problem with the above code fragment is that 
XSentenceCursor.gotoNextSentence() will keep moving to the next sentence until it 
reaches the end of the text document. This is not the desired behavior – what I want is 
for the loop to terminate when the last sentence of the current paragraph has been 
processed. </p>
<p>We need to compare text ranges, in this case the end of the current sentence with the 
end of the current paragraph. This capability is handled by the XTextRangeCompare 
interface. A comparer object is created at the beginning of speakSentence(), initialized 
to compare ranges that can span the entire document: </p>
<p>XTextRangeCompare comparer =<br />
   Lo.qi(XTextRangeCompare.class, doc.getText()); </p>
<p>This comparer object is utilized inside the sentence-iterating loop to compare the end 
of the current paragraph (the endPara text range) with the end of current sentence (the 
sc.getEnd() text range):  </p>
<p>if (comparer.compareRegionEnds(endPara, sc.getEnd()) &gt; 0) 
  break; </p>
<p>If the sentence ends after the end of the paragraph then compareRegionEnds() returns 
a positive number, and the inner loop terminates.  </p>
<p>This approach doesn't suffer from the problem in Write.getPosition() with 
XTextRange.getString(), and using its length as a position:<br />
To further confuse matters, a 
XText object does not always 
correspond to the entire text 
document. For example, a text 
frame (e.g. like this one) can 
return an XText object for the 
text only inside the frame. </p>
<p>public static int getPosition(XTextCursor cursor) 
{  return (cursor.getText().getString()).length();   </p>
<p>Since there's no String object being created by the comparer, there's no way that the 
instantiation can fail due to the size of the text. </p>
<h2 id="7-insertingchanging-text-in-a-document">7.  Inserting/Changing Text in a Document</h2>
<p>My ShuffleWords.java example searches a document and changes the words it 
encounters. Figure 8 shows the program in progress: "predominates" has been 
selected but not yet changed, but all the previous 'big' words have been shuffled. </p>
<p><img alt="" src="images/05-Text_API_Overview-8.png" /></p>
<p>Figure 8. Shuffling of Words. </p>
<p>A word shuffle is applied to every word of four letters or more, but only involves the 
random exchange of the middle letters without changing the first and last characters. </p>
<p>The applyShuffle() function which iterates through the words in the input file is 
similar to countWords() in HighlightText.java. One difference is the use of 
XText.insertString(): </p>
<p>private static void applyShuffle(XTextDocument doc) 
{ 
  XText docText = doc.getText(); </p>
<p>XWordCursor wordCursor = Write.getWordCursor(doc); 
  wordCursor.gotoStart(false);     // go to start of text </p>
<p>XTextViewCursor tvc = Write.getViewCursor(doc); </p>
<p>String currWord; 
  do { 
    wordCursor.gotoEndOfWord(true); </p>
<pre><code>// move the text view cursor, and highlight the current word 
tvc.gotoRange(wordCursor.getStart(), false); 
tvc.gotoRange(wordCursor.getEnd(), true); 
currWord = wordCursor.getString().trim(); 
if (currWord.length() &gt; 0) { 
  Lo.wait(250);    
      // slow down so user can see selection before change 
  docText.insertString(wordCursor, midShuffle(currWord), true); 
}
</code></pre>
<p>} while( wordCursor.gotoNextWord(false)); 
}  // end of applyShuffle() </p>
<p>insertString() is located in XSimpleText: 
void insertString(XTextRange xRange, String s, boolean willReplace) 
The string s is inserted at the cursor's text range position. If willReplace is true then 
the string replaces the current selection (which is the case in applyShuffle()). </p>
<p>midShuffle() shuffles the string in currWord, returning a new word. It doesn't use the 
Office API, so I won't explain it here. </p>
<h2 id="8-treating-a-document-as-paragraphs-and-text-portions">8.  Treating a Document as Paragraphs and Text Portions</h2>
<p>Another approach for moving around a document involves the XEnumerationAccess 
interface which treats the document as a series of Paragraph text contents.  </p>
<p>XEnumerationAccess is an interface in the Text service, which means that an XText 
reference can be converted into it by using Lo.qi(). These relationships are shown in </p>
<p><img alt="" src="images/05-Text_API_Overview-9.png" /></p>
<p>Figure 9. </p>
<p><img alt="" src="images/05-Text_API_Overview-9.png" /></p>
<p>Figure 9. The Text Service and its Interfaces. </p>
<p>The following code fragment utilizes this technique: </p>
<p>XText xText = doc.getText();    // get text of document 
XEnumerationAccess enumAccess =<br />
               Lo.qi(XEnumerationAccess.class, xText); </p>
<p>XEnumerationAccess contains a single method, createEnumeration() which creates an 
enumerator (an instance of XEnumeration). Each element returned from this iterator is 
a Paragraph text content: </p>
<p>// create enumerator over the document text 
XEnumeration textEnum = enumAccess.createEnumeration(); </p>
<p>while (textEnum.hasMoreElements()) {    // loop through paragraphs 
   XTextContent textCon =<br />
         Lo.qi(XTextContent.class, textEnum.nextElement()); 
   // use the Paragraph text content (textCon) in some way... </p>
<p>} </p>
<p>Paragraph doesn't support its own interface (i.e. there's no XParagraph), so I've used 
Lo.qi() to access its XTextContent interface, which belongs to the TextContent 
subclass. The hierarchy is shown in Figure 10. </p>
<p><img alt="" src="images/05-Text_API_Overview-10.png" /></p>
<p>Figure 10. The Paragraph Text Content Hierarchy. </p>
<p>Iterating over a document to access Paragraph text contents doesn't seem much 
different from iterating over a document using a paragraph cursor, except that the 
Paragraph service offers a more structured view of a paragraph.  </p>
<p>In particular, you can use another XEnumerationAccess instance  to iterate over a 
single paragraph, viewing it as a sequence of text portions. </p>
<p>The following code illustrates the notion, using the textCon text content from the 
previous piece of code: </p>
<p>if (!Info.supportService(textCon, "com.sun.star.text.TextTable")) { 
  // create enumerator over a paragraph 
  XEnumerationAccess enumAccess =<br />
                 Lo.qi(XEnumerationAccess.class, textCon); 
  XEnumeration paraEnum = enumAccess.createEnumeration(); </p>
<p>while (paraEnum.hasMoreElements()) {    // loop through portions 
    XTextRange txtRange =<br />
           Lo.qi(XTextRange.class, paraEnum.nextElement()); 
    // use the text portion (txtRange) in some way... </p>
<p>} 
} </p>
<p>The TextTable service is a subclass of Paragraph, and cannot be enumerated. </p>
<p>Therefore, I surrounded the paragraph enumerator with an if-test to skip a paragraph if 
it's really a table. </p>
<p>The paragraph enumerator returns text portions, represented by the TextPortion 
service. TextPortion contains a lot of useful properties which describe the paragraph, 
but it doesn't have its own interface (such as XTextPortion). However, TextPortion 
inherits the TextRange service, so I can use Lo.qi() to obtain its XTextRange 
interface. This hierarchy is shown in Figure 11. </p>
<p><img alt="" src="images/05-Text_API_Overview-11.png" /></p>
<p>Figure 11. The TextPortion Service Hierarchy. </p>
<p>TextPortion includes a "TextPortionType" property which identifies the type of the 
portion. Other properties access different kinds of portion data, such as a text field or 
footnote. </p>
<p>For instance, the following prints the text portion type and the string inside the 
txtRange text portion (txtRange comes from the previous code fragment): </p>
<p>System.out.println("  " +<br />
   Props.getProperty(txtRange, "TextPortionType") + 
   " = \"" + txtRange.getString() + "\""); </p>
<p>These code fragments are combined together in my ShowBookText.java example.  </p>
<p>More details on enumerators and text portions are given in the Developers Guide at 
https://wiki.openoffice.org/wiki/Documentation/DevGuide/Text/Iterating_over_Text 
(or use loGuide "Iterating over Text"). </p>
<h2 id="9-appending-documents-together">9.  Appending Documents Together</h2>
<p>If you need to write a large multi-part document (e.g. a thesis with chapters, 
appendices, contents page, and an index) then you should utilize a master document, 
which acts as a repository of links to documents representing the component parts. </p>
<p>You can find out about master documents in Chapter 13 of the Writers Guide, at 
https://wiki.documentfoundation.org/Documentation/Publications.  </p>
<p>However, the complexity of master documents isn't always needed. Often the aim is 
simply to append one document to the end of another. In that case, the 
XDocumentInsertable interface, and its insertDocumentFromURL() method is more 
suitable. </p>
<p>My DocsAppend.java example uses 
XDocumentInsertable.insertDocumentFromURL(). A list of filenames is read from 
the command line; the first file is opened, and the other files appended to it by 
appendTextFiles(): </p>
<p>// part of DocsAppend.java 
private static void appendTextFiles(XTextDocument doc, String[] args) 
{ 
  XTextCursor cursor = Write.getCursor(doc); 
  for (int i=1; i &lt; args.length; i++) { <br />
    /<em> start at 1 to skip the first file, which has 
       been opened as doc </em>/ 
    try { 
      cursor.gotoEnd(false); 
      // Write.pageBreak(cursor); </p>
<pre><code>  System.out.println("Appending " + args[i]); 
  XDocumentInsertable inserter =  
                  Lo.qi(XDocumentInsertable.class, cursor); 
  if (inserter == null) 
    System.out.println("Inserter could not be created"); 
  else 
    inserter.insertDocumentFromURL( 
        FileIO.fnmToURL(args[i]), new PropertyValue[0]); 
} 
catch (java.lang.Exception e) 
{  System.out.println("Could not append " +  
                                 args[i] + ": " + e);    }
</code></pre>
<p>} 
}  // end of appendTextFiles() </p>
<p>An XDocumentInsertable instance is obtained by converting the text cursor with 
UnoRuntime.queryInterface(). </p>
<p>XDocumentInsertable.insertDocumentFromURL() requires two arguments – the URL 
of the file that's being appended, and an empty property value array. </p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="05%20Part%202%20Writer.html" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Part 2 Writer
            </div>
          </div>
        </a>
      
      
        <a href="06-Text_Styles.html" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Chapter 6. Text Styles
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": ".", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.a1c7c35e.min.js"></script>
      
    
  </body>
</html>